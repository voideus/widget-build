import mG, { unstable_batchedUpdates as Zl, createPortal as wK } from "react-dom";
import { jsx as fe, jsxs as Wi, Fragment as Df } from "react/jsx-runtime";
import * as Te from "react";
import qi, { createContext as qC, useContext as za, useRef as Dt, useState as cn, useReducer as wf, useDebugValue as yK, useEffect as gi, useLayoutEffect as cy, useMemo as ni, forwardRef as zc, useCallback as dg, memo as mK, useImperativeHandle as SK, Suspense as MK, Component as RK } from "react";
const SG = qC({
  cameraControls: { current: null },
  sceneRef: { current: null },
  modelMesh: { current: null },
  mousePosition: { current: null },
  raycastIntersectionRef: { current: void 0 },
  gizmoRef: { current: null },
  mouseHelper: { current: null }
}), NK = ({ children: g }) => {
  const A = Dt(null), e = Dt(null), t = Dt(null), i = Dt(null), n = Dt(), r = Dt(null), s = Dt(null);
  return /* @__PURE__ */ fe(
    SG.Provider,
    {
      value: {
        cameraControls: A,
        sceneRef: e,
        modelMesh: t,
        mousePosition: i,
        raycastIntersectionRef: n,
        gizmoRef: r,
        mouseHelper: s
      },
      children: g
    }
  );
}, Vc = () => za(SG), MG = qC({
  model: "",
  rotation: 0,
  setRotation: () => {
  },
  scale: 0,
  setScale: () => {
  },
  pastedStickers: [],
  setPastedStickers: () => {
  },
  threeRef: void 0,
  backgrounds: [],
  stickers: [],
  selectedSticker: "",
  setSelectedSticker: () => {
  },
  fetchingStickers: !1,
  fetchMoreStickers: async () => !1,
  modelScaleFactor: 1,
  modelPosition: [0, 0, 0],
  currentBackground: "",
  setCurrentBackground: () => {
  },
  isDragging: !1,
  setIsDragging: () => {
  },
  isRotating: !1,
  setIsRotating: () => {
  }
}), FK = ({
  children: g,
  model: A,
  backgrounds: e,
  stickers: t,
  fetchingStickers: i,
  fetchMoreStickers: n,
  modelScaleFactor: r = 1,
  modelPosition: s = [0, 0, 0]
}) => {
  const B = Dt(), [I, E] = cn([]), [C, c] = cn(0), [u, d] = cn(0), [p, D] = cn(""), [f, S] = cn(""), [y, m] = cn(!1), [N, F] = cn(!1);
  return /* @__PURE__ */ fe(NK, { children: /* @__PURE__ */ fe(
    MG.Provider,
    {
      value: {
        model: A,
        rotation: C,
        setRotation: c,
        scale: u,
        setScale: d,
        backgrounds: e,
        stickers: t,
        pastedStickers: I,
        setPastedStickers: E,
        threeRef: B,
        selectedSticker: p,
        setSelectedSticker: D,
        fetchingStickers: i,
        fetchMoreStickers: n,
        modelScaleFactor: r,
        modelPosition: s,
        currentBackground: f,
        setCurrentBackground: S,
        isDragging: y,
        setIsDragging: m,
        isRotating: N,
        setIsRotating: F
      },
      children: g
    }
  ) });
}, dB = () => za(MG);
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const yf = "151", GK = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, vK = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, RG = 0, Iw = 1, NG = 2, UK = 3, FG = 0, mf = 1, Sc = 2, DC = 3, ea = 0, ir = 1, Rr = 2, kK = 2, Wa = 0, MC = 1, Bw = 2, Cw = 3, Qw = 4, GG = 5, fC = 100, vG = 101, UG = 102, Ew = 103, lw = 104, kG = 200, xG = 201, LG = 202, TG = 203, uy = 204, hy = 205, KG = 206, bG = 207, YG = 208, HG = 209, _G = 210, JG = 0, OG = 1, qG = 2, af = 3, PG = 4, WG = 5, zG = 6, VG = 7, jc = 0, jG = 1, ZG = 2, Is = 0, XG = 1, $G = 2, Av = 3, dy = 4, ev = 5, Sf = 300, lB = 301, cB = 302, RE = 303, xc = 304, KE = 306, Bs = 1e3, Jn = 1001, kC = 1002, un = 1003, NE = 1004, xK = 1004, RC = 1005, LK = 1005, Gi = 1006, Zc = 1007, TK = 1007, Cs = 1008, KK = 1008, Va = 1009, tv = 1010, iv = 1011, fy = 1012, nv = 1013, aB = 1014, $s = 1015, xC = 1016, gv = 1017, rv = 1018, NC = 1020, ov = 1021, tr = 1023, sv = 1024, av = 1025, EB = 1026, LC = 1027, Iv = 1028, Bv = 1029, Cv = 1030, Qv = 1031, Ev = 1033, Zd = 33776, Xd = 33777, $d = 33778, Af = 33779, cw = 35840, uw = 35841, hw = 35842, dw = 35843, lv = 36196, fw = 37492, pw = 37496, Dw = 37808, ww = 37809, yw = 37810, mw = 37811, Sw = 37812, Mw = 37813, Rw = 37814, Nw = 37815, Fw = 37816, Gw = 37817, vw = 37818, Uw = 37819, kw = 37820, xw = 37821, ef = 36492, cv = 36283, Lw = 36284, Tw = 36285, Kw = 36286, uv = 2200, hv = 2201, dv = 2202, TC = 2300, uB = 2301, tf = 2302, wC = 2400, yC = 2401, Lc = 2402, Mf = 2500, py = 2501, fv = 0, Dy = 1, If = 2, ta = 3e3, Ht = 3001, pv = 3200, Dv = 3201, fB = 0, wv = 1, bK = "", ss = "srgb", FE = "srgb-linear", wy = "display-p3", YK = 0, nf = 7680, HK = 7681, _K = 7682, JK = 7683, OK = 34055, qK = 34056, PK = 5386, WK = 512, zK = 513, VK = 514, jK = 515, ZK = 516, XK = 517, $K = 518, yv = 519, Tc = 35044, Ab = 35048, eb = 35040, tb = 35045, ib = 35049, nb = 35041, gb = 35046, rb = 35050, ob = 35042, sb = "100", bw = "300 es", Bf = 1035;
let Za = class {
  addEventListener(A, e) {
    this._listeners === void 0 && (this._listeners = {});
    const t = this._listeners;
    t[A] === void 0 && (t[A] = []), t[A].indexOf(e) === -1 && t[A].push(e);
  }
  hasEventListener(A, e) {
    if (this._listeners === void 0)
      return !1;
    const t = this._listeners;
    return t[A] !== void 0 && t[A].indexOf(e) !== -1;
  }
  removeEventListener(A, e) {
    if (this._listeners === void 0)
      return;
    const i = this._listeners[A];
    if (i !== void 0) {
      const n = i.indexOf(e);
      n !== -1 && i.splice(n, 1);
    }
  }
  dispatchEvent(A) {
    if (this._listeners === void 0)
      return;
    const t = this._listeners[A.type];
    if (t !== void 0) {
      A.target = this;
      const i = t.slice(0);
      for (let n = 0, r = i.length; n < r; n++)
        i[n].call(this, A);
      A.target = null;
    }
  }
};
const Tg = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let cR = 1234567;
const FC = Math.PI / 180, GE = 180 / Math.PI;
function io() {
  const g = Math.random() * 4294967295 | 0, A = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0;
  return (Tg[g & 255] + Tg[g >> 8 & 255] + Tg[g >> 16 & 255] + Tg[g >> 24 & 255] + "-" + Tg[A & 255] + Tg[A >> 8 & 255] + "-" + Tg[A >> 16 & 15 | 64] + Tg[A >> 24 & 255] + "-" + Tg[e & 63 | 128] + Tg[e >> 8 & 255] + "-" + Tg[e >> 16 & 255] + Tg[e >> 24 & 255] + Tg[t & 255] + Tg[t >> 8 & 255] + Tg[t >> 16 & 255] + Tg[t >> 24 & 255]).toLowerCase();
}
function yn(g, A, e) {
  return Math.max(A, Math.min(e, g));
}
function yy(g, A) {
  return (g % A + A) % A;
}
function ab(g, A, e, t, i) {
  return t + (g - A) * (i - t) / (e - A);
}
function Ib(g, A, e) {
  return g !== A ? (e - g) / (A - g) : 0;
}
function Mc(g, A, e) {
  return (1 - e) * g + e * A;
}
function Bb(g, A, e, t) {
  return Mc(g, A, 1 - Math.exp(-e * t));
}
function Cb(g, A = 1) {
  return A - Math.abs(yy(g, A * 2) - A);
}
function Qb(g, A, e) {
  return g <= A ? 0 : g >= e ? 1 : (g = (g - A) / (e - A), g * g * (3 - 2 * g));
}
function Eb(g, A, e) {
  return g <= A ? 0 : g >= e ? 1 : (g = (g - A) / (e - A), g * g * g * (g * (g * 6 - 15) + 10));
}
function lb(g, A) {
  return g + Math.floor(Math.random() * (A - g + 1));
}
function cb(g, A) {
  return g + Math.random() * (A - g);
}
function ub(g) {
  return g * (0.5 - Math.random());
}
function hb(g) {
  g !== void 0 && (cR = g);
  let A = cR += 1831565813;
  return A = Math.imul(A ^ A >>> 15, A | 1), A ^= A + Math.imul(A ^ A >>> 7, A | 61), ((A ^ A >>> 14) >>> 0) / 4294967296;
}
function db(g) {
  return g * FC;
}
function fb(g) {
  return g * GE;
}
function Yw(g) {
  return (g & g - 1) === 0 && g !== 0;
}
function mv(g) {
  return Math.pow(2, Math.ceil(Math.log(g) / Math.LN2));
}
function Sv(g) {
  return Math.pow(2, Math.floor(Math.log(g) / Math.LN2));
}
function pb(g, A, e, t, i) {
  const n = Math.cos, r = Math.sin, s = n(e / 2), B = r(e / 2), I = n((A + t) / 2), E = r((A + t) / 2), C = n((A - t) / 2), c = r((A - t) / 2), u = n((t - A) / 2), d = r((t - A) / 2);
  switch (i) {
    case "XYX":
      g.set(s * E, B * C, B * c, s * I);
      break;
    case "YZY":
      g.set(B * c, s * E, B * C, s * I);
      break;
    case "ZXZ":
      g.set(B * C, B * c, s * E, s * I);
      break;
    case "XZX":
      g.set(s * E, B * d, B * u, s * I);
      break;
    case "YXY":
      g.set(B * u, s * E, B * d, s * I);
      break;
    case "ZYZ":
      g.set(B * d, B * u, s * E, s * I);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
  }
}
function $r(g, A) {
  switch (A.constructor) {
    case Float32Array:
      return g;
    case Uint16Array:
      return g / 65535;
    case Uint8Array:
      return g / 255;
    case Int16Array:
      return Math.max(g / 32767, -1);
    case Int8Array:
      return Math.max(g / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function _t(g, A) {
  switch (A.constructor) {
    case Float32Array:
      return g;
    case Uint16Array:
      return Math.round(g * 65535);
    case Uint8Array:
      return Math.round(g * 255);
    case Int16Array:
      return Math.round(g * 32767);
    case Int8Array:
      return Math.round(g * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const bg = {
  DEG2RAD: FC,
  RAD2DEG: GE,
  generateUUID: io,
  clamp: yn,
  euclideanModulo: yy,
  mapLinear: ab,
  inverseLerp: Ib,
  lerp: Mc,
  damp: Bb,
  pingpong: Cb,
  smoothstep: Qb,
  smootherstep: Eb,
  randInt: lb,
  randFloat: cb,
  randFloatSpread: ub,
  seededRandom: hb,
  degToRad: db,
  radToDeg: fb,
  isPowerOfTwo: Yw,
  ceilPowerOfTwo: mv,
  floorPowerOfTwo: Sv,
  setQuaternionFromProperEuler: pb,
  normalize: _t,
  denormalize: $r
};
class ue {
  constructor(A = 0, e = 0) {
    ue.prototype.isVector2 = !0, this.x = A, this.y = e;
  }
  get width() {
    return this.x;
  }
  set width(A) {
    this.x = A;
  }
  get height() {
    return this.y;
  }
  set height(A) {
    this.y = A;
  }
  set(A, e) {
    return this.x = A, this.y = e, this;
  }
  setScalar(A) {
    return this.x = A, this.y = A, this;
  }
  setX(A) {
    return this.x = A, this;
  }
  setY(A) {
    return this.y = A, this;
  }
  setComponent(A, e) {
    switch (A) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error("index is out of range: " + A);
    }
    return this;
  }
  getComponent(A) {
    switch (A) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + A);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(A) {
    return this.x = A.x, this.y = A.y, this;
  }
  add(A) {
    return this.x += A.x, this.y += A.y, this;
  }
  addScalar(A) {
    return this.x += A, this.y += A, this;
  }
  addVectors(A, e) {
    return this.x = A.x + e.x, this.y = A.y + e.y, this;
  }
  addScaledVector(A, e) {
    return this.x += A.x * e, this.y += A.y * e, this;
  }
  sub(A) {
    return this.x -= A.x, this.y -= A.y, this;
  }
  subScalar(A) {
    return this.x -= A, this.y -= A, this;
  }
  subVectors(A, e) {
    return this.x = A.x - e.x, this.y = A.y - e.y, this;
  }
  multiply(A) {
    return this.x *= A.x, this.y *= A.y, this;
  }
  multiplyScalar(A) {
    return this.x *= A, this.y *= A, this;
  }
  divide(A) {
    return this.x /= A.x, this.y /= A.y, this;
  }
  divideScalar(A) {
    return this.multiplyScalar(1 / A);
  }
  applyMatrix3(A) {
    const e = this.x, t = this.y, i = A.elements;
    return this.x = i[0] * e + i[3] * t + i[6], this.y = i[1] * e + i[4] * t + i[7], this;
  }
  min(A) {
    return this.x = Math.min(this.x, A.x), this.y = Math.min(this.y, A.y), this;
  }
  max(A) {
    return this.x = Math.max(this.x, A.x), this.y = Math.max(this.y, A.y), this;
  }
  clamp(A, e) {
    return this.x = Math.max(A.x, Math.min(e.x, this.x)), this.y = Math.max(A.y, Math.min(e.y, this.y)), this;
  }
  clampScalar(A, e) {
    return this.x = Math.max(A, Math.min(e, this.x)), this.y = Math.max(A, Math.min(e, this.y)), this;
  }
  clampLength(A, e) {
    const t = this.length();
    return this.divideScalar(t || 1).multiplyScalar(Math.max(A, Math.min(e, t)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(A) {
    return this.x * A.x + this.y * A.y;
  }
  cross(A) {
    return this.x * A.y - this.y * A.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(A) {
    const e = Math.sqrt(this.lengthSq() * A.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const t = this.dot(A) / e;
    return Math.acos(yn(t, -1, 1));
  }
  distanceTo(A) {
    return Math.sqrt(this.distanceToSquared(A));
  }
  distanceToSquared(A) {
    const e = this.x - A.x, t = this.y - A.y;
    return e * e + t * t;
  }
  manhattanDistanceTo(A) {
    return Math.abs(this.x - A.x) + Math.abs(this.y - A.y);
  }
  setLength(A) {
    return this.normalize().multiplyScalar(A);
  }
  lerp(A, e) {
    return this.x += (A.x - this.x) * e, this.y += (A.y - this.y) * e, this;
  }
  lerpVectors(A, e, t) {
    return this.x = A.x + (e.x - A.x) * t, this.y = A.y + (e.y - A.y) * t, this;
  }
  equals(A) {
    return A.x === this.x && A.y === this.y;
  }
  fromArray(A, e = 0) {
    return this.x = A[e], this.y = A[e + 1], this;
  }
  toArray(A = [], e = 0) {
    return A[e] = this.x, A[e + 1] = this.y, A;
  }
  fromBufferAttribute(A, e) {
    return this.x = A.getX(e), this.y = A.getY(e), this;
  }
  rotateAround(A, e) {
    const t = Math.cos(e), i = Math.sin(e), n = this.x - A.x, r = this.y - A.y;
    return this.x = n * t - r * i + A.x, this.y = n * i + r * t + A.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class kt {
  constructor() {
    kt.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
  }
  set(A, e, t, i, n, r, s, B, I) {
    const E = this.elements;
    return E[0] = A, E[1] = i, E[2] = s, E[3] = e, E[4] = n, E[5] = B, E[6] = t, E[7] = r, E[8] = I, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(A) {
    const e = this.elements, t = A.elements;
    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this;
  }
  extractBasis(A, e, t) {
    return A.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), t.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(A) {
    const e = A.elements;
    return this.set(
      e[0],
      e[4],
      e[8],
      e[1],
      e[5],
      e[9],
      e[2],
      e[6],
      e[10]
    ), this;
  }
  multiply(A) {
    return this.multiplyMatrices(this, A);
  }
  premultiply(A) {
    return this.multiplyMatrices(A, this);
  }
  multiplyMatrices(A, e) {
    const t = A.elements, i = e.elements, n = this.elements, r = t[0], s = t[3], B = t[6], I = t[1], E = t[4], C = t[7], c = t[2], u = t[5], d = t[8], p = i[0], D = i[3], f = i[6], S = i[1], y = i[4], m = i[7], N = i[2], F = i[5], G = i[8];
    return n[0] = r * p + s * S + B * N, n[3] = r * D + s * y + B * F, n[6] = r * f + s * m + B * G, n[1] = I * p + E * S + C * N, n[4] = I * D + E * y + C * F, n[7] = I * f + E * m + C * G, n[2] = c * p + u * S + d * N, n[5] = c * D + u * y + d * F, n[8] = c * f + u * m + d * G, this;
  }
  multiplyScalar(A) {
    const e = this.elements;
    return e[0] *= A, e[3] *= A, e[6] *= A, e[1] *= A, e[4] *= A, e[7] *= A, e[2] *= A, e[5] *= A, e[8] *= A, this;
  }
  determinant() {
    const A = this.elements, e = A[0], t = A[1], i = A[2], n = A[3], r = A[4], s = A[5], B = A[6], I = A[7], E = A[8];
    return e * r * E - e * s * I - t * n * E + t * s * B + i * n * I - i * r * B;
  }
  invert() {
    const A = this.elements, e = A[0], t = A[1], i = A[2], n = A[3], r = A[4], s = A[5], B = A[6], I = A[7], E = A[8], C = E * r - s * I, c = s * B - E * n, u = I * n - r * B, d = e * C + t * c + i * u;
    if (d === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const p = 1 / d;
    return A[0] = C * p, A[1] = (i * I - E * t) * p, A[2] = (s * t - i * r) * p, A[3] = c * p, A[4] = (E * e - i * B) * p, A[5] = (i * n - s * e) * p, A[6] = u * p, A[7] = (t * B - I * e) * p, A[8] = (r * e - t * n) * p, this;
  }
  transpose() {
    let A;
    const e = this.elements;
    return A = e[1], e[1] = e[3], e[3] = A, A = e[2], e[2] = e[6], e[6] = A, A = e[5], e[5] = e[7], e[7] = A, this;
  }
  getNormalMatrix(A) {
    return this.setFromMatrix4(A).invert().transpose();
  }
  transposeIntoArray(A) {
    const e = this.elements;
    return A[0] = e[0], A[1] = e[3], A[2] = e[6], A[3] = e[1], A[4] = e[4], A[5] = e[7], A[6] = e[2], A[7] = e[5], A[8] = e[8], this;
  }
  setUvTransform(A, e, t, i, n, r, s) {
    const B = Math.cos(n), I = Math.sin(n);
    return this.set(
      t * B,
      t * I,
      -t * (B * r + I * s) + r + A,
      -i * I,
      i * B,
      -i * (-I * r + B * s) + s + e,
      0,
      0,
      1
    ), this;
  }
  //
  scale(A, e) {
    return this.premultiply(XD.makeScale(A, e)), this;
  }
  rotate(A) {
    return this.premultiply(XD.makeRotation(-A)), this;
  }
  translate(A, e) {
    return this.premultiply(XD.makeTranslation(A, e)), this;
  }
  // for 2D Transforms
  makeTranslation(A, e) {
    return this.set(
      1,
      0,
      A,
      0,
      1,
      e,
      0,
      0,
      1
    ), this;
  }
  makeRotation(A) {
    const e = Math.cos(A), t = Math.sin(A);
    return this.set(
      e,
      -t,
      0,
      t,
      e,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(A, e) {
    return this.set(
      A,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(A) {
    const e = this.elements, t = A.elements;
    for (let i = 0; i < 9; i++)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
  fromArray(A, e = 0) {
    for (let t = 0; t < 9; t++)
      this.elements[t] = A[t + e];
    return this;
  }
  toArray(A = [], e = 0) {
    const t = this.elements;
    return A[e] = t[0], A[e + 1] = t[1], A[e + 2] = t[2], A[e + 3] = t[3], A[e + 4] = t[4], A[e + 5] = t[5], A[e + 6] = t[6], A[e + 7] = t[7], A[e + 8] = t[8], A;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const XD = /* @__PURE__ */ new kt();
function Mv(g) {
  for (let A = g.length - 1; A >= 0; --A)
    if (g[A] >= 65535)
      return !0;
  return !1;
}
const Db = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function hE(g, A) {
  return new Db[g](A);
}
function Kc(g) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", g);
}
function DE(g) {
  return g < 0.04045 ? g * 0.0773993808 : Math.pow(g * 0.9478672986 + 0.0521327014, 2.4);
}
function $D(g) {
  return g < 31308e-7 ? g * 12.92 : 1.055 * Math.pow(g, 0.41666) - 0.055;
}
const wb = /* @__PURE__ */ new kt().fromArray([
  0.8224621,
  0.0331941,
  0.0170827,
  0.177538,
  0.9668058,
  0.0723974,
  -1e-7,
  1e-7,
  0.9105199
]), yb = /* @__PURE__ */ new kt().fromArray([
  1.2249401,
  -0.0420569,
  -0.0196376,
  -0.2249404,
  1.0420571,
  -0.0786361,
  1e-7,
  0,
  1.0982735
]);
function mb(g) {
  return g.convertSRGBToLinear().applyMatrix3(yb);
}
function Sb(g) {
  return g.applyMatrix3(wb).convertLinearToSRGB();
}
const Mb = {
  [FE]: (g) => g,
  [ss]: (g) => g.convertSRGBToLinear(),
  [wy]: mb
}, Rb = {
  [FE]: (g) => g,
  [ss]: (g) => g.convertLinearToSRGB(),
  [wy]: Sb
}, pr = {
  enabled: !1,
  get legacyMode() {
    return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled;
  },
  set legacyMode(g) {
    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !g;
  },
  get workingColorSpace() {
    return FE;
  },
  set workingColorSpace(g) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  },
  convert: function(g, A, e) {
    if (this.enabled === !1 || A === e || !A || !e)
      return g;
    const t = Mb[A], i = Rb[e];
    if (t === void 0 || i === void 0)
      throw new Error(`Unsupported color space conversion, "${A}" to "${e}".`);
    return i(t(g));
  },
  fromWorkingColorSpace: function(g, A) {
    return this.convert(g, this.workingColorSpace, A);
  },
  toWorkingColorSpace: function(g, A) {
    return this.convert(g, A, this.workingColorSpace);
  }
};
let HQ;
class my {
  static getDataURL(A) {
    if (/^data:/i.test(A.src) || typeof HTMLCanvasElement > "u")
      return A.src;
    let e;
    if (A instanceof HTMLCanvasElement)
      e = A;
    else {
      HQ === void 0 && (HQ = Kc("canvas")), HQ.width = A.width, HQ.height = A.height;
      const t = HQ.getContext("2d");
      A instanceof ImageData ? t.putImageData(A, 0, 0) : t.drawImage(A, 0, 0, A.width, A.height), e = HQ;
    }
    return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", A), e.toDataURL("image/jpeg", 0.6)) : e.toDataURL("image/png");
  }
  static sRGBToLinear(A) {
    if (typeof HTMLImageElement < "u" && A instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && A instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && A instanceof ImageBitmap) {
      const e = Kc("canvas");
      e.width = A.width, e.height = A.height;
      const t = e.getContext("2d");
      t.drawImage(A, 0, 0, A.width, A.height);
      const i = t.getImageData(0, 0, A.width, A.height), n = i.data;
      for (let r = 0; r < n.length; r++)
        n[r] = DE(n[r] / 255) * 255;
      return t.putImageData(i, 0, 0), e;
    } else if (A.data) {
      const e = A.data.slice(0);
      for (let t = 0; t < e.length; t++)
        e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(DE(e[t] / 255) * 255) : e[t] = DE(e[t]);
      return {
        data: e,
        width: A.width,
        height: A.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), A;
  }
}
class IB {
  constructor(A = null) {
    this.isSource = !0, this.uuid = io(), this.data = A, this.version = 0;
  }
  set needsUpdate(A) {
    A === !0 && this.version++;
  }
  toJSON(A) {
    const e = A === void 0 || typeof A == "string";
    if (!e && A.images[this.uuid] !== void 0)
      return A.images[this.uuid];
    const t = {
      uuid: this.uuid,
      url: ""
    }, i = this.data;
    if (i !== null) {
      let n;
      if (Array.isArray(i)) {
        n = [];
        for (let r = 0, s = i.length; r < s; r++)
          i[r].isDataTexture ? n.push(A0(i[r].image)) : n.push(A0(i[r]));
      } else
        n = A0(i);
      t.url = n;
    }
    return e || (A.images[this.uuid] = t), t;
  }
}
function A0(g) {
  return typeof HTMLImageElement < "u" && g instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && g instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && g instanceof ImageBitmap ? my.getDataURL(g) : g.data ? {
    data: Array.from(g.data),
    width: g.width,
    height: g.height,
    type: g.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let Nb = 0;
class xi extends Za {
  constructor(A = xi.DEFAULT_IMAGE, e = xi.DEFAULT_MAPPING, t = Jn, i = Jn, n = Gi, r = Cs, s = tr, B = Va, I = xi.DEFAULT_ANISOTROPY, E = ta) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: Nb++ }), this.uuid = io(), this.name = "", this.source = new IB(A), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = t, this.wrapT = i, this.magFilter = n, this.minFilter = r, this.anisotropy = I, this.format = s, this.internalFormat = null, this.type = B, this.offset = new ue(0, 0), this.repeat = new ue(1, 1), this.center = new ue(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new kt(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = E, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(A = null) {
    this.source.data = A;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(A) {
    return this.name = A.name, this.source = A.source, this.mipmaps = A.mipmaps.slice(0), this.mapping = A.mapping, this.channel = A.channel, this.wrapS = A.wrapS, this.wrapT = A.wrapT, this.magFilter = A.magFilter, this.minFilter = A.minFilter, this.anisotropy = A.anisotropy, this.format = A.format, this.internalFormat = A.internalFormat, this.type = A.type, this.offset.copy(A.offset), this.repeat.copy(A.repeat), this.center.copy(A.center), this.rotation = A.rotation, this.matrixAutoUpdate = A.matrixAutoUpdate, this.matrix.copy(A.matrix), this.generateMipmaps = A.generateMipmaps, this.premultiplyAlpha = A.premultiplyAlpha, this.flipY = A.flipY, this.unpackAlignment = A.unpackAlignment, this.encoding = A.encoding, this.userData = JSON.parse(JSON.stringify(A.userData)), this.needsUpdate = !0, this;
  }
  toJSON(A) {
    const e = A === void 0 || typeof A == "string";
    if (!e && A.textures[this.uuid] !== void 0)
      return A.textures[this.uuid];
    const t = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(A).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (t.userData = this.userData), e || (A.textures[this.uuid] = t), t;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(A) {
    if (this.mapping !== Sf)
      return A;
    if (A.applyMatrix3(this.matrix), A.x < 0 || A.x > 1)
      switch (this.wrapS) {
        case Bs:
          A.x = A.x - Math.floor(A.x);
          break;
        case Jn:
          A.x = A.x < 0 ? 0 : 1;
          break;
        case kC:
          Math.abs(Math.floor(A.x) % 2) === 1 ? A.x = Math.ceil(A.x) - A.x : A.x = A.x - Math.floor(A.x);
          break;
      }
    if (A.y < 0 || A.y > 1)
      switch (this.wrapT) {
        case Bs:
          A.y = A.y - Math.floor(A.y);
          break;
        case Jn:
          A.y = A.y < 0 ? 0 : 1;
          break;
        case kC:
          Math.abs(Math.floor(A.y) % 2) === 1 ? A.y = Math.ceil(A.y) - A.y : A.y = A.y - Math.floor(A.y);
          break;
      }
    return this.flipY && (A.y = 1 - A.y), A;
  }
  set needsUpdate(A) {
    A === !0 && (this.version++, this.source.needsUpdate = !0);
  }
}
xi.DEFAULT_IMAGE = null;
xi.DEFAULT_MAPPING = Sf;
xi.DEFAULT_ANISOTROPY = 1;
class Bi {
  constructor(A = 0, e = 0, t = 0, i = 1) {
    Bi.prototype.isVector4 = !0, this.x = A, this.y = e, this.z = t, this.w = i;
  }
  get width() {
    return this.z;
  }
  set width(A) {
    this.z = A;
  }
  get height() {
    return this.w;
  }
  set height(A) {
    this.w = A;
  }
  set(A, e, t, i) {
    return this.x = A, this.y = e, this.z = t, this.w = i, this;
  }
  setScalar(A) {
    return this.x = A, this.y = A, this.z = A, this.w = A, this;
  }
  setX(A) {
    return this.x = A, this;
  }
  setY(A) {
    return this.y = A, this;
  }
  setZ(A) {
    return this.z = A, this;
  }
  setW(A) {
    return this.w = A, this;
  }
  setComponent(A, e) {
    switch (A) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      case 3:
        this.w = e;
        break;
      default:
        throw new Error("index is out of range: " + A);
    }
    return this;
  }
  getComponent(A) {
    switch (A) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + A);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(A) {
    return this.x = A.x, this.y = A.y, this.z = A.z, this.w = A.w !== void 0 ? A.w : 1, this;
  }
  add(A) {
    return this.x += A.x, this.y += A.y, this.z += A.z, this.w += A.w, this;
  }
  addScalar(A) {
    return this.x += A, this.y += A, this.z += A, this.w += A, this;
  }
  addVectors(A, e) {
    return this.x = A.x + e.x, this.y = A.y + e.y, this.z = A.z + e.z, this.w = A.w + e.w, this;
  }
  addScaledVector(A, e) {
    return this.x += A.x * e, this.y += A.y * e, this.z += A.z * e, this.w += A.w * e, this;
  }
  sub(A) {
    return this.x -= A.x, this.y -= A.y, this.z -= A.z, this.w -= A.w, this;
  }
  subScalar(A) {
    return this.x -= A, this.y -= A, this.z -= A, this.w -= A, this;
  }
  subVectors(A, e) {
    return this.x = A.x - e.x, this.y = A.y - e.y, this.z = A.z - e.z, this.w = A.w - e.w, this;
  }
  multiply(A) {
    return this.x *= A.x, this.y *= A.y, this.z *= A.z, this.w *= A.w, this;
  }
  multiplyScalar(A) {
    return this.x *= A, this.y *= A, this.z *= A, this.w *= A, this;
  }
  applyMatrix4(A) {
    const e = this.x, t = this.y, i = this.z, n = this.w, r = A.elements;
    return this.x = r[0] * e + r[4] * t + r[8] * i + r[12] * n, this.y = r[1] * e + r[5] * t + r[9] * i + r[13] * n, this.z = r[2] * e + r[6] * t + r[10] * i + r[14] * n, this.w = r[3] * e + r[7] * t + r[11] * i + r[15] * n, this;
  }
  divideScalar(A) {
    return this.multiplyScalar(1 / A);
  }
  setAxisAngleFromQuaternion(A) {
    this.w = 2 * Math.acos(A.w);
    const e = Math.sqrt(1 - A.w * A.w);
    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = A.x / e, this.y = A.y / e, this.z = A.z / e), this;
  }
  setAxisAngleFromRotationMatrix(A) {
    let e, t, i, n;
    const B = A.elements, I = B[0], E = B[4], C = B[8], c = B[1], u = B[5], d = B[9], p = B[2], D = B[6], f = B[10];
    if (Math.abs(E - c) < 0.01 && Math.abs(C - p) < 0.01 && Math.abs(d - D) < 0.01) {
      if (Math.abs(E + c) < 0.1 && Math.abs(C + p) < 0.1 && Math.abs(d + D) < 0.1 && Math.abs(I + u + f - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      e = Math.PI;
      const y = (I + 1) / 2, m = (u + 1) / 2, N = (f + 1) / 2, F = (E + c) / 4, G = (C + p) / 4, k = (d + D) / 4;
      return y > m && y > N ? y < 0.01 ? (t = 0, i = 0.707106781, n = 0.707106781) : (t = Math.sqrt(y), i = F / t, n = G / t) : m > N ? m < 0.01 ? (t = 0.707106781, i = 0, n = 0.707106781) : (i = Math.sqrt(m), t = F / i, n = k / i) : N < 0.01 ? (t = 0.707106781, i = 0.707106781, n = 0) : (n = Math.sqrt(N), t = G / n, i = k / n), this.set(t, i, n, e), this;
    }
    let S = Math.sqrt((D - d) * (D - d) + (C - p) * (C - p) + (c - E) * (c - E));
    return Math.abs(S) < 1e-3 && (S = 1), this.x = (D - d) / S, this.y = (C - p) / S, this.z = (c - E) / S, this.w = Math.acos((I + u + f - 1) / 2), this;
  }
  min(A) {
    return this.x = Math.min(this.x, A.x), this.y = Math.min(this.y, A.y), this.z = Math.min(this.z, A.z), this.w = Math.min(this.w, A.w), this;
  }
  max(A) {
    return this.x = Math.max(this.x, A.x), this.y = Math.max(this.y, A.y), this.z = Math.max(this.z, A.z), this.w = Math.max(this.w, A.w), this;
  }
  clamp(A, e) {
    return this.x = Math.max(A.x, Math.min(e.x, this.x)), this.y = Math.max(A.y, Math.min(e.y, this.y)), this.z = Math.max(A.z, Math.min(e.z, this.z)), this.w = Math.max(A.w, Math.min(e.w, this.w)), this;
  }
  clampScalar(A, e) {
    return this.x = Math.max(A, Math.min(e, this.x)), this.y = Math.max(A, Math.min(e, this.y)), this.z = Math.max(A, Math.min(e, this.z)), this.w = Math.max(A, Math.min(e, this.w)), this;
  }
  clampLength(A, e) {
    const t = this.length();
    return this.divideScalar(t || 1).multiplyScalar(Math.max(A, Math.min(e, t)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(A) {
    return this.x * A.x + this.y * A.y + this.z * A.z + this.w * A.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(A) {
    return this.normalize().multiplyScalar(A);
  }
  lerp(A, e) {
    return this.x += (A.x - this.x) * e, this.y += (A.y - this.y) * e, this.z += (A.z - this.z) * e, this.w += (A.w - this.w) * e, this;
  }
  lerpVectors(A, e, t) {
    return this.x = A.x + (e.x - A.x) * t, this.y = A.y + (e.y - A.y) * t, this.z = A.z + (e.z - A.z) * t, this.w = A.w + (e.w - A.w) * t, this;
  }
  equals(A) {
    return A.x === this.x && A.y === this.y && A.z === this.z && A.w === this.w;
  }
  fromArray(A, e = 0) {
    return this.x = A[e], this.y = A[e + 1], this.z = A[e + 2], this.w = A[e + 3], this;
  }
  toArray(A = [], e = 0) {
    return A[e] = this.x, A[e + 1] = this.y, A[e + 2] = this.z, A[e + 3] = this.w, A;
  }
  fromBufferAttribute(A, e) {
    return this.x = A.getX(e), this.y = A.getY(e), this.z = A.getZ(e), this.w = A.getW(e), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Uo extends Za {
  constructor(A = 1, e = 1, t = {}) {
    super(), this.isWebGLRenderTarget = !0, this.width = A, this.height = e, this.depth = 1, this.scissor = new Bi(0, 0, A, e), this.scissorTest = !1, this.viewport = new Bi(0, 0, A, e);
    const i = { width: A, height: e, depth: 1 };
    this.texture = new xi(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.internalFormat = t.internalFormat !== void 0 ? t.internalFormat : null, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Gi, this.depthBuffer = t.depthBuffer !== void 0 ? t.depthBuffer : !0, this.stencilBuffer = t.stencilBuffer !== void 0 ? t.stencilBuffer : !1, this.depthTexture = t.depthTexture !== void 0 ? t.depthTexture : null, this.samples = t.samples !== void 0 ? t.samples : 0;
  }
  setSize(A, e, t = 1) {
    (this.width !== A || this.height !== e || this.depth !== t) && (this.width = A, this.height = e, this.depth = t, this.texture.image.width = A, this.texture.image.height = e, this.texture.image.depth = t, this.dispose()), this.viewport.set(0, 0, A, e), this.scissor.set(0, 0, A, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(A) {
    this.width = A.width, this.height = A.height, this.depth = A.depth, this.viewport.copy(A.viewport), this.texture = A.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const e = Object.assign({}, A.texture.image);
    return this.texture.source = new IB(e), this.depthBuffer = A.depthBuffer, this.stencilBuffer = A.stencilBuffer, A.depthTexture !== null && (this.depthTexture = A.depthTexture.clone()), this.samples = A.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Rf extends xi {
  constructor(A = null, e = 1, t = 1, i = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: A, width: e, height: t, depth: i }, this.magFilter = un, this.minFilter = un, this.wrapR = Jn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Fb extends Uo {
  constructor(A = 1, e = 1, t = 1) {
    super(A, e), this.isWebGLArrayRenderTarget = !0, this.depth = t, this.texture = new Rf(null, A, e, t), this.texture.isRenderTargetTexture = !0;
  }
}
class Sy extends xi {
  constructor(A = null, e = 1, t = 1, i = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: A, width: e, height: t, depth: i }, this.magFilter = un, this.minFilter = un, this.wrapR = Jn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Gb extends Uo {
  constructor(A = 1, e = 1, t = 1) {
    super(A, e), this.isWebGL3DRenderTarget = !0, this.depth = t, this.texture = new Sy(null, A, e, t), this.texture.isRenderTargetTexture = !0;
  }
}
class vb extends Uo {
  constructor(A = 1, e = 1, t = 1, i = {}) {
    super(A, e, i), this.isWebGLMultipleRenderTargets = !0;
    const n = this.texture;
    this.texture = [];
    for (let r = 0; r < t; r++)
      this.texture[r] = n.clone(), this.texture[r].isRenderTargetTexture = !0;
  }
  setSize(A, e, t = 1) {
    if (this.width !== A || this.height !== e || this.depth !== t) {
      this.width = A, this.height = e, this.depth = t;
      for (let i = 0, n = this.texture.length; i < n; i++)
        this.texture[i].image.width = A, this.texture[i].image.height = e, this.texture[i].image.depth = t;
      this.dispose();
    }
    return this.viewport.set(0, 0, A, e), this.scissor.set(0, 0, A, e), this;
  }
  copy(A) {
    this.dispose(), this.width = A.width, this.height = A.height, this.depth = A.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = A.depthBuffer, this.stencilBuffer = A.stencilBuffer, A.depthTexture !== null && (this.depthTexture = A.depthTexture.clone()), this.texture.length = 0;
    for (let e = 0, t = A.texture.length; e < t; e++)
      this.texture[e] = A.texture[e].clone(), this.texture[e].isRenderTargetTexture = !0;
    return this;
  }
}
class On {
  constructor(A = 0, e = 0, t = 0, i = 1) {
    this.isQuaternion = !0, this._x = A, this._y = e, this._z = t, this._w = i;
  }
  static slerpFlat(A, e, t, i, n, r, s) {
    let B = t[i + 0], I = t[i + 1], E = t[i + 2], C = t[i + 3];
    const c = n[r + 0], u = n[r + 1], d = n[r + 2], p = n[r + 3];
    if (s === 0) {
      A[e + 0] = B, A[e + 1] = I, A[e + 2] = E, A[e + 3] = C;
      return;
    }
    if (s === 1) {
      A[e + 0] = c, A[e + 1] = u, A[e + 2] = d, A[e + 3] = p;
      return;
    }
    if (C !== p || B !== c || I !== u || E !== d) {
      let D = 1 - s;
      const f = B * c + I * u + E * d + C * p, S = f >= 0 ? 1 : -1, y = 1 - f * f;
      if (y > Number.EPSILON) {
        const N = Math.sqrt(y), F = Math.atan2(N, f * S);
        D = Math.sin(D * F) / N, s = Math.sin(s * F) / N;
      }
      const m = s * S;
      if (B = B * D + c * m, I = I * D + u * m, E = E * D + d * m, C = C * D + p * m, D === 1 - s) {
        const N = 1 / Math.sqrt(B * B + I * I + E * E + C * C);
        B *= N, I *= N, E *= N, C *= N;
      }
    }
    A[e] = B, A[e + 1] = I, A[e + 2] = E, A[e + 3] = C;
  }
  static multiplyQuaternionsFlat(A, e, t, i, n, r) {
    const s = t[i], B = t[i + 1], I = t[i + 2], E = t[i + 3], C = n[r], c = n[r + 1], u = n[r + 2], d = n[r + 3];
    return A[e] = s * d + E * C + B * u - I * c, A[e + 1] = B * d + E * c + I * C - s * u, A[e + 2] = I * d + E * u + s * c - B * C, A[e + 3] = E * d - s * C - B * c - I * u, A;
  }
  get x() {
    return this._x;
  }
  set x(A) {
    this._x = A, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(A) {
    this._y = A, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(A) {
    this._z = A, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(A) {
    this._w = A, this._onChangeCallback();
  }
  set(A, e, t, i) {
    return this._x = A, this._y = e, this._z = t, this._w = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(A) {
    return this._x = A.x, this._y = A.y, this._z = A.z, this._w = A.w, this._onChangeCallback(), this;
  }
  setFromEuler(A, e) {
    const t = A._x, i = A._y, n = A._z, r = A._order, s = Math.cos, B = Math.sin, I = s(t / 2), E = s(i / 2), C = s(n / 2), c = B(t / 2), u = B(i / 2), d = B(n / 2);
    switch (r) {
      case "XYZ":
        this._x = c * E * C + I * u * d, this._y = I * u * C - c * E * d, this._z = I * E * d + c * u * C, this._w = I * E * C - c * u * d;
        break;
      case "YXZ":
        this._x = c * E * C + I * u * d, this._y = I * u * C - c * E * d, this._z = I * E * d - c * u * C, this._w = I * E * C + c * u * d;
        break;
      case "ZXY":
        this._x = c * E * C - I * u * d, this._y = I * u * C + c * E * d, this._z = I * E * d + c * u * C, this._w = I * E * C - c * u * d;
        break;
      case "ZYX":
        this._x = c * E * C - I * u * d, this._y = I * u * C + c * E * d, this._z = I * E * d - c * u * C, this._w = I * E * C + c * u * d;
        break;
      case "YZX":
        this._x = c * E * C + I * u * d, this._y = I * u * C + c * E * d, this._z = I * E * d - c * u * C, this._w = I * E * C - c * u * d;
        break;
      case "XZY":
        this._x = c * E * C - I * u * d, this._y = I * u * C - c * E * d, this._z = I * E * d + c * u * C, this._w = I * E * C + c * u * d;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + r);
    }
    return e !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(A, e) {
    const t = e / 2, i = Math.sin(t);
    return this._x = A.x * i, this._y = A.y * i, this._z = A.z * i, this._w = Math.cos(t), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(A) {
    const e = A.elements, t = e[0], i = e[4], n = e[8], r = e[1], s = e[5], B = e[9], I = e[2], E = e[6], C = e[10], c = t + s + C;
    if (c > 0) {
      const u = 0.5 / Math.sqrt(c + 1);
      this._w = 0.25 / u, this._x = (E - B) * u, this._y = (n - I) * u, this._z = (r - i) * u;
    } else if (t > s && t > C) {
      const u = 2 * Math.sqrt(1 + t - s - C);
      this._w = (E - B) / u, this._x = 0.25 * u, this._y = (i + r) / u, this._z = (n + I) / u;
    } else if (s > C) {
      const u = 2 * Math.sqrt(1 + s - t - C);
      this._w = (n - I) / u, this._x = (i + r) / u, this._y = 0.25 * u, this._z = (B + E) / u;
    } else {
      const u = 2 * Math.sqrt(1 + C - t - s);
      this._w = (r - i) / u, this._x = (n + I) / u, this._y = (B + E) / u, this._z = 0.25 * u;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(A, e) {
    let t = A.dot(e) + 1;
    return t < Number.EPSILON ? (t = 0, Math.abs(A.x) > Math.abs(A.z) ? (this._x = -A.y, this._y = A.x, this._z = 0, this._w = t) : (this._x = 0, this._y = -A.z, this._z = A.y, this._w = t)) : (this._x = A.y * e.z - A.z * e.y, this._y = A.z * e.x - A.x * e.z, this._z = A.x * e.y - A.y * e.x, this._w = t), this.normalize();
  }
  angleTo(A) {
    return 2 * Math.acos(Math.abs(yn(this.dot(A), -1, 1)));
  }
  rotateTowards(A, e) {
    const t = this.angleTo(A);
    if (t === 0)
      return this;
    const i = Math.min(1, e / t);
    return this.slerp(A, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(A) {
    return this._x * A._x + this._y * A._y + this._z * A._z + this._w * A._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let A = this.length();
    return A === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (A = 1 / A, this._x = this._x * A, this._y = this._y * A, this._z = this._z * A, this._w = this._w * A), this._onChangeCallback(), this;
  }
  multiply(A) {
    return this.multiplyQuaternions(this, A);
  }
  premultiply(A) {
    return this.multiplyQuaternions(A, this);
  }
  multiplyQuaternions(A, e) {
    const t = A._x, i = A._y, n = A._z, r = A._w, s = e._x, B = e._y, I = e._z, E = e._w;
    return this._x = t * E + r * s + i * I - n * B, this._y = i * E + r * B + n * s - t * I, this._z = n * E + r * I + t * B - i * s, this._w = r * E - t * s - i * B - n * I, this._onChangeCallback(), this;
  }
  slerp(A, e) {
    if (e === 0)
      return this;
    if (e === 1)
      return this.copy(A);
    const t = this._x, i = this._y, n = this._z, r = this._w;
    let s = r * A._w + t * A._x + i * A._y + n * A._z;
    if (s < 0 ? (this._w = -A._w, this._x = -A._x, this._y = -A._y, this._z = -A._z, s = -s) : this.copy(A), s >= 1)
      return this._w = r, this._x = t, this._y = i, this._z = n, this;
    const B = 1 - s * s;
    if (B <= Number.EPSILON) {
      const u = 1 - e;
      return this._w = u * r + e * this._w, this._x = u * t + e * this._x, this._y = u * i + e * this._y, this._z = u * n + e * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const I = Math.sqrt(B), E = Math.atan2(I, s), C = Math.sin((1 - e) * E) / I, c = Math.sin(e * E) / I;
    return this._w = r * C + this._w * c, this._x = t * C + this._x * c, this._y = i * C + this._y * c, this._z = n * C + this._z * c, this._onChangeCallback(), this;
  }
  slerpQuaternions(A, e, t) {
    return this.copy(A).slerp(e, t);
  }
  random() {
    const A = Math.random(), e = Math.sqrt(1 - A), t = Math.sqrt(A), i = 2 * Math.PI * Math.random(), n = 2 * Math.PI * Math.random();
    return this.set(
      e * Math.cos(i),
      t * Math.sin(n),
      t * Math.cos(n),
      e * Math.sin(i)
    );
  }
  equals(A) {
    return A._x === this._x && A._y === this._y && A._z === this._z && A._w === this._w;
  }
  fromArray(A, e = 0) {
    return this._x = A[e], this._y = A[e + 1], this._z = A[e + 2], this._w = A[e + 3], this._onChangeCallback(), this;
  }
  toArray(A = [], e = 0) {
    return A[e] = this._x, A[e + 1] = this._y, A[e + 2] = this._z, A[e + 3] = this._w, A;
  }
  fromBufferAttribute(A, e) {
    return this._x = A.getX(e), this._y = A.getY(e), this._z = A.getZ(e), this._w = A.getW(e), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(A) {
    return this._onChangeCallback = A, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class IA {
  constructor(A = 0, e = 0, t = 0) {
    IA.prototype.isVector3 = !0, this.x = A, this.y = e, this.z = t;
  }
  set(A, e, t) {
    return t === void 0 && (t = this.z), this.x = A, this.y = e, this.z = t, this;
  }
  setScalar(A) {
    return this.x = A, this.y = A, this.z = A, this;
  }
  setX(A) {
    return this.x = A, this;
  }
  setY(A) {
    return this.y = A, this;
  }
  setZ(A) {
    return this.z = A, this;
  }
  setComponent(A, e) {
    switch (A) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error("index is out of range: " + A);
    }
    return this;
  }
  getComponent(A) {
    switch (A) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + A);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(A) {
    return this.x = A.x, this.y = A.y, this.z = A.z, this;
  }
  add(A) {
    return this.x += A.x, this.y += A.y, this.z += A.z, this;
  }
  addScalar(A) {
    return this.x += A, this.y += A, this.z += A, this;
  }
  addVectors(A, e) {
    return this.x = A.x + e.x, this.y = A.y + e.y, this.z = A.z + e.z, this;
  }
  addScaledVector(A, e) {
    return this.x += A.x * e, this.y += A.y * e, this.z += A.z * e, this;
  }
  sub(A) {
    return this.x -= A.x, this.y -= A.y, this.z -= A.z, this;
  }
  subScalar(A) {
    return this.x -= A, this.y -= A, this.z -= A, this;
  }
  subVectors(A, e) {
    return this.x = A.x - e.x, this.y = A.y - e.y, this.z = A.z - e.z, this;
  }
  multiply(A) {
    return this.x *= A.x, this.y *= A.y, this.z *= A.z, this;
  }
  multiplyScalar(A) {
    return this.x *= A, this.y *= A, this.z *= A, this;
  }
  multiplyVectors(A, e) {
    return this.x = A.x * e.x, this.y = A.y * e.y, this.z = A.z * e.z, this;
  }
  applyEuler(A) {
    return this.applyQuaternion(uR.setFromEuler(A));
  }
  applyAxisAngle(A, e) {
    return this.applyQuaternion(uR.setFromAxisAngle(A, e));
  }
  applyMatrix3(A) {
    const e = this.x, t = this.y, i = this.z, n = A.elements;
    return this.x = n[0] * e + n[3] * t + n[6] * i, this.y = n[1] * e + n[4] * t + n[7] * i, this.z = n[2] * e + n[5] * t + n[8] * i, this;
  }
  applyNormalMatrix(A) {
    return this.applyMatrix3(A).normalize();
  }
  applyMatrix4(A) {
    const e = this.x, t = this.y, i = this.z, n = A.elements, r = 1 / (n[3] * e + n[7] * t + n[11] * i + n[15]);
    return this.x = (n[0] * e + n[4] * t + n[8] * i + n[12]) * r, this.y = (n[1] * e + n[5] * t + n[9] * i + n[13]) * r, this.z = (n[2] * e + n[6] * t + n[10] * i + n[14]) * r, this;
  }
  applyQuaternion(A) {
    const e = this.x, t = this.y, i = this.z, n = A.x, r = A.y, s = A.z, B = A.w, I = B * e + r * i - s * t, E = B * t + s * e - n * i, C = B * i + n * t - r * e, c = -n * e - r * t - s * i;
    return this.x = I * B + c * -n + E * -s - C * -r, this.y = E * B + c * -r + C * -n - I * -s, this.z = C * B + c * -s + I * -r - E * -n, this;
  }
  project(A) {
    return this.applyMatrix4(A.matrixWorldInverse).applyMatrix4(A.projectionMatrix);
  }
  unproject(A) {
    return this.applyMatrix4(A.projectionMatrixInverse).applyMatrix4(A.matrixWorld);
  }
  transformDirection(A) {
    const e = this.x, t = this.y, i = this.z, n = A.elements;
    return this.x = n[0] * e + n[4] * t + n[8] * i, this.y = n[1] * e + n[5] * t + n[9] * i, this.z = n[2] * e + n[6] * t + n[10] * i, this.normalize();
  }
  divide(A) {
    return this.x /= A.x, this.y /= A.y, this.z /= A.z, this;
  }
  divideScalar(A) {
    return this.multiplyScalar(1 / A);
  }
  min(A) {
    return this.x = Math.min(this.x, A.x), this.y = Math.min(this.y, A.y), this.z = Math.min(this.z, A.z), this;
  }
  max(A) {
    return this.x = Math.max(this.x, A.x), this.y = Math.max(this.y, A.y), this.z = Math.max(this.z, A.z), this;
  }
  clamp(A, e) {
    return this.x = Math.max(A.x, Math.min(e.x, this.x)), this.y = Math.max(A.y, Math.min(e.y, this.y)), this.z = Math.max(A.z, Math.min(e.z, this.z)), this;
  }
  clampScalar(A, e) {
    return this.x = Math.max(A, Math.min(e, this.x)), this.y = Math.max(A, Math.min(e, this.y)), this.z = Math.max(A, Math.min(e, this.z)), this;
  }
  clampLength(A, e) {
    const t = this.length();
    return this.divideScalar(t || 1).multiplyScalar(Math.max(A, Math.min(e, t)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(A) {
    return this.x * A.x + this.y * A.y + this.z * A.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(A) {
    return this.normalize().multiplyScalar(A);
  }
  lerp(A, e) {
    return this.x += (A.x - this.x) * e, this.y += (A.y - this.y) * e, this.z += (A.z - this.z) * e, this;
  }
  lerpVectors(A, e, t) {
    return this.x = A.x + (e.x - A.x) * t, this.y = A.y + (e.y - A.y) * t, this.z = A.z + (e.z - A.z) * t, this;
  }
  cross(A) {
    return this.crossVectors(this, A);
  }
  crossVectors(A, e) {
    const t = A.x, i = A.y, n = A.z, r = e.x, s = e.y, B = e.z;
    return this.x = i * B - n * s, this.y = n * r - t * B, this.z = t * s - i * r, this;
  }
  projectOnVector(A) {
    const e = A.lengthSq();
    if (e === 0)
      return this.set(0, 0, 0);
    const t = A.dot(this) / e;
    return this.copy(A).multiplyScalar(t);
  }
  projectOnPlane(A) {
    return e0.copy(this).projectOnVector(A), this.sub(e0);
  }
  reflect(A) {
    return this.sub(e0.copy(A).multiplyScalar(2 * this.dot(A)));
  }
  angleTo(A) {
    const e = Math.sqrt(this.lengthSq() * A.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const t = this.dot(A) / e;
    return Math.acos(yn(t, -1, 1));
  }
  distanceTo(A) {
    return Math.sqrt(this.distanceToSquared(A));
  }
  distanceToSquared(A) {
    const e = this.x - A.x, t = this.y - A.y, i = this.z - A.z;
    return e * e + t * t + i * i;
  }
  manhattanDistanceTo(A) {
    return Math.abs(this.x - A.x) + Math.abs(this.y - A.y) + Math.abs(this.z - A.z);
  }
  setFromSpherical(A) {
    return this.setFromSphericalCoords(A.radius, A.phi, A.theta);
  }
  setFromSphericalCoords(A, e, t) {
    const i = Math.sin(e) * A;
    return this.x = i * Math.sin(t), this.y = Math.cos(e) * A, this.z = i * Math.cos(t), this;
  }
  setFromCylindrical(A) {
    return this.setFromCylindricalCoords(A.radius, A.theta, A.y);
  }
  setFromCylindricalCoords(A, e, t) {
    return this.x = A * Math.sin(e), this.y = t, this.z = A * Math.cos(e), this;
  }
  setFromMatrixPosition(A) {
    const e = A.elements;
    return this.x = e[12], this.y = e[13], this.z = e[14], this;
  }
  setFromMatrixScale(A) {
    const e = this.setFromMatrixColumn(A, 0).length(), t = this.setFromMatrixColumn(A, 1).length(), i = this.setFromMatrixColumn(A, 2).length();
    return this.x = e, this.y = t, this.z = i, this;
  }
  setFromMatrixColumn(A, e) {
    return this.fromArray(A.elements, e * 4);
  }
  setFromMatrix3Column(A, e) {
    return this.fromArray(A.elements, e * 3);
  }
  setFromEuler(A) {
    return this.x = A._x, this.y = A._y, this.z = A._z, this;
  }
  setFromColor(A) {
    return this.x = A.r, this.y = A.g, this.z = A.b, this;
  }
  equals(A) {
    return A.x === this.x && A.y === this.y && A.z === this.z;
  }
  fromArray(A, e = 0) {
    return this.x = A[e], this.y = A[e + 1], this.z = A[e + 2], this;
  }
  toArray(A = [], e = 0) {
    return A[e] = this.x, A[e + 1] = this.y, A[e + 2] = this.z, A;
  }
  fromBufferAttribute(A, e) {
    return this.x = A.getX(e), this.y = A.getY(e), this.z = A.getZ(e), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const A = (Math.random() - 0.5) * 2, e = Math.random() * Math.PI * 2, t = Math.sqrt(1 - A ** 2);
    return this.x = t * Math.cos(e), this.y = t * Math.sin(e), this.z = A, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const e0 = /* @__PURE__ */ new IA(), uR = /* @__PURE__ */ new On();
class cs {
  constructor(A = new IA(1 / 0, 1 / 0, 1 / 0), e = new IA(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = A, this.max = e;
  }
  set(A, e) {
    return this.min.copy(A), this.max.copy(e), this;
  }
  setFromArray(A) {
    this.makeEmpty();
    for (let e = 0, t = A.length; e < t; e += 3)
      this.expandByPoint(ba.fromArray(A, e));
    return this;
  }
  setFromBufferAttribute(A) {
    this.makeEmpty();
    for (let e = 0, t = A.count; e < t; e++)
      this.expandByPoint(ba.fromBufferAttribute(A, e));
    return this;
  }
  setFromPoints(A) {
    this.makeEmpty();
    for (let e = 0, t = A.length; e < t; e++)
      this.expandByPoint(A[e]);
    return this;
  }
  setFromCenterAndSize(A, e) {
    const t = ba.copy(e).multiplyScalar(0.5);
    return this.min.copy(A).sub(t), this.max.copy(A).add(t), this;
  }
  setFromObject(A, e = !1) {
    return this.makeEmpty(), this.expandByObject(A, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(A) {
    return this.min.copy(A.min), this.max.copy(A.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(A) {
    return this.isEmpty() ? A.set(0, 0, 0) : A.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(A) {
    return this.isEmpty() ? A.set(0, 0, 0) : A.subVectors(this.max, this.min);
  }
  expandByPoint(A) {
    return this.min.min(A), this.max.max(A), this;
  }
  expandByVector(A) {
    return this.min.sub(A), this.max.add(A), this;
  }
  expandByScalar(A) {
    return this.min.addScalar(-A), this.max.addScalar(A), this;
  }
  expandByObject(A, e = !1) {
    if (A.updateWorldMatrix(!1, !1), A.boundingBox !== void 0)
      A.boundingBox === null && A.computeBoundingBox(), _Q.copy(A.boundingBox), _Q.applyMatrix4(A.matrixWorld), this.union(_Q);
    else {
      const i = A.geometry;
      if (i !== void 0)
        if (e && i.attributes !== void 0 && i.attributes.position !== void 0) {
          const n = i.attributes.position;
          for (let r = 0, s = n.count; r < s; r++)
            ba.fromBufferAttribute(n, r).applyMatrix4(A.matrixWorld), this.expandByPoint(ba);
        } else
          i.boundingBox === null && i.computeBoundingBox(), _Q.copy(i.boundingBox), _Q.applyMatrix4(A.matrixWorld), this.union(_Q);
    }
    const t = A.children;
    for (let i = 0, n = t.length; i < n; i++)
      this.expandByObject(t[i], e);
    return this;
  }
  containsPoint(A) {
    return !(A.x < this.min.x || A.x > this.max.x || A.y < this.min.y || A.y > this.max.y || A.z < this.min.z || A.z > this.max.z);
  }
  containsBox(A) {
    return this.min.x <= A.min.x && A.max.x <= this.max.x && this.min.y <= A.min.y && A.max.y <= this.max.y && this.min.z <= A.min.z && A.max.z <= this.max.z;
  }
  getParameter(A, e) {
    return e.set(
      (A.x - this.min.x) / (this.max.x - this.min.x),
      (A.y - this.min.y) / (this.max.y - this.min.y),
      (A.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(A) {
    return !(A.max.x < this.min.x || A.min.x > this.max.x || A.max.y < this.min.y || A.min.y > this.max.y || A.max.z < this.min.z || A.min.z > this.max.z);
  }
  intersectsSphere(A) {
    return this.clampPoint(A.center, ba), ba.distanceToSquared(A.center) <= A.radius * A.radius;
  }
  intersectsPlane(A) {
    let e, t;
    return A.normal.x > 0 ? (e = A.normal.x * this.min.x, t = A.normal.x * this.max.x) : (e = A.normal.x * this.max.x, t = A.normal.x * this.min.x), A.normal.y > 0 ? (e += A.normal.y * this.min.y, t += A.normal.y * this.max.y) : (e += A.normal.y * this.max.y, t += A.normal.y * this.min.y), A.normal.z > 0 ? (e += A.normal.z * this.min.z, t += A.normal.z * this.max.z) : (e += A.normal.z * this.max.z, t += A.normal.z * this.min.z), e <= -A.constant && t >= -A.constant;
  }
  intersectsTriangle(A) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Xl), jh.subVectors(this.max, Xl), JQ.subVectors(A.a, Xl), OQ.subVectors(A.b, Xl), qQ.subVectors(A.c, Xl), zI.subVectors(OQ, JQ), VI.subVectors(qQ, OQ), aC.subVectors(JQ, qQ);
    let e = [
      0,
      -zI.z,
      zI.y,
      0,
      -VI.z,
      VI.y,
      0,
      -aC.z,
      aC.y,
      zI.z,
      0,
      -zI.x,
      VI.z,
      0,
      -VI.x,
      aC.z,
      0,
      -aC.x,
      -zI.y,
      zI.x,
      0,
      -VI.y,
      VI.x,
      0,
      -aC.y,
      aC.x,
      0
    ];
    return !t0(e, JQ, OQ, qQ, jh) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !t0(e, JQ, OQ, qQ, jh)) ? !1 : (Zh.crossVectors(zI, VI), e = [Zh.x, Zh.y, Zh.z], t0(e, JQ, OQ, qQ, jh));
  }
  clampPoint(A, e) {
    return e.copy(A).clamp(this.min, this.max);
  }
  distanceToPoint(A) {
    return this.clampPoint(A, ba).distanceTo(A);
  }
  getBoundingSphere(A) {
    return this.isEmpty() ? A.makeEmpty() : (this.getCenter(A.center), A.radius = this.getSize(ba).length() * 0.5), A;
  }
  intersect(A) {
    return this.min.max(A.min), this.max.min(A.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(A) {
    return this.min.min(A.min), this.max.max(A.max), this;
  }
  applyMatrix4(A) {
    return this.isEmpty() ? this : (Ka[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(A), Ka[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(A), Ka[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(A), Ka[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(A), Ka[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(A), Ka[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(A), Ka[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(A), Ka[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(A), this.setFromPoints(Ka), this);
  }
  translate(A) {
    return this.min.add(A), this.max.add(A), this;
  }
  equals(A) {
    return A.min.equals(this.min) && A.max.equals(this.max);
  }
}
const Ka = [
  /* @__PURE__ */ new IA(),
  /* @__PURE__ */ new IA(),
  /* @__PURE__ */ new IA(),
  /* @__PURE__ */ new IA(),
  /* @__PURE__ */ new IA(),
  /* @__PURE__ */ new IA(),
  /* @__PURE__ */ new IA(),
  /* @__PURE__ */ new IA()
], ba = /* @__PURE__ */ new IA(), _Q = /* @__PURE__ */ new cs(), JQ = /* @__PURE__ */ new IA(), OQ = /* @__PURE__ */ new IA(), qQ = /* @__PURE__ */ new IA(), zI = /* @__PURE__ */ new IA(), VI = /* @__PURE__ */ new IA(), aC = /* @__PURE__ */ new IA(), Xl = /* @__PURE__ */ new IA(), jh = /* @__PURE__ */ new IA(), Zh = /* @__PURE__ */ new IA(), IC = /* @__PURE__ */ new IA();
function t0(g, A, e, t, i) {
  for (let n = 0, r = g.length - 3; n <= r; n += 3) {
    IC.fromArray(g, n);
    const s = i.x * Math.abs(IC.x) + i.y * Math.abs(IC.y) + i.z * Math.abs(IC.z), B = A.dot(IC), I = e.dot(IC), E = t.dot(IC);
    if (Math.max(-Math.max(B, I, E), Math.min(B, I, E)) > s)
      return !1;
  }
  return !0;
}
const Ub = /* @__PURE__ */ new cs(), $l = /* @__PURE__ */ new IA(), i0 = /* @__PURE__ */ new IA();
class us {
  constructor(A = new IA(), e = -1) {
    this.center = A, this.radius = e;
  }
  set(A, e) {
    return this.center.copy(A), this.radius = e, this;
  }
  setFromPoints(A, e) {
    const t = this.center;
    e !== void 0 ? t.copy(e) : Ub.setFromPoints(A).getCenter(t);
    let i = 0;
    for (let n = 0, r = A.length; n < r; n++)
      i = Math.max(i, t.distanceToSquared(A[n]));
    return this.radius = Math.sqrt(i), this;
  }
  copy(A) {
    return this.center.copy(A.center), this.radius = A.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(A) {
    return A.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(A) {
    return A.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(A) {
    const e = this.radius + A.radius;
    return A.center.distanceToSquared(this.center) <= e * e;
  }
  intersectsBox(A) {
    return A.intersectsSphere(this);
  }
  intersectsPlane(A) {
    return Math.abs(A.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(A, e) {
    const t = this.center.distanceToSquared(A);
    return e.copy(A), t > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
  }
  getBoundingBox(A) {
    return this.isEmpty() ? (A.makeEmpty(), A) : (A.set(this.center, this.center), A.expandByScalar(this.radius), A);
  }
  applyMatrix4(A) {
    return this.center.applyMatrix4(A), this.radius = this.radius * A.getMaxScaleOnAxis(), this;
  }
  translate(A) {
    return this.center.add(A), this;
  }
  expandByPoint(A) {
    if (this.isEmpty())
      return this.center.copy(A), this.radius = 0, this;
    $l.subVectors(A, this.center);
    const e = $l.lengthSq();
    if (e > this.radius * this.radius) {
      const t = Math.sqrt(e), i = (t - this.radius) * 0.5;
      this.center.addScaledVector($l, i / t), this.radius += i;
    }
    return this;
  }
  union(A) {
    return A.isEmpty() ? this : this.isEmpty() ? (this.copy(A), this) : (this.center.equals(A.center) === !0 ? this.radius = Math.max(this.radius, A.radius) : (i0.subVectors(A.center, this.center).setLength(A.radius), this.expandByPoint($l.copy(A.center).add(i0)), this.expandByPoint($l.copy(A.center).sub(i0))), this);
  }
  equals(A) {
    return A.center.equals(this.center) && A.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ya = /* @__PURE__ */ new IA(), n0 = /* @__PURE__ */ new IA(), Xh = /* @__PURE__ */ new IA(), jI = /* @__PURE__ */ new IA(), g0 = /* @__PURE__ */ new IA(), $h = /* @__PURE__ */ new IA(), r0 = /* @__PURE__ */ new IA();
class Xc {
  constructor(A = new IA(), e = new IA(0, 0, -1)) {
    this.origin = A, this.direction = e;
  }
  set(A, e) {
    return this.origin.copy(A), this.direction.copy(e), this;
  }
  copy(A) {
    return this.origin.copy(A.origin), this.direction.copy(A.direction), this;
  }
  at(A, e) {
    return e.copy(this.origin).addScaledVector(this.direction, A);
  }
  lookAt(A) {
    return this.direction.copy(A).sub(this.origin).normalize(), this;
  }
  recast(A) {
    return this.origin.copy(this.at(A, Ya)), this;
  }
  closestPointToPoint(A, e) {
    e.subVectors(A, this.origin);
    const t = e.dot(this.direction);
    return t < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, t);
  }
  distanceToPoint(A) {
    return Math.sqrt(this.distanceSqToPoint(A));
  }
  distanceSqToPoint(A) {
    const e = Ya.subVectors(A, this.origin).dot(this.direction);
    return e < 0 ? this.origin.distanceToSquared(A) : (Ya.copy(this.origin).addScaledVector(this.direction, e), Ya.distanceToSquared(A));
  }
  distanceSqToSegment(A, e, t, i) {
    n0.copy(A).add(e).multiplyScalar(0.5), Xh.copy(e).sub(A).normalize(), jI.copy(this.origin).sub(n0);
    const n = A.distanceTo(e) * 0.5, r = -this.direction.dot(Xh), s = jI.dot(this.direction), B = -jI.dot(Xh), I = jI.lengthSq(), E = Math.abs(1 - r * r);
    let C, c, u, d;
    if (E > 0)
      if (C = r * B - s, c = r * s - B, d = n * E, C >= 0)
        if (c >= -d)
          if (c <= d) {
            const p = 1 / E;
            C *= p, c *= p, u = C * (C + r * c + 2 * s) + c * (r * C + c + 2 * B) + I;
          } else
            c = n, C = Math.max(0, -(r * c + s)), u = -C * C + c * (c + 2 * B) + I;
        else
          c = -n, C = Math.max(0, -(r * c + s)), u = -C * C + c * (c + 2 * B) + I;
      else
        c <= -d ? (C = Math.max(0, -(-r * n + s)), c = C > 0 ? -n : Math.min(Math.max(-n, -B), n), u = -C * C + c * (c + 2 * B) + I) : c <= d ? (C = 0, c = Math.min(Math.max(-n, -B), n), u = c * (c + 2 * B) + I) : (C = Math.max(0, -(r * n + s)), c = C > 0 ? n : Math.min(Math.max(-n, -B), n), u = -C * C + c * (c + 2 * B) + I);
    else
      c = r > 0 ? -n : n, C = Math.max(0, -(r * c + s)), u = -C * C + c * (c + 2 * B) + I;
    return t && t.copy(this.origin).addScaledVector(this.direction, C), i && i.copy(n0).addScaledVector(Xh, c), u;
  }
  intersectSphere(A, e) {
    Ya.subVectors(A.center, this.origin);
    const t = Ya.dot(this.direction), i = Ya.dot(Ya) - t * t, n = A.radius * A.radius;
    if (i > n)
      return null;
    const r = Math.sqrt(n - i), s = t - r, B = t + r;
    return B < 0 ? null : s < 0 ? this.at(B, e) : this.at(s, e);
  }
  intersectsSphere(A) {
    return this.distanceSqToPoint(A.center) <= A.radius * A.radius;
  }
  distanceToPlane(A) {
    const e = A.normal.dot(this.direction);
    if (e === 0)
      return A.distanceToPoint(this.origin) === 0 ? 0 : null;
    const t = -(this.origin.dot(A.normal) + A.constant) / e;
    return t >= 0 ? t : null;
  }
  intersectPlane(A, e) {
    const t = this.distanceToPlane(A);
    return t === null ? null : this.at(t, e);
  }
  intersectsPlane(A) {
    const e = A.distanceToPoint(this.origin);
    return e === 0 || A.normal.dot(this.direction) * e < 0;
  }
  intersectBox(A, e) {
    let t, i, n, r, s, B;
    const I = 1 / this.direction.x, E = 1 / this.direction.y, C = 1 / this.direction.z, c = this.origin;
    return I >= 0 ? (t = (A.min.x - c.x) * I, i = (A.max.x - c.x) * I) : (t = (A.max.x - c.x) * I, i = (A.min.x - c.x) * I), E >= 0 ? (n = (A.min.y - c.y) * E, r = (A.max.y - c.y) * E) : (n = (A.max.y - c.y) * E, r = (A.min.y - c.y) * E), t > r || n > i || ((n > t || isNaN(t)) && (t = n), (r < i || isNaN(i)) && (i = r), C >= 0 ? (s = (A.min.z - c.z) * C, B = (A.max.z - c.z) * C) : (s = (A.max.z - c.z) * C, B = (A.min.z - c.z) * C), t > B || s > i) || ((s > t || t !== t) && (t = s), (B < i || i !== i) && (i = B), i < 0) ? null : this.at(t >= 0 ? t : i, e);
  }
  intersectsBox(A) {
    return this.intersectBox(A, Ya) !== null;
  }
  intersectTriangle(A, e, t, i, n) {
    g0.subVectors(e, A), $h.subVectors(t, A), r0.crossVectors(g0, $h);
    let r = this.direction.dot(r0), s;
    if (r > 0) {
      if (i)
        return null;
      s = 1;
    } else if (r < 0)
      s = -1, r = -r;
    else
      return null;
    jI.subVectors(this.origin, A);
    const B = s * this.direction.dot($h.crossVectors(jI, $h));
    if (B < 0)
      return null;
    const I = s * this.direction.dot(g0.cross(jI));
    if (I < 0 || B + I > r)
      return null;
    const E = -s * jI.dot(r0);
    return E < 0 ? null : this.at(E / r, n);
  }
  applyMatrix4(A) {
    return this.origin.applyMatrix4(A), this.direction.transformDirection(A), this;
  }
  equals(A) {
    return A.origin.equals(this.origin) && A.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Ve {
  constructor() {
    Ve.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  set(A, e, t, i, n, r, s, B, I, E, C, c, u, d, p, D) {
    const f = this.elements;
    return f[0] = A, f[4] = e, f[8] = t, f[12] = i, f[1] = n, f[5] = r, f[9] = s, f[13] = B, f[2] = I, f[6] = E, f[10] = C, f[14] = c, f[3] = u, f[7] = d, f[11] = p, f[15] = D, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Ve().fromArray(this.elements);
  }
  copy(A) {
    const e = this.elements, t = A.elements;
    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this;
  }
  copyPosition(A) {
    const e = this.elements, t = A.elements;
    return e[12] = t[12], e[13] = t[13], e[14] = t[14], this;
  }
  setFromMatrix3(A) {
    const e = A.elements;
    return this.set(
      e[0],
      e[3],
      e[6],
      0,
      e[1],
      e[4],
      e[7],
      0,
      e[2],
      e[5],
      e[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(A, e, t) {
    return A.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), t.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(A, e, t) {
    return this.set(
      A.x,
      e.x,
      t.x,
      0,
      A.y,
      e.y,
      t.y,
      0,
      A.z,
      e.z,
      t.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(A) {
    const e = this.elements, t = A.elements, i = 1 / PQ.setFromMatrixColumn(A, 0).length(), n = 1 / PQ.setFromMatrixColumn(A, 1).length(), r = 1 / PQ.setFromMatrixColumn(A, 2).length();
    return e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i, e[3] = 0, e[4] = t[4] * n, e[5] = t[5] * n, e[6] = t[6] * n, e[7] = 0, e[8] = t[8] * r, e[9] = t[9] * r, e[10] = t[10] * r, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromEuler(A) {
    const e = this.elements, t = A.x, i = A.y, n = A.z, r = Math.cos(t), s = Math.sin(t), B = Math.cos(i), I = Math.sin(i), E = Math.cos(n), C = Math.sin(n);
    if (A.order === "XYZ") {
      const c = r * E, u = r * C, d = s * E, p = s * C;
      e[0] = B * E, e[4] = -B * C, e[8] = I, e[1] = u + d * I, e[5] = c - p * I, e[9] = -s * B, e[2] = p - c * I, e[6] = d + u * I, e[10] = r * B;
    } else if (A.order === "YXZ") {
      const c = B * E, u = B * C, d = I * E, p = I * C;
      e[0] = c + p * s, e[4] = d * s - u, e[8] = r * I, e[1] = r * C, e[5] = r * E, e[9] = -s, e[2] = u * s - d, e[6] = p + c * s, e[10] = r * B;
    } else if (A.order === "ZXY") {
      const c = B * E, u = B * C, d = I * E, p = I * C;
      e[0] = c - p * s, e[4] = -r * C, e[8] = d + u * s, e[1] = u + d * s, e[5] = r * E, e[9] = p - c * s, e[2] = -r * I, e[6] = s, e[10] = r * B;
    } else if (A.order === "ZYX") {
      const c = r * E, u = r * C, d = s * E, p = s * C;
      e[0] = B * E, e[4] = d * I - u, e[8] = c * I + p, e[1] = B * C, e[5] = p * I + c, e[9] = u * I - d, e[2] = -I, e[6] = s * B, e[10] = r * B;
    } else if (A.order === "YZX") {
      const c = r * B, u = r * I, d = s * B, p = s * I;
      e[0] = B * E, e[4] = p - c * C, e[8] = d * C + u, e[1] = C, e[5] = r * E, e[9] = -s * E, e[2] = -I * E, e[6] = u * C + d, e[10] = c - p * C;
    } else if (A.order === "XZY") {
      const c = r * B, u = r * I, d = s * B, p = s * I;
      e[0] = B * E, e[4] = -C, e[8] = I * E, e[1] = c * C + p, e[5] = r * E, e[9] = u * C - d, e[2] = d * C - u, e[6] = s * E, e[10] = p * C + c;
    }
    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromQuaternion(A) {
    return this.compose(kb, A, xb);
  }
  lookAt(A, e, t) {
    const i = this.elements;
    return jr.subVectors(A, e), jr.lengthSq() === 0 && (jr.z = 1), jr.normalize(), ZI.crossVectors(t, jr), ZI.lengthSq() === 0 && (Math.abs(t.z) === 1 ? jr.x += 1e-4 : jr.z += 1e-4, jr.normalize(), ZI.crossVectors(t, jr)), ZI.normalize(), Ad.crossVectors(jr, ZI), i[0] = ZI.x, i[4] = Ad.x, i[8] = jr.x, i[1] = ZI.y, i[5] = Ad.y, i[9] = jr.y, i[2] = ZI.z, i[6] = Ad.z, i[10] = jr.z, this;
  }
  multiply(A) {
    return this.multiplyMatrices(this, A);
  }
  premultiply(A) {
    return this.multiplyMatrices(A, this);
  }
  multiplyMatrices(A, e) {
    const t = A.elements, i = e.elements, n = this.elements, r = t[0], s = t[4], B = t[8], I = t[12], E = t[1], C = t[5], c = t[9], u = t[13], d = t[2], p = t[6], D = t[10], f = t[14], S = t[3], y = t[7], m = t[11], N = t[15], F = i[0], G = i[4], k = i[8], v = i[12], x = i[1], H = i[5], _ = i[9], j = i[13], V = i[2], iA = i[6], eA = i[10], oA = i[14], P = i[3], J = i[7], tA = i[11], Y = i[15];
    return n[0] = r * F + s * x + B * V + I * P, n[4] = r * G + s * H + B * iA + I * J, n[8] = r * k + s * _ + B * eA + I * tA, n[12] = r * v + s * j + B * oA + I * Y, n[1] = E * F + C * x + c * V + u * P, n[5] = E * G + C * H + c * iA + u * J, n[9] = E * k + C * _ + c * eA + u * tA, n[13] = E * v + C * j + c * oA + u * Y, n[2] = d * F + p * x + D * V + f * P, n[6] = d * G + p * H + D * iA + f * J, n[10] = d * k + p * _ + D * eA + f * tA, n[14] = d * v + p * j + D * oA + f * Y, n[3] = S * F + y * x + m * V + N * P, n[7] = S * G + y * H + m * iA + N * J, n[11] = S * k + y * _ + m * eA + N * tA, n[15] = S * v + y * j + m * oA + N * Y, this;
  }
  multiplyScalar(A) {
    const e = this.elements;
    return e[0] *= A, e[4] *= A, e[8] *= A, e[12] *= A, e[1] *= A, e[5] *= A, e[9] *= A, e[13] *= A, e[2] *= A, e[6] *= A, e[10] *= A, e[14] *= A, e[3] *= A, e[7] *= A, e[11] *= A, e[15] *= A, this;
  }
  determinant() {
    const A = this.elements, e = A[0], t = A[4], i = A[8], n = A[12], r = A[1], s = A[5], B = A[9], I = A[13], E = A[2], C = A[6], c = A[10], u = A[14], d = A[3], p = A[7], D = A[11], f = A[15];
    return d * (+n * B * C - i * I * C - n * s * c + t * I * c + i * s * u - t * B * u) + p * (+e * B * u - e * I * c + n * r * c - i * r * u + i * I * E - n * B * E) + D * (+e * I * C - e * s * u - n * r * C + t * r * u + n * s * E - t * I * E) + f * (-i * s * E - e * B * C + e * s * c + i * r * C - t * r * c + t * B * E);
  }
  transpose() {
    const A = this.elements;
    let e;
    return e = A[1], A[1] = A[4], A[4] = e, e = A[2], A[2] = A[8], A[8] = e, e = A[6], A[6] = A[9], A[9] = e, e = A[3], A[3] = A[12], A[12] = e, e = A[7], A[7] = A[13], A[13] = e, e = A[11], A[11] = A[14], A[14] = e, this;
  }
  setPosition(A, e, t) {
    const i = this.elements;
    return A.isVector3 ? (i[12] = A.x, i[13] = A.y, i[14] = A.z) : (i[12] = A, i[13] = e, i[14] = t), this;
  }
  invert() {
    const A = this.elements, e = A[0], t = A[1], i = A[2], n = A[3], r = A[4], s = A[5], B = A[6], I = A[7], E = A[8], C = A[9], c = A[10], u = A[11], d = A[12], p = A[13], D = A[14], f = A[15], S = C * D * I - p * c * I + p * B * u - s * D * u - C * B * f + s * c * f, y = d * c * I - E * D * I - d * B * u + r * D * u + E * B * f - r * c * f, m = E * p * I - d * C * I + d * s * u - r * p * u - E * s * f + r * C * f, N = d * C * B - E * p * B - d * s * c + r * p * c + E * s * D - r * C * D, F = e * S + t * y + i * m + n * N;
    if (F === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const G = 1 / F;
    return A[0] = S * G, A[1] = (p * c * n - C * D * n - p * i * u + t * D * u + C * i * f - t * c * f) * G, A[2] = (s * D * n - p * B * n + p * i * I - t * D * I - s * i * f + t * B * f) * G, A[3] = (C * B * n - s * c * n - C * i * I + t * c * I + s * i * u - t * B * u) * G, A[4] = y * G, A[5] = (E * D * n - d * c * n + d * i * u - e * D * u - E * i * f + e * c * f) * G, A[6] = (d * B * n - r * D * n - d * i * I + e * D * I + r * i * f - e * B * f) * G, A[7] = (r * c * n - E * B * n + E * i * I - e * c * I - r * i * u + e * B * u) * G, A[8] = m * G, A[9] = (d * C * n - E * p * n - d * t * u + e * p * u + E * t * f - e * C * f) * G, A[10] = (r * p * n - d * s * n + d * t * I - e * p * I - r * t * f + e * s * f) * G, A[11] = (E * s * n - r * C * n - E * t * I + e * C * I + r * t * u - e * s * u) * G, A[12] = N * G, A[13] = (E * p * i - d * C * i + d * t * c - e * p * c - E * t * D + e * C * D) * G, A[14] = (d * s * i - r * p * i - d * t * B + e * p * B + r * t * D - e * s * D) * G, A[15] = (r * C * i - E * s * i + E * t * B - e * C * B - r * t * c + e * s * c) * G, this;
  }
  scale(A) {
    const e = this.elements, t = A.x, i = A.y, n = A.z;
    return e[0] *= t, e[4] *= i, e[8] *= n, e[1] *= t, e[5] *= i, e[9] *= n, e[2] *= t, e[6] *= i, e[10] *= n, e[3] *= t, e[7] *= i, e[11] *= n, this;
  }
  getMaxScaleOnAxis() {
    const A = this.elements, e = A[0] * A[0] + A[1] * A[1] + A[2] * A[2], t = A[4] * A[4] + A[5] * A[5] + A[6] * A[6], i = A[8] * A[8] + A[9] * A[9] + A[10] * A[10];
    return Math.sqrt(Math.max(e, t, i));
  }
  makeTranslation(A, e, t) {
    return this.set(
      1,
      0,
      0,
      A,
      0,
      1,
      0,
      e,
      0,
      0,
      1,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(A) {
    const e = Math.cos(A), t = Math.sin(A);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      e,
      -t,
      0,
      0,
      t,
      e,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(A) {
    const e = Math.cos(A), t = Math.sin(A);
    return this.set(
      e,
      0,
      t,
      0,
      0,
      1,
      0,
      0,
      -t,
      0,
      e,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(A) {
    const e = Math.cos(A), t = Math.sin(A);
    return this.set(
      e,
      -t,
      0,
      0,
      t,
      e,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(A, e) {
    const t = Math.cos(e), i = Math.sin(e), n = 1 - t, r = A.x, s = A.y, B = A.z, I = n * r, E = n * s;
    return this.set(
      I * r + t,
      I * s - i * B,
      I * B + i * s,
      0,
      I * s + i * B,
      E * s + t,
      E * B - i * r,
      0,
      I * B - i * s,
      E * B + i * r,
      n * B * B + t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(A, e, t) {
    return this.set(
      A,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(A, e, t, i, n, r) {
    return this.set(
      1,
      t,
      n,
      0,
      A,
      1,
      r,
      0,
      e,
      i,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(A, e, t) {
    const i = this.elements, n = e._x, r = e._y, s = e._z, B = e._w, I = n + n, E = r + r, C = s + s, c = n * I, u = n * E, d = n * C, p = r * E, D = r * C, f = s * C, S = B * I, y = B * E, m = B * C, N = t.x, F = t.y, G = t.z;
    return i[0] = (1 - (p + f)) * N, i[1] = (u + m) * N, i[2] = (d - y) * N, i[3] = 0, i[4] = (u - m) * F, i[5] = (1 - (c + f)) * F, i[6] = (D + S) * F, i[7] = 0, i[8] = (d + y) * G, i[9] = (D - S) * G, i[10] = (1 - (c + p)) * G, i[11] = 0, i[12] = A.x, i[13] = A.y, i[14] = A.z, i[15] = 1, this;
  }
  decompose(A, e, t) {
    const i = this.elements;
    let n = PQ.set(i[0], i[1], i[2]).length();
    const r = PQ.set(i[4], i[5], i[6]).length(), s = PQ.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (n = -n), A.x = i[12], A.y = i[13], A.z = i[14], is.copy(this);
    const I = 1 / n, E = 1 / r, C = 1 / s;
    return is.elements[0] *= I, is.elements[1] *= I, is.elements[2] *= I, is.elements[4] *= E, is.elements[5] *= E, is.elements[6] *= E, is.elements[8] *= C, is.elements[9] *= C, is.elements[10] *= C, e.setFromRotationMatrix(is), t.x = n, t.y = r, t.z = s, this;
  }
  makePerspective(A, e, t, i, n, r) {
    const s = this.elements, B = 2 * n / (e - A), I = 2 * n / (t - i), E = (e + A) / (e - A), C = (t + i) / (t - i), c = -(r + n) / (r - n), u = -2 * r * n / (r - n);
    return s[0] = B, s[4] = 0, s[8] = E, s[12] = 0, s[1] = 0, s[5] = I, s[9] = C, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = c, s[14] = u, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this;
  }
  makeOrthographic(A, e, t, i, n, r) {
    const s = this.elements, B = 1 / (e - A), I = 1 / (t - i), E = 1 / (r - n), C = (e + A) * B, c = (t + i) * I, u = (r + n) * E;
    return s[0] = 2 * B, s[4] = 0, s[8] = 0, s[12] = -C, s[1] = 0, s[5] = 2 * I, s[9] = 0, s[13] = -c, s[2] = 0, s[6] = 0, s[10] = -2 * E, s[14] = -u, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this;
  }
  equals(A) {
    const e = this.elements, t = A.elements;
    for (let i = 0; i < 16; i++)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
  fromArray(A, e = 0) {
    for (let t = 0; t < 16; t++)
      this.elements[t] = A[t + e];
    return this;
  }
  toArray(A = [], e = 0) {
    const t = this.elements;
    return A[e] = t[0], A[e + 1] = t[1], A[e + 2] = t[2], A[e + 3] = t[3], A[e + 4] = t[4], A[e + 5] = t[5], A[e + 6] = t[6], A[e + 7] = t[7], A[e + 8] = t[8], A[e + 9] = t[9], A[e + 10] = t[10], A[e + 11] = t[11], A[e + 12] = t[12], A[e + 13] = t[13], A[e + 14] = t[14], A[e + 15] = t[15], A;
  }
}
const PQ = /* @__PURE__ */ new IA(), is = /* @__PURE__ */ new Ve(), kb = /* @__PURE__ */ new IA(0, 0, 0), xb = /* @__PURE__ */ new IA(1, 1, 1), ZI = /* @__PURE__ */ new IA(), Ad = /* @__PURE__ */ new IA(), jr = /* @__PURE__ */ new IA(), hR = /* @__PURE__ */ new Ve(), dR = /* @__PURE__ */ new On();
class Nr {
  constructor(A = 0, e = 0, t = 0, i = Nr.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = A, this._y = e, this._z = t, this._order = i;
  }
  get x() {
    return this._x;
  }
  set x(A) {
    this._x = A, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(A) {
    this._y = A, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(A) {
    this._z = A, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(A) {
    this._order = A, this._onChangeCallback();
  }
  set(A, e, t, i = this._order) {
    return this._x = A, this._y = e, this._z = t, this._order = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(A) {
    return this._x = A._x, this._y = A._y, this._z = A._z, this._order = A._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(A, e = this._order, t = !0) {
    const i = A.elements, n = i[0], r = i[4], s = i[8], B = i[1], I = i[5], E = i[9], C = i[2], c = i[6], u = i[10];
    switch (e) {
      case "XYZ":
        this._y = Math.asin(yn(s, -1, 1)), Math.abs(s) < 0.9999999 ? (this._x = Math.atan2(-E, u), this._z = Math.atan2(-r, n)) : (this._x = Math.atan2(c, I), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-yn(E, -1, 1)), Math.abs(E) < 0.9999999 ? (this._y = Math.atan2(s, u), this._z = Math.atan2(B, I)) : (this._y = Math.atan2(-C, n), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(yn(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._y = Math.atan2(-C, u), this._z = Math.atan2(-r, I)) : (this._y = 0, this._z = Math.atan2(B, n));
        break;
      case "ZYX":
        this._y = Math.asin(-yn(C, -1, 1)), Math.abs(C) < 0.9999999 ? (this._x = Math.atan2(c, u), this._z = Math.atan2(B, n)) : (this._x = 0, this._z = Math.atan2(-r, I));
        break;
      case "YZX":
        this._z = Math.asin(yn(B, -1, 1)), Math.abs(B) < 0.9999999 ? (this._x = Math.atan2(-E, I), this._y = Math.atan2(-C, n)) : (this._x = 0, this._y = Math.atan2(s, u));
        break;
      case "XZY":
        this._z = Math.asin(-yn(r, -1, 1)), Math.abs(r) < 0.9999999 ? (this._x = Math.atan2(c, I), this._y = Math.atan2(s, n)) : (this._x = Math.atan2(-E, u), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
    }
    return this._order = e, t === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(A, e, t) {
    return hR.makeRotationFromQuaternion(A), this.setFromRotationMatrix(hR, e, t);
  }
  setFromVector3(A, e = this._order) {
    return this.set(A.x, A.y, A.z, e);
  }
  reorder(A) {
    return dR.setFromEuler(this), this.setFromQuaternion(dR, A);
  }
  equals(A) {
    return A._x === this._x && A._y === this._y && A._z === this._z && A._order === this._order;
  }
  fromArray(A) {
    return this._x = A[0], this._y = A[1], this._z = A[2], A[3] !== void 0 && (this._order = A[3]), this._onChangeCallback(), this;
  }
  toArray(A = [], e = 0) {
    return A[e] = this._x, A[e + 1] = this._y, A[e + 2] = this._z, A[e + 3] = this._order, A;
  }
  _onChange(A) {
    return this._onChangeCallback = A, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Nr.DEFAULT_ORDER = "XYZ";
class GC {
  constructor() {
    this.mask = 1;
  }
  set(A) {
    this.mask = (1 << A | 0) >>> 0;
  }
  enable(A) {
    this.mask |= 1 << A | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(A) {
    this.mask ^= 1 << A | 0;
  }
  disable(A) {
    this.mask &= ~(1 << A | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(A) {
    return (this.mask & A.mask) !== 0;
  }
  isEnabled(A) {
    return (this.mask & (1 << A | 0)) !== 0;
  }
}
let Lb = 0;
const fR = /* @__PURE__ */ new IA(), WQ = /* @__PURE__ */ new On(), Ha = /* @__PURE__ */ new Ve(), ed = /* @__PURE__ */ new IA(), Ac = /* @__PURE__ */ new IA(), Tb = /* @__PURE__ */ new IA(), Kb = /* @__PURE__ */ new On(), pR = /* @__PURE__ */ new IA(1, 0, 0), DR = /* @__PURE__ */ new IA(0, 1, 0), wR = /* @__PURE__ */ new IA(0, 0, 1), bb = { type: "added" }, yR = { type: "removed" };
class Xt extends Za {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: Lb++ }), this.uuid = io(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Xt.DEFAULT_UP.clone();
    const A = new IA(), e = new Nr(), t = new On(), i = new IA(1, 1, 1);
    function n() {
      t.setFromEuler(e, !1);
    }
    function r() {
      e.setFromQuaternion(t, void 0, !1);
    }
    e._onChange(n), t._onChange(r), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: A
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      modelViewMatrix: {
        value: new Ve()
      },
      normalMatrix: {
        value: new kt()
      }
    }), this.matrix = new Ve(), this.matrixWorld = new Ve(), this.matrixAutoUpdate = Xt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = Xt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new GC(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(A) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(A), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(A) {
    return this.quaternion.premultiply(A), this;
  }
  setRotationFromAxisAngle(A, e) {
    this.quaternion.setFromAxisAngle(A, e);
  }
  setRotationFromEuler(A) {
    this.quaternion.setFromEuler(A, !0);
  }
  setRotationFromMatrix(A) {
    this.quaternion.setFromRotationMatrix(A);
  }
  setRotationFromQuaternion(A) {
    this.quaternion.copy(A);
  }
  rotateOnAxis(A, e) {
    return WQ.setFromAxisAngle(A, e), this.quaternion.multiply(WQ), this;
  }
  rotateOnWorldAxis(A, e) {
    return WQ.setFromAxisAngle(A, e), this.quaternion.premultiply(WQ), this;
  }
  rotateX(A) {
    return this.rotateOnAxis(pR, A);
  }
  rotateY(A) {
    return this.rotateOnAxis(DR, A);
  }
  rotateZ(A) {
    return this.rotateOnAxis(wR, A);
  }
  translateOnAxis(A, e) {
    return fR.copy(A).applyQuaternion(this.quaternion), this.position.add(fR.multiplyScalar(e)), this;
  }
  translateX(A) {
    return this.translateOnAxis(pR, A);
  }
  translateY(A) {
    return this.translateOnAxis(DR, A);
  }
  translateZ(A) {
    return this.translateOnAxis(wR, A);
  }
  localToWorld(A) {
    return this.updateWorldMatrix(!0, !1), A.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(A) {
    return this.updateWorldMatrix(!0, !1), A.applyMatrix4(Ha.copy(this.matrixWorld).invert());
  }
  lookAt(A, e, t) {
    A.isVector3 ? ed.copy(A) : ed.set(A, e, t);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1), Ac.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ha.lookAt(Ac, ed, this.up) : Ha.lookAt(ed, Ac, this.up), this.quaternion.setFromRotationMatrix(Ha), i && (Ha.extractRotation(i.matrixWorld), WQ.setFromRotationMatrix(Ha), this.quaternion.premultiply(WQ.invert()));
  }
  add(A) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++)
        this.add(arguments[e]);
      return this;
    }
    return A === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", A), this) : (A && A.isObject3D ? (A.parent !== null && A.parent.remove(A), A.parent = this, this.children.push(A), A.dispatchEvent(bb)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", A), this);
  }
  remove(A) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.remove(arguments[t]);
      return this;
    }
    const e = this.children.indexOf(A);
    return e !== -1 && (A.parent = null, this.children.splice(e, 1), A.dispatchEvent(yR)), this;
  }
  removeFromParent() {
    const A = this.parent;
    return A !== null && A.remove(this), this;
  }
  clear() {
    for (let A = 0; A < this.children.length; A++) {
      const e = this.children[A];
      e.parent = null, e.dispatchEvent(yR);
    }
    return this.children.length = 0, this;
  }
  attach(A) {
    return this.updateWorldMatrix(!0, !1), Ha.copy(this.matrixWorld).invert(), A.parent !== null && (A.parent.updateWorldMatrix(!0, !1), Ha.multiply(A.parent.matrixWorld)), A.applyMatrix4(Ha), this.add(A), A.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(A) {
    return this.getObjectByProperty("id", A);
  }
  getObjectByName(A) {
    return this.getObjectByProperty("name", A);
  }
  getObjectByProperty(A, e) {
    if (this[A] === e)
      return this;
    for (let t = 0, i = this.children.length; t < i; t++) {
      const r = this.children[t].getObjectByProperty(A, e);
      if (r !== void 0)
        return r;
    }
  }
  getObjectsByProperty(A, e) {
    let t = [];
    this[A] === e && t.push(this);
    for (let i = 0, n = this.children.length; i < n; i++) {
      const r = this.children[i].getObjectsByProperty(A, e);
      r.length > 0 && (t = t.concat(r));
    }
    return t;
  }
  getWorldPosition(A) {
    return this.updateWorldMatrix(!0, !1), A.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(A) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ac, A, Tb), A;
  }
  getWorldScale(A) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ac, Kb, A), A;
  }
  getWorldDirection(A) {
    this.updateWorldMatrix(!0, !1);
    const e = this.matrixWorld.elements;
    return A.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {
  }
  traverse(A) {
    A(this);
    const e = this.children;
    for (let t = 0, i = e.length; t < i; t++)
      e[t].traverse(A);
  }
  traverseVisible(A) {
    if (this.visible === !1)
      return;
    A(this);
    const e = this.children;
    for (let t = 0, i = e.length; t < i; t++)
      e[t].traverseVisible(A);
  }
  traverseAncestors(A) {
    const e = this.parent;
    e !== null && (A(e), e.traverseAncestors(A));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(A) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || A) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, A = !0);
    const e = this.children;
    for (let t = 0, i = e.length; t < i; t++) {
      const n = e[t];
      (n.matrixWorldAutoUpdate === !0 || A === !0) && n.updateMatrixWorld(A);
    }
  }
  updateWorldMatrix(A, e) {
    const t = this.parent;
    if (A === !0 && t !== null && t.matrixWorldAutoUpdate === !0 && t.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e === !0) {
      const i = this.children;
      for (let n = 0, r = i.length; n < r; n++) {
        const s = i[n];
        s.matrixWorldAutoUpdate === !0 && s.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(A) {
    const e = A === void 0 || typeof A == "string", t = {};
    e && (A = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, t.metadata = {
      version: 4.5,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const i = {};
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON()));
    function n(s, B) {
      return s[B.uuid] === void 0 && (s[B.uuid] = B.toJSON(A)), B.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(A).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(A).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = n(A.geometries, this.geometry);
      const s = this.geometry.parameters;
      if (s !== void 0 && s.shapes !== void 0) {
        const B = s.shapes;
        if (Array.isArray(B))
          for (let I = 0, E = B.length; I < E; I++) {
            const C = B[I];
            n(A.shapes, C);
          }
        else
          n(A.shapes, B);
      }
    }
    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (n(A.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const s = [];
        for (let B = 0, I = this.material.length; B < I; B++)
          s.push(n(A.materials, this.material[B]));
        i.material = s;
      } else
        i.material = n(A.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let s = 0; s < this.children.length; s++)
        i.children.push(this.children[s].toJSON(A).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let s = 0; s < this.animations.length; s++) {
        const B = this.animations[s];
        i.animations.push(n(A.animations, B));
      }
    }
    if (e) {
      const s = r(A.geometries), B = r(A.materials), I = r(A.textures), E = r(A.images), C = r(A.shapes), c = r(A.skeletons), u = r(A.animations), d = r(A.nodes);
      s.length > 0 && (t.geometries = s), B.length > 0 && (t.materials = B), I.length > 0 && (t.textures = I), E.length > 0 && (t.images = E), C.length > 0 && (t.shapes = C), c.length > 0 && (t.skeletons = c), u.length > 0 && (t.animations = u), d.length > 0 && (t.nodes = d);
    }
    return t.object = i, t;
    function r(s) {
      const B = [];
      for (const I in s) {
        const E = s[I];
        delete E.metadata, B.push(E);
      }
      return B;
    }
  }
  clone(A) {
    return new this.constructor().copy(this, A);
  }
  copy(A, e = !0) {
    if (this.name = A.name, this.up.copy(A.up), this.position.copy(A.position), this.rotation.order = A.rotation.order, this.quaternion.copy(A.quaternion), this.scale.copy(A.scale), this.matrix.copy(A.matrix), this.matrixWorld.copy(A.matrixWorld), this.matrixAutoUpdate = A.matrixAutoUpdate, this.matrixWorldNeedsUpdate = A.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = A.matrixWorldAutoUpdate, this.layers.mask = A.layers.mask, this.visible = A.visible, this.castShadow = A.castShadow, this.receiveShadow = A.receiveShadow, this.frustumCulled = A.frustumCulled, this.renderOrder = A.renderOrder, this.userData = JSON.parse(JSON.stringify(A.userData)), e === !0)
      for (let t = 0; t < A.children.length; t++) {
        const i = A.children[t];
        this.add(i.clone());
      }
    return this;
  }
}
Xt.DEFAULT_UP = /* @__PURE__ */ new IA(0, 1, 0);
Xt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Xt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const ns = /* @__PURE__ */ new IA(), _a = /* @__PURE__ */ new IA(), o0 = /* @__PURE__ */ new IA(), Ja = /* @__PURE__ */ new IA(), zQ = /* @__PURE__ */ new IA(), VQ = /* @__PURE__ */ new IA(), mR = /* @__PURE__ */ new IA(), s0 = /* @__PURE__ */ new IA(), a0 = /* @__PURE__ */ new IA(), I0 = /* @__PURE__ */ new IA();
let td = !1;
class Sr {
  constructor(A = new IA(), e = new IA(), t = new IA()) {
    this.a = A, this.b = e, this.c = t;
  }
  static getNormal(A, e, t, i) {
    i.subVectors(t, e), ns.subVectors(A, e), i.cross(ns);
    const n = i.lengthSq();
    return n > 0 ? i.multiplyScalar(1 / Math.sqrt(n)) : i.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(A, e, t, i, n) {
    ns.subVectors(i, e), _a.subVectors(t, e), o0.subVectors(A, e);
    const r = ns.dot(ns), s = ns.dot(_a), B = ns.dot(o0), I = _a.dot(_a), E = _a.dot(o0), C = r * I - s * s;
    if (C === 0)
      return n.set(-2, -1, -1);
    const c = 1 / C, u = (I * B - s * E) * c, d = (r * E - s * B) * c;
    return n.set(1 - u - d, d, u);
  }
  static containsPoint(A, e, t, i) {
    return this.getBarycoord(A, e, t, i, Ja), Ja.x >= 0 && Ja.y >= 0 && Ja.x + Ja.y <= 1;
  }
  static getUV(A, e, t, i, n, r, s, B) {
    return td === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), td = !0), this.getInterpolation(A, e, t, i, n, r, s, B);
  }
  static getInterpolation(A, e, t, i, n, r, s, B) {
    return this.getBarycoord(A, e, t, i, Ja), B.setScalar(0), B.addScaledVector(n, Ja.x), B.addScaledVector(r, Ja.y), B.addScaledVector(s, Ja.z), B;
  }
  static isFrontFacing(A, e, t, i) {
    return ns.subVectors(t, e), _a.subVectors(A, e), ns.cross(_a).dot(i) < 0;
  }
  set(A, e, t) {
    return this.a.copy(A), this.b.copy(e), this.c.copy(t), this;
  }
  setFromPointsAndIndices(A, e, t, i) {
    return this.a.copy(A[e]), this.b.copy(A[t]), this.c.copy(A[i]), this;
  }
  setFromAttributeAndIndices(A, e, t, i) {
    return this.a.fromBufferAttribute(A, e), this.b.fromBufferAttribute(A, t), this.c.fromBufferAttribute(A, i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(A) {
    return this.a.copy(A.a), this.b.copy(A.b), this.c.copy(A.c), this;
  }
  getArea() {
    return ns.subVectors(this.c, this.b), _a.subVectors(this.a, this.b), ns.cross(_a).length() * 0.5;
  }
  getMidpoint(A) {
    return A.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(A) {
    return Sr.getNormal(this.a, this.b, this.c, A);
  }
  getPlane(A) {
    return A.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(A, e) {
    return Sr.getBarycoord(A, this.a, this.b, this.c, e);
  }
  getUV(A, e, t, i, n) {
    return td === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), td = !0), Sr.getInterpolation(A, this.a, this.b, this.c, e, t, i, n);
  }
  getInterpolation(A, e, t, i, n) {
    return Sr.getInterpolation(A, this.a, this.b, this.c, e, t, i, n);
  }
  containsPoint(A) {
    return Sr.containsPoint(A, this.a, this.b, this.c);
  }
  isFrontFacing(A) {
    return Sr.isFrontFacing(this.a, this.b, this.c, A);
  }
  intersectsBox(A) {
    return A.intersectsTriangle(this);
  }
  closestPointToPoint(A, e) {
    const t = this.a, i = this.b, n = this.c;
    let r, s;
    zQ.subVectors(i, t), VQ.subVectors(n, t), s0.subVectors(A, t);
    const B = zQ.dot(s0), I = VQ.dot(s0);
    if (B <= 0 && I <= 0)
      return e.copy(t);
    a0.subVectors(A, i);
    const E = zQ.dot(a0), C = VQ.dot(a0);
    if (E >= 0 && C <= E)
      return e.copy(i);
    const c = B * C - E * I;
    if (c <= 0 && B >= 0 && E <= 0)
      return r = B / (B - E), e.copy(t).addScaledVector(zQ, r);
    I0.subVectors(A, n);
    const u = zQ.dot(I0), d = VQ.dot(I0);
    if (d >= 0 && u <= d)
      return e.copy(n);
    const p = u * I - B * d;
    if (p <= 0 && I >= 0 && d <= 0)
      return s = I / (I - d), e.copy(t).addScaledVector(VQ, s);
    const D = E * d - u * C;
    if (D <= 0 && C - E >= 0 && u - d >= 0)
      return mR.subVectors(n, i), s = (C - E) / (C - E + (u - d)), e.copy(i).addScaledVector(mR, s);
    const f = 1 / (D + p + c);
    return r = p * f, s = c * f, e.copy(t).addScaledVector(zQ, r).addScaledVector(VQ, s);
  }
  equals(A) {
    return A.a.equals(this.a) && A.b.equals(this.b) && A.c.equals(this.c);
  }
}
let Yb = 0;
class Sn extends Za {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: Yb++ }), this.uuid = io(), this.name = "", this.type = "Material", this.blending = MC, this.side = ea, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = uy, this.blendDst = hy, this.blendEquation = fC, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = af, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = yv, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = nf, this.stencilZFail = nf, this.stencilZPass = nf, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(A) {
    this._alphaTest > 0 != A > 0 && this.version++, this._alphaTest = A;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(A) {
    if (A !== void 0)
      for (const e in A) {
        const t = A[e];
        if (t === void 0) {
          console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
          continue;
        }
        const i = this[e];
        if (i === void 0) {
          console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
          continue;
        }
        i && i.isColor ? i.set(t) : i && i.isVector3 && t && t.isVector3 ? i.copy(t) : this[e] = t;
      }
  }
  toJSON(A) {
    const e = A === void 0 || typeof A == "string";
    e && (A = {
      textures: {},
      images: {}
    });
    const t = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), this.color && this.color.isColor && (t.color = this.color.getHex()), this.roughness !== void 0 && (t.roughness = this.roughness), this.metalness !== void 0 && (t.metalness = this.metalness), this.sheen !== void 0 && (t.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (t.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (t.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (t.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (t.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (t.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (t.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (t.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (t.shininess = this.shininess), this.clearcoat !== void 0 && (t.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (t.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (t.clearcoatMap = this.clearcoatMap.toJSON(A).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (t.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(A).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (t.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(A).uuid, t.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (t.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (t.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (t.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (t.iridescenceMap = this.iridescenceMap.toJSON(A).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (t.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(A).uuid), this.map && this.map.isTexture && (t.map = this.map.toJSON(A).uuid), this.matcap && this.matcap.isTexture && (t.matcap = this.matcap.toJSON(A).uuid), this.alphaMap && this.alphaMap.isTexture && (t.alphaMap = this.alphaMap.toJSON(A).uuid), this.lightMap && this.lightMap.isTexture && (t.lightMap = this.lightMap.toJSON(A).uuid, t.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (t.aoMap = this.aoMap.toJSON(A).uuid, t.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (t.bumpMap = this.bumpMap.toJSON(A).uuid, t.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (t.normalMap = this.normalMap.toJSON(A).uuid, t.normalMapType = this.normalMapType, t.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (t.displacementMap = this.displacementMap.toJSON(A).uuid, t.displacementScale = this.displacementScale, t.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (t.roughnessMap = this.roughnessMap.toJSON(A).uuid), this.metalnessMap && this.metalnessMap.isTexture && (t.metalnessMap = this.metalnessMap.toJSON(A).uuid), this.emissiveMap && this.emissiveMap.isTexture && (t.emissiveMap = this.emissiveMap.toJSON(A).uuid), this.specularMap && this.specularMap.isTexture && (t.specularMap = this.specularMap.toJSON(A).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (t.specularIntensityMap = this.specularIntensityMap.toJSON(A).uuid), this.specularColorMap && this.specularColorMap.isTexture && (t.specularColorMap = this.specularColorMap.toJSON(A).uuid), this.envMap && this.envMap.isTexture && (t.envMap = this.envMap.toJSON(A).uuid, this.combine !== void 0 && (t.combine = this.combine)), this.envMapIntensity !== void 0 && (t.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (t.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (t.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (t.gradientMap = this.gradientMap.toJSON(A).uuid), this.transmission !== void 0 && (t.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (t.transmissionMap = this.transmissionMap.toJSON(A).uuid), this.thickness !== void 0 && (t.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (t.thicknessMap = this.thicknessMap.toJSON(A).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (t.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (t.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (t.size = this.size), this.shadowSide !== null && (t.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (t.sizeAttenuation = this.sizeAttenuation), this.blending !== MC && (t.blending = this.blending), this.side !== ea && (t.side = this.side), this.vertexColors && (t.vertexColors = !0), this.opacity < 1 && (t.opacity = this.opacity), this.transparent === !0 && (t.transparent = this.transparent), t.depthFunc = this.depthFunc, t.depthTest = this.depthTest, t.depthWrite = this.depthWrite, t.colorWrite = this.colorWrite, t.stencilWrite = this.stencilWrite, t.stencilWriteMask = this.stencilWriteMask, t.stencilFunc = this.stencilFunc, t.stencilRef = this.stencilRef, t.stencilFuncMask = this.stencilFuncMask, t.stencilFail = this.stencilFail, t.stencilZFail = this.stencilZFail, t.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (t.rotation = this.rotation), this.polygonOffset === !0 && (t.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (t.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (t.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (t.linewidth = this.linewidth), this.dashSize !== void 0 && (t.dashSize = this.dashSize), this.gapSize !== void 0 && (t.gapSize = this.gapSize), this.scale !== void 0 && (t.scale = this.scale), this.dithering === !0 && (t.dithering = !0), this.alphaTest > 0 && (t.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (t.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (t.premultipliedAlpha = this.premultipliedAlpha), this.forceSinglePass === !0 && (t.forceSinglePass = this.forceSinglePass), this.wireframe === !0 && (t.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (t.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (t.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (t.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (t.flatShading = this.flatShading), this.visible === !1 && (t.visible = !1), this.toneMapped === !1 && (t.toneMapped = !1), this.fog === !1 && (t.fog = !1), Object.keys(this.userData).length > 0 && (t.userData = this.userData);
    function i(n) {
      const r = [];
      for (const s in n) {
        const B = n[s];
        delete B.metadata, r.push(B);
      }
      return r;
    }
    if (e) {
      const n = i(A.textures), r = i(A.images);
      n.length > 0 && (t.textures = n), r.length > 0 && (t.images = r);
    }
    return t;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(A) {
    this.name = A.name, this.blending = A.blending, this.side = A.side, this.vertexColors = A.vertexColors, this.opacity = A.opacity, this.transparent = A.transparent, this.blendSrc = A.blendSrc, this.blendDst = A.blendDst, this.blendEquation = A.blendEquation, this.blendSrcAlpha = A.blendSrcAlpha, this.blendDstAlpha = A.blendDstAlpha, this.blendEquationAlpha = A.blendEquationAlpha, this.depthFunc = A.depthFunc, this.depthTest = A.depthTest, this.depthWrite = A.depthWrite, this.stencilWriteMask = A.stencilWriteMask, this.stencilFunc = A.stencilFunc, this.stencilRef = A.stencilRef, this.stencilFuncMask = A.stencilFuncMask, this.stencilFail = A.stencilFail, this.stencilZFail = A.stencilZFail, this.stencilZPass = A.stencilZPass, this.stencilWrite = A.stencilWrite;
    const e = A.clippingPlanes;
    let t = null;
    if (e !== null) {
      const i = e.length;
      t = new Array(i);
      for (let n = 0; n !== i; ++n)
        t[n] = e[n].clone();
    }
    return this.clippingPlanes = t, this.clipIntersection = A.clipIntersection, this.clipShadows = A.clipShadows, this.shadowSide = A.shadowSide, this.colorWrite = A.colorWrite, this.precision = A.precision, this.polygonOffset = A.polygonOffset, this.polygonOffsetFactor = A.polygonOffsetFactor, this.polygonOffsetUnits = A.polygonOffsetUnits, this.dithering = A.dithering, this.alphaTest = A.alphaTest, this.alphaToCoverage = A.alphaToCoverage, this.premultipliedAlpha = A.premultipliedAlpha, this.forceSinglePass = A.forceSinglePass, this.visible = A.visible, this.toneMapped = A.toneMapped, this.userData = JSON.parse(JSON.stringify(A.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(A) {
    A === !0 && this.version++;
  }
}
const Rv = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, gs = { h: 0, s: 0, l: 0 }, id = { h: 0, s: 0, l: 0 };
function B0(g, A, e) {
  return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? g + (A - g) * 6 * e : e < 1 / 2 ? A : e < 2 / 3 ? g + (A - g) * 6 * (2 / 3 - e) : g;
}
class ke {
  constructor(A, e, t) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, e === void 0 && t === void 0 ? this.set(A) : this.setRGB(A, e, t);
  }
  set(A) {
    return A && A.isColor ? this.copy(A) : typeof A == "number" ? this.setHex(A) : typeof A == "string" && this.setStyle(A), this;
  }
  setScalar(A) {
    return this.r = A, this.g = A, this.b = A, this;
  }
  setHex(A, e = ss) {
    return A = Math.floor(A), this.r = (A >> 16 & 255) / 255, this.g = (A >> 8 & 255) / 255, this.b = (A & 255) / 255, pr.toWorkingColorSpace(this, e), this;
  }
  setRGB(A, e, t, i = pr.workingColorSpace) {
    return this.r = A, this.g = e, this.b = t, pr.toWorkingColorSpace(this, i), this;
  }
  setHSL(A, e, t, i = pr.workingColorSpace) {
    if (A = yy(A, 1), e = yn(e, 0, 1), t = yn(t, 0, 1), e === 0)
      this.r = this.g = this.b = t;
    else {
      const n = t <= 0.5 ? t * (1 + e) : t + e - t * e, r = 2 * t - n;
      this.r = B0(r, n, A + 1 / 3), this.g = B0(r, n, A), this.b = B0(r, n, A - 1 / 3);
    }
    return pr.toWorkingColorSpace(this, i), this;
  }
  setStyle(A, e = ss) {
    function t(n) {
      n !== void 0 && parseFloat(n) < 1 && console.warn("THREE.Color: Alpha component of " + A + " will be ignored.");
    }
    let i;
    if (i = /^(\w+)\(([^\)]*)\)/.exec(A)) {
      let n;
      const r = i[1], s = i[2];
      switch (r) {
        case "rgb":
        case "rgba":
          if (n = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
            return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, pr.toWorkingColorSpace(this, e), t(n[4]), this;
          if (n = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
            return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, pr.toWorkingColorSpace(this, e), t(n[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (n = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
            const B = parseFloat(n[1]) / 360, I = parseFloat(n[2]) / 100, E = parseFloat(n[3]) / 100;
            return t(n[4]), this.setHSL(B, I, E, e);
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + A);
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(A)) {
      const n = i[1], r = n.length;
      if (r === 3)
        return this.setRGB(
          parseInt(n.charAt(0), 16) / 15,
          parseInt(n.charAt(1), 16) / 15,
          parseInt(n.charAt(2), 16) / 15,
          e
        );
      if (r === 6)
        return this.setHex(parseInt(n, 16), e);
      console.warn("THREE.Color: Invalid hex color " + A);
    } else if (A && A.length > 0)
      return this.setColorName(A, e);
    return this;
  }
  setColorName(A, e = ss) {
    const t = Rv[A.toLowerCase()];
    return t !== void 0 ? this.setHex(t, e) : console.warn("THREE.Color: Unknown color " + A), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(A) {
    return this.r = A.r, this.g = A.g, this.b = A.b, this;
  }
  copySRGBToLinear(A) {
    return this.r = DE(A.r), this.g = DE(A.g), this.b = DE(A.b), this;
  }
  copyLinearToSRGB(A) {
    return this.r = $D(A.r), this.g = $D(A.g), this.b = $D(A.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(A = ss) {
    return pr.fromWorkingColorSpace(Kg.copy(this), A), yn(Kg.r * 255, 0, 255) << 16 ^ yn(Kg.g * 255, 0, 255) << 8 ^ yn(Kg.b * 255, 0, 255) << 0;
  }
  getHexString(A = ss) {
    return ("000000" + this.getHex(A).toString(16)).slice(-6);
  }
  getHSL(A, e = pr.workingColorSpace) {
    pr.fromWorkingColorSpace(Kg.copy(this), e);
    const t = Kg.r, i = Kg.g, n = Kg.b, r = Math.max(t, i, n), s = Math.min(t, i, n);
    let B, I;
    const E = (s + r) / 2;
    if (s === r)
      B = 0, I = 0;
    else {
      const C = r - s;
      switch (I = E <= 0.5 ? C / (r + s) : C / (2 - r - s), r) {
        case t:
          B = (i - n) / C + (i < n ? 6 : 0);
          break;
        case i:
          B = (n - t) / C + 2;
          break;
        case n:
          B = (t - i) / C + 4;
          break;
      }
      B /= 6;
    }
    return A.h = B, A.s = I, A.l = E, A;
  }
  getRGB(A, e = pr.workingColorSpace) {
    return pr.fromWorkingColorSpace(Kg.copy(this), e), A.r = Kg.r, A.g = Kg.g, A.b = Kg.b, A;
  }
  getStyle(A = ss) {
    pr.fromWorkingColorSpace(Kg.copy(this), A);
    const e = Kg.r, t = Kg.g, i = Kg.b;
    return A !== ss ? `color(${A} ${e.toFixed(3)} ${t.toFixed(3)} ${i.toFixed(3)})` : `rgb(${e * 255 | 0},${t * 255 | 0},${i * 255 | 0})`;
  }
  offsetHSL(A, e, t) {
    return this.getHSL(gs), gs.h += A, gs.s += e, gs.l += t, this.setHSL(gs.h, gs.s, gs.l), this;
  }
  add(A) {
    return this.r += A.r, this.g += A.g, this.b += A.b, this;
  }
  addColors(A, e) {
    return this.r = A.r + e.r, this.g = A.g + e.g, this.b = A.b + e.b, this;
  }
  addScalar(A) {
    return this.r += A, this.g += A, this.b += A, this;
  }
  sub(A) {
    return this.r = Math.max(0, this.r - A.r), this.g = Math.max(0, this.g - A.g), this.b = Math.max(0, this.b - A.b), this;
  }
  multiply(A) {
    return this.r *= A.r, this.g *= A.g, this.b *= A.b, this;
  }
  multiplyScalar(A) {
    return this.r *= A, this.g *= A, this.b *= A, this;
  }
  lerp(A, e) {
    return this.r += (A.r - this.r) * e, this.g += (A.g - this.g) * e, this.b += (A.b - this.b) * e, this;
  }
  lerpColors(A, e, t) {
    return this.r = A.r + (e.r - A.r) * t, this.g = A.g + (e.g - A.g) * t, this.b = A.b + (e.b - A.b) * t, this;
  }
  lerpHSL(A, e) {
    this.getHSL(gs), A.getHSL(id);
    const t = Mc(gs.h, id.h, e), i = Mc(gs.s, id.s, e), n = Mc(gs.l, id.l, e);
    return this.setHSL(t, i, n), this;
  }
  setFromVector3(A) {
    return this.r = A.x, this.g = A.y, this.b = A.z, this;
  }
  applyMatrix3(A) {
    const e = this.r, t = this.g, i = this.b, n = A.elements;
    return this.r = n[0] * e + n[3] * t + n[6] * i, this.g = n[1] * e + n[4] * t + n[7] * i, this.b = n[2] * e + n[5] * t + n[8] * i, this;
  }
  equals(A) {
    return A.r === this.r && A.g === this.g && A.b === this.b;
  }
  fromArray(A, e = 0) {
    return this.r = A[e], this.g = A[e + 1], this.b = A[e + 2], this;
  }
  toArray(A = [], e = 0) {
    return A[e] = this.r, A[e + 1] = this.g, A[e + 2] = this.b, A;
  }
  fromBufferAttribute(A, e) {
    return this.r = A.getX(e), this.g = A.getY(e), this.b = A.getZ(e), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Kg = /* @__PURE__ */ new ke();
ke.NAMES = Rv;
class Ao extends Sn {
  constructor(A) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new ke(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = jc, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(A);
  }
  copy(A) {
    return super.copy(A), this.color.copy(A.color), this.map = A.map, this.lightMap = A.lightMap, this.lightMapIntensity = A.lightMapIntensity, this.aoMap = A.aoMap, this.aoMapIntensity = A.aoMapIntensity, this.specularMap = A.specularMap, this.alphaMap = A.alphaMap, this.envMap = A.envMap, this.combine = A.combine, this.reflectivity = A.reflectivity, this.refractionRatio = A.refractionRatio, this.wireframe = A.wireframe, this.wireframeLinewidth = A.wireframeLinewidth, this.wireframeLinecap = A.wireframeLinecap, this.wireframeLinejoin = A.wireframeLinejoin, this.fog = A.fog, this;
  }
}
const qa = /* @__PURE__ */ Hb();
function Hb() {
  const g = new ArrayBuffer(4), A = new Float32Array(g), e = new Uint32Array(g), t = new Uint32Array(512), i = new Uint32Array(512);
  for (let B = 0; B < 256; ++B) {
    const I = B - 127;
    I < -27 ? (t[B] = 0, t[B | 256] = 32768, i[B] = 24, i[B | 256] = 24) : I < -14 ? (t[B] = 1024 >> -I - 14, t[B | 256] = 1024 >> -I - 14 | 32768, i[B] = -I - 1, i[B | 256] = -I - 1) : I <= 15 ? (t[B] = I + 15 << 10, t[B | 256] = I + 15 << 10 | 32768, i[B] = 13, i[B | 256] = 13) : I < 128 ? (t[B] = 31744, t[B | 256] = 64512, i[B] = 24, i[B | 256] = 24) : (t[B] = 31744, t[B | 256] = 64512, i[B] = 13, i[B | 256] = 13);
  }
  const n = new Uint32Array(2048), r = new Uint32Array(64), s = new Uint32Array(64);
  for (let B = 1; B < 1024; ++B) {
    let I = B << 13, E = 0;
    for (; !(I & 8388608); )
      I <<= 1, E -= 8388608;
    I &= -8388609, E += 947912704, n[B] = I | E;
  }
  for (let B = 1024; B < 2048; ++B)
    n[B] = 939524096 + (B - 1024 << 13);
  for (let B = 1; B < 31; ++B)
    r[B] = B << 23;
  r[31] = 1199570944, r[32] = 2147483648;
  for (let B = 33; B < 63; ++B)
    r[B] = 2147483648 + (B - 32 << 23);
  r[63] = 3347054592;
  for (let B = 1; B < 64; ++B)
    B !== 32 && (s[B] = 1024);
  return {
    floatView: A,
    uint32View: e,
    baseTable: t,
    shiftTable: i,
    mantissaTable: n,
    exponentTable: r,
    offsetTable: s
  };
}
function Dr(g) {
  Math.abs(g) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), g = yn(g, -65504, 65504), qa.floatView[0] = g;
  const A = qa.uint32View[0], e = A >> 23 & 511;
  return qa.baseTable[e] + ((A & 8388607) >> qa.shiftTable[e]);
}
function wc(g) {
  const A = g >> 10;
  return qa.uint32View[0] = qa.mantissaTable[qa.offsetTable[A] + (g & 1023)] + qa.exponentTable[A], qa.floatView[0];
}
const _b = {
  toHalfFloat: Dr,
  fromHalfFloat: wc
}, _n = /* @__PURE__ */ new IA(), nd = /* @__PURE__ */ new ue();
class Pt {
  constructor(A, e, t = !1) {
    if (Array.isArray(A))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = A, this.itemSize = e, this.count = A !== void 0 ? A.length / e : 0, this.normalized = t, this.usage = Tc, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(A) {
    A === !0 && this.version++;
  }
  setUsage(A) {
    return this.usage = A, this;
  }
  copy(A) {
    return this.name = A.name, this.array = new A.array.constructor(A.array), this.itemSize = A.itemSize, this.count = A.count, this.normalized = A.normalized, this.usage = A.usage, this;
  }
  copyAt(A, e, t) {
    A *= this.itemSize, t *= e.itemSize;
    for (let i = 0, n = this.itemSize; i < n; i++)
      this.array[A + i] = e.array[t + i];
    return this;
  }
  copyArray(A) {
    return this.array.set(A), this;
  }
  applyMatrix3(A) {
    if (this.itemSize === 2)
      for (let e = 0, t = this.count; e < t; e++)
        nd.fromBufferAttribute(this, e), nd.applyMatrix3(A), this.setXY(e, nd.x, nd.y);
    else if (this.itemSize === 3)
      for (let e = 0, t = this.count; e < t; e++)
        _n.fromBufferAttribute(this, e), _n.applyMatrix3(A), this.setXYZ(e, _n.x, _n.y, _n.z);
    return this;
  }
  applyMatrix4(A) {
    for (let e = 0, t = this.count; e < t; e++)
      _n.fromBufferAttribute(this, e), _n.applyMatrix4(A), this.setXYZ(e, _n.x, _n.y, _n.z);
    return this;
  }
  applyNormalMatrix(A) {
    for (let e = 0, t = this.count; e < t; e++)
      _n.fromBufferAttribute(this, e), _n.applyNormalMatrix(A), this.setXYZ(e, _n.x, _n.y, _n.z);
    return this;
  }
  transformDirection(A) {
    for (let e = 0, t = this.count; e < t; e++)
      _n.fromBufferAttribute(this, e), _n.transformDirection(A), this.setXYZ(e, _n.x, _n.y, _n.z);
    return this;
  }
  set(A, e = 0) {
    return this.array.set(A, e), this;
  }
  getX(A) {
    let e = this.array[A * this.itemSize];
    return this.normalized && (e = $r(e, this.array)), e;
  }
  setX(A, e) {
    return this.normalized && (e = _t(e, this.array)), this.array[A * this.itemSize] = e, this;
  }
  getY(A) {
    let e = this.array[A * this.itemSize + 1];
    return this.normalized && (e = $r(e, this.array)), e;
  }
  setY(A, e) {
    return this.normalized && (e = _t(e, this.array)), this.array[A * this.itemSize + 1] = e, this;
  }
  getZ(A) {
    let e = this.array[A * this.itemSize + 2];
    return this.normalized && (e = $r(e, this.array)), e;
  }
  setZ(A, e) {
    return this.normalized && (e = _t(e, this.array)), this.array[A * this.itemSize + 2] = e, this;
  }
  getW(A) {
    let e = this.array[A * this.itemSize + 3];
    return this.normalized && (e = $r(e, this.array)), e;
  }
  setW(A, e) {
    return this.normalized && (e = _t(e, this.array)), this.array[A * this.itemSize + 3] = e, this;
  }
  setXY(A, e, t) {
    return A *= this.itemSize, this.normalized && (e = _t(e, this.array), t = _t(t, this.array)), this.array[A + 0] = e, this.array[A + 1] = t, this;
  }
  setXYZ(A, e, t, i) {
    return A *= this.itemSize, this.normalized && (e = _t(e, this.array), t = _t(t, this.array), i = _t(i, this.array)), this.array[A + 0] = e, this.array[A + 1] = t, this.array[A + 2] = i, this;
  }
  setXYZW(A, e, t, i, n) {
    return A *= this.itemSize, this.normalized && (e = _t(e, this.array), t = _t(t, this.array), i = _t(i, this.array), n = _t(n, this.array)), this.array[A + 0] = e, this.array[A + 1] = t, this.array[A + 2] = i, this.array[A + 3] = n, this;
  }
  onUpload(A) {
    return this.onUploadCallback = A, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const A = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (A.name = this.name), this.usage !== Tc && (A.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (A.updateRange = this.updateRange), A;
  }
  copyColorsArray() {
    console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.");
  }
  copyVector2sArray() {
    console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.");
  }
  copyVector3sArray() {
    console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.");
  }
  copyVector4sArray() {
    console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.");
  }
}
class Jb extends Pt {
  constructor(A, e, t) {
    super(new Int8Array(A), e, t);
  }
}
class Ob extends Pt {
  constructor(A, e, t) {
    super(new Uint8Array(A), e, t);
  }
}
class qb extends Pt {
  constructor(A, e, t) {
    super(new Uint8ClampedArray(A), e, t);
  }
}
class Pb extends Pt {
  constructor(A, e, t) {
    super(new Int16Array(A), e, t);
  }
}
class Nf extends Pt {
  constructor(A, e, t) {
    super(new Uint16Array(A), e, t);
  }
}
class Wb extends Pt {
  constructor(A, e, t) {
    super(new Int32Array(A), e, t);
  }
}
class My extends Pt {
  constructor(A, e, t) {
    super(new Uint32Array(A), e, t);
  }
}
class zb extends Pt {
  constructor(A, e, t) {
    super(new Uint16Array(A), e, t), this.isFloat16BufferAttribute = !0;
  }
  getX(A) {
    let e = wc(this.array[A * this.itemSize]);
    return this.normalized && (e = $r(e, this.array)), e;
  }
  setX(A, e) {
    return this.normalized && (e = _t(e, this.array)), this.array[A * this.itemSize] = Dr(e), this;
  }
  getY(A) {
    let e = wc(this.array[A * this.itemSize + 1]);
    return this.normalized && (e = $r(e, this.array)), e;
  }
  setY(A, e) {
    return this.normalized && (e = _t(e, this.array)), this.array[A * this.itemSize + 1] = Dr(e), this;
  }
  getZ(A) {
    let e = wc(this.array[A * this.itemSize + 2]);
    return this.normalized && (e = $r(e, this.array)), e;
  }
  setZ(A, e) {
    return this.normalized && (e = _t(e, this.array)), this.array[A * this.itemSize + 2] = Dr(e), this;
  }
  getW(A) {
    let e = wc(this.array[A * this.itemSize + 3]);
    return this.normalized && (e = $r(e, this.array)), e;
  }
  setW(A, e) {
    return this.normalized && (e = _t(e, this.array)), this.array[A * this.itemSize + 3] = Dr(e), this;
  }
  setXY(A, e, t) {
    return A *= this.itemSize, this.normalized && (e = _t(e, this.array), t = _t(t, this.array)), this.array[A + 0] = Dr(e), this.array[A + 1] = Dr(t), this;
  }
  setXYZ(A, e, t, i) {
    return A *= this.itemSize, this.normalized && (e = _t(e, this.array), t = _t(t, this.array), i = _t(i, this.array)), this.array[A + 0] = Dr(e), this.array[A + 1] = Dr(t), this.array[A + 2] = Dr(i), this;
  }
  setXYZW(A, e, t, i, n) {
    return A *= this.itemSize, this.normalized && (e = _t(e, this.array), t = _t(t, this.array), i = _t(i, this.array), n = _t(n, this.array)), this.array[A + 0] = Dr(e), this.array[A + 1] = Dr(t), this.array[A + 2] = Dr(i), this.array[A + 3] = Dr(n), this;
  }
}
class Oe extends Pt {
  constructor(A, e, t) {
    super(new Float32Array(A), e, t);
  }
}
class Vb extends Pt {
  constructor(A, e, t) {
    super(new Float64Array(A), e, t);
  }
}
let jb = 0;
const mo = /* @__PURE__ */ new Ve(), C0 = /* @__PURE__ */ new Xt(), jQ = /* @__PURE__ */ new IA(), Zr = /* @__PURE__ */ new cs(), ec = /* @__PURE__ */ new cs(), rg = /* @__PURE__ */ new IA();
class ut extends Za {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: jb++ }), this.uuid = io(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(A) {
    return Array.isArray(A) ? this.index = new (Mv(A) ? My : Nf)(A, 1) : this.index = A, this;
  }
  getAttribute(A) {
    return this.attributes[A];
  }
  setAttribute(A, e) {
    return this.attributes[A] = e, this;
  }
  deleteAttribute(A) {
    return delete this.attributes[A], this;
  }
  hasAttribute(A) {
    return this.attributes[A] !== void 0;
  }
  addGroup(A, e, t = 0) {
    this.groups.push({
      start: A,
      count: e,
      materialIndex: t
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(A, e) {
    this.drawRange.start = A, this.drawRange.count = e;
  }
  applyMatrix4(A) {
    const e = this.attributes.position;
    e !== void 0 && (e.applyMatrix4(A), e.needsUpdate = !0);
    const t = this.attributes.normal;
    if (t !== void 0) {
      const n = new kt().getNormalMatrix(A);
      t.applyNormalMatrix(n), t.needsUpdate = !0;
    }
    const i = this.attributes.tangent;
    return i !== void 0 && (i.transformDirection(A), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(A) {
    return mo.makeRotationFromQuaternion(A), this.applyMatrix4(mo), this;
  }
  rotateX(A) {
    return mo.makeRotationX(A), this.applyMatrix4(mo), this;
  }
  rotateY(A) {
    return mo.makeRotationY(A), this.applyMatrix4(mo), this;
  }
  rotateZ(A) {
    return mo.makeRotationZ(A), this.applyMatrix4(mo), this;
  }
  translate(A, e, t) {
    return mo.makeTranslation(A, e, t), this.applyMatrix4(mo), this;
  }
  scale(A, e, t) {
    return mo.makeScale(A, e, t), this.applyMatrix4(mo), this;
  }
  lookAt(A) {
    return C0.lookAt(A), C0.updateMatrix(), this.applyMatrix4(C0.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(jQ).negate(), this.translate(jQ.x, jQ.y, jQ.z), this;
  }
  setFromPoints(A) {
    const e = [];
    for (let t = 0, i = A.length; t < i; t++) {
      const n = A[t];
      e.push(n.x, n.y, n.z || 0);
    }
    return this.setAttribute("position", new Oe(e, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new cs());
    const A = this.attributes.position, e = this.morphAttributes.position;
    if (A && A.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new IA(-1 / 0, -1 / 0, -1 / 0),
        new IA(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (A !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(A), e)
        for (let t = 0, i = e.length; t < i; t++) {
          const n = e[t];
          Zr.setFromBufferAttribute(n), this.morphTargetsRelative ? (rg.addVectors(this.boundingBox.min, Zr.min), this.boundingBox.expandByPoint(rg), rg.addVectors(this.boundingBox.max, Zr.max), this.boundingBox.expandByPoint(rg)) : (this.boundingBox.expandByPoint(Zr.min), this.boundingBox.expandByPoint(Zr.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new us());
    const A = this.attributes.position, e = this.morphAttributes.position;
    if (A && A.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new IA(), 1 / 0);
      return;
    }
    if (A) {
      const t = this.boundingSphere.center;
      if (Zr.setFromBufferAttribute(A), e)
        for (let n = 0, r = e.length; n < r; n++) {
          const s = e[n];
          ec.setFromBufferAttribute(s), this.morphTargetsRelative ? (rg.addVectors(Zr.min, ec.min), Zr.expandByPoint(rg), rg.addVectors(Zr.max, ec.max), Zr.expandByPoint(rg)) : (Zr.expandByPoint(ec.min), Zr.expandByPoint(ec.max));
        }
      Zr.getCenter(t);
      let i = 0;
      for (let n = 0, r = A.count; n < r; n++)
        rg.fromBufferAttribute(A, n), i = Math.max(i, t.distanceToSquared(rg));
      if (e)
        for (let n = 0, r = e.length; n < r; n++) {
          const s = e[n], B = this.morphTargetsRelative;
          for (let I = 0, E = s.count; I < E; I++)
            rg.fromBufferAttribute(s, I), B && (jQ.fromBufferAttribute(A, I), rg.add(jQ)), i = Math.max(i, t.distanceToSquared(rg));
        }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const A = this.index, e = this.attributes;
    if (A === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const t = A.array, i = e.position.array, n = e.normal.array, r = e.uv.array, s = i.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Pt(new Float32Array(4 * s), 4));
    const B = this.getAttribute("tangent").array, I = [], E = [];
    for (let x = 0; x < s; x++)
      I[x] = new IA(), E[x] = new IA();
    const C = new IA(), c = new IA(), u = new IA(), d = new ue(), p = new ue(), D = new ue(), f = new IA(), S = new IA();
    function y(x, H, _) {
      C.fromArray(i, x * 3), c.fromArray(i, H * 3), u.fromArray(i, _ * 3), d.fromArray(r, x * 2), p.fromArray(r, H * 2), D.fromArray(r, _ * 2), c.sub(C), u.sub(C), p.sub(d), D.sub(d);
      const j = 1 / (p.x * D.y - D.x * p.y);
      isFinite(j) && (f.copy(c).multiplyScalar(D.y).addScaledVector(u, -p.y).multiplyScalar(j), S.copy(u).multiplyScalar(p.x).addScaledVector(c, -D.x).multiplyScalar(j), I[x].add(f), I[H].add(f), I[_].add(f), E[x].add(S), E[H].add(S), E[_].add(S));
    }
    let m = this.groups;
    m.length === 0 && (m = [{
      start: 0,
      count: t.length
    }]);
    for (let x = 0, H = m.length; x < H; ++x) {
      const _ = m[x], j = _.start, V = _.count;
      for (let iA = j, eA = j + V; iA < eA; iA += 3)
        y(
          t[iA + 0],
          t[iA + 1],
          t[iA + 2]
        );
    }
    const N = new IA(), F = new IA(), G = new IA(), k = new IA();
    function v(x) {
      G.fromArray(n, x * 3), k.copy(G);
      const H = I[x];
      N.copy(H), N.sub(G.multiplyScalar(G.dot(H))).normalize(), F.crossVectors(k, H);
      const j = F.dot(E[x]) < 0 ? -1 : 1;
      B[x * 4] = N.x, B[x * 4 + 1] = N.y, B[x * 4 + 2] = N.z, B[x * 4 + 3] = j;
    }
    for (let x = 0, H = m.length; x < H; ++x) {
      const _ = m[x], j = _.start, V = _.count;
      for (let iA = j, eA = j + V; iA < eA; iA += 3)
        v(t[iA + 0]), v(t[iA + 1]), v(t[iA + 2]);
    }
  }
  computeVertexNormals() {
    const A = this.index, e = this.getAttribute("position");
    if (e !== void 0) {
      let t = this.getAttribute("normal");
      if (t === void 0)
        t = new Pt(new Float32Array(e.count * 3), 3), this.setAttribute("normal", t);
      else
        for (let c = 0, u = t.count; c < u; c++)
          t.setXYZ(c, 0, 0, 0);
      const i = new IA(), n = new IA(), r = new IA(), s = new IA(), B = new IA(), I = new IA(), E = new IA(), C = new IA();
      if (A)
        for (let c = 0, u = A.count; c < u; c += 3) {
          const d = A.getX(c + 0), p = A.getX(c + 1), D = A.getX(c + 2);
          i.fromBufferAttribute(e, d), n.fromBufferAttribute(e, p), r.fromBufferAttribute(e, D), E.subVectors(r, n), C.subVectors(i, n), E.cross(C), s.fromBufferAttribute(t, d), B.fromBufferAttribute(t, p), I.fromBufferAttribute(t, D), s.add(E), B.add(E), I.add(E), t.setXYZ(d, s.x, s.y, s.z), t.setXYZ(p, B.x, B.y, B.z), t.setXYZ(D, I.x, I.y, I.z);
        }
      else
        for (let c = 0, u = e.count; c < u; c += 3)
          i.fromBufferAttribute(e, c + 0), n.fromBufferAttribute(e, c + 1), r.fromBufferAttribute(e, c + 2), E.subVectors(r, n), C.subVectors(i, n), E.cross(C), t.setXYZ(c + 0, E.x, E.y, E.z), t.setXYZ(c + 1, E.x, E.y, E.z), t.setXYZ(c + 2, E.x, E.y, E.z);
      this.normalizeNormals(), t.needsUpdate = !0;
    }
  }
  merge() {
    return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead."), this;
  }
  normalizeNormals() {
    const A = this.attributes.normal;
    for (let e = 0, t = A.count; e < t; e++)
      rg.fromBufferAttribute(A, e), rg.normalize(), A.setXYZ(e, rg.x, rg.y, rg.z);
  }
  toNonIndexed() {
    function A(s, B) {
      const I = s.array, E = s.itemSize, C = s.normalized, c = new I.constructor(B.length * E);
      let u = 0, d = 0;
      for (let p = 0, D = B.length; p < D; p++) {
        s.isInterleavedBufferAttribute ? u = B[p] * s.data.stride + s.offset : u = B[p] * E;
        for (let f = 0; f < E; f++)
          c[d++] = I[u++];
      }
      return new Pt(c, E, C);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const e = new ut(), t = this.index.array, i = this.attributes;
    for (const s in i) {
      const B = i[s], I = A(B, t);
      e.setAttribute(s, I);
    }
    const n = this.morphAttributes;
    for (const s in n) {
      const B = [], I = n[s];
      for (let E = 0, C = I.length; E < C; E++) {
        const c = I[E], u = A(c, t);
        B.push(u);
      }
      e.morphAttributes[s] = B;
    }
    e.morphTargetsRelative = this.morphTargetsRelative;
    const r = this.groups;
    for (let s = 0, B = r.length; s < B; s++) {
      const I = r[s];
      e.addGroup(I.start, I.count, I.materialIndex);
    }
    return e;
  }
  toJSON() {
    const A = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (A.uuid = this.uuid, A.type = this.type, this.name !== "" && (A.name = this.name), Object.keys(this.userData).length > 0 && (A.userData = this.userData), this.parameters !== void 0) {
      const B = this.parameters;
      for (const I in B)
        B[I] !== void 0 && (A[I] = B[I]);
      return A;
    }
    A.data = { attributes: {} };
    const e = this.index;
    e !== null && (A.data.index = {
      type: e.array.constructor.name,
      array: Array.prototype.slice.call(e.array)
    });
    const t = this.attributes;
    for (const B in t) {
      const I = t[B];
      A.data.attributes[B] = I.toJSON(A.data);
    }
    const i = {};
    let n = !1;
    for (const B in this.morphAttributes) {
      const I = this.morphAttributes[B], E = [];
      for (let C = 0, c = I.length; C < c; C++) {
        const u = I[C];
        E.push(u.toJSON(A.data));
      }
      E.length > 0 && (i[B] = E, n = !0);
    }
    n && (A.data.morphAttributes = i, A.data.morphTargetsRelative = this.morphTargetsRelative);
    const r = this.groups;
    r.length > 0 && (A.data.groups = JSON.parse(JSON.stringify(r)));
    const s = this.boundingSphere;
    return s !== null && (A.data.boundingSphere = {
      center: s.center.toArray(),
      radius: s.radius
    }), A;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(A) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const e = {};
    this.name = A.name;
    const t = A.index;
    t !== null && this.setIndex(t.clone(e));
    const i = A.attributes;
    for (const I in i) {
      const E = i[I];
      this.setAttribute(I, E.clone(e));
    }
    const n = A.morphAttributes;
    for (const I in n) {
      const E = [], C = n[I];
      for (let c = 0, u = C.length; c < u; c++)
        E.push(C[c].clone(e));
      this.morphAttributes[I] = E;
    }
    this.morphTargetsRelative = A.morphTargetsRelative;
    const r = A.groups;
    for (let I = 0, E = r.length; I < E; I++) {
      const C = r[I];
      this.addGroup(C.start, C.count, C.materialIndex);
    }
    const s = A.boundingBox;
    s !== null && (this.boundingBox = s.clone());
    const B = A.boundingSphere;
    return B !== null && (this.boundingSphere = B.clone()), this.drawRange.start = A.drawRange.start, this.drawRange.count = A.drawRange.count, this.userData = A.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const SR = /* @__PURE__ */ new Ve(), js = /* @__PURE__ */ new Xc(), gd = /* @__PURE__ */ new us(), MR = /* @__PURE__ */ new IA(), ZQ = /* @__PURE__ */ new IA(), XQ = /* @__PURE__ */ new IA(), $Q = /* @__PURE__ */ new IA(), Q0 = /* @__PURE__ */ new IA(), rd = /* @__PURE__ */ new IA(), od = /* @__PURE__ */ new ue(), sd = /* @__PURE__ */ new ue(), ad = /* @__PURE__ */ new ue(), RR = /* @__PURE__ */ new IA(), NR = /* @__PURE__ */ new IA(), FR = /* @__PURE__ */ new IA(), Id = /* @__PURE__ */ new IA(), Bd = /* @__PURE__ */ new IA();
let Xi = class extends Xt {
  constructor(A = new ut(), e = new Ao()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = A, this.material = e, this.updateMorphTargets();
  }
  copy(A, e) {
    return super.copy(A, e), A.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = A.morphTargetInfluences.slice()), A.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, A.morphTargetDictionary)), this.material = A.material, this.geometry = A.geometry, this;
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, t = Object.keys(e);
    if (t.length > 0) {
      const i = e[t[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let n = 0, r = i.length; n < r; n++) {
          const s = i[n].name || String(n);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = n;
        }
      }
    }
  }
  getVertexPosition(A, e) {
    const t = this.geometry, i = t.attributes.position, n = t.morphAttributes.position, r = t.morphTargetsRelative;
    e.fromBufferAttribute(i, A);
    const s = this.morphTargetInfluences;
    if (n && s) {
      rd.set(0, 0, 0);
      for (let B = 0, I = n.length; B < I; B++) {
        const E = s[B], C = n[B];
        E !== 0 && (Q0.fromBufferAttribute(C, A), r ? rd.addScaledVector(Q0, E) : rd.addScaledVector(Q0.sub(e), E));
      }
      e.add(rd);
    }
    return this.isSkinnedMesh && this.applyBoneTransform(A, e), e;
  }
  raycast(A, e) {
    const t = this.geometry, i = this.material, n = this.matrixWorld;
    if (i === void 0 || (t.boundingSphere === null && t.computeBoundingSphere(), gd.copy(t.boundingSphere), gd.applyMatrix4(n), js.copy(A.ray).recast(A.near), gd.containsPoint(js.origin) === !1 && (js.intersectSphere(gd, MR) === null || js.origin.distanceToSquared(MR) > (A.far - A.near) ** 2)) || (SR.copy(n).invert(), js.copy(A.ray).applyMatrix4(SR), t.boundingBox !== null && js.intersectsBox(t.boundingBox) === !1))
      return;
    let r;
    const s = t.index, B = t.attributes.position, I = t.attributes.uv, E = t.attributes.uv2, C = t.attributes.normal, c = t.groups, u = t.drawRange;
    if (s !== null)
      if (Array.isArray(i))
        for (let d = 0, p = c.length; d < p; d++) {
          const D = c[d], f = i[D.materialIndex], S = Math.max(D.start, u.start), y = Math.min(s.count, Math.min(D.start + D.count, u.start + u.count));
          for (let m = S, N = y; m < N; m += 3) {
            const F = s.getX(m), G = s.getX(m + 1), k = s.getX(m + 2);
            r = Cd(this, f, A, js, I, E, C, F, G, k), r && (r.faceIndex = Math.floor(m / 3), r.face.materialIndex = D.materialIndex, e.push(r));
          }
        }
      else {
        const d = Math.max(0, u.start), p = Math.min(s.count, u.start + u.count);
        for (let D = d, f = p; D < f; D += 3) {
          const S = s.getX(D), y = s.getX(D + 1), m = s.getX(D + 2);
          r = Cd(this, i, A, js, I, E, C, S, y, m), r && (r.faceIndex = Math.floor(D / 3), e.push(r));
        }
      }
    else if (B !== void 0)
      if (Array.isArray(i))
        for (let d = 0, p = c.length; d < p; d++) {
          const D = c[d], f = i[D.materialIndex], S = Math.max(D.start, u.start), y = Math.min(B.count, Math.min(D.start + D.count, u.start + u.count));
          for (let m = S, N = y; m < N; m += 3) {
            const F = m, G = m + 1, k = m + 2;
            r = Cd(this, f, A, js, I, E, C, F, G, k), r && (r.faceIndex = Math.floor(m / 3), r.face.materialIndex = D.materialIndex, e.push(r));
          }
        }
      else {
        const d = Math.max(0, u.start), p = Math.min(B.count, u.start + u.count);
        for (let D = d, f = p; D < f; D += 3) {
          const S = D, y = D + 1, m = D + 2;
          r = Cd(this, i, A, js, I, E, C, S, y, m), r && (r.faceIndex = Math.floor(D / 3), e.push(r));
        }
      }
  }
};
function Zb(g, A, e, t, i, n, r, s) {
  let B;
  if (A.side === ir ? B = t.intersectTriangle(r, n, i, !0, s) : B = t.intersectTriangle(i, n, r, A.side === ea, s), B === null)
    return null;
  Bd.copy(s), Bd.applyMatrix4(g.matrixWorld);
  const I = e.ray.origin.distanceTo(Bd);
  return I < e.near || I > e.far ? null : {
    distance: I,
    point: Bd.clone(),
    object: g
  };
}
function Cd(g, A, e, t, i, n, r, s, B, I) {
  g.getVertexPosition(s, ZQ), g.getVertexPosition(B, XQ), g.getVertexPosition(I, $Q);
  const E = Zb(g, A, e, t, ZQ, XQ, $Q, Id);
  if (E) {
    i && (od.fromBufferAttribute(i, s), sd.fromBufferAttribute(i, B), ad.fromBufferAttribute(i, I), E.uv = Sr.getInterpolation(Id, ZQ, XQ, $Q, od, sd, ad, new ue())), n && (od.fromBufferAttribute(n, s), sd.fromBufferAttribute(n, B), ad.fromBufferAttribute(n, I), E.uv2 = Sr.getInterpolation(Id, ZQ, XQ, $Q, od, sd, ad, new ue())), r && (RR.fromBufferAttribute(r, s), NR.fromBufferAttribute(r, B), FR.fromBufferAttribute(r, I), E.normal = Sr.getInterpolation(Id, ZQ, XQ, $Q, RR, NR, FR, new IA()), E.normal.dot(t.direction) > 0 && E.normal.multiplyScalar(-1));
    const C = {
      a: s,
      b: B,
      c: I,
      normal: new IA(),
      materialIndex: 0
    };
    Sr.getNormal(ZQ, XQ, $Q, C.normal), E.face = C;
  }
  return E;
}
class Xa extends ut {
  constructor(A = 1, e = 1, t = 1, i = 1, n = 1, r = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: A,
      height: e,
      depth: t,
      widthSegments: i,
      heightSegments: n,
      depthSegments: r
    };
    const s = this;
    i = Math.floor(i), n = Math.floor(n), r = Math.floor(r);
    const B = [], I = [], E = [], C = [];
    let c = 0, u = 0;
    d("z", "y", "x", -1, -1, t, e, A, r, n, 0), d("z", "y", "x", 1, -1, t, e, -A, r, n, 1), d("x", "z", "y", 1, 1, A, t, e, i, r, 2), d("x", "z", "y", 1, -1, A, t, -e, i, r, 3), d("x", "y", "z", 1, -1, A, e, t, i, n, 4), d("x", "y", "z", -1, -1, A, e, -t, i, n, 5), this.setIndex(B), this.setAttribute("position", new Oe(I, 3)), this.setAttribute("normal", new Oe(E, 3)), this.setAttribute("uv", new Oe(C, 2));
    function d(p, D, f, S, y, m, N, F, G, k, v) {
      const x = m / G, H = N / k, _ = m / 2, j = N / 2, V = F / 2, iA = G + 1, eA = k + 1;
      let oA = 0, P = 0;
      const J = new IA();
      for (let tA = 0; tA < eA; tA++) {
        const Y = tA * H - j;
        for (let rA = 0; rA < iA; rA++) {
          const QA = rA * x - _;
          J[p] = QA * S, J[D] = Y * y, J[f] = V, I.push(J.x, J.y, J.z), J[p] = 0, J[D] = 0, J[f] = F > 0 ? 1 : -1, E.push(J.x, J.y, J.z), C.push(rA / G), C.push(1 - tA / k), oA += 1;
        }
      }
      for (let tA = 0; tA < k; tA++)
        for (let Y = 0; Y < G; Y++) {
          const rA = c + Y + iA * tA, QA = c + Y + iA * (tA + 1), aA = c + (Y + 1) + iA * (tA + 1), MA = c + (Y + 1) + iA * tA;
          B.push(rA, QA, MA), B.push(QA, aA, MA), P += 6;
        }
      s.addGroup(u, P, v), u += P, c += oA;
    }
  }
  copy(A) {
    return super.copy(A), this.parameters = Object.assign({}, A.parameters), this;
  }
  static fromJSON(A) {
    return new Xa(A.width, A.height, A.depth, A.widthSegments, A.heightSegments, A.depthSegments);
  }
}
function vE(g) {
  const A = {};
  for (const e in g) {
    A[e] = {};
    for (const t in g[e]) {
      const i = g[e][t];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), A[e][t] = null) : A[e][t] = i.clone() : Array.isArray(i) ? A[e][t] = i.slice() : A[e][t] = i;
    }
  }
  return A;
}
function Ar(g) {
  const A = {};
  for (let e = 0; e < g.length; e++) {
    const t = vE(g[e]);
    for (const i in t)
      A[i] = t[i];
  }
  return A;
}
function Xb(g) {
  const A = [];
  for (let e = 0; e < g.length; e++)
    A.push(g[e].clone());
  return A;
}
function Nv(g) {
  return g.getRenderTarget() === null && g.outputEncoding === Ht ? ss : FE;
}
const Fv = { clone: vE, merge: Ar };
var $b = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, A2 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ia extends Sn {
  constructor(A) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = $b, this.fragmentShader = A2, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      derivatives: !1,
      // set to use derivatives
      fragDepth: !1,
      // set to use fragment depth values
      drawBuffers: !1,
      // set to use draw buffers
      shaderTextureLOD: !1
      // set to use shader texture LOD
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv2: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, A !== void 0 && this.setValues(A);
  }
  copy(A) {
    return super.copy(A), this.fragmentShader = A.fragmentShader, this.vertexShader = A.vertexShader, this.uniforms = vE(A.uniforms), this.uniformsGroups = Xb(A.uniformsGroups), this.defines = Object.assign({}, A.defines), this.wireframe = A.wireframe, this.wireframeLinewidth = A.wireframeLinewidth, this.fog = A.fog, this.lights = A.lights, this.clipping = A.clipping, this.extensions = Object.assign({}, A.extensions), this.glslVersion = A.glslVersion, this;
  }
  toJSON(A) {
    const e = super.toJSON(A);
    e.glslVersion = this.glslVersion, e.uniforms = {};
    for (const i in this.uniforms) {
      const r = this.uniforms[i].value;
      r && r.isTexture ? e.uniforms[i] = {
        type: "t",
        value: r.toJSON(A).uuid
      } : r && r.isColor ? e.uniforms[i] = {
        type: "c",
        value: r.getHex()
      } : r && r.isVector2 ? e.uniforms[i] = {
        type: "v2",
        value: r.toArray()
      } : r && r.isVector3 ? e.uniforms[i] = {
        type: "v3",
        value: r.toArray()
      } : r && r.isVector4 ? e.uniforms[i] = {
        type: "v4",
        value: r.toArray()
      } : r && r.isMatrix3 ? e.uniforms[i] = {
        type: "m3",
        value: r.toArray()
      } : r && r.isMatrix4 ? e.uniforms[i] = {
        type: "m4",
        value: r.toArray()
      } : e.uniforms[i] = {
        value: r
      };
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
    const t = {};
    for (const i in this.extensions)
      this.extensions[i] === !0 && (t[i] = !0);
    return Object.keys(t).length > 0 && (e.extensions = t), e;
  }
}
class $c extends Xt {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Ve(), this.projectionMatrix = new Ve(), this.projectionMatrixInverse = new Ve();
  }
  copy(A, e) {
    return super.copy(A, e), this.matrixWorldInverse.copy(A.matrixWorldInverse), this.projectionMatrix.copy(A.projectionMatrix), this.projectionMatrixInverse.copy(A.projectionMatrixInverse), this;
  }
  getWorldDirection(A) {
    this.updateWorldMatrix(!0, !1);
    const e = this.matrixWorld.elements;
    return A.set(-e[8], -e[9], -e[10]).normalize();
  }
  updateMatrixWorld(A) {
    super.updateMatrixWorld(A), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(A, e) {
    super.updateWorldMatrix(A, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
let mn = class extends $c {
  constructor(A = 50, e = 1, t = 0.1, i = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = A, this.zoom = 1, this.near = t, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(A, e) {
    return super.copy(A, e), this.fov = A.fov, this.zoom = A.zoom, this.near = A.near, this.far = A.far, this.focus = A.focus, this.aspect = A.aspect, this.view = A.view === null ? null : Object.assign({}, A.view), this.filmGauge = A.filmGauge, this.filmOffset = A.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(A) {
    const e = 0.5 * this.getFilmHeight() / A;
    this.fov = GE * 2 * Math.atan(e), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const A = Math.tan(FC * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / A;
  }
  getEffectiveFOV() {
    return GE * 2 * Math.atan(
      Math.tan(FC * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(A, e, t, i, n, r) {
    this.aspect = A / e, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = A, this.view.fullHeight = e, this.view.offsetX = t, this.view.offsetY = i, this.view.width = n, this.view.height = r, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const A = this.near;
    let e = A * Math.tan(FC * 0.5 * this.fov) / this.zoom, t = 2 * e, i = this.aspect * t, n = -0.5 * i;
    const r = this.view;
    if (this.view !== null && this.view.enabled) {
      const B = r.fullWidth, I = r.fullHeight;
      n += r.offsetX * i / B, e -= r.offsetY * t / I, i *= r.width / B, t *= r.height / I;
    }
    const s = this.filmOffset;
    s !== 0 && (n += A * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(n, n + i, e, e - t, A, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(A) {
    const e = super.toJSON(A);
    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
  }
};
const AE = -90, eE = 1;
class Gv extends Xt {
  constructor(A, e, t) {
    super(), this.type = "CubeCamera", this.renderTarget = t;
    const i = new mn(AE, eE, A, e);
    i.layers = this.layers, i.up.set(0, 1, 0), i.lookAt(1, 0, 0), this.add(i);
    const n = new mn(AE, eE, A, e);
    n.layers = this.layers, n.up.set(0, 1, 0), n.lookAt(-1, 0, 0), this.add(n);
    const r = new mn(AE, eE, A, e);
    r.layers = this.layers, r.up.set(0, 0, -1), r.lookAt(0, 1, 0), this.add(r);
    const s = new mn(AE, eE, A, e);
    s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(0, -1, 0), this.add(s);
    const B = new mn(AE, eE, A, e);
    B.layers = this.layers, B.up.set(0, 1, 0), B.lookAt(0, 0, 1), this.add(B);
    const I = new mn(AE, eE, A, e);
    I.layers = this.layers, I.up.set(0, 1, 0), I.lookAt(0, 0, -1), this.add(I);
  }
  update(A, e) {
    this.parent === null && this.updateMatrixWorld();
    const t = this.renderTarget, [i, n, r, s, B, I] = this.children, E = A.getRenderTarget(), C = A.toneMapping, c = A.xr.enabled;
    A.toneMapping = Is, A.xr.enabled = !1;
    const u = t.texture.generateMipmaps;
    t.texture.generateMipmaps = !1, A.setRenderTarget(t, 0), A.render(e, i), A.setRenderTarget(t, 1), A.render(e, n), A.setRenderTarget(t, 2), A.render(e, r), A.setRenderTarget(t, 3), A.render(e, s), A.setRenderTarget(t, 4), A.render(e, B), t.texture.generateMipmaps = u, A.setRenderTarget(t, 5), A.render(e, I), A.setRenderTarget(E), A.toneMapping = C, A.xr.enabled = c, t.texture.needsPMREMUpdate = !0;
  }
}
class Au extends xi {
  constructor(A, e, t, i, n, r, s, B, I, E) {
    A = A !== void 0 ? A : [], e = e !== void 0 ? e : lB, super(A, e, t, i, n, r, s, B, I, E), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(A) {
    this.image = A;
  }
}
class vv extends Uo {
  constructor(A = 1, e = {}) {
    super(A, A, e), this.isWebGLCubeRenderTarget = !0;
    const t = { width: A, height: A, depth: 1 }, i = [t, t, t, t, t, t];
    this.texture = new Au(i, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : !1, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : Gi;
  }
  fromEquirectangularTexture(A, e) {
    this.texture.type = e.type, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
    const t = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, i = new Xa(5, 5, 5), n = new ia({
      name: "CubemapFromEquirect",
      uniforms: vE(t.uniforms),
      vertexShader: t.vertexShader,
      fragmentShader: t.fragmentShader,
      side: ir,
      blending: Wa
    });
    n.uniforms.tEquirect.value = e;
    const r = new Xi(i, n), s = e.minFilter;
    return e.minFilter === Cs && (e.minFilter = Gi), new Gv(1, 10, this).update(A, r), e.minFilter = s, r.geometry.dispose(), r.material.dispose(), this;
  }
  clear(A, e, t, i) {
    const n = A.getRenderTarget();
    for (let r = 0; r < 6; r++)
      A.setRenderTarget(this, r), A.clear(e, t, i);
    A.setRenderTarget(n);
  }
}
const E0 = /* @__PURE__ */ new IA(), e2 = /* @__PURE__ */ new IA(), t2 = /* @__PURE__ */ new kt();
class rB {
  constructor(A = new IA(1, 0, 0), e = 0) {
    this.isPlane = !0, this.normal = A, this.constant = e;
  }
  set(A, e) {
    return this.normal.copy(A), this.constant = e, this;
  }
  setComponents(A, e, t, i) {
    return this.normal.set(A, e, t), this.constant = i, this;
  }
  setFromNormalAndCoplanarPoint(A, e) {
    return this.normal.copy(A), this.constant = -e.dot(this.normal), this;
  }
  setFromCoplanarPoints(A, e, t) {
    const i = E0.subVectors(t, e).cross(e2.subVectors(A, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, A), this;
  }
  copy(A) {
    return this.normal.copy(A.normal), this.constant = A.constant, this;
  }
  normalize() {
    const A = 1 / this.normal.length();
    return this.normal.multiplyScalar(A), this.constant *= A, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(A) {
    return this.normal.dot(A) + this.constant;
  }
  distanceToSphere(A) {
    return this.distanceToPoint(A.center) - A.radius;
  }
  projectPoint(A, e) {
    return e.copy(A).addScaledVector(this.normal, -this.distanceToPoint(A));
  }
  intersectLine(A, e) {
    const t = A.delta(E0), i = this.normal.dot(t);
    if (i === 0)
      return this.distanceToPoint(A.start) === 0 ? e.copy(A.start) : null;
    const n = -(A.start.dot(this.normal) + this.constant) / i;
    return n < 0 || n > 1 ? null : e.copy(A.start).addScaledVector(t, n);
  }
  intersectsLine(A) {
    const e = this.distanceToPoint(A.start), t = this.distanceToPoint(A.end);
    return e < 0 && t > 0 || t < 0 && e > 0;
  }
  intersectsBox(A) {
    return A.intersectsPlane(this);
  }
  intersectsSphere(A) {
    return A.intersectsPlane(this);
  }
  coplanarPoint(A) {
    return A.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(A, e) {
    const t = e || t2.getNormalMatrix(A), i = this.coplanarPoint(E0).applyMatrix4(A), n = this.normal.applyMatrix3(t).normalize();
    return this.constant = -i.dot(n), this;
  }
  translate(A) {
    return this.constant -= A.dot(this.normal), this;
  }
  equals(A) {
    return A.normal.equals(this.normal) && A.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const BC = /* @__PURE__ */ new us(), Qd = /* @__PURE__ */ new IA();
class Ff {
  constructor(A = new rB(), e = new rB(), t = new rB(), i = new rB(), n = new rB(), r = new rB()) {
    this.planes = [A, e, t, i, n, r];
  }
  set(A, e, t, i, n, r) {
    const s = this.planes;
    return s[0].copy(A), s[1].copy(e), s[2].copy(t), s[3].copy(i), s[4].copy(n), s[5].copy(r), this;
  }
  copy(A) {
    const e = this.planes;
    for (let t = 0; t < 6; t++)
      e[t].copy(A.planes[t]);
    return this;
  }
  setFromProjectionMatrix(A) {
    const e = this.planes, t = A.elements, i = t[0], n = t[1], r = t[2], s = t[3], B = t[4], I = t[5], E = t[6], C = t[7], c = t[8], u = t[9], d = t[10], p = t[11], D = t[12], f = t[13], S = t[14], y = t[15];
    return e[0].setComponents(s - i, C - B, p - c, y - D).normalize(), e[1].setComponents(s + i, C + B, p + c, y + D).normalize(), e[2].setComponents(s + n, C + I, p + u, y + f).normalize(), e[3].setComponents(s - n, C - I, p - u, y - f).normalize(), e[4].setComponents(s - r, C - E, p - d, y - S).normalize(), e[5].setComponents(s + r, C + E, p + d, y + S).normalize(), this;
  }
  intersectsObject(A) {
    if (A.boundingSphere !== void 0)
      A.boundingSphere === null && A.computeBoundingSphere(), BC.copy(A.boundingSphere).applyMatrix4(A.matrixWorld);
    else {
      const e = A.geometry;
      e.boundingSphere === null && e.computeBoundingSphere(), BC.copy(e.boundingSphere).applyMatrix4(A.matrixWorld);
    }
    return this.intersectsSphere(BC);
  }
  intersectsSprite(A) {
    return BC.center.set(0, 0, 0), BC.radius = 0.7071067811865476, BC.applyMatrix4(A.matrixWorld), this.intersectsSphere(BC);
  }
  intersectsSphere(A) {
    const e = this.planes, t = A.center, i = -A.radius;
    for (let n = 0; n < 6; n++)
      if (e[n].distanceToPoint(t) < i)
        return !1;
    return !0;
  }
  intersectsBox(A) {
    const e = this.planes;
    for (let t = 0; t < 6; t++) {
      const i = e[t];
      if (Qd.x = i.normal.x > 0 ? A.max.x : A.min.x, Qd.y = i.normal.y > 0 ? A.max.y : A.min.y, Qd.z = i.normal.z > 0 ? A.max.z : A.min.z, i.distanceToPoint(Qd) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(A) {
    const e = this.planes;
    for (let t = 0; t < 6; t++)
      if (e[t].distanceToPoint(A) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Uv() {
  let g = null, A = !1, e = null, t = null;
  function i(n, r) {
    e(n, r), t = g.requestAnimationFrame(i);
  }
  return {
    start: function() {
      A !== !0 && e !== null && (t = g.requestAnimationFrame(i), A = !0);
    },
    stop: function() {
      g.cancelAnimationFrame(t), A = !1;
    },
    setAnimationLoop: function(n) {
      e = n;
    },
    setContext: function(n) {
      g = n;
    }
  };
}
function i2(g, A) {
  const e = A.isWebGL2, t = /* @__PURE__ */ new WeakMap();
  function i(I, E) {
    const C = I.array, c = I.usage, u = g.createBuffer();
    g.bindBuffer(E, u), g.bufferData(E, C, c), I.onUploadCallback();
    let d;
    if (C instanceof Float32Array)
      d = 5126;
    else if (C instanceof Uint16Array)
      if (I.isFloat16BufferAttribute)
        if (e)
          d = 5131;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        d = 5123;
    else if (C instanceof Int16Array)
      d = 5122;
    else if (C instanceof Uint32Array)
      d = 5125;
    else if (C instanceof Int32Array)
      d = 5124;
    else if (C instanceof Int8Array)
      d = 5120;
    else if (C instanceof Uint8Array)
      d = 5121;
    else if (C instanceof Uint8ClampedArray)
      d = 5121;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + C);
    return {
      buffer: u,
      type: d,
      bytesPerElement: C.BYTES_PER_ELEMENT,
      version: I.version
    };
  }
  function n(I, E, C) {
    const c = E.array, u = E.updateRange;
    g.bindBuffer(C, I), u.count === -1 ? g.bufferSubData(C, 0, c) : (e ? g.bufferSubData(
      C,
      u.offset * c.BYTES_PER_ELEMENT,
      c,
      u.offset,
      u.count
    ) : g.bufferSubData(
      C,
      u.offset * c.BYTES_PER_ELEMENT,
      c.subarray(u.offset, u.offset + u.count)
    ), u.count = -1), E.onUploadCallback();
  }
  function r(I) {
    return I.isInterleavedBufferAttribute && (I = I.data), t.get(I);
  }
  function s(I) {
    I.isInterleavedBufferAttribute && (I = I.data);
    const E = t.get(I);
    E && (g.deleteBuffer(E.buffer), t.delete(I));
  }
  function B(I, E) {
    if (I.isGLBufferAttribute) {
      const c = t.get(I);
      (!c || c.version < I.version) && t.set(I, {
        buffer: I.buffer,
        type: I.type,
        bytesPerElement: I.elementSize,
        version: I.version
      });
      return;
    }
    I.isInterleavedBufferAttribute && (I = I.data);
    const C = t.get(I);
    C === void 0 ? t.set(I, i(I, E)) : C.version < I.version && (n(C.buffer, I, E), C.version = I.version);
  }
  return {
    get: r,
    remove: s,
    update: B
  };
}
class PC extends ut {
  constructor(A = 1, e = 1, t = 1, i = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: A,
      height: e,
      widthSegments: t,
      heightSegments: i
    };
    const n = A / 2, r = e / 2, s = Math.floor(t), B = Math.floor(i), I = s + 1, E = B + 1, C = A / s, c = e / B, u = [], d = [], p = [], D = [];
    for (let f = 0; f < E; f++) {
      const S = f * c - r;
      for (let y = 0; y < I; y++) {
        const m = y * C - n;
        d.push(m, -S, 0), p.push(0, 0, 1), D.push(y / s), D.push(1 - f / B);
      }
    }
    for (let f = 0; f < B; f++)
      for (let S = 0; S < s; S++) {
        const y = S + I * f, m = S + I * (f + 1), N = S + 1 + I * (f + 1), F = S + 1 + I * f;
        u.push(y, m, F), u.push(m, N, F);
      }
    this.setIndex(u), this.setAttribute("position", new Oe(d, 3)), this.setAttribute("normal", new Oe(p, 3)), this.setAttribute("uv", new Oe(D, 2));
  }
  copy(A) {
    return super.copy(A), this.parameters = Object.assign({}, A.parameters), this;
  }
  static fromJSON(A) {
    return new PC(A.width, A.height, A.widthSegments, A.heightSegments);
  }
}
var n2 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, g2 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, r2 = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, o2 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, s2 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, a2 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, I2 = "vec3 transformed = vec3( position );", B2 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, C2 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, Q2 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, E2 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, l2 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, c2 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, u2 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, h2 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, d2 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, f2 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, p2 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, D2 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, w2 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, y2 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, m2 = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, S2 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, M2 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, R2 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, N2 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, F2 = "gl_FragColor = linearToOutputTexel( gl_FragColor );", G2 = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, v2 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, U2 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, k2 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, x2 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, L2 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, T2 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, K2 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, b2 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, Y2 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, H2 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, _2 = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, J2 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, O2 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, q2 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, P2 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, W2 = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`, z2 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, V2 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, j2 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Z2 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, X2 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif`, $2 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, AY = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, eY = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, tY = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, iY = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, nY = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, gY = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, rY = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, oY = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, sY = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, aY = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, IY = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, BY = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, CY = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, QY = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, EY = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, lY = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, cY = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, uY = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#ifdef USE_NORMALMAP_TANGENTSPACE
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`, hY = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, dY = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, fY = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, pY = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, DY = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, wY = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, yY = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, mY = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, SY = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, MY = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, RY = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, NY = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, FY = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, GY = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, vY = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, UY = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, kY = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, xY = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, LY = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, TY = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, KY = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, bY = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, YY = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, HY = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, _Y = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, JY = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, OY = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, qY = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, PY = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, WY = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`, zY = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, vec2 fullSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		
		vec2 lodFudge = pow( 1.95, lod ) / fullSize;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec2 fullSize = vec2( textureSize( sampler, 0 ) );
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), fullSize, floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), fullSize, ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`, VY = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, jY = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_UV2
	attribute vec2 uv2;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, ZY = `#ifdef USE_UV
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, XY = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const $Y = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, AH = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, eH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, tH = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, iH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, nH = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, gH = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, rH = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, oH = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, sH = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, aH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, IH = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, BH = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, CH = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, QH = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, EH = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, lH = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, cH = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, uH = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, hH = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, dH = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, fH = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, pH = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, DH = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, wH = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, yH = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, mH = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, SH = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, MH = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, RH = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, NH = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, FH = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, GH = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, vH = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, Yt = {
  alphamap_fragment: n2,
  alphamap_pars_fragment: g2,
  alphatest_fragment: r2,
  alphatest_pars_fragment: o2,
  aomap_fragment: s2,
  aomap_pars_fragment: a2,
  begin_vertex: I2,
  beginnormal_vertex: B2,
  bsdfs: C2,
  iridescence_fragment: Q2,
  bumpmap_pars_fragment: E2,
  clipping_planes_fragment: l2,
  clipping_planes_pars_fragment: c2,
  clipping_planes_pars_vertex: u2,
  clipping_planes_vertex: h2,
  color_fragment: d2,
  color_pars_fragment: f2,
  color_pars_vertex: p2,
  color_vertex: D2,
  common: w2,
  cube_uv_reflection_fragment: y2,
  defaultnormal_vertex: m2,
  displacementmap_pars_vertex: S2,
  displacementmap_vertex: M2,
  emissivemap_fragment: R2,
  emissivemap_pars_fragment: N2,
  encodings_fragment: F2,
  encodings_pars_fragment: G2,
  envmap_fragment: v2,
  envmap_common_pars_fragment: U2,
  envmap_pars_fragment: k2,
  envmap_pars_vertex: x2,
  envmap_physical_pars_fragment: W2,
  envmap_vertex: L2,
  fog_vertex: T2,
  fog_pars_vertex: K2,
  fog_fragment: b2,
  fog_pars_fragment: Y2,
  gradientmap_pars_fragment: H2,
  lightmap_fragment: _2,
  lightmap_pars_fragment: J2,
  lights_lambert_fragment: O2,
  lights_lambert_pars_fragment: q2,
  lights_pars_begin: P2,
  lights_toon_fragment: z2,
  lights_toon_pars_fragment: V2,
  lights_phong_fragment: j2,
  lights_phong_pars_fragment: Z2,
  lights_physical_fragment: X2,
  lights_physical_pars_fragment: $2,
  lights_fragment_begin: AY,
  lights_fragment_maps: eY,
  lights_fragment_end: tY,
  logdepthbuf_fragment: iY,
  logdepthbuf_pars_fragment: nY,
  logdepthbuf_pars_vertex: gY,
  logdepthbuf_vertex: rY,
  map_fragment: oY,
  map_pars_fragment: sY,
  map_particle_fragment: aY,
  map_particle_pars_fragment: IY,
  metalnessmap_fragment: BY,
  metalnessmap_pars_fragment: CY,
  morphcolor_vertex: QY,
  morphnormal_vertex: EY,
  morphtarget_pars_vertex: lY,
  morphtarget_vertex: cY,
  normal_fragment_begin: uY,
  normal_fragment_maps: hY,
  normal_pars_fragment: dY,
  normal_pars_vertex: fY,
  normal_vertex: pY,
  normalmap_pars_fragment: DY,
  clearcoat_normal_fragment_begin: wY,
  clearcoat_normal_fragment_maps: yY,
  clearcoat_pars_fragment: mY,
  iridescence_pars_fragment: SY,
  output_fragment: MY,
  packing: RY,
  premultiplied_alpha_fragment: NY,
  project_vertex: FY,
  dithering_fragment: GY,
  dithering_pars_fragment: vY,
  roughnessmap_fragment: UY,
  roughnessmap_pars_fragment: kY,
  shadowmap_pars_fragment: xY,
  shadowmap_pars_vertex: LY,
  shadowmap_vertex: TY,
  shadowmask_pars_fragment: KY,
  skinbase_vertex: bY,
  skinning_pars_vertex: YY,
  skinning_vertex: HY,
  skinnormal_vertex: _Y,
  specularmap_fragment: JY,
  specularmap_pars_fragment: OY,
  tonemapping_fragment: qY,
  tonemapping_pars_fragment: PY,
  transmission_fragment: WY,
  transmission_pars_fragment: zY,
  uv_pars_fragment: VY,
  uv_pars_vertex: jY,
  uv_vertex: ZY,
  worldpos_vertex: XY,
  background_vert: $Y,
  background_frag: AH,
  backgroundCube_vert: eH,
  backgroundCube_frag: tH,
  cube_vert: iH,
  cube_frag: nH,
  depth_vert: gH,
  depth_frag: rH,
  distanceRGBA_vert: oH,
  distanceRGBA_frag: sH,
  equirect_vert: aH,
  equirect_frag: IH,
  linedashed_vert: BH,
  linedashed_frag: CH,
  meshbasic_vert: QH,
  meshbasic_frag: EH,
  meshlambert_vert: lH,
  meshlambert_frag: cH,
  meshmatcap_vert: uH,
  meshmatcap_frag: hH,
  meshnormal_vert: dH,
  meshnormal_frag: fH,
  meshphong_vert: pH,
  meshphong_frag: DH,
  meshphysical_vert: wH,
  meshphysical_frag: yH,
  meshtoon_vert: mH,
  meshtoon_frag: SH,
  points_vert: MH,
  points_frag: RH,
  shadow_vert: NH,
  shadow_frag: FH,
  sprite_vert: GH,
  sprite_frag: vH
}, be = {
  common: {
    diffuse: { value: /* @__PURE__ */ new ke(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new kt() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new kt() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new kt() }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new kt() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new kt() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new kt() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new kt() },
    normalScale: { value: /* @__PURE__ */ new ue(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new kt() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new kt() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new kt() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new kt() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new ke(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new ke(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new kt() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new ke(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new ue(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new kt() },
    alphaMap: { value: null },
    alphaTest: { value: 0 }
  }
}, as = {
  basic: {
    uniforms: /* @__PURE__ */ Ar([
      be.common,
      be.specularmap,
      be.envmap,
      be.aomap,
      be.lightmap,
      be.fog
    ]),
    vertexShader: Yt.meshbasic_vert,
    fragmentShader: Yt.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ Ar([
      be.common,
      be.specularmap,
      be.envmap,
      be.aomap,
      be.lightmap,
      be.emissivemap,
      be.bumpmap,
      be.normalmap,
      be.displacementmap,
      be.fog,
      be.lights,
      {
        emissive: { value: /* @__PURE__ */ new ke(0) }
      }
    ]),
    vertexShader: Yt.meshlambert_vert,
    fragmentShader: Yt.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ Ar([
      be.common,
      be.specularmap,
      be.envmap,
      be.aomap,
      be.lightmap,
      be.emissivemap,
      be.bumpmap,
      be.normalmap,
      be.displacementmap,
      be.fog,
      be.lights,
      {
        emissive: { value: /* @__PURE__ */ new ke(0) },
        specular: { value: /* @__PURE__ */ new ke(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Yt.meshphong_vert,
    fragmentShader: Yt.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ Ar([
      be.common,
      be.envmap,
      be.aomap,
      be.lightmap,
      be.emissivemap,
      be.bumpmap,
      be.normalmap,
      be.displacementmap,
      be.roughnessmap,
      be.metalnessmap,
      be.fog,
      be.lights,
      {
        emissive: { value: /* @__PURE__ */ new ke(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: Yt.meshphysical_vert,
    fragmentShader: Yt.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ Ar([
      be.common,
      be.aomap,
      be.lightmap,
      be.emissivemap,
      be.bumpmap,
      be.normalmap,
      be.displacementmap,
      be.gradientmap,
      be.fog,
      be.lights,
      {
        emissive: { value: /* @__PURE__ */ new ke(0) }
      }
    ]),
    vertexShader: Yt.meshtoon_vert,
    fragmentShader: Yt.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ Ar([
      be.common,
      be.bumpmap,
      be.normalmap,
      be.displacementmap,
      be.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Yt.meshmatcap_vert,
    fragmentShader: Yt.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ Ar([
      be.points,
      be.fog
    ]),
    vertexShader: Yt.points_vert,
    fragmentShader: Yt.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ Ar([
      be.common,
      be.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Yt.linedashed_vert,
    fragmentShader: Yt.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ Ar([
      be.common,
      be.displacementmap
    ]),
    vertexShader: Yt.depth_vert,
    fragmentShader: Yt.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ Ar([
      be.common,
      be.bumpmap,
      be.normalmap,
      be.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Yt.meshnormal_vert,
    fragmentShader: Yt.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ Ar([
      be.sprite,
      be.fog
    ]),
    vertexShader: Yt.sprite_vert,
    fragmentShader: Yt.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new kt() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Yt.background_vert,
    fragmentShader: Yt.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Yt.backgroundCube_vert,
    fragmentShader: Yt.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Yt.cube_vert,
    fragmentShader: Yt.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Yt.equirect_vert,
    fragmentShader: Yt.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ Ar([
      be.common,
      be.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new IA() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Yt.distanceRGBA_vert,
    fragmentShader: Yt.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ Ar([
      be.lights,
      be.fog,
      {
        color: { value: /* @__PURE__ */ new ke(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Yt.shadow_vert,
    fragmentShader: Yt.shadow_frag
  }
};
as.physical = {
  uniforms: /* @__PURE__ */ Ar([
    as.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new kt() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new kt() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new ue(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new kt() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new kt() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new kt() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new ke(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new kt() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new kt() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new kt() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new ue() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new kt() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new ke(0) },
      specularColor: { value: /* @__PURE__ */ new ke(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new kt() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new kt() }
    }
  ]),
  vertexShader: Yt.meshphysical_vert,
  fragmentShader: Yt.meshphysical_frag
};
const Ed = { r: 0, b: 0, g: 0 };
function UH(g, A, e, t, i, n, r) {
  const s = new ke(0);
  let B = n === !0 ? 0 : 1, I, E, C = null, c = 0, u = null;
  function d(D, f) {
    let S = !1, y = f.isScene === !0 ? f.background : null;
    y && y.isTexture && (y = (f.backgroundBlurriness > 0 ? e : A).get(y));
    const m = g.xr, N = m.getSession && m.getSession();
    N && N.environmentBlendMode === "additive" && (y = null), y === null ? p(s, B) : y && y.isColor && (p(y, 1), S = !0), (g.autoClear || S) && g.clear(g.autoClearColor, g.autoClearDepth, g.autoClearStencil), y && (y.isCubeTexture || y.mapping === KE) ? (E === void 0 && (E = new Xi(
      new Xa(1, 1, 1),
      new ia({
        name: "BackgroundCubeMaterial",
        uniforms: vE(as.backgroundCube.uniforms),
        vertexShader: as.backgroundCube.vertexShader,
        fragmentShader: as.backgroundCube.fragmentShader,
        side: ir,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), E.geometry.deleteAttribute("normal"), E.geometry.deleteAttribute("uv"), E.onBeforeRender = function(F, G, k) {
      this.matrixWorld.copyPosition(k.matrixWorld);
    }, Object.defineProperty(E.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), i.update(E)), E.material.uniforms.envMap.value = y, E.material.uniforms.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1, E.material.uniforms.backgroundBlurriness.value = f.backgroundBlurriness, E.material.uniforms.backgroundIntensity.value = f.backgroundIntensity, E.material.toneMapped = y.encoding !== Ht, (C !== y || c !== y.version || u !== g.toneMapping) && (E.material.needsUpdate = !0, C = y, c = y.version, u = g.toneMapping), E.layers.enableAll(), D.unshift(E, E.geometry, E.material, 0, 0, null)) : y && y.isTexture && (I === void 0 && (I = new Xi(
      new PC(2, 2),
      new ia({
        name: "BackgroundMaterial",
        uniforms: vE(as.background.uniforms),
        vertexShader: as.background.vertexShader,
        fragmentShader: as.background.fragmentShader,
        side: ea,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), I.geometry.deleteAttribute("normal"), Object.defineProperty(I.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), i.update(I)), I.material.uniforms.t2D.value = y, I.material.uniforms.backgroundIntensity.value = f.backgroundIntensity, I.material.toneMapped = y.encoding !== Ht, y.matrixAutoUpdate === !0 && y.updateMatrix(), I.material.uniforms.uvTransform.value.copy(y.matrix), (C !== y || c !== y.version || u !== g.toneMapping) && (I.material.needsUpdate = !0, C = y, c = y.version, u = g.toneMapping), I.layers.enableAll(), D.unshift(I, I.geometry, I.material, 0, 0, null));
  }
  function p(D, f) {
    D.getRGB(Ed, Nv(g)), t.buffers.color.setClear(Ed.r, Ed.g, Ed.b, f, r);
  }
  return {
    getClearColor: function() {
      return s;
    },
    setClearColor: function(D, f = 1) {
      s.set(D), B = f, p(s, B);
    },
    getClearAlpha: function() {
      return B;
    },
    setClearAlpha: function(D) {
      B = D, p(s, B);
    },
    render: d
  };
}
function kH(g, A, e, t) {
  const i = g.getParameter(34921), n = t.isWebGL2 ? null : A.get("OES_vertex_array_object"), r = t.isWebGL2 || n !== null, s = {}, B = D(null);
  let I = B, E = !1;
  function C(V, iA, eA, oA, P) {
    let J = !1;
    if (r) {
      const tA = p(oA, eA, iA);
      I !== tA && (I = tA, u(I.object)), J = f(V, oA, eA, P), J && S(V, oA, eA, P);
    } else {
      const tA = iA.wireframe === !0;
      (I.geometry !== oA.id || I.program !== eA.id || I.wireframe !== tA) && (I.geometry = oA.id, I.program = eA.id, I.wireframe = tA, J = !0);
    }
    P !== null && e.update(P, 34963), (J || E) && (E = !1, k(V, iA, eA, oA), P !== null && g.bindBuffer(34963, e.get(P).buffer));
  }
  function c() {
    return t.isWebGL2 ? g.createVertexArray() : n.createVertexArrayOES();
  }
  function u(V) {
    return t.isWebGL2 ? g.bindVertexArray(V) : n.bindVertexArrayOES(V);
  }
  function d(V) {
    return t.isWebGL2 ? g.deleteVertexArray(V) : n.deleteVertexArrayOES(V);
  }
  function p(V, iA, eA) {
    const oA = eA.wireframe === !0;
    let P = s[V.id];
    P === void 0 && (P = {}, s[V.id] = P);
    let J = P[iA.id];
    J === void 0 && (J = {}, P[iA.id] = J);
    let tA = J[oA];
    return tA === void 0 && (tA = D(c()), J[oA] = tA), tA;
  }
  function D(V) {
    const iA = [], eA = [], oA = [];
    for (let P = 0; P < i; P++)
      iA[P] = 0, eA[P] = 0, oA[P] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: iA,
      enabledAttributes: eA,
      attributeDivisors: oA,
      object: V,
      attributes: {},
      index: null
    };
  }
  function f(V, iA, eA, oA) {
    const P = I.attributes, J = iA.attributes;
    let tA = 0;
    const Y = eA.getAttributes();
    for (const rA in Y)
      if (Y[rA].location >= 0) {
        const aA = P[rA];
        let MA = J[rA];
        if (MA === void 0 && (rA === "instanceMatrix" && V.instanceMatrix && (MA = V.instanceMatrix), rA === "instanceColor" && V.instanceColor && (MA = V.instanceColor)), aA === void 0 || aA.attribute !== MA || MA && aA.data !== MA.data)
          return !0;
        tA++;
      }
    return I.attributesNum !== tA || I.index !== oA;
  }
  function S(V, iA, eA, oA) {
    const P = {}, J = iA.attributes;
    let tA = 0;
    const Y = eA.getAttributes();
    for (const rA in Y)
      if (Y[rA].location >= 0) {
        let aA = J[rA];
        aA === void 0 && (rA === "instanceMatrix" && V.instanceMatrix && (aA = V.instanceMatrix), rA === "instanceColor" && V.instanceColor && (aA = V.instanceColor));
        const MA = {};
        MA.attribute = aA, aA && aA.data && (MA.data = aA.data), P[rA] = MA, tA++;
      }
    I.attributes = P, I.attributesNum = tA, I.index = oA;
  }
  function y() {
    const V = I.newAttributes;
    for (let iA = 0, eA = V.length; iA < eA; iA++)
      V[iA] = 0;
  }
  function m(V) {
    N(V, 0);
  }
  function N(V, iA) {
    const eA = I.newAttributes, oA = I.enabledAttributes, P = I.attributeDivisors;
    eA[V] = 1, oA[V] === 0 && (g.enableVertexAttribArray(V), oA[V] = 1), P[V] !== iA && ((t.isWebGL2 ? g : A.get("ANGLE_instanced_arrays"))[t.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](V, iA), P[V] = iA);
  }
  function F() {
    const V = I.newAttributes, iA = I.enabledAttributes;
    for (let eA = 0, oA = iA.length; eA < oA; eA++)
      iA[eA] !== V[eA] && (g.disableVertexAttribArray(eA), iA[eA] = 0);
  }
  function G(V, iA, eA, oA, P, J) {
    t.isWebGL2 === !0 && (eA === 5124 || eA === 5125) ? g.vertexAttribIPointer(V, iA, eA, P, J) : g.vertexAttribPointer(V, iA, eA, oA, P, J);
  }
  function k(V, iA, eA, oA) {
    if (t.isWebGL2 === !1 && (V.isInstancedMesh || oA.isInstancedBufferGeometry) && A.get("ANGLE_instanced_arrays") === null)
      return;
    y();
    const P = oA.attributes, J = eA.getAttributes(), tA = iA.defaultAttributeValues;
    for (const Y in J) {
      const rA = J[Y];
      if (rA.location >= 0) {
        let QA = P[Y];
        if (QA === void 0 && (Y === "instanceMatrix" && V.instanceMatrix && (QA = V.instanceMatrix), Y === "instanceColor" && V.instanceColor && (QA = V.instanceColor)), QA !== void 0) {
          const aA = QA.normalized, MA = QA.itemSize, hA = e.get(QA);
          if (hA === void 0)
            continue;
          const fA = hA.buffer, wA = hA.type, yA = hA.bytesPerElement;
          if (QA.isInterleavedBufferAttribute) {
            const kA = QA.data, FA = kA.stride, dA = QA.offset;
            if (kA.isInstancedInterleavedBuffer) {
              for (let vA = 0; vA < rA.locationSize; vA++)
                N(rA.location + vA, kA.meshPerAttribute);
              V.isInstancedMesh !== !0 && oA._maxInstanceCount === void 0 && (oA._maxInstanceCount = kA.meshPerAttribute * kA.count);
            } else
              for (let vA = 0; vA < rA.locationSize; vA++)
                m(rA.location + vA);
            g.bindBuffer(34962, fA);
            for (let vA = 0; vA < rA.locationSize; vA++)
              G(
                rA.location + vA,
                MA / rA.locationSize,
                wA,
                aA,
                FA * yA,
                (dA + MA / rA.locationSize * vA) * yA
              );
          } else {
            if (QA.isInstancedBufferAttribute) {
              for (let kA = 0; kA < rA.locationSize; kA++)
                N(rA.location + kA, QA.meshPerAttribute);
              V.isInstancedMesh !== !0 && oA._maxInstanceCount === void 0 && (oA._maxInstanceCount = QA.meshPerAttribute * QA.count);
            } else
              for (let kA = 0; kA < rA.locationSize; kA++)
                m(rA.location + kA);
            g.bindBuffer(34962, fA);
            for (let kA = 0; kA < rA.locationSize; kA++)
              G(
                rA.location + kA,
                MA / rA.locationSize,
                wA,
                aA,
                MA * yA,
                MA / rA.locationSize * kA * yA
              );
          }
        } else if (tA !== void 0) {
          const aA = tA[Y];
          if (aA !== void 0)
            switch (aA.length) {
              case 2:
                g.vertexAttrib2fv(rA.location, aA);
                break;
              case 3:
                g.vertexAttrib3fv(rA.location, aA);
                break;
              case 4:
                g.vertexAttrib4fv(rA.location, aA);
                break;
              default:
                g.vertexAttrib1fv(rA.location, aA);
            }
        }
      }
    }
    F();
  }
  function v() {
    _();
    for (const V in s) {
      const iA = s[V];
      for (const eA in iA) {
        const oA = iA[eA];
        for (const P in oA)
          d(oA[P].object), delete oA[P];
        delete iA[eA];
      }
      delete s[V];
    }
  }
  function x(V) {
    if (s[V.id] === void 0)
      return;
    const iA = s[V.id];
    for (const eA in iA) {
      const oA = iA[eA];
      for (const P in oA)
        d(oA[P].object), delete oA[P];
      delete iA[eA];
    }
    delete s[V.id];
  }
  function H(V) {
    for (const iA in s) {
      const eA = s[iA];
      if (eA[V.id] === void 0)
        continue;
      const oA = eA[V.id];
      for (const P in oA)
        d(oA[P].object), delete oA[P];
      delete eA[V.id];
    }
  }
  function _() {
    j(), E = !0, I !== B && (I = B, u(I.object));
  }
  function j() {
    B.geometry = null, B.program = null, B.wireframe = !1;
  }
  return {
    setup: C,
    reset: _,
    resetDefaultState: j,
    dispose: v,
    releaseStatesOfGeometry: x,
    releaseStatesOfProgram: H,
    initAttributes: y,
    enableAttribute: m,
    disableUnusedAttributes: F
  };
}
function xH(g, A, e, t) {
  const i = t.isWebGL2;
  let n;
  function r(I) {
    n = I;
  }
  function s(I, E) {
    g.drawArrays(n, I, E), e.update(E, n, 1);
  }
  function B(I, E, C) {
    if (C === 0)
      return;
    let c, u;
    if (i)
      c = g, u = "drawArraysInstanced";
    else if (c = A.get("ANGLE_instanced_arrays"), u = "drawArraysInstancedANGLE", c === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    c[u](n, I, E, C), e.update(E, n, C);
  }
  this.setMode = r, this.render = s, this.renderInstances = B;
}
function LH(g, A, e) {
  let t;
  function i() {
    if (t !== void 0)
      return t;
    if (A.has("EXT_texture_filter_anisotropic") === !0) {
      const G = A.get("EXT_texture_filter_anisotropic");
      t = g.getParameter(G.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      t = 0;
    return t;
  }
  function n(G) {
    if (G === "highp") {
      if (g.getShaderPrecisionFormat(35633, 36338).precision > 0 && g.getShaderPrecisionFormat(35632, 36338).precision > 0)
        return "highp";
      G = "mediump";
    }
    return G === "mediump" && g.getShaderPrecisionFormat(35633, 36337).precision > 0 && g.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const r = typeof WebGL2RenderingContext < "u" && g.constructor.name === "WebGL2RenderingContext";
  let s = e.precision !== void 0 ? e.precision : "highp";
  const B = n(s);
  B !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", B, "instead."), s = B);
  const I = r || A.has("WEBGL_draw_buffers"), E = e.logarithmicDepthBuffer === !0, C = g.getParameter(34930), c = g.getParameter(35660), u = g.getParameter(3379), d = g.getParameter(34076), p = g.getParameter(34921), D = g.getParameter(36347), f = g.getParameter(36348), S = g.getParameter(36349), y = c > 0, m = r || A.has("OES_texture_float"), N = y && m, F = r ? g.getParameter(36183) : 0;
  return {
    isWebGL2: r,
    drawBuffers: I,
    getMaxAnisotropy: i,
    getMaxPrecision: n,
    precision: s,
    logarithmicDepthBuffer: E,
    maxTextures: C,
    maxVertexTextures: c,
    maxTextureSize: u,
    maxCubemapSize: d,
    maxAttributes: p,
    maxVertexUniforms: D,
    maxVaryings: f,
    maxFragmentUniforms: S,
    vertexTextures: y,
    floatFragmentTextures: m,
    floatVertexTextures: N,
    maxSamples: F
  };
}
function TH(g) {
  const A = this;
  let e = null, t = 0, i = !1, n = !1;
  const r = new rB(), s = new kt(), B = { value: null, needsUpdate: !1 };
  this.uniform = B, this.numPlanes = 0, this.numIntersection = 0, this.init = function(C, c) {
    const u = C.length !== 0 || c || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    t !== 0 || i;
    return i = c, t = C.length, u;
  }, this.beginShadows = function() {
    n = !0, E(null);
  }, this.endShadows = function() {
    n = !1;
  }, this.setGlobalState = function(C, c) {
    e = E(C, c, 0);
  }, this.setState = function(C, c, u) {
    const d = C.clippingPlanes, p = C.clipIntersection, D = C.clipShadows, f = g.get(C);
    if (!i || d === null || d.length === 0 || n && !D)
      n ? E(null) : I();
    else {
      const S = n ? 0 : t, y = S * 4;
      let m = f.clippingState || null;
      B.value = m, m = E(d, c, y, u);
      for (let N = 0; N !== y; ++N)
        m[N] = e[N];
      f.clippingState = m, this.numIntersection = p ? this.numPlanes : 0, this.numPlanes += S;
    }
  };
  function I() {
    B.value !== e && (B.value = e, B.needsUpdate = t > 0), A.numPlanes = t, A.numIntersection = 0;
  }
  function E(C, c, u, d) {
    const p = C !== null ? C.length : 0;
    let D = null;
    if (p !== 0) {
      if (D = B.value, d !== !0 || D === null) {
        const f = u + p * 4, S = c.matrixWorldInverse;
        s.getNormalMatrix(S), (D === null || D.length < f) && (D = new Float32Array(f));
        for (let y = 0, m = u; y !== p; ++y, m += 4)
          r.copy(C[y]).applyMatrix4(S, s), r.normal.toArray(D, m), D[m + 3] = r.constant;
      }
      B.value = D, B.needsUpdate = !0;
    }
    return A.numPlanes = p, A.numIntersection = 0, D;
  }
}
function KH(g) {
  let A = /* @__PURE__ */ new WeakMap();
  function e(r, s) {
    return s === RE ? r.mapping = lB : s === xc && (r.mapping = cB), r;
  }
  function t(r) {
    if (r && r.isTexture && r.isRenderTargetTexture === !1) {
      const s = r.mapping;
      if (s === RE || s === xc)
        if (A.has(r)) {
          const B = A.get(r).texture;
          return e(B, r.mapping);
        } else {
          const B = r.image;
          if (B && B.height > 0) {
            const I = new vv(B.height / 2);
            return I.fromEquirectangularTexture(g, r), A.set(r, I), r.addEventListener("dispose", i), e(I.texture, r.mapping);
          } else
            return null;
        }
    }
    return r;
  }
  function i(r) {
    const s = r.target;
    s.removeEventListener("dispose", i);
    const B = A.get(s);
    B !== void 0 && (A.delete(s), B.dispose());
  }
  function n() {
    A = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    dispose: n
  };
}
class $a extends $c {
  constructor(A = -1, e = 1, t = 1, i = -1, n = 0.1, r = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = A, this.right = e, this.top = t, this.bottom = i, this.near = n, this.far = r, this.updateProjectionMatrix();
  }
  copy(A, e) {
    return super.copy(A, e), this.left = A.left, this.right = A.right, this.top = A.top, this.bottom = A.bottom, this.near = A.near, this.far = A.far, this.zoom = A.zoom, this.view = A.view === null ? null : Object.assign({}, A.view), this;
  }
  setViewOffset(A, e, t, i, n, r) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = A, this.view.fullHeight = e, this.view.offsetX = t, this.view.offsetY = i, this.view.width = n, this.view.height = r, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const A = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), t = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
    let n = t - A, r = t + A, s = i + e, B = i - e;
    if (this.view !== null && this.view.enabled) {
      const I = (this.right - this.left) / this.view.fullWidth / this.zoom, E = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      n += I * this.view.offsetX, r = n + I * this.view.width, s -= E * this.view.offsetY, B = s - E * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(n, r, s, B, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(A) {
    const e = super.toJSON(A);
    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
  }
}
const dE = 4, GR = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], pC = 20, l0 = /* @__PURE__ */ new $a(), vR = /* @__PURE__ */ new ke();
let c0 = null;
const dC = (1 + Math.sqrt(5)) / 2, tE = 1 / dC, UR = [
  /* @__PURE__ */ new IA(1, 1, 1),
  /* @__PURE__ */ new IA(-1, 1, 1),
  /* @__PURE__ */ new IA(1, 1, -1),
  /* @__PURE__ */ new IA(-1, 1, -1),
  /* @__PURE__ */ new IA(0, dC, tE),
  /* @__PURE__ */ new IA(0, dC, -tE),
  /* @__PURE__ */ new IA(tE, 0, dC),
  /* @__PURE__ */ new IA(-tE, 0, dC),
  /* @__PURE__ */ new IA(dC, tE, 0),
  /* @__PURE__ */ new IA(-dC, tE, 0)
];
class Hw {
  constructor(A) {
    this._renderer = A, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(A, e = 0, t = 0.1, i = 100) {
    c0 = this._renderer.getRenderTarget(), this._setSize(256);
    const n = this._allocateTargets();
    return n.depthBuffer = !0, this._sceneToCubeUV(A, t, i, n), e > 0 && this._blur(n, 0, 0, e), this._applyPMREM(n), this._cleanup(n), n;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(A, e = null) {
    return this._fromTexture(A, e);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(A, e = null) {
    return this._fromTexture(A, e);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = LR(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = xR(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(A) {
    this._lodMax = Math.floor(Math.log2(A)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let A = 0; A < this._lodPlanes.length; A++)
      this._lodPlanes[A].dispose();
  }
  _cleanup(A) {
    this._renderer.setRenderTarget(c0), A.scissorTest = !1, ld(A, 0, 0, A.width, A.height);
  }
  _fromTexture(A, e) {
    A.mapping === lB || A.mapping === cB ? this._setSize(A.image.length === 0 ? 16 : A.image[0].width || A.image[0].image.width) : this._setSize(A.image.width / 4), c0 = this._renderer.getRenderTarget();
    const t = e || this._allocateTargets();
    return this._textureToCubeUV(A, t), this._applyPMREM(t), this._cleanup(t), t;
  }
  _allocateTargets() {
    const A = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, t = {
      magFilter: Gi,
      minFilter: Gi,
      generateMipmaps: !1,
      type: xC,
      format: tr,
      encoding: ta,
      depthBuffer: !1
    }, i = kR(A, e, t);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== A || this._pingPongRenderTarget.height !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = kR(A, e, t);
      const { _lodMax: n } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = bH(n)), this._blurMaterial = YH(n, A, e);
    }
    return i;
  }
  _compileMaterial(A) {
    const e = new Xi(this._lodPlanes[0], A);
    this._renderer.compile(e, l0);
  }
  _sceneToCubeUV(A, e, t, i) {
    const s = new mn(90, 1, e, t), B = [1, -1, 1, 1, 1, 1], I = [1, 1, 1, -1, -1, -1], E = this._renderer, C = E.autoClear, c = E.toneMapping;
    E.getClearColor(vR), E.toneMapping = Is, E.autoClear = !1;
    const u = new Ao({
      name: "PMREM.Background",
      side: ir,
      depthWrite: !1,
      depthTest: !1
    }), d = new Xi(new Xa(), u);
    let p = !1;
    const D = A.background;
    D ? D.isColor && (u.color.copy(D), A.background = null, p = !0) : (u.color.copy(vR), p = !0);
    for (let f = 0; f < 6; f++) {
      const S = f % 3;
      S === 0 ? (s.up.set(0, B[f], 0), s.lookAt(I[f], 0, 0)) : S === 1 ? (s.up.set(0, 0, B[f]), s.lookAt(0, I[f], 0)) : (s.up.set(0, B[f], 0), s.lookAt(0, 0, I[f]));
      const y = this._cubeSize;
      ld(i, S * y, f > 2 ? y : 0, y, y), E.setRenderTarget(i), p && E.render(d, s), E.render(A, s);
    }
    d.geometry.dispose(), d.material.dispose(), E.toneMapping = c, E.autoClear = C, A.background = D;
  }
  _textureToCubeUV(A, e) {
    const t = this._renderer, i = A.mapping === lB || A.mapping === cB;
    i ? (this._cubemapMaterial === null && (this._cubemapMaterial = LR()), this._cubemapMaterial.uniforms.flipEnvMap.value = A.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = xR());
    const n = i ? this._cubemapMaterial : this._equirectMaterial, r = new Xi(this._lodPlanes[0], n), s = n.uniforms;
    s.envMap.value = A;
    const B = this._cubeSize;
    ld(e, 0, 0, 3 * B, 2 * B), t.setRenderTarget(e), t.render(r, l0);
  }
  _applyPMREM(A) {
    const e = this._renderer, t = e.autoClear;
    e.autoClear = !1;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const n = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]), r = UR[(i - 1) % UR.length];
      this._blur(A, i - 1, i, n, r);
    }
    e.autoClear = t;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(A, e, t, i, n) {
    const r = this._pingPongRenderTarget;
    this._halfBlur(
      A,
      r,
      e,
      t,
      i,
      "latitudinal",
      n
    ), this._halfBlur(
      r,
      A,
      t,
      t,
      i,
      "longitudinal",
      n
    );
  }
  _halfBlur(A, e, t, i, n, r, s) {
    const B = this._renderer, I = this._blurMaterial;
    r !== "latitudinal" && r !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const E = 3, C = new Xi(this._lodPlanes[i], I), c = I.uniforms, u = this._sizeLods[t] - 1, d = isFinite(n) ? Math.PI / (2 * u) : 2 * Math.PI / (2 * pC - 1), p = n / d, D = isFinite(n) ? 1 + Math.floor(E * p) : pC;
    D > pC && console.warn(`sigmaRadians, ${n}, is too large and will clip, as it requested ${D} samples when the maximum is set to ${pC}`);
    const f = [];
    let S = 0;
    for (let G = 0; G < pC; ++G) {
      const k = G / p, v = Math.exp(-k * k / 2);
      f.push(v), G === 0 ? S += v : G < D && (S += 2 * v);
    }
    for (let G = 0; G < f.length; G++)
      f[G] = f[G] / S;
    c.envMap.value = A.texture, c.samples.value = D, c.weights.value = f, c.latitudinal.value = r === "latitudinal", s && (c.poleAxis.value = s);
    const { _lodMax: y } = this;
    c.dTheta.value = d, c.mipInt.value = y - t;
    const m = this._sizeLods[i], N = 3 * m * (i > y - dE ? i - y + dE : 0), F = 4 * (this._cubeSize - m);
    ld(e, N, F, 3 * m, 2 * m), B.setRenderTarget(e), B.render(C, l0);
  }
}
function bH(g) {
  const A = [], e = [], t = [];
  let i = g;
  const n = g - dE + 1 + GR.length;
  for (let r = 0; r < n; r++) {
    const s = Math.pow(2, i);
    e.push(s);
    let B = 1 / s;
    r > g - dE ? B = GR[r - g + dE - 1] : r === 0 && (B = 0), t.push(B);
    const I = 1 / (s - 2), E = -I, C = 1 + I, c = [E, E, C, E, C, C, E, E, C, C, E, C], u = 6, d = 6, p = 3, D = 2, f = 1, S = new Float32Array(p * d * u), y = new Float32Array(D * d * u), m = new Float32Array(f * d * u);
    for (let F = 0; F < u; F++) {
      const G = F % 3 * 2 / 3 - 1, k = F > 2 ? 0 : -1, v = [
        G,
        k,
        0,
        G + 2 / 3,
        k,
        0,
        G + 2 / 3,
        k + 1,
        0,
        G,
        k,
        0,
        G + 2 / 3,
        k + 1,
        0,
        G,
        k + 1,
        0
      ];
      S.set(v, p * d * F), y.set(c, D * d * F);
      const x = [F, F, F, F, F, F];
      m.set(x, f * d * F);
    }
    const N = new ut();
    N.setAttribute("position", new Pt(S, p)), N.setAttribute("uv", new Pt(y, D)), N.setAttribute("faceIndex", new Pt(m, f)), A.push(N), i > dE && i--;
  }
  return { lodPlanes: A, sizeLods: e, sigmas: t };
}
function kR(g, A, e) {
  const t = new Uo(g, A, e);
  return t.texture.mapping = KE, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t;
}
function ld(g, A, e, t, i) {
  g.viewport.set(A, e, t, i), g.scissor.set(A, e, t, i);
}
function YH(g, A, e) {
  const t = new Float32Array(pC), i = new IA(0, 1, 0);
  return new ia({
    name: "SphericalGaussianBlur",
    defines: {
      n: pC,
      CUBEUV_TEXEL_WIDTH: 1 / A,
      CUBEUV_TEXEL_HEIGHT: 1 / e,
      CUBEUV_MAX_MIP: `${g}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: t },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i }
    },
    vertexShader: Ry(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: Wa,
    depthTest: !1,
    depthWrite: !1
  });
}
function xR() {
  return new ia({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: Ry(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: Wa,
    depthTest: !1,
    depthWrite: !1
  });
}
function LR() {
  return new ia({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: Ry(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: Wa,
    depthTest: !1,
    depthWrite: !1
  });
}
function Ry() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function HH(g) {
  let A = /* @__PURE__ */ new WeakMap(), e = null;
  function t(s) {
    if (s && s.isTexture) {
      const B = s.mapping, I = B === RE || B === xc, E = B === lB || B === cB;
      if (I || E)
        if (s.isRenderTargetTexture && s.needsPMREMUpdate === !0) {
          s.needsPMREMUpdate = !1;
          let C = A.get(s);
          return e === null && (e = new Hw(g)), C = I ? e.fromEquirectangular(s, C) : e.fromCubemap(s, C), A.set(s, C), C.texture;
        } else {
          if (A.has(s))
            return A.get(s).texture;
          {
            const C = s.image;
            if (I && C && C.height > 0 || E && C && i(C)) {
              e === null && (e = new Hw(g));
              const c = I ? e.fromEquirectangular(s) : e.fromCubemap(s);
              return A.set(s, c), s.addEventListener("dispose", n), c.texture;
            } else
              return null;
          }
        }
    }
    return s;
  }
  function i(s) {
    let B = 0;
    const I = 6;
    for (let E = 0; E < I; E++)
      s[E] !== void 0 && B++;
    return B === I;
  }
  function n(s) {
    const B = s.target;
    B.removeEventListener("dispose", n);
    const I = A.get(B);
    I !== void 0 && (A.delete(B), I.dispose());
  }
  function r() {
    A = /* @__PURE__ */ new WeakMap(), e !== null && (e.dispose(), e = null);
  }
  return {
    get: t,
    dispose: r
  };
}
function _H(g) {
  const A = {};
  function e(t) {
    if (A[t] !== void 0)
      return A[t];
    let i;
    switch (t) {
      case "WEBGL_depth_texture":
        i = g.getExtension("WEBGL_depth_texture") || g.getExtension("MOZ_WEBGL_depth_texture") || g.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = g.getExtension("EXT_texture_filter_anisotropic") || g.getExtension("MOZ_EXT_texture_filter_anisotropic") || g.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = g.getExtension("WEBGL_compressed_texture_s3tc") || g.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || g.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = g.getExtension("WEBGL_compressed_texture_pvrtc") || g.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = g.getExtension(t);
    }
    return A[t] = i, i;
  }
  return {
    has: function(t) {
      return e(t) !== null;
    },
    init: function(t) {
      t.isWebGL2 ? e("EXT_color_buffer_float") : (e("WEBGL_depth_texture"), e("OES_texture_float"), e("OES_texture_half_float"), e("OES_texture_half_float_linear"), e("OES_standard_derivatives"), e("OES_element_index_uint"), e("OES_vertex_array_object"), e("ANGLE_instanced_arrays")), e("OES_texture_float_linear"), e("EXT_color_buffer_half_float"), e("WEBGL_multisampled_render_to_texture");
    },
    get: function(t) {
      const i = e(t);
      return i === null && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), i;
    }
  };
}
function JH(g, A, e, t) {
  const i = {}, n = /* @__PURE__ */ new WeakMap();
  function r(C) {
    const c = C.target;
    c.index !== null && A.remove(c.index);
    for (const d in c.attributes)
      A.remove(c.attributes[d]);
    c.removeEventListener("dispose", r), delete i[c.id];
    const u = n.get(c);
    u && (A.remove(u), n.delete(c)), t.releaseStatesOfGeometry(c), c.isInstancedBufferGeometry === !0 && delete c._maxInstanceCount, e.memory.geometries--;
  }
  function s(C, c) {
    return i[c.id] === !0 || (c.addEventListener("dispose", r), i[c.id] = !0, e.memory.geometries++), c;
  }
  function B(C) {
    const c = C.attributes;
    for (const d in c)
      A.update(c[d], 34962);
    const u = C.morphAttributes;
    for (const d in u) {
      const p = u[d];
      for (let D = 0, f = p.length; D < f; D++)
        A.update(p[D], 34962);
    }
  }
  function I(C) {
    const c = [], u = C.index, d = C.attributes.position;
    let p = 0;
    if (u !== null) {
      const S = u.array;
      p = u.version;
      for (let y = 0, m = S.length; y < m; y += 3) {
        const N = S[y + 0], F = S[y + 1], G = S[y + 2];
        c.push(N, F, F, G, G, N);
      }
    } else {
      const S = d.array;
      p = d.version;
      for (let y = 0, m = S.length / 3 - 1; y < m; y += 3) {
        const N = y + 0, F = y + 1, G = y + 2;
        c.push(N, F, F, G, G, N);
      }
    }
    const D = new (Mv(c) ? My : Nf)(c, 1);
    D.version = p;
    const f = n.get(C);
    f && A.remove(f), n.set(C, D);
  }
  function E(C) {
    const c = n.get(C);
    if (c) {
      const u = C.index;
      u !== null && c.version < u.version && I(C);
    } else
      I(C);
    return n.get(C);
  }
  return {
    get: s,
    update: B,
    getWireframeAttribute: E
  };
}
function OH(g, A, e, t) {
  const i = t.isWebGL2;
  let n;
  function r(c) {
    n = c;
  }
  let s, B;
  function I(c) {
    s = c.type, B = c.bytesPerElement;
  }
  function E(c, u) {
    g.drawElements(n, u, s, c * B), e.update(u, n, 1);
  }
  function C(c, u, d) {
    if (d === 0)
      return;
    let p, D;
    if (i)
      p = g, D = "drawElementsInstanced";
    else if (p = A.get("ANGLE_instanced_arrays"), D = "drawElementsInstancedANGLE", p === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    p[D](n, u, s, c * B, d), e.update(u, n, d);
  }
  this.setMode = r, this.setIndex = I, this.render = E, this.renderInstances = C;
}
function qH(g) {
  const A = {
    geometries: 0,
    textures: 0
  }, e = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function t(n, r, s) {
    switch (e.calls++, r) {
      case 4:
        e.triangles += s * (n / 3);
        break;
      case 1:
        e.lines += s * (n / 2);
        break;
      case 3:
        e.lines += s * (n - 1);
        break;
      case 2:
        e.lines += s * n;
        break;
      case 0:
        e.points += s * n;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", r);
        break;
    }
  }
  function i() {
    e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
  }
  return {
    memory: A,
    render: e,
    programs: null,
    autoReset: !0,
    reset: i,
    update: t
  };
}
function PH(g, A) {
  return g[0] - A[0];
}
function WH(g, A) {
  return Math.abs(A[1]) - Math.abs(g[1]);
}
function zH(g, A, e) {
  const t = {}, i = new Float32Array(8), n = /* @__PURE__ */ new WeakMap(), r = new Bi(), s = [];
  for (let I = 0; I < 8; I++)
    s[I] = [I, 0];
  function B(I, E, C) {
    const c = I.morphTargetInfluences;
    if (A.isWebGL2 === !0) {
      const u = E.morphAttributes.position || E.morphAttributes.normal || E.morphAttributes.color, d = u !== void 0 ? u.length : 0;
      let p = n.get(E);
      if (p === void 0 || p.count !== d) {
        let V = function() {
          _.dispose(), n.delete(E), E.removeEventListener("dispose", V);
        };
        p !== void 0 && p.texture.dispose();
        const S = E.morphAttributes.position !== void 0, y = E.morphAttributes.normal !== void 0, m = E.morphAttributes.color !== void 0, N = E.morphAttributes.position || [], F = E.morphAttributes.normal || [], G = E.morphAttributes.color || [];
        let k = 0;
        S === !0 && (k = 1), y === !0 && (k = 2), m === !0 && (k = 3);
        let v = E.attributes.position.count * k, x = 1;
        v > A.maxTextureSize && (x = Math.ceil(v / A.maxTextureSize), v = A.maxTextureSize);
        const H = new Float32Array(v * x * 4 * d), _ = new Rf(H, v, x, d);
        _.type = $s, _.needsUpdate = !0;
        const j = k * 4;
        for (let iA = 0; iA < d; iA++) {
          const eA = N[iA], oA = F[iA], P = G[iA], J = v * x * 4 * iA;
          for (let tA = 0; tA < eA.count; tA++) {
            const Y = tA * j;
            S === !0 && (r.fromBufferAttribute(eA, tA), H[J + Y + 0] = r.x, H[J + Y + 1] = r.y, H[J + Y + 2] = r.z, H[J + Y + 3] = 0), y === !0 && (r.fromBufferAttribute(oA, tA), H[J + Y + 4] = r.x, H[J + Y + 5] = r.y, H[J + Y + 6] = r.z, H[J + Y + 7] = 0), m === !0 && (r.fromBufferAttribute(P, tA), H[J + Y + 8] = r.x, H[J + Y + 9] = r.y, H[J + Y + 10] = r.z, H[J + Y + 11] = P.itemSize === 4 ? r.w : 1);
          }
        }
        p = {
          count: d,
          texture: _,
          size: new ue(v, x)
        }, n.set(E, p), E.addEventListener("dispose", V);
      }
      let D = 0;
      for (let S = 0; S < c.length; S++)
        D += c[S];
      const f = E.morphTargetsRelative ? 1 : 1 - D;
      C.getUniforms().setValue(g, "morphTargetBaseInfluence", f), C.getUniforms().setValue(g, "morphTargetInfluences", c), C.getUniforms().setValue(g, "morphTargetsTexture", p.texture, e), C.getUniforms().setValue(g, "morphTargetsTextureSize", p.size);
    } else {
      const u = c === void 0 ? 0 : c.length;
      let d = t[E.id];
      if (d === void 0 || d.length !== u) {
        d = [];
        for (let y = 0; y < u; y++)
          d[y] = [y, 0];
        t[E.id] = d;
      }
      for (let y = 0; y < u; y++) {
        const m = d[y];
        m[0] = y, m[1] = c[y];
      }
      d.sort(WH);
      for (let y = 0; y < 8; y++)
        y < u && d[y][1] ? (s[y][0] = d[y][0], s[y][1] = d[y][1]) : (s[y][0] = Number.MAX_SAFE_INTEGER, s[y][1] = 0);
      s.sort(PH);
      const p = E.morphAttributes.position, D = E.morphAttributes.normal;
      let f = 0;
      for (let y = 0; y < 8; y++) {
        const m = s[y], N = m[0], F = m[1];
        N !== Number.MAX_SAFE_INTEGER && F ? (p && E.getAttribute("morphTarget" + y) !== p[N] && E.setAttribute("morphTarget" + y, p[N]), D && E.getAttribute("morphNormal" + y) !== D[N] && E.setAttribute("morphNormal" + y, D[N]), i[y] = F, f += F) : (p && E.hasAttribute("morphTarget" + y) === !0 && E.deleteAttribute("morphTarget" + y), D && E.hasAttribute("morphNormal" + y) === !0 && E.deleteAttribute("morphNormal" + y), i[y] = 0);
      }
      const S = E.morphTargetsRelative ? 1 : 1 - f;
      C.getUniforms().setValue(g, "morphTargetBaseInfluence", S), C.getUniforms().setValue(g, "morphTargetInfluences", i);
    }
  }
  return {
    update: B
  };
}
function VH(g, A, e, t) {
  let i = /* @__PURE__ */ new WeakMap();
  function n(B) {
    const I = t.render.frame, E = B.geometry, C = A.get(B, E);
    return i.get(C) !== I && (A.update(C), i.set(C, I)), B.isInstancedMesh && (B.hasEventListener("dispose", s) === !1 && B.addEventListener("dispose", s), e.update(B.instanceMatrix, 34962), B.instanceColor !== null && e.update(B.instanceColor, 34962)), C;
  }
  function r() {
    i = /* @__PURE__ */ new WeakMap();
  }
  function s(B) {
    const I = B.target;
    I.removeEventListener("dispose", s), e.remove(I.instanceMatrix), I.instanceColor !== null && e.remove(I.instanceColor);
  }
  return {
    update: n,
    dispose: r
  };
}
const kv = /* @__PURE__ */ new xi(), xv = /* @__PURE__ */ new Rf(), Lv = /* @__PURE__ */ new Sy(), Tv = /* @__PURE__ */ new Au(), TR = [], KR = [], bR = new Float32Array(16), YR = new Float32Array(9), HR = new Float32Array(4);
function bE(g, A, e) {
  const t = g[0];
  if (t <= 0 || t > 0)
    return g;
  const i = A * e;
  let n = TR[i];
  if (n === void 0 && (n = new Float32Array(i), TR[i] = n), A !== 0) {
    t.toArray(n, 0);
    for (let r = 1, s = 0; r !== A; ++r)
      s += e, g[r].toArray(n, s);
  }
  return n;
}
function Ag(g, A) {
  if (g.length !== A.length)
    return !1;
  for (let e = 0, t = g.length; e < t; e++)
    if (g[e] !== A[e])
      return !1;
  return !0;
}
function eg(g, A) {
  for (let e = 0, t = A.length; e < t; e++)
    g[e] = A[e];
}
function Gf(g, A) {
  let e = KR[A];
  e === void 0 && (e = new Int32Array(A), KR[A] = e);
  for (let t = 0; t !== A; ++t)
    e[t] = g.allocateTextureUnit();
  return e;
}
function jH(g, A) {
  const e = this.cache;
  e[0] !== A && (g.uniform1f(this.addr, A), e[0] = A);
}
function ZH(g, A) {
  const e = this.cache;
  if (A.x !== void 0)
    (e[0] !== A.x || e[1] !== A.y) && (g.uniform2f(this.addr, A.x, A.y), e[0] = A.x, e[1] = A.y);
  else {
    if (Ag(e, A))
      return;
    g.uniform2fv(this.addr, A), eg(e, A);
  }
}
function XH(g, A) {
  const e = this.cache;
  if (A.x !== void 0)
    (e[0] !== A.x || e[1] !== A.y || e[2] !== A.z) && (g.uniform3f(this.addr, A.x, A.y, A.z), e[0] = A.x, e[1] = A.y, e[2] = A.z);
  else if (A.r !== void 0)
    (e[0] !== A.r || e[1] !== A.g || e[2] !== A.b) && (g.uniform3f(this.addr, A.r, A.g, A.b), e[0] = A.r, e[1] = A.g, e[2] = A.b);
  else {
    if (Ag(e, A))
      return;
    g.uniform3fv(this.addr, A), eg(e, A);
  }
}
function $H(g, A) {
  const e = this.cache;
  if (A.x !== void 0)
    (e[0] !== A.x || e[1] !== A.y || e[2] !== A.z || e[3] !== A.w) && (g.uniform4f(this.addr, A.x, A.y, A.z, A.w), e[0] = A.x, e[1] = A.y, e[2] = A.z, e[3] = A.w);
  else {
    if (Ag(e, A))
      return;
    g.uniform4fv(this.addr, A), eg(e, A);
  }
}
function A_(g, A) {
  const e = this.cache, t = A.elements;
  if (t === void 0) {
    if (Ag(e, A))
      return;
    g.uniformMatrix2fv(this.addr, !1, A), eg(e, A);
  } else {
    if (Ag(e, t))
      return;
    HR.set(t), g.uniformMatrix2fv(this.addr, !1, HR), eg(e, t);
  }
}
function e_(g, A) {
  const e = this.cache, t = A.elements;
  if (t === void 0) {
    if (Ag(e, A))
      return;
    g.uniformMatrix3fv(this.addr, !1, A), eg(e, A);
  } else {
    if (Ag(e, t))
      return;
    YR.set(t), g.uniformMatrix3fv(this.addr, !1, YR), eg(e, t);
  }
}
function t_(g, A) {
  const e = this.cache, t = A.elements;
  if (t === void 0) {
    if (Ag(e, A))
      return;
    g.uniformMatrix4fv(this.addr, !1, A), eg(e, A);
  } else {
    if (Ag(e, t))
      return;
    bR.set(t), g.uniformMatrix4fv(this.addr, !1, bR), eg(e, t);
  }
}
function i_(g, A) {
  const e = this.cache;
  e[0] !== A && (g.uniform1i(this.addr, A), e[0] = A);
}
function n_(g, A) {
  const e = this.cache;
  if (A.x !== void 0)
    (e[0] !== A.x || e[1] !== A.y) && (g.uniform2i(this.addr, A.x, A.y), e[0] = A.x, e[1] = A.y);
  else {
    if (Ag(e, A))
      return;
    g.uniform2iv(this.addr, A), eg(e, A);
  }
}
function g_(g, A) {
  const e = this.cache;
  if (A.x !== void 0)
    (e[0] !== A.x || e[1] !== A.y || e[2] !== A.z) && (g.uniform3i(this.addr, A.x, A.y, A.z), e[0] = A.x, e[1] = A.y, e[2] = A.z);
  else {
    if (Ag(e, A))
      return;
    g.uniform3iv(this.addr, A), eg(e, A);
  }
}
function r_(g, A) {
  const e = this.cache;
  if (A.x !== void 0)
    (e[0] !== A.x || e[1] !== A.y || e[2] !== A.z || e[3] !== A.w) && (g.uniform4i(this.addr, A.x, A.y, A.z, A.w), e[0] = A.x, e[1] = A.y, e[2] = A.z, e[3] = A.w);
  else {
    if (Ag(e, A))
      return;
    g.uniform4iv(this.addr, A), eg(e, A);
  }
}
function o_(g, A) {
  const e = this.cache;
  e[0] !== A && (g.uniform1ui(this.addr, A), e[0] = A);
}
function s_(g, A) {
  const e = this.cache;
  if (A.x !== void 0)
    (e[0] !== A.x || e[1] !== A.y) && (g.uniform2ui(this.addr, A.x, A.y), e[0] = A.x, e[1] = A.y);
  else {
    if (Ag(e, A))
      return;
    g.uniform2uiv(this.addr, A), eg(e, A);
  }
}
function a_(g, A) {
  const e = this.cache;
  if (A.x !== void 0)
    (e[0] !== A.x || e[1] !== A.y || e[2] !== A.z) && (g.uniform3ui(this.addr, A.x, A.y, A.z), e[0] = A.x, e[1] = A.y, e[2] = A.z);
  else {
    if (Ag(e, A))
      return;
    g.uniform3uiv(this.addr, A), eg(e, A);
  }
}
function I_(g, A) {
  const e = this.cache;
  if (A.x !== void 0)
    (e[0] !== A.x || e[1] !== A.y || e[2] !== A.z || e[3] !== A.w) && (g.uniform4ui(this.addr, A.x, A.y, A.z, A.w), e[0] = A.x, e[1] = A.y, e[2] = A.z, e[3] = A.w);
  else {
    if (Ag(e, A))
      return;
    g.uniform4uiv(this.addr, A), eg(e, A);
  }
}
function B_(g, A, e) {
  const t = this.cache, i = e.allocateTextureUnit();
  t[0] !== i && (g.uniform1i(this.addr, i), t[0] = i), e.setTexture2D(A || kv, i);
}
function C_(g, A, e) {
  const t = this.cache, i = e.allocateTextureUnit();
  t[0] !== i && (g.uniform1i(this.addr, i), t[0] = i), e.setTexture3D(A || Lv, i);
}
function Q_(g, A, e) {
  const t = this.cache, i = e.allocateTextureUnit();
  t[0] !== i && (g.uniform1i(this.addr, i), t[0] = i), e.setTextureCube(A || Tv, i);
}
function E_(g, A, e) {
  const t = this.cache, i = e.allocateTextureUnit();
  t[0] !== i && (g.uniform1i(this.addr, i), t[0] = i), e.setTexture2DArray(A || xv, i);
}
function l_(g) {
  switch (g) {
    case 5126:
      return jH;
    case 35664:
      return ZH;
    case 35665:
      return XH;
    case 35666:
      return $H;
    case 35674:
      return A_;
    case 35675:
      return e_;
    case 35676:
      return t_;
    case 5124:
    case 35670:
      return i_;
    case 35667:
    case 35671:
      return n_;
    case 35668:
    case 35672:
      return g_;
    case 35669:
    case 35673:
      return r_;
    case 5125:
      return o_;
    case 36294:
      return s_;
    case 36295:
      return a_;
    case 36296:
      return I_;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return B_;
    case 35679:
    case 36299:
    case 36307:
      return C_;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Q_;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return E_;
  }
}
function c_(g, A) {
  g.uniform1fv(this.addr, A);
}
function u_(g, A) {
  const e = bE(A, this.size, 2);
  g.uniform2fv(this.addr, e);
}
function h_(g, A) {
  const e = bE(A, this.size, 3);
  g.uniform3fv(this.addr, e);
}
function d_(g, A) {
  const e = bE(A, this.size, 4);
  g.uniform4fv(this.addr, e);
}
function f_(g, A) {
  const e = bE(A, this.size, 4);
  g.uniformMatrix2fv(this.addr, !1, e);
}
function p_(g, A) {
  const e = bE(A, this.size, 9);
  g.uniformMatrix3fv(this.addr, !1, e);
}
function D_(g, A) {
  const e = bE(A, this.size, 16);
  g.uniformMatrix4fv(this.addr, !1, e);
}
function w_(g, A) {
  g.uniform1iv(this.addr, A);
}
function y_(g, A) {
  g.uniform2iv(this.addr, A);
}
function m_(g, A) {
  g.uniform3iv(this.addr, A);
}
function S_(g, A) {
  g.uniform4iv(this.addr, A);
}
function M_(g, A) {
  g.uniform1uiv(this.addr, A);
}
function R_(g, A) {
  g.uniform2uiv(this.addr, A);
}
function N_(g, A) {
  g.uniform3uiv(this.addr, A);
}
function F_(g, A) {
  g.uniform4uiv(this.addr, A);
}
function G_(g, A, e) {
  const t = this.cache, i = A.length, n = Gf(e, i);
  Ag(t, n) || (g.uniform1iv(this.addr, n), eg(t, n));
  for (let r = 0; r !== i; ++r)
    e.setTexture2D(A[r] || kv, n[r]);
}
function v_(g, A, e) {
  const t = this.cache, i = A.length, n = Gf(e, i);
  Ag(t, n) || (g.uniform1iv(this.addr, n), eg(t, n));
  for (let r = 0; r !== i; ++r)
    e.setTexture3D(A[r] || Lv, n[r]);
}
function U_(g, A, e) {
  const t = this.cache, i = A.length, n = Gf(e, i);
  Ag(t, n) || (g.uniform1iv(this.addr, n), eg(t, n));
  for (let r = 0; r !== i; ++r)
    e.setTextureCube(A[r] || Tv, n[r]);
}
function k_(g, A, e) {
  const t = this.cache, i = A.length, n = Gf(e, i);
  Ag(t, n) || (g.uniform1iv(this.addr, n), eg(t, n));
  for (let r = 0; r !== i; ++r)
    e.setTexture2DArray(A[r] || xv, n[r]);
}
function x_(g) {
  switch (g) {
    case 5126:
      return c_;
    case 35664:
      return u_;
    case 35665:
      return h_;
    case 35666:
      return d_;
    case 35674:
      return f_;
    case 35675:
      return p_;
    case 35676:
      return D_;
    case 5124:
    case 35670:
      return w_;
    case 35667:
    case 35671:
      return y_;
    case 35668:
    case 35672:
      return m_;
    case 35669:
    case 35673:
      return S_;
    case 5125:
      return M_;
    case 36294:
      return R_;
    case 36295:
      return N_;
    case 36296:
      return F_;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return G_;
    case 35679:
    case 36299:
    case 36307:
      return v_;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return U_;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return k_;
  }
}
class L_ {
  constructor(A, e, t) {
    this.id = A, this.addr = t, this.cache = [], this.setValue = l_(e.type);
  }
}
class T_ {
  constructor(A, e, t) {
    this.id = A, this.addr = t, this.cache = [], this.size = e.size, this.setValue = x_(e.type);
  }
}
class K_ {
  constructor(A) {
    this.id = A, this.seq = [], this.map = {};
  }
  setValue(A, e, t) {
    const i = this.seq;
    for (let n = 0, r = i.length; n !== r; ++n) {
      const s = i[n];
      s.setValue(A, e[s.id], t);
    }
  }
}
const u0 = /(\w+)(\])?(\[|\.)?/g;
function _R(g, A) {
  g.seq.push(A), g.map[A.id] = A;
}
function b_(g, A, e) {
  const t = g.name, i = t.length;
  for (u0.lastIndex = 0; ; ) {
    const n = u0.exec(t), r = u0.lastIndex;
    let s = n[1];
    const B = n[2] === "]", I = n[3];
    if (B && (s = s | 0), I === void 0 || I === "[" && r + 2 === i) {
      _R(e, I === void 0 ? new L_(s, g, A) : new T_(s, g, A));
      break;
    } else {
      let C = e.map[s];
      C === void 0 && (C = new K_(s), _R(e, C)), e = C;
    }
  }
}
class gf {
  constructor(A, e) {
    this.seq = [], this.map = {};
    const t = A.getProgramParameter(e, 35718);
    for (let i = 0; i < t; ++i) {
      const n = A.getActiveUniform(e, i), r = A.getUniformLocation(e, n.name);
      b_(n, r, this);
    }
  }
  setValue(A, e, t, i) {
    const n = this.map[e];
    n !== void 0 && n.setValue(A, t, i);
  }
  setOptional(A, e, t) {
    const i = e[t];
    i !== void 0 && this.setValue(A, t, i);
  }
  static upload(A, e, t, i) {
    for (let n = 0, r = e.length; n !== r; ++n) {
      const s = e[n], B = t[s.id];
      B.needsUpdate !== !1 && s.setValue(A, B.value, i);
    }
  }
  static seqWithValue(A, e) {
    const t = [];
    for (let i = 0, n = A.length; i !== n; ++i) {
      const r = A[i];
      r.id in e && t.push(r);
    }
    return t;
  }
}
function JR(g, A, e) {
  const t = g.createShader(A);
  return g.shaderSource(t, e), g.compileShader(t), t;
}
let Y_ = 0;
function H_(g, A) {
  const e = g.split(`
`), t = [], i = Math.max(A - 6, 0), n = Math.min(A + 6, e.length);
  for (let r = i; r < n; r++) {
    const s = r + 1;
    t.push(`${s === A ? ">" : " "} ${s}: ${e[r]}`);
  }
  return t.join(`
`);
}
function __(g) {
  switch (g) {
    case ta:
      return ["Linear", "( value )"];
    case Ht:
      return ["sRGB", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", g), ["Linear", "( value )"];
  }
}
function OR(g, A, e) {
  const t = g.getShaderParameter(A, 35713), i = g.getShaderInfoLog(A).trim();
  if (t && i === "")
    return "";
  const n = /ERROR: 0:(\d+)/.exec(i);
  if (n) {
    const r = parseInt(n[1]);
    return e.toUpperCase() + `

` + i + `

` + H_(g.getShaderSource(A), r);
  } else
    return i;
}
function J_(g, A) {
  const e = __(A);
  return "vec4 " + g + "( vec4 value ) { return LinearTo" + e[0] + e[1] + "; }";
}
function O_(g, A) {
  let e;
  switch (A) {
    case XG:
      e = "Linear";
      break;
    case $G:
      e = "Reinhard";
      break;
    case Av:
      e = "OptimizedCineon";
      break;
    case dy:
      e = "ACESFilmic";
      break;
    case ev:
      e = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", A), e = "Linear";
  }
  return "vec3 " + g + "( vec3 color ) { return " + e + "ToneMapping( color ); }";
}
function q_(g) {
  return [
    g.extensionDerivatives || g.envMapCubeUVHeight || g.bumpMap || g.normalMapTangentSpace || g.clearcoatNormalMap || g.flatShading || g.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (g.extensionFragDepth || g.logarithmicDepthBuffer) && g.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    g.extensionDrawBuffers && g.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (g.extensionShaderTextureLOD || g.envMap || g.transmission) && g.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(yc).join(`
`);
}
function P_(g) {
  const A = [];
  for (const e in g) {
    const t = g[e];
    t !== !1 && A.push("#define " + e + " " + t);
  }
  return A.join(`
`);
}
function W_(g, A) {
  const e = {}, t = g.getProgramParameter(A, 35721);
  for (let i = 0; i < t; i++) {
    const n = g.getActiveAttrib(A, i), r = n.name;
    let s = 1;
    n.type === 35674 && (s = 2), n.type === 35675 && (s = 3), n.type === 35676 && (s = 4), e[r] = {
      type: n.type,
      location: g.getAttribLocation(A, r),
      locationSize: s
    };
  }
  return e;
}
function yc(g) {
  return g !== "";
}
function qR(g, A) {
  const e = A.numSpotLightShadows + A.numSpotLightMaps - A.numSpotLightShadowsWithMaps;
  return g.replace(/NUM_DIR_LIGHTS/g, A.numDirLights).replace(/NUM_SPOT_LIGHTS/g, A.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, A.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, e).replace(/NUM_RECT_AREA_LIGHTS/g, A.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, A.numPointLights).replace(/NUM_HEMI_LIGHTS/g, A.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, A.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, A.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, A.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, A.numPointLightShadows);
}
function PR(g, A) {
  return g.replace(/NUM_CLIPPING_PLANES/g, A.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, A.numClippingPlanes - A.numClipIntersection);
}
const z_ = /^[ \t]*#include +<([\w\d./]+)>/gm;
function _w(g) {
  return g.replace(z_, V_);
}
function V_(g, A) {
  const e = Yt[A];
  if (e === void 0)
    throw new Error("Can not resolve #include <" + A + ">");
  return _w(e);
}
const j_ = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function WR(g) {
  return g.replace(j_, Z_);
}
function Z_(g, A, e, t) {
  let i = "";
  for (let n = parseInt(A); n < parseInt(e); n++)
    i += t.replace(/\[\s*i\s*\]/g, "[ " + n + " ]").replace(/UNROLLED_LOOP_INDEX/g, n);
  return i;
}
function zR(g) {
  let A = "precision " + g.precision + ` float;
precision ` + g.precision + " int;";
  return g.precision === "highp" ? A += `
#define HIGH_PRECISION` : g.precision === "mediump" ? A += `
#define MEDIUM_PRECISION` : g.precision === "lowp" && (A += `
#define LOW_PRECISION`), A;
}
function X_(g) {
  let A = "SHADOWMAP_TYPE_BASIC";
  return g.shadowMapType === mf ? A = "SHADOWMAP_TYPE_PCF" : g.shadowMapType === Sc ? A = "SHADOWMAP_TYPE_PCF_SOFT" : g.shadowMapType === DC && (A = "SHADOWMAP_TYPE_VSM"), A;
}
function $_(g) {
  let A = "ENVMAP_TYPE_CUBE";
  if (g.envMap)
    switch (g.envMapMode) {
      case lB:
      case cB:
        A = "ENVMAP_TYPE_CUBE";
        break;
      case KE:
        A = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return A;
}
function AJ(g) {
  let A = "ENVMAP_MODE_REFLECTION";
  if (g.envMap)
    switch (g.envMapMode) {
      case cB:
        A = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return A;
}
function eJ(g) {
  let A = "ENVMAP_BLENDING_NONE";
  if (g.envMap)
    switch (g.combine) {
      case jc:
        A = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case jG:
        A = "ENVMAP_BLENDING_MIX";
        break;
      case ZG:
        A = "ENVMAP_BLENDING_ADD";
        break;
    }
  return A;
}
function tJ(g) {
  const A = g.envMapCubeUVHeight;
  if (A === null)
    return null;
  const e = Math.log2(A) - 2, t = 1 / A;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)), texelHeight: t, maxMip: e };
}
function iJ(g, A, e, t) {
  const i = g.getContext(), n = e.defines;
  let r = e.vertexShader, s = e.fragmentShader;
  const B = X_(e), I = $_(e), E = AJ(e), C = eJ(e), c = tJ(e), u = e.isWebGL2 ? "" : q_(e), d = P_(n), p = i.createProgram();
  let D, f, S = e.glslVersion ? "#version " + e.glslVersion + `
` : "";
  e.isRawShaderMaterial ? (D = [
    d
  ].filter(yc).join(`
`), D.length > 0 && (D += `
`), f = [
    u,
    d
  ].filter(yc).join(`
`), f.length > 0 && (f += `
`)) : (D = [
    zR(e),
    "#define SHADER_NAME " + e.shaderName,
    d,
    e.instancing ? "#define USE_INSTANCING" : "",
    e.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    e.useFog && e.fog ? "#define USE_FOG" : "",
    e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
    e.map ? "#define USE_MAP" : "",
    e.envMap ? "#define USE_ENVMAP" : "",
    e.envMap ? "#define " + E : "",
    e.lightMap ? "#define USE_LIGHTMAP" : "",
    e.aoMap ? "#define USE_AOMAP" : "",
    e.bumpMap ? "#define USE_BUMPMAP" : "",
    e.normalMap ? "#define USE_NORMALMAP" : "",
    e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    e.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    e.specularMap ? "#define USE_SPECULARMAP" : "",
    e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    e.metalnessMap ? "#define USE_METALNESSMAP" : "",
    e.alphaMap ? "#define USE_ALPHAMAP" : "",
    e.transmission ? "#define USE_TRANSMISSION" : "",
    e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    e.mapUv ? "#define MAP_UV " + e.mapUv : "",
    e.alphaMapUv ? "#define ALPHAMAP_UV " + e.alphaMapUv : "",
    e.lightMapUv ? "#define LIGHTMAP_UV " + e.lightMapUv : "",
    e.aoMapUv ? "#define AOMAP_UV " + e.aoMapUv : "",
    e.emissiveMapUv ? "#define EMISSIVEMAP_UV " + e.emissiveMapUv : "",
    e.bumpMapUv ? "#define BUMPMAP_UV " + e.bumpMapUv : "",
    e.normalMapUv ? "#define NORMALMAP_UV " + e.normalMapUv : "",
    e.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + e.displacementMapUv : "",
    e.metalnessMapUv ? "#define METALNESSMAP_UV " + e.metalnessMapUv : "",
    e.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + e.roughnessMapUv : "",
    e.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + e.clearcoatMapUv : "",
    e.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + e.clearcoatNormalMapUv : "",
    e.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + e.clearcoatRoughnessMapUv : "",
    e.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + e.iridescenceMapUv : "",
    e.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + e.iridescenceThicknessMapUv : "",
    e.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + e.sheenColorMapUv : "",
    e.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + e.sheenRoughnessMapUv : "",
    e.specularMapUv ? "#define SPECULARMAP_UV " + e.specularMapUv : "",
    e.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + e.specularColorMapUv : "",
    e.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + e.specularIntensityMapUv : "",
    e.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + e.transmissionMapUv : "",
    e.thicknessMapUv ? "#define THICKNESSMAP_UV " + e.thicknessMapUv : "",
    //
    e.vertexTangents ? "#define USE_TANGENT" : "",
    e.vertexColors ? "#define USE_COLOR" : "",
    e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    e.vertexUvs2 ? "#define USE_UV2" : "",
    e.pointsUvs ? "#define USE_POINTS_UV" : "",
    e.flatShading ? "#define FLAT_SHADED" : "",
    e.skinning ? "#define USE_SKINNING" : "",
    e.morphTargets ? "#define USE_MORPHTARGETS" : "",
    e.morphNormals && e.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    e.morphColors && e.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + e.morphTextureStride : "",
    e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount : "",
    e.doubleSided ? "#define DOUBLE_SIDED" : "",
    e.flipSided ? "#define FLIP_SIDED" : "",
    e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    e.shadowMapEnabled ? "#define " + B : "",
    e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    e.logarithmicDepthBuffer && e.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(yc).join(`
`), f = [
    u,
    zR(e),
    "#define SHADER_NAME " + e.shaderName,
    d,
    e.useFog && e.fog ? "#define USE_FOG" : "",
    e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
    e.map ? "#define USE_MAP" : "",
    e.matcap ? "#define USE_MATCAP" : "",
    e.envMap ? "#define USE_ENVMAP" : "",
    e.envMap ? "#define " + I : "",
    e.envMap ? "#define " + E : "",
    e.envMap ? "#define " + C : "",
    c ? "#define CUBEUV_TEXEL_WIDTH " + c.texelWidth : "",
    c ? "#define CUBEUV_TEXEL_HEIGHT " + c.texelHeight : "",
    c ? "#define CUBEUV_MAX_MIP " + c.maxMip + ".0" : "",
    e.lightMap ? "#define USE_LIGHTMAP" : "",
    e.aoMap ? "#define USE_AOMAP" : "",
    e.bumpMap ? "#define USE_BUMPMAP" : "",
    e.normalMap ? "#define USE_NORMALMAP" : "",
    e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    e.clearcoat ? "#define USE_CLEARCOAT" : "",
    e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    e.iridescence ? "#define USE_IRIDESCENCE" : "",
    e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    e.specularMap ? "#define USE_SPECULARMAP" : "",
    e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    e.metalnessMap ? "#define USE_METALNESSMAP" : "",
    e.alphaMap ? "#define USE_ALPHAMAP" : "",
    e.alphaTest ? "#define USE_ALPHATEST" : "",
    e.sheen ? "#define USE_SHEEN" : "",
    e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    e.transmission ? "#define USE_TRANSMISSION" : "",
    e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    e.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    e.vertexTangents ? "#define USE_TANGENT" : "",
    e.vertexColors || e.instancingColor ? "#define USE_COLOR" : "",
    e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    e.vertexUvs2 ? "#define USE_UV2" : "",
    e.pointsUvs ? "#define USE_POINTS_UV" : "",
    e.gradientMap ? "#define USE_GRADIENTMAP" : "",
    e.flatShading ? "#define FLAT_SHADED" : "",
    e.doubleSided ? "#define DOUBLE_SIDED" : "",
    e.flipSided ? "#define FLIP_SIDED" : "",
    e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    e.shadowMapEnabled ? "#define " + B : "",
    e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    e.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    e.logarithmicDepthBuffer && e.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    e.toneMapping !== Is ? "#define TONE_MAPPING" : "",
    e.toneMapping !== Is ? Yt.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    e.toneMapping !== Is ? O_("toneMapping", e.toneMapping) : "",
    e.dithering ? "#define DITHERING" : "",
    e.opaque ? "#define OPAQUE" : "",
    Yt.encodings_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    J_("linearToOutputTexel", e.outputEncoding),
    e.useDepthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "",
    `
`
  ].filter(yc).join(`
`)), r = _w(r), r = qR(r, e), r = PR(r, e), s = _w(s), s = qR(s, e), s = PR(s, e), r = WR(r), s = WR(s), e.isWebGL2 && e.isRawShaderMaterial !== !0 && (S = `#version 300 es
`, D = [
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + D, f = [
    "#define varying in",
    e.glslVersion === bw ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    e.glslVersion === bw ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + f);
  const y = S + D + r, m = S + f + s, N = JR(i, 35633, y), F = JR(i, 35632, m);
  if (i.attachShader(p, N), i.attachShader(p, F), e.index0AttributeName !== void 0 ? i.bindAttribLocation(p, 0, e.index0AttributeName) : e.morphTargets === !0 && i.bindAttribLocation(p, 0, "position"), i.linkProgram(p), g.debug.checkShaderErrors) {
    const v = i.getProgramInfoLog(p).trim(), x = i.getShaderInfoLog(N).trim(), H = i.getShaderInfoLog(F).trim();
    let _ = !0, j = !0;
    if (i.getProgramParameter(p, 35714) === !1)
      if (_ = !1, typeof g.debug.onShaderError == "function")
        g.debug.onShaderError(i, p, N, F);
      else {
        const V = OR(i, N, "vertex"), iA = OR(i, F, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(p, 35715) + `

Program Info Log: ` + v + `
` + V + `
` + iA
        );
      }
    else
      v !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", v) : (x === "" || H === "") && (j = !1);
    j && (this.diagnostics = {
      runnable: _,
      programLog: v,
      vertexShader: {
        log: x,
        prefix: D
      },
      fragmentShader: {
        log: H,
        prefix: f
      }
    });
  }
  i.deleteShader(N), i.deleteShader(F);
  let G;
  this.getUniforms = function() {
    return G === void 0 && (G = new gf(i, p)), G;
  };
  let k;
  return this.getAttributes = function() {
    return k === void 0 && (k = W_(i, p)), k;
  }, this.destroy = function() {
    t.releaseStatesOfProgram(this), i.deleteProgram(p), this.program = void 0;
  }, this.name = e.shaderName, this.id = Y_++, this.cacheKey = A, this.usedTimes = 1, this.program = p, this.vertexShader = N, this.fragmentShader = F, this;
}
let nJ = 0;
class gJ {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(A) {
    const e = A.vertexShader, t = A.fragmentShader, i = this._getShaderStage(e), n = this._getShaderStage(t), r = this._getShaderCacheForMaterial(A);
    return r.has(i) === !1 && (r.add(i), i.usedTimes++), r.has(n) === !1 && (r.add(n), n.usedTimes++), this;
  }
  remove(A) {
    const e = this.materialCache.get(A);
    for (const t of e)
      t.usedTimes--, t.usedTimes === 0 && this.shaderCache.delete(t.code);
    return this.materialCache.delete(A), this;
  }
  getVertexShaderID(A) {
    return this._getShaderStage(A.vertexShader).id;
  }
  getFragmentShaderID(A) {
    return this._getShaderStage(A.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(A) {
    const e = this.materialCache;
    let t = e.get(A);
    return t === void 0 && (t = /* @__PURE__ */ new Set(), e.set(A, t)), t;
  }
  _getShaderStage(A) {
    const e = this.shaderCache;
    let t = e.get(A);
    return t === void 0 && (t = new rJ(A), e.set(A, t)), t;
  }
}
class rJ {
  constructor(A) {
    this.id = nJ++, this.code = A, this.usedTimes = 0;
  }
}
function oJ(g, A, e, t, i, n, r) {
  const s = new GC(), B = new gJ(), I = [], E = i.isWebGL2, C = i.logarithmicDepthBuffer, c = i.vertexTextures;
  let u = i.precision;
  const d = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function p(v) {
    return v === 1 ? "uv2" : "uv";
  }
  function D(v, x, H, _, j) {
    const V = _.fog, iA = j.geometry, eA = v.isMeshStandardMaterial ? _.environment : null, oA = (v.isMeshStandardMaterial ? e : A).get(v.envMap || eA), P = oA && oA.mapping === KE ? oA.image.height : null, J = d[v.type];
    v.precision !== null && (u = i.getMaxPrecision(v.precision), u !== v.precision && console.warn("THREE.WebGLProgram.getParameters:", v.precision, "not supported, using", u, "instead."));
    const tA = iA.morphAttributes.position || iA.morphAttributes.normal || iA.morphAttributes.color, Y = tA !== void 0 ? tA.length : 0;
    let rA = 0;
    iA.morphAttributes.position !== void 0 && (rA = 1), iA.morphAttributes.normal !== void 0 && (rA = 2), iA.morphAttributes.color !== void 0 && (rA = 3);
    let QA, aA, MA, hA;
    if (J) {
      const TA = as[J];
      QA = TA.vertexShader, aA = TA.fragmentShader;
    } else
      QA = v.vertexShader, aA = v.fragmentShader, B.update(v), MA = B.getVertexShaderID(v), hA = B.getFragmentShaderID(v);
    const fA = g.getRenderTarget(), wA = j.isInstancedMesh === !0, yA = !!v.map, kA = !!v.matcap, FA = !!oA, dA = !!v.aoMap, vA = !!v.lightMap, JA = !!v.bumpMap, ne = !!v.normalMap, ee = !!v.displacementMap, pe = !!v.emissiveMap, Ae = !!v.metalnessMap, ie = !!v.roughnessMap, de = v.clearcoat > 0, O = v.iridescence > 0, AA = v.sheen > 0, q = v.transmission > 0, Z = de && !!v.clearcoatMap, $ = de && !!v.clearcoatNormalMap, BA = de && !!v.clearcoatRoughnessMap, GA = O && !!v.iridescenceMap, bA = O && !!v.iridescenceThicknessMap, DA = AA && !!v.sheenColorMap, SA = AA && !!v.sheenRoughnessMap, EA = !!v.specularMap, mA = !!v.specularColorMap, YA = !!v.specularIntensityMap, ZA = q && !!v.transmissionMap, _A = q && !!v.thicknessMap, Se = !!v.gradientMap, cA = !!v.alphaMap, xA = v.alphaTest > 0, gA = !!v.extensions, RA = !!iA.attributes.uv2;
    return {
      isWebGL2: E,
      shaderID: J,
      shaderName: v.type,
      vertexShader: QA,
      fragmentShader: aA,
      defines: v.defines,
      customVertexShaderID: MA,
      customFragmentShaderID: hA,
      isRawShaderMaterial: v.isRawShaderMaterial === !0,
      glslVersion: v.glslVersion,
      precision: u,
      instancing: wA,
      instancingColor: wA && j.instanceColor !== null,
      supportsVertexTextures: c,
      outputEncoding: fA === null ? g.outputEncoding : fA.isXRRenderTarget === !0 ? fA.texture.encoding : ta,
      map: yA,
      matcap: kA,
      envMap: FA,
      envMapMode: FA && oA.mapping,
      envMapCubeUVHeight: P,
      aoMap: dA,
      lightMap: vA,
      bumpMap: JA,
      normalMap: ne,
      displacementMap: c && ee,
      emissiveMap: pe,
      normalMapObjectSpace: ne && v.normalMapType === wv,
      normalMapTangentSpace: ne && v.normalMapType === fB,
      decodeVideoTexture: yA && v.map.isVideoTexture === !0 && v.map.encoding === Ht,
      metalnessMap: Ae,
      roughnessMap: ie,
      clearcoat: de,
      clearcoatMap: Z,
      clearcoatNormalMap: $,
      clearcoatRoughnessMap: BA,
      iridescence: O,
      iridescenceMap: GA,
      iridescenceThicknessMap: bA,
      sheen: AA,
      sheenColorMap: DA,
      sheenRoughnessMap: SA,
      specularMap: EA,
      specularColorMap: mA,
      specularIntensityMap: YA,
      transmission: q,
      transmissionMap: ZA,
      thicknessMap: _A,
      gradientMap: Se,
      opaque: v.transparent === !1 && v.blending === MC,
      alphaMap: cA,
      alphaTest: xA,
      combine: v.combine,
      //
      mapUv: yA && p(v.map.channel),
      aoMapUv: dA && p(v.aoMap.channel),
      lightMapUv: vA && p(v.lightMap.channel),
      bumpMapUv: JA && p(v.bumpMap.channel),
      normalMapUv: ne && p(v.normalMap.channel),
      displacementMapUv: ee && p(v.displacementMap.channel),
      emissiveMapUv: pe && p(v.emissiveMap.channel),
      metalnessMapUv: Ae && p(v.metalnessMap.channel),
      roughnessMapUv: ie && p(v.roughnessMap.channel),
      clearcoatMapUv: Z && p(v.clearcoatMap.channel),
      clearcoatNormalMapUv: $ && p(v.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: BA && p(v.clearcoatRoughnessMap.channel),
      iridescenceMapUv: GA && p(v.iridescenceMap.channel),
      iridescenceThicknessMapUv: bA && p(v.iridescenceThicknessMap.channel),
      sheenColorMapUv: DA && p(v.sheenColorMap.channel),
      sheenRoughnessMapUv: SA && p(v.sheenRoughnessMap.channel),
      specularMapUv: EA && p(v.specularMap.channel),
      specularColorMapUv: mA && p(v.specularColorMap.channel),
      specularIntensityMapUv: YA && p(v.specularIntensityMap.channel),
      transmissionMapUv: ZA && p(v.transmissionMap.channel),
      thicknessMapUv: _A && p(v.thicknessMap.channel),
      alphaMapUv: cA && p(v.alphaMap.channel),
      //
      vertexTangents: ne && !!iA.attributes.tangent,
      vertexColors: v.vertexColors,
      vertexAlphas: v.vertexColors === !0 && !!iA.attributes.color && iA.attributes.color.itemSize === 4,
      vertexUvs2: RA,
      pointsUvs: j.isPoints === !0 && !!iA.attributes.uv && (yA || cA),
      fog: !!V,
      useFog: v.fog === !0,
      fogExp2: V && V.isFogExp2,
      flatShading: v.flatShading === !0,
      sizeAttenuation: v.sizeAttenuation === !0,
      logarithmicDepthBuffer: C,
      skinning: j.isSkinnedMesh === !0,
      morphTargets: iA.morphAttributes.position !== void 0,
      morphNormals: iA.morphAttributes.normal !== void 0,
      morphColors: iA.morphAttributes.color !== void 0,
      morphTargetsCount: Y,
      morphTextureStride: rA,
      numDirLights: x.directional.length,
      numPointLights: x.point.length,
      numSpotLights: x.spot.length,
      numSpotLightMaps: x.spotLightMap.length,
      numRectAreaLights: x.rectArea.length,
      numHemiLights: x.hemi.length,
      numDirLightShadows: x.directionalShadowMap.length,
      numPointLightShadows: x.pointShadowMap.length,
      numSpotLightShadows: x.spotShadowMap.length,
      numSpotLightShadowsWithMaps: x.numSpotLightShadowsWithMaps,
      numClippingPlanes: r.numPlanes,
      numClipIntersection: r.numIntersection,
      dithering: v.dithering,
      shadowMapEnabled: g.shadowMap.enabled && H.length > 0,
      shadowMapType: g.shadowMap.type,
      toneMapping: v.toneMapped ? g.toneMapping : Is,
      useLegacyLights: g.useLegacyLights,
      premultipliedAlpha: v.premultipliedAlpha,
      doubleSided: v.side === Rr,
      flipSided: v.side === ir,
      useDepthPacking: v.depthPacking >= 0,
      depthPacking: v.depthPacking || 0,
      index0AttributeName: v.index0AttributeName,
      extensionDerivatives: gA && v.extensions.derivatives === !0,
      extensionFragDepth: gA && v.extensions.fragDepth === !0,
      extensionDrawBuffers: gA && v.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: gA && v.extensions.shaderTextureLOD === !0,
      rendererExtensionFragDepth: E || t.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: E || t.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: E || t.has("EXT_shader_texture_lod"),
      customProgramCacheKey: v.customProgramCacheKey()
    };
  }
  function f(v) {
    const x = [];
    if (v.shaderID ? x.push(v.shaderID) : (x.push(v.customVertexShaderID), x.push(v.customFragmentShaderID)), v.defines !== void 0)
      for (const H in v.defines)
        x.push(H), x.push(v.defines[H]);
    return v.isRawShaderMaterial === !1 && (S(x, v), y(x, v), x.push(g.outputEncoding)), x.push(v.customProgramCacheKey), x.join();
  }
  function S(v, x) {
    v.push(x.precision), v.push(x.outputEncoding), v.push(x.envMapMode), v.push(x.envMapCubeUVHeight), v.push(x.mapUv), v.push(x.alphaMapUv), v.push(x.lightMapUv), v.push(x.aoMapUv), v.push(x.bumpMapUv), v.push(x.normalMapUv), v.push(x.displacementMapUv), v.push(x.emissiveMapUv), v.push(x.metalnessMapUv), v.push(x.roughnessMapUv), v.push(x.clearcoatMapUv), v.push(x.clearcoatNormalMapUv), v.push(x.clearcoatRoughnessMapUv), v.push(x.iridescenceMapUv), v.push(x.iridescenceThicknessMapUv), v.push(x.sheenColorMapUv), v.push(x.sheenRoughnessMapUv), v.push(x.specularMapUv), v.push(x.specularColorMapUv), v.push(x.specularIntensityMapUv), v.push(x.transmissionMapUv), v.push(x.thicknessMapUv), v.push(x.combine), v.push(x.fogExp2), v.push(x.sizeAttenuation), v.push(x.morphTargetsCount), v.push(x.morphAttributeCount), v.push(x.numDirLights), v.push(x.numPointLights), v.push(x.numSpotLights), v.push(x.numSpotLightMaps), v.push(x.numHemiLights), v.push(x.numRectAreaLights), v.push(x.numDirLightShadows), v.push(x.numPointLightShadows), v.push(x.numSpotLightShadows), v.push(x.numSpotLightShadowsWithMaps), v.push(x.shadowMapType), v.push(x.toneMapping), v.push(x.numClippingPlanes), v.push(x.numClipIntersection), v.push(x.depthPacking);
  }
  function y(v, x) {
    s.disableAll(), x.isWebGL2 && s.enable(0), x.supportsVertexTextures && s.enable(1), x.instancing && s.enable(2), x.instancingColor && s.enable(3), x.matcap && s.enable(4), x.envMap && s.enable(5), x.normalMapObjectSpace && s.enable(6), x.normalMapTangentSpace && s.enable(7), x.clearcoat && s.enable(8), x.iridescence && s.enable(9), x.alphaTest && s.enable(10), x.vertexColors && s.enable(11), x.vertexAlphas && s.enable(12), x.vertexUvs2 && s.enable(13), x.vertexTangents && s.enable(14), v.push(s.mask), s.disableAll(), x.fog && s.enable(0), x.useFog && s.enable(1), x.flatShading && s.enable(2), x.logarithmicDepthBuffer && s.enable(3), x.skinning && s.enable(4), x.morphTargets && s.enable(5), x.morphNormals && s.enable(6), x.morphColors && s.enable(7), x.premultipliedAlpha && s.enable(8), x.shadowMapEnabled && s.enable(9), x.useLegacyLights && s.enable(10), x.doubleSided && s.enable(11), x.flipSided && s.enable(12), x.useDepthPacking && s.enable(13), x.dithering && s.enable(14), x.transmission && s.enable(15), x.sheen && s.enable(16), x.decodeVideoTexture && s.enable(17), x.opaque && s.enable(18), x.pointsUvs && s.enable(19), v.push(s.mask);
  }
  function m(v) {
    const x = d[v.type];
    let H;
    if (x) {
      const _ = as[x];
      H = Fv.clone(_.uniforms);
    } else
      H = v.uniforms;
    return H;
  }
  function N(v, x) {
    let H;
    for (let _ = 0, j = I.length; _ < j; _++) {
      const V = I[_];
      if (V.cacheKey === x) {
        H = V, ++H.usedTimes;
        break;
      }
    }
    return H === void 0 && (H = new iJ(g, x, v, n), I.push(H)), H;
  }
  function F(v) {
    if (--v.usedTimes === 0) {
      const x = I.indexOf(v);
      I[x] = I[I.length - 1], I.pop(), v.destroy();
    }
  }
  function G(v) {
    B.remove(v);
  }
  function k() {
    B.dispose();
  }
  return {
    getParameters: D,
    getProgramCacheKey: f,
    getUniforms: m,
    acquireProgram: N,
    releaseProgram: F,
    releaseShaderCache: G,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: I,
    dispose: k
  };
}
function sJ() {
  let g = /* @__PURE__ */ new WeakMap();
  function A(n) {
    let r = g.get(n);
    return r === void 0 && (r = {}, g.set(n, r)), r;
  }
  function e(n) {
    g.delete(n);
  }
  function t(n, r, s) {
    g.get(n)[r] = s;
  }
  function i() {
    g = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: A,
    remove: e,
    update: t,
    dispose: i
  };
}
function aJ(g, A) {
  return g.groupOrder !== A.groupOrder ? g.groupOrder - A.groupOrder : g.renderOrder !== A.renderOrder ? g.renderOrder - A.renderOrder : g.material.id !== A.material.id ? g.material.id - A.material.id : g.z !== A.z ? g.z - A.z : g.id - A.id;
}
function VR(g, A) {
  return g.groupOrder !== A.groupOrder ? g.groupOrder - A.groupOrder : g.renderOrder !== A.renderOrder ? g.renderOrder - A.renderOrder : g.z !== A.z ? A.z - g.z : g.id - A.id;
}
function jR() {
  const g = [];
  let A = 0;
  const e = [], t = [], i = [];
  function n() {
    A = 0, e.length = 0, t.length = 0, i.length = 0;
  }
  function r(C, c, u, d, p, D) {
    let f = g[A];
    return f === void 0 ? (f = {
      id: C.id,
      object: C,
      geometry: c,
      material: u,
      groupOrder: d,
      renderOrder: C.renderOrder,
      z: p,
      group: D
    }, g[A] = f) : (f.id = C.id, f.object = C, f.geometry = c, f.material = u, f.groupOrder = d, f.renderOrder = C.renderOrder, f.z = p, f.group = D), A++, f;
  }
  function s(C, c, u, d, p, D) {
    const f = r(C, c, u, d, p, D);
    u.transmission > 0 ? t.push(f) : u.transparent === !0 ? i.push(f) : e.push(f);
  }
  function B(C, c, u, d, p, D) {
    const f = r(C, c, u, d, p, D);
    u.transmission > 0 ? t.unshift(f) : u.transparent === !0 ? i.unshift(f) : e.unshift(f);
  }
  function I(C, c) {
    e.length > 1 && e.sort(C || aJ), t.length > 1 && t.sort(c || VR), i.length > 1 && i.sort(c || VR);
  }
  function E() {
    for (let C = A, c = g.length; C < c; C++) {
      const u = g[C];
      if (u.id === null)
        break;
      u.id = null, u.object = null, u.geometry = null, u.material = null, u.group = null;
    }
  }
  return {
    opaque: e,
    transmissive: t,
    transparent: i,
    init: n,
    push: s,
    unshift: B,
    finish: E,
    sort: I
  };
}
function IJ() {
  let g = /* @__PURE__ */ new WeakMap();
  function A(t, i) {
    const n = g.get(t);
    let r;
    return n === void 0 ? (r = new jR(), g.set(t, [r])) : i >= n.length ? (r = new jR(), n.push(r)) : r = n[i], r;
  }
  function e() {
    g = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: A,
    dispose: e
  };
}
function BJ() {
  const g = {};
  return {
    get: function(A) {
      if (g[A.id] !== void 0)
        return g[A.id];
      let e;
      switch (A.type) {
        case "DirectionalLight":
          e = {
            direction: new IA(),
            color: new ke()
          };
          break;
        case "SpotLight":
          e = {
            position: new IA(),
            direction: new IA(),
            color: new ke(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          e = {
            position: new IA(),
            color: new ke(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          e = {
            direction: new IA(),
            skyColor: new ke(),
            groundColor: new ke()
          };
          break;
        case "RectAreaLight":
          e = {
            color: new ke(),
            position: new IA(),
            halfWidth: new IA(),
            halfHeight: new IA()
          };
          break;
      }
      return g[A.id] = e, e;
    }
  };
}
function CJ() {
  const g = {};
  return {
    get: function(A) {
      if (g[A.id] !== void 0)
        return g[A.id];
      let e;
      switch (A.type) {
        case "DirectionalLight":
          e = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ue()
          };
          break;
        case "SpotLight":
          e = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ue()
          };
          break;
        case "PointLight":
          e = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ue(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return g[A.id] = e, e;
    }
  };
}
let QJ = 0;
function EJ(g, A) {
  return (A.castShadow ? 2 : 0) - (g.castShadow ? 2 : 0) + (A.map ? 1 : 0) - (g.map ? 1 : 0);
}
function lJ(g, A) {
  const e = new BJ(), t = CJ(), i = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0
  };
  for (let E = 0; E < 9; E++)
    i.probe.push(new IA());
  const n = new IA(), r = new Ve(), s = new Ve();
  function B(E, C) {
    let c = 0, u = 0, d = 0;
    for (let H = 0; H < 9; H++)
      i.probe[H].set(0, 0, 0);
    let p = 0, D = 0, f = 0, S = 0, y = 0, m = 0, N = 0, F = 0, G = 0, k = 0;
    E.sort(EJ);
    const v = C === !0 ? Math.PI : 1;
    for (let H = 0, _ = E.length; H < _; H++) {
      const j = E[H], V = j.color, iA = j.intensity, eA = j.distance, oA = j.shadow && j.shadow.map ? j.shadow.map.texture : null;
      if (j.isAmbientLight)
        c += V.r * iA * v, u += V.g * iA * v, d += V.b * iA * v;
      else if (j.isLightProbe)
        for (let P = 0; P < 9; P++)
          i.probe[P].addScaledVector(j.sh.coefficients[P], iA);
      else if (j.isDirectionalLight) {
        const P = e.get(j);
        if (P.color.copy(j.color).multiplyScalar(j.intensity * v), j.castShadow) {
          const J = j.shadow, tA = t.get(j);
          tA.shadowBias = J.bias, tA.shadowNormalBias = J.normalBias, tA.shadowRadius = J.radius, tA.shadowMapSize = J.mapSize, i.directionalShadow[p] = tA, i.directionalShadowMap[p] = oA, i.directionalShadowMatrix[p] = j.shadow.matrix, m++;
        }
        i.directional[p] = P, p++;
      } else if (j.isSpotLight) {
        const P = e.get(j);
        P.position.setFromMatrixPosition(j.matrixWorld), P.color.copy(V).multiplyScalar(iA * v), P.distance = eA, P.coneCos = Math.cos(j.angle), P.penumbraCos = Math.cos(j.angle * (1 - j.penumbra)), P.decay = j.decay, i.spot[f] = P;
        const J = j.shadow;
        if (j.map && (i.spotLightMap[G] = j.map, G++, J.updateMatrices(j), j.castShadow && k++), i.spotLightMatrix[f] = J.matrix, j.castShadow) {
          const tA = t.get(j);
          tA.shadowBias = J.bias, tA.shadowNormalBias = J.normalBias, tA.shadowRadius = J.radius, tA.shadowMapSize = J.mapSize, i.spotShadow[f] = tA, i.spotShadowMap[f] = oA, F++;
        }
        f++;
      } else if (j.isRectAreaLight) {
        const P = e.get(j);
        P.color.copy(V).multiplyScalar(iA), P.halfWidth.set(j.width * 0.5, 0, 0), P.halfHeight.set(0, j.height * 0.5, 0), i.rectArea[S] = P, S++;
      } else if (j.isPointLight) {
        const P = e.get(j);
        if (P.color.copy(j.color).multiplyScalar(j.intensity * v), P.distance = j.distance, P.decay = j.decay, j.castShadow) {
          const J = j.shadow, tA = t.get(j);
          tA.shadowBias = J.bias, tA.shadowNormalBias = J.normalBias, tA.shadowRadius = J.radius, tA.shadowMapSize = J.mapSize, tA.shadowCameraNear = J.camera.near, tA.shadowCameraFar = J.camera.far, i.pointShadow[D] = tA, i.pointShadowMap[D] = oA, i.pointShadowMatrix[D] = j.shadow.matrix, N++;
        }
        i.point[D] = P, D++;
      } else if (j.isHemisphereLight) {
        const P = e.get(j);
        P.skyColor.copy(j.color).multiplyScalar(iA * v), P.groundColor.copy(j.groundColor).multiplyScalar(iA * v), i.hemi[y] = P, y++;
      }
    }
    S > 0 && (A.isWebGL2 || g.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = be.LTC_FLOAT_1, i.rectAreaLTC2 = be.LTC_FLOAT_2) : g.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = be.LTC_HALF_1, i.rectAreaLTC2 = be.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = c, i.ambient[1] = u, i.ambient[2] = d;
    const x = i.hash;
    (x.directionalLength !== p || x.pointLength !== D || x.spotLength !== f || x.rectAreaLength !== S || x.hemiLength !== y || x.numDirectionalShadows !== m || x.numPointShadows !== N || x.numSpotShadows !== F || x.numSpotMaps !== G) && (i.directional.length = p, i.spot.length = f, i.rectArea.length = S, i.point.length = D, i.hemi.length = y, i.directionalShadow.length = m, i.directionalShadowMap.length = m, i.pointShadow.length = N, i.pointShadowMap.length = N, i.spotShadow.length = F, i.spotShadowMap.length = F, i.directionalShadowMatrix.length = m, i.pointShadowMatrix.length = N, i.spotLightMatrix.length = F + G - k, i.spotLightMap.length = G, i.numSpotLightShadowsWithMaps = k, x.directionalLength = p, x.pointLength = D, x.spotLength = f, x.rectAreaLength = S, x.hemiLength = y, x.numDirectionalShadows = m, x.numPointShadows = N, x.numSpotShadows = F, x.numSpotMaps = G, i.version = QJ++);
  }
  function I(E, C) {
    let c = 0, u = 0, d = 0, p = 0, D = 0;
    const f = C.matrixWorldInverse;
    for (let S = 0, y = E.length; S < y; S++) {
      const m = E[S];
      if (m.isDirectionalLight) {
        const N = i.directional[c];
        N.direction.setFromMatrixPosition(m.matrixWorld), n.setFromMatrixPosition(m.target.matrixWorld), N.direction.sub(n), N.direction.transformDirection(f), c++;
      } else if (m.isSpotLight) {
        const N = i.spot[d];
        N.position.setFromMatrixPosition(m.matrixWorld), N.position.applyMatrix4(f), N.direction.setFromMatrixPosition(m.matrixWorld), n.setFromMatrixPosition(m.target.matrixWorld), N.direction.sub(n), N.direction.transformDirection(f), d++;
      } else if (m.isRectAreaLight) {
        const N = i.rectArea[p];
        N.position.setFromMatrixPosition(m.matrixWorld), N.position.applyMatrix4(f), s.identity(), r.copy(m.matrixWorld), r.premultiply(f), s.extractRotation(r), N.halfWidth.set(m.width * 0.5, 0, 0), N.halfHeight.set(0, m.height * 0.5, 0), N.halfWidth.applyMatrix4(s), N.halfHeight.applyMatrix4(s), p++;
      } else if (m.isPointLight) {
        const N = i.point[u];
        N.position.setFromMatrixPosition(m.matrixWorld), N.position.applyMatrix4(f), u++;
      } else if (m.isHemisphereLight) {
        const N = i.hemi[D];
        N.direction.setFromMatrixPosition(m.matrixWorld), N.direction.transformDirection(f), D++;
      }
    }
  }
  return {
    setup: B,
    setupView: I,
    state: i
  };
}
function ZR(g, A) {
  const e = new lJ(g, A), t = [], i = [];
  function n() {
    t.length = 0, i.length = 0;
  }
  function r(C) {
    t.push(C);
  }
  function s(C) {
    i.push(C);
  }
  function B(C) {
    e.setup(t, C);
  }
  function I(C) {
    e.setupView(t, C);
  }
  return {
    init: n,
    state: {
      lightsArray: t,
      shadowsArray: i,
      lights: e
    },
    setupLights: B,
    setupLightsView: I,
    pushLight: r,
    pushShadow: s
  };
}
function cJ(g, A) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(n, r = 0) {
    const s = e.get(n);
    let B;
    return s === void 0 ? (B = new ZR(g, A), e.set(n, [B])) : r >= s.length ? (B = new ZR(g, A), s.push(B)) : B = s[r], B;
  }
  function i() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    dispose: i
  };
}
class Ny extends Sn {
  constructor(A) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = pv, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(A);
  }
  copy(A) {
    return super.copy(A), this.depthPacking = A.depthPacking, this.map = A.map, this.alphaMap = A.alphaMap, this.displacementMap = A.displacementMap, this.displacementScale = A.displacementScale, this.displacementBias = A.displacementBias, this.wireframe = A.wireframe, this.wireframeLinewidth = A.wireframeLinewidth, this;
  }
}
class Fy extends Sn {
  constructor(A) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(A);
  }
  copy(A) {
    return super.copy(A), this.map = A.map, this.alphaMap = A.alphaMap, this.displacementMap = A.displacementMap, this.displacementScale = A.displacementScale, this.displacementBias = A.displacementBias, this;
  }
}
const uJ = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, hJ = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function dJ(g, A, e) {
  let t = new Ff();
  const i = new ue(), n = new ue(), r = new Bi(), s = new Ny({ depthPacking: Dv }), B = new Fy(), I = {}, E = e.maxTextureSize, C = { [ea]: ir, [ir]: ea, [Rr]: Rr }, c = new ia({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new ue() },
      radius: { value: 4 }
    },
    vertexShader: uJ,
    fragmentShader: hJ
  }), u = c.clone();
  u.defines.HORIZONTAL_PASS = 1;
  const d = new ut();
  d.setAttribute(
    "position",
    new Pt(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const p = new Xi(d, c), D = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = mf, this.render = function(m, N, F) {
    if (D.enabled === !1 || D.autoUpdate === !1 && D.needsUpdate === !1 || m.length === 0)
      return;
    const G = g.getRenderTarget(), k = g.getActiveCubeFace(), v = g.getActiveMipmapLevel(), x = g.state;
    x.setBlending(Wa), x.buffers.color.setClear(1, 1, 1, 1), x.buffers.depth.setTest(!0), x.setScissorTest(!1);
    for (let H = 0, _ = m.length; H < _; H++) {
      const j = m[H], V = j.shadow;
      if (V === void 0) {
        console.warn("THREE.WebGLShadowMap:", j, "has no shadow.");
        continue;
      }
      if (V.autoUpdate === !1 && V.needsUpdate === !1)
        continue;
      i.copy(V.mapSize);
      const iA = V.getFrameExtents();
      if (i.multiply(iA), n.copy(V.mapSize), (i.x > E || i.y > E) && (i.x > E && (n.x = Math.floor(E / iA.x), i.x = n.x * iA.x, V.mapSize.x = n.x), i.y > E && (n.y = Math.floor(E / iA.y), i.y = n.y * iA.y, V.mapSize.y = n.y)), V.map === null) {
        const oA = this.type !== DC ? { minFilter: un, magFilter: un } : {};
        V.map = new Uo(i.x, i.y, oA), V.map.texture.name = j.name + ".shadowMap", V.camera.updateProjectionMatrix();
      }
      g.setRenderTarget(V.map), g.clear();
      const eA = V.getViewportCount();
      for (let oA = 0; oA < eA; oA++) {
        const P = V.getViewport(oA);
        r.set(
          n.x * P.x,
          n.y * P.y,
          n.x * P.z,
          n.y * P.w
        ), x.viewport(r), V.updateMatrices(j, oA), t = V.getFrustum(), y(N, F, V.camera, j, this.type);
      }
      V.isPointLightShadow !== !0 && this.type === DC && f(V, F), V.needsUpdate = !1;
    }
    D.needsUpdate = !1, g.setRenderTarget(G, k, v);
  };
  function f(m, N) {
    const F = A.update(p);
    c.defines.VSM_SAMPLES !== m.blurSamples && (c.defines.VSM_SAMPLES = m.blurSamples, u.defines.VSM_SAMPLES = m.blurSamples, c.needsUpdate = !0, u.needsUpdate = !0), m.mapPass === null && (m.mapPass = new Uo(i.x, i.y)), c.uniforms.shadow_pass.value = m.map.texture, c.uniforms.resolution.value = m.mapSize, c.uniforms.radius.value = m.radius, g.setRenderTarget(m.mapPass), g.clear(), g.renderBufferDirect(N, null, F, c, p, null), u.uniforms.shadow_pass.value = m.mapPass.texture, u.uniforms.resolution.value = m.mapSize, u.uniforms.radius.value = m.radius, g.setRenderTarget(m.map), g.clear(), g.renderBufferDirect(N, null, F, u, p, null);
  }
  function S(m, N, F, G) {
    let k = null;
    const v = F.isPointLight === !0 ? m.customDistanceMaterial : m.customDepthMaterial;
    if (v !== void 0)
      k = v;
    else if (k = F.isPointLight === !0 ? B : s, g.localClippingEnabled && N.clipShadows === !0 && Array.isArray(N.clippingPlanes) && N.clippingPlanes.length !== 0 || N.displacementMap && N.displacementScale !== 0 || N.alphaMap && N.alphaTest > 0 || N.map && N.alphaTest > 0) {
      const x = k.uuid, H = N.uuid;
      let _ = I[x];
      _ === void 0 && (_ = {}, I[x] = _);
      let j = _[H];
      j === void 0 && (j = k.clone(), _[H] = j), k = j;
    }
    if (k.visible = N.visible, k.wireframe = N.wireframe, G === DC ? k.side = N.shadowSide !== null ? N.shadowSide : N.side : k.side = N.shadowSide !== null ? N.shadowSide : C[N.side], k.alphaMap = N.alphaMap, k.alphaTest = N.alphaTest, k.map = N.map, k.clipShadows = N.clipShadows, k.clippingPlanes = N.clippingPlanes, k.clipIntersection = N.clipIntersection, k.displacementMap = N.displacementMap, k.displacementScale = N.displacementScale, k.displacementBias = N.displacementBias, k.wireframeLinewidth = N.wireframeLinewidth, k.linewidth = N.linewidth, F.isPointLight === !0 && k.isMeshDistanceMaterial === !0) {
      const x = g.properties.get(k);
      x.light = F;
    }
    return k;
  }
  function y(m, N, F, G, k) {
    if (m.visible === !1)
      return;
    if (m.layers.test(N.layers) && (m.isMesh || m.isLine || m.isPoints) && (m.castShadow || m.receiveShadow && k === DC) && (!m.frustumCulled || t.intersectsObject(m))) {
      m.modelViewMatrix.multiplyMatrices(F.matrixWorldInverse, m.matrixWorld);
      const H = A.update(m), _ = m.material;
      if (Array.isArray(_)) {
        const j = H.groups;
        for (let V = 0, iA = j.length; V < iA; V++) {
          const eA = j[V], oA = _[eA.materialIndex];
          if (oA && oA.visible) {
            const P = S(m, oA, G, k);
            g.renderBufferDirect(F, null, H, P, m, eA);
          }
        }
      } else if (_.visible) {
        const j = S(m, _, G, k);
        g.renderBufferDirect(F, null, H, j, m, null);
      }
    }
    const x = m.children;
    for (let H = 0, _ = x.length; H < _; H++)
      y(x[H], N, F, G, k);
  }
}
function fJ(g, A, e) {
  const t = e.isWebGL2;
  function i() {
    let gA = !1;
    const RA = new Bi();
    let UA = null;
    const TA = new Bi(0, 0, 0, 0);
    return {
      setMask: function(ge) {
        UA !== ge && !gA && (g.colorMask(ge, ge, ge, ge), UA = ge);
      },
      setLocked: function(ge) {
        gA = ge;
      },
      setClear: function(ge, Me, xe, we, Ee) {
        Ee === !0 && (ge *= we, Me *= we, xe *= we), RA.set(ge, Me, xe, we), TA.equals(RA) === !1 && (g.clearColor(ge, Me, xe, we), TA.copy(RA));
      },
      reset: function() {
        gA = !1, UA = null, TA.set(-1, 0, 0, 0);
      }
    };
  }
  function n() {
    let gA = !1, RA = null, UA = null, TA = null;
    return {
      setTest: function(ge) {
        ge ? fA(2929) : wA(2929);
      },
      setMask: function(ge) {
        RA !== ge && !gA && (g.depthMask(ge), RA = ge);
      },
      setFunc: function(ge) {
        if (UA !== ge) {
          switch (ge) {
            case JG:
              g.depthFunc(512);
              break;
            case OG:
              g.depthFunc(519);
              break;
            case qG:
              g.depthFunc(513);
              break;
            case af:
              g.depthFunc(515);
              break;
            case PG:
              g.depthFunc(514);
              break;
            case WG:
              g.depthFunc(518);
              break;
            case zG:
              g.depthFunc(516);
              break;
            case VG:
              g.depthFunc(517);
              break;
            default:
              g.depthFunc(515);
          }
          UA = ge;
        }
      },
      setLocked: function(ge) {
        gA = ge;
      },
      setClear: function(ge) {
        TA !== ge && (g.clearDepth(ge), TA = ge);
      },
      reset: function() {
        gA = !1, RA = null, UA = null, TA = null;
      }
    };
  }
  function r() {
    let gA = !1, RA = null, UA = null, TA = null, ge = null, Me = null, xe = null, we = null, Ee = null;
    return {
      setTest: function(he) {
        gA || (he ? fA(2960) : wA(2960));
      },
      setMask: function(he) {
        RA !== he && !gA && (g.stencilMask(he), RA = he);
      },
      setFunc: function(he, _e, Pe) {
        (UA !== he || TA !== _e || ge !== Pe) && (g.stencilFunc(he, _e, Pe), UA = he, TA = _e, ge = Pe);
      },
      setOp: function(he, _e, Pe) {
        (Me !== he || xe !== _e || we !== Pe) && (g.stencilOp(he, _e, Pe), Me = he, xe = _e, we = Pe);
      },
      setLocked: function(he) {
        gA = he;
      },
      setClear: function(he) {
        Ee !== he && (g.clearStencil(he), Ee = he);
      },
      reset: function() {
        gA = !1, RA = null, UA = null, TA = null, ge = null, Me = null, xe = null, we = null, Ee = null;
      }
    };
  }
  const s = new i(), B = new n(), I = new r(), E = /* @__PURE__ */ new WeakMap(), C = /* @__PURE__ */ new WeakMap();
  let c = {}, u = {}, d = /* @__PURE__ */ new WeakMap(), p = [], D = null, f = !1, S = null, y = null, m = null, N = null, F = null, G = null, k = null, v = !1, x = null, H = null, _ = null, j = null, V = null;
  const iA = g.getParameter(35661);
  let eA = !1, oA = 0;
  const P = g.getParameter(7938);
  P.indexOf("WebGL") !== -1 ? (oA = parseFloat(/^WebGL (\d)/.exec(P)[1]), eA = oA >= 1) : P.indexOf("OpenGL ES") !== -1 && (oA = parseFloat(/^OpenGL ES (\d)/.exec(P)[1]), eA = oA >= 2);
  let J = null, tA = {};
  const Y = g.getParameter(3088), rA = g.getParameter(2978), QA = new Bi().fromArray(Y), aA = new Bi().fromArray(rA);
  function MA(gA, RA, UA) {
    const TA = new Uint8Array(4), ge = g.createTexture();
    g.bindTexture(gA, ge), g.texParameteri(gA, 10241, 9728), g.texParameteri(gA, 10240, 9728);
    for (let Me = 0; Me < UA; Me++)
      g.texImage2D(RA + Me, 0, 6408, 1, 1, 0, 6408, 5121, TA);
    return ge;
  }
  const hA = {};
  hA[3553] = MA(3553, 3553, 1), hA[34067] = MA(34067, 34069, 6), s.setClear(0, 0, 0, 1), B.setClear(1), I.setClear(0), fA(2929), B.setFunc(af), ee(!1), pe(Iw), fA(2884), JA(Wa);
  function fA(gA) {
    c[gA] !== !0 && (g.enable(gA), c[gA] = !0);
  }
  function wA(gA) {
    c[gA] !== !1 && (g.disable(gA), c[gA] = !1);
  }
  function yA(gA, RA) {
    return u[gA] !== RA ? (g.bindFramebuffer(gA, RA), u[gA] = RA, t && (gA === 36009 && (u[36160] = RA), gA === 36160 && (u[36009] = RA)), !0) : !1;
  }
  function kA(gA, RA) {
    let UA = p, TA = !1;
    if (gA)
      if (UA = d.get(RA), UA === void 0 && (UA = [], d.set(RA, UA)), gA.isWebGLMultipleRenderTargets) {
        const ge = gA.texture;
        if (UA.length !== ge.length || UA[0] !== 36064) {
          for (let Me = 0, xe = ge.length; Me < xe; Me++)
            UA[Me] = 36064 + Me;
          UA.length = ge.length, TA = !0;
        }
      } else
        UA[0] !== 36064 && (UA[0] = 36064, TA = !0);
    else
      UA[0] !== 1029 && (UA[0] = 1029, TA = !0);
    TA && (e.isWebGL2 ? g.drawBuffers(UA) : A.get("WEBGL_draw_buffers").drawBuffersWEBGL(UA));
  }
  function FA(gA) {
    return D !== gA ? (g.useProgram(gA), D = gA, !0) : !1;
  }
  const dA = {
    [fC]: 32774,
    [vG]: 32778,
    [UG]: 32779
  };
  if (t)
    dA[Ew] = 32775, dA[lw] = 32776;
  else {
    const gA = A.get("EXT_blend_minmax");
    gA !== null && (dA[Ew] = gA.MIN_EXT, dA[lw] = gA.MAX_EXT);
  }
  const vA = {
    [kG]: 0,
    [xG]: 1,
    [LG]: 768,
    [uy]: 770,
    [_G]: 776,
    [YG]: 774,
    [KG]: 772,
    [TG]: 769,
    [hy]: 771,
    [HG]: 775,
    [bG]: 773
  };
  function JA(gA, RA, UA, TA, ge, Me, xe, we) {
    if (gA === Wa) {
      f === !0 && (wA(3042), f = !1);
      return;
    }
    if (f === !1 && (fA(3042), f = !0), gA !== GG) {
      if (gA !== S || we !== v) {
        if ((y !== fC || F !== fC) && (g.blendEquation(32774), y = fC, F = fC), we)
          switch (gA) {
            case MC:
              g.blendFuncSeparate(1, 771, 1, 771);
              break;
            case Bw:
              g.blendFunc(1, 1);
              break;
            case Cw:
              g.blendFuncSeparate(0, 769, 0, 1);
              break;
            case Qw:
              g.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", gA);
              break;
          }
        else
          switch (gA) {
            case MC:
              g.blendFuncSeparate(770, 771, 1, 771);
              break;
            case Bw:
              g.blendFunc(770, 1);
              break;
            case Cw:
              g.blendFuncSeparate(0, 769, 0, 1);
              break;
            case Qw:
              g.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", gA);
              break;
          }
        m = null, N = null, G = null, k = null, S = gA, v = we;
      }
      return;
    }
    ge = ge || RA, Me = Me || UA, xe = xe || TA, (RA !== y || ge !== F) && (g.blendEquationSeparate(dA[RA], dA[ge]), y = RA, F = ge), (UA !== m || TA !== N || Me !== G || xe !== k) && (g.blendFuncSeparate(vA[UA], vA[TA], vA[Me], vA[xe]), m = UA, N = TA, G = Me, k = xe), S = gA, v = !1;
  }
  function ne(gA, RA) {
    gA.side === Rr ? wA(2884) : fA(2884);
    let UA = gA.side === ir;
    RA && (UA = !UA), ee(UA), gA.blending === MC && gA.transparent === !1 ? JA(Wa) : JA(gA.blending, gA.blendEquation, gA.blendSrc, gA.blendDst, gA.blendEquationAlpha, gA.blendSrcAlpha, gA.blendDstAlpha, gA.premultipliedAlpha), B.setFunc(gA.depthFunc), B.setTest(gA.depthTest), B.setMask(gA.depthWrite), s.setMask(gA.colorWrite);
    const TA = gA.stencilWrite;
    I.setTest(TA), TA && (I.setMask(gA.stencilWriteMask), I.setFunc(gA.stencilFunc, gA.stencilRef, gA.stencilFuncMask), I.setOp(gA.stencilFail, gA.stencilZFail, gA.stencilZPass)), ie(gA.polygonOffset, gA.polygonOffsetFactor, gA.polygonOffsetUnits), gA.alphaToCoverage === !0 ? fA(32926) : wA(32926);
  }
  function ee(gA) {
    x !== gA && (gA ? g.frontFace(2304) : g.frontFace(2305), x = gA);
  }
  function pe(gA) {
    gA !== RG ? (fA(2884), gA !== H && (gA === Iw ? g.cullFace(1029) : gA === NG ? g.cullFace(1028) : g.cullFace(1032))) : wA(2884), H = gA;
  }
  function Ae(gA) {
    gA !== _ && (eA && g.lineWidth(gA), _ = gA);
  }
  function ie(gA, RA, UA) {
    gA ? (fA(32823), (j !== RA || V !== UA) && (g.polygonOffset(RA, UA), j = RA, V = UA)) : wA(32823);
  }
  function de(gA) {
    gA ? fA(3089) : wA(3089);
  }
  function O(gA) {
    gA === void 0 && (gA = 33984 + iA - 1), J !== gA && (g.activeTexture(gA), J = gA);
  }
  function AA(gA, RA, UA) {
    UA === void 0 && (J === null ? UA = 33984 + iA - 1 : UA = J);
    let TA = tA[UA];
    TA === void 0 && (TA = { type: void 0, texture: void 0 }, tA[UA] = TA), (TA.type !== gA || TA.texture !== RA) && (J !== UA && (g.activeTexture(UA), J = UA), g.bindTexture(gA, RA || hA[gA]), TA.type = gA, TA.texture = RA);
  }
  function q() {
    const gA = tA[J];
    gA !== void 0 && gA.type !== void 0 && (g.bindTexture(gA.type, null), gA.type = void 0, gA.texture = void 0);
  }
  function Z() {
    try {
      g.compressedTexImage2D.apply(g, arguments);
    } catch (gA) {
      console.error("THREE.WebGLState:", gA);
    }
  }
  function $() {
    try {
      g.compressedTexImage3D.apply(g, arguments);
    } catch (gA) {
      console.error("THREE.WebGLState:", gA);
    }
  }
  function BA() {
    try {
      g.texSubImage2D.apply(g, arguments);
    } catch (gA) {
      console.error("THREE.WebGLState:", gA);
    }
  }
  function GA() {
    try {
      g.texSubImage3D.apply(g, arguments);
    } catch (gA) {
      console.error("THREE.WebGLState:", gA);
    }
  }
  function bA() {
    try {
      g.compressedTexSubImage2D.apply(g, arguments);
    } catch (gA) {
      console.error("THREE.WebGLState:", gA);
    }
  }
  function DA() {
    try {
      g.compressedTexSubImage3D.apply(g, arguments);
    } catch (gA) {
      console.error("THREE.WebGLState:", gA);
    }
  }
  function SA() {
    try {
      g.texStorage2D.apply(g, arguments);
    } catch (gA) {
      console.error("THREE.WebGLState:", gA);
    }
  }
  function EA() {
    try {
      g.texStorage3D.apply(g, arguments);
    } catch (gA) {
      console.error("THREE.WebGLState:", gA);
    }
  }
  function mA() {
    try {
      g.texImage2D.apply(g, arguments);
    } catch (gA) {
      console.error("THREE.WebGLState:", gA);
    }
  }
  function YA() {
    try {
      g.texImage3D.apply(g, arguments);
    } catch (gA) {
      console.error("THREE.WebGLState:", gA);
    }
  }
  function ZA(gA) {
    QA.equals(gA) === !1 && (g.scissor(gA.x, gA.y, gA.z, gA.w), QA.copy(gA));
  }
  function _A(gA) {
    aA.equals(gA) === !1 && (g.viewport(gA.x, gA.y, gA.z, gA.w), aA.copy(gA));
  }
  function Se(gA, RA) {
    let UA = C.get(RA);
    UA === void 0 && (UA = /* @__PURE__ */ new WeakMap(), C.set(RA, UA));
    let TA = UA.get(gA);
    TA === void 0 && (TA = g.getUniformBlockIndex(RA, gA.name), UA.set(gA, TA));
  }
  function cA(gA, RA) {
    const TA = C.get(RA).get(gA);
    E.get(RA) !== TA && (g.uniformBlockBinding(RA, TA, gA.__bindingPointIndex), E.set(RA, TA));
  }
  function xA() {
    g.disable(3042), g.disable(2884), g.disable(2929), g.disable(32823), g.disable(3089), g.disable(2960), g.disable(32926), g.blendEquation(32774), g.blendFunc(1, 0), g.blendFuncSeparate(1, 0, 1, 0), g.colorMask(!0, !0, !0, !0), g.clearColor(0, 0, 0, 0), g.depthMask(!0), g.depthFunc(513), g.clearDepth(1), g.stencilMask(4294967295), g.stencilFunc(519, 0, 4294967295), g.stencilOp(7680, 7680, 7680), g.clearStencil(0), g.cullFace(1029), g.frontFace(2305), g.polygonOffset(0, 0), g.activeTexture(33984), g.bindFramebuffer(36160, null), t === !0 && (g.bindFramebuffer(36009, null), g.bindFramebuffer(36008, null)), g.useProgram(null), g.lineWidth(1), g.scissor(0, 0, g.canvas.width, g.canvas.height), g.viewport(0, 0, g.canvas.width, g.canvas.height), c = {}, J = null, tA = {}, u = {}, d = /* @__PURE__ */ new WeakMap(), p = [], D = null, f = !1, S = null, y = null, m = null, N = null, F = null, G = null, k = null, v = !1, x = null, H = null, _ = null, j = null, V = null, QA.set(0, 0, g.canvas.width, g.canvas.height), aA.set(0, 0, g.canvas.width, g.canvas.height), s.reset(), B.reset(), I.reset();
  }
  return {
    buffers: {
      color: s,
      depth: B,
      stencil: I
    },
    enable: fA,
    disable: wA,
    bindFramebuffer: yA,
    drawBuffers: kA,
    useProgram: FA,
    setBlending: JA,
    setMaterial: ne,
    setFlipSided: ee,
    setCullFace: pe,
    setLineWidth: Ae,
    setPolygonOffset: ie,
    setScissorTest: de,
    activeTexture: O,
    bindTexture: AA,
    unbindTexture: q,
    compressedTexImage2D: Z,
    compressedTexImage3D: $,
    texImage2D: mA,
    texImage3D: YA,
    updateUBOMapping: Se,
    uniformBlockBinding: cA,
    texStorage2D: SA,
    texStorage3D: EA,
    texSubImage2D: BA,
    texSubImage3D: GA,
    compressedTexSubImage2D: bA,
    compressedTexSubImage3D: DA,
    scissor: ZA,
    viewport: _A,
    reset: xA
  };
}
function pJ(g, A, e, t, i, n, r) {
  const s = i.isWebGL2, B = i.maxTextures, I = i.maxCubemapSize, E = i.maxTextureSize, C = i.maxSamples, c = A.has("WEBGL_multisampled_render_to_texture") ? A.get("WEBGL_multisampled_render_to_texture") : null, u = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), d = /* @__PURE__ */ new WeakMap();
  let p;
  const D = /* @__PURE__ */ new WeakMap();
  let f = !1;
  try {
    f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function S(AA, q) {
    return f ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(AA, q)
    ) : Kc("canvas");
  }
  function y(AA, q, Z, $) {
    let BA = 1;
    if ((AA.width > $ || AA.height > $) && (BA = $ / Math.max(AA.width, AA.height)), BA < 1 || q === !0)
      if (typeof HTMLImageElement < "u" && AA instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && AA instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && AA instanceof ImageBitmap) {
        const GA = q ? Sv : Math.floor, bA = GA(BA * AA.width), DA = GA(BA * AA.height);
        p === void 0 && (p = S(bA, DA));
        const SA = Z ? S(bA, DA) : p;
        return SA.width = bA, SA.height = DA, SA.getContext("2d").drawImage(AA, 0, 0, bA, DA), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + AA.width + "x" + AA.height + ") to (" + bA + "x" + DA + ")."), SA;
      } else
        return "data" in AA && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + AA.width + "x" + AA.height + ")."), AA;
    return AA;
  }
  function m(AA) {
    return Yw(AA.width) && Yw(AA.height);
  }
  function N(AA) {
    return s ? !1 : AA.wrapS !== Jn || AA.wrapT !== Jn || AA.minFilter !== un && AA.minFilter !== Gi;
  }
  function F(AA, q) {
    return AA.generateMipmaps && q && AA.minFilter !== un && AA.minFilter !== Gi;
  }
  function G(AA) {
    g.generateMipmap(AA);
  }
  function k(AA, q, Z, $, BA = !1) {
    if (s === !1)
      return q;
    if (AA !== null) {
      if (g[AA] !== void 0)
        return g[AA];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + AA + "'");
    }
    let GA = q;
    return q === 6403 && (Z === 5126 && (GA = 33326), Z === 5131 && (GA = 33325), Z === 5121 && (GA = 33321)), q === 33319 && (Z === 5126 && (GA = 33328), Z === 5131 && (GA = 33327), Z === 5121 && (GA = 33323)), q === 6408 && (Z === 5126 && (GA = 34836), Z === 5131 && (GA = 34842), Z === 5121 && (GA = $ === Ht && BA === !1 ? 35907 : 32856), Z === 32819 && (GA = 32854), Z === 32820 && (GA = 32855)), (GA === 33325 || GA === 33326 || GA === 33327 || GA === 33328 || GA === 34842 || GA === 34836) && A.get("EXT_color_buffer_float"), GA;
  }
  function v(AA, q, Z) {
    return F(AA, Z) === !0 || AA.isFramebufferTexture && AA.minFilter !== un && AA.minFilter !== Gi ? Math.log2(Math.max(q.width, q.height)) + 1 : AA.mipmaps !== void 0 && AA.mipmaps.length > 0 ? AA.mipmaps.length : AA.isCompressedTexture && Array.isArray(AA.image) ? q.mipmaps.length : 1;
  }
  function x(AA) {
    return AA === un || AA === NE || AA === RC ? 9728 : 9729;
  }
  function H(AA) {
    const q = AA.target;
    q.removeEventListener("dispose", H), j(q), q.isVideoTexture && d.delete(q);
  }
  function _(AA) {
    const q = AA.target;
    q.removeEventListener("dispose", _), iA(q);
  }
  function j(AA) {
    const q = t.get(AA);
    if (q.__webglInit === void 0)
      return;
    const Z = AA.source, $ = D.get(Z);
    if ($) {
      const BA = $[q.__cacheKey];
      BA.usedTimes--, BA.usedTimes === 0 && V(AA), Object.keys($).length === 0 && D.delete(Z);
    }
    t.remove(AA);
  }
  function V(AA) {
    const q = t.get(AA);
    g.deleteTexture(q.__webglTexture);
    const Z = AA.source, $ = D.get(Z);
    delete $[q.__cacheKey], r.memory.textures--;
  }
  function iA(AA) {
    const q = AA.texture, Z = t.get(AA), $ = t.get(q);
    if ($.__webglTexture !== void 0 && (g.deleteTexture($.__webglTexture), r.memory.textures--), AA.depthTexture && AA.depthTexture.dispose(), AA.isWebGLCubeRenderTarget)
      for (let BA = 0; BA < 6; BA++)
        g.deleteFramebuffer(Z.__webglFramebuffer[BA]), Z.__webglDepthbuffer && g.deleteRenderbuffer(Z.__webglDepthbuffer[BA]);
    else {
      if (g.deleteFramebuffer(Z.__webglFramebuffer), Z.__webglDepthbuffer && g.deleteRenderbuffer(Z.__webglDepthbuffer), Z.__webglMultisampledFramebuffer && g.deleteFramebuffer(Z.__webglMultisampledFramebuffer), Z.__webglColorRenderbuffer)
        for (let BA = 0; BA < Z.__webglColorRenderbuffer.length; BA++)
          Z.__webglColorRenderbuffer[BA] && g.deleteRenderbuffer(Z.__webglColorRenderbuffer[BA]);
      Z.__webglDepthRenderbuffer && g.deleteRenderbuffer(Z.__webglDepthRenderbuffer);
    }
    if (AA.isWebGLMultipleRenderTargets)
      for (let BA = 0, GA = q.length; BA < GA; BA++) {
        const bA = t.get(q[BA]);
        bA.__webglTexture && (g.deleteTexture(bA.__webglTexture), r.memory.textures--), t.remove(q[BA]);
      }
    t.remove(q), t.remove(AA);
  }
  let eA = 0;
  function oA() {
    eA = 0;
  }
  function P() {
    const AA = eA;
    return AA >= B && console.warn("THREE.WebGLTextures: Trying to use " + AA + " texture units while this GPU supports only " + B), eA += 1, AA;
  }
  function J(AA) {
    const q = [];
    return q.push(AA.wrapS), q.push(AA.wrapT), q.push(AA.wrapR || 0), q.push(AA.magFilter), q.push(AA.minFilter), q.push(AA.anisotropy), q.push(AA.internalFormat), q.push(AA.format), q.push(AA.type), q.push(AA.generateMipmaps), q.push(AA.premultiplyAlpha), q.push(AA.flipY), q.push(AA.unpackAlignment), q.push(AA.encoding), q.join();
  }
  function tA(AA, q) {
    const Z = t.get(AA);
    if (AA.isVideoTexture && de(AA), AA.isRenderTargetTexture === !1 && AA.version > 0 && Z.__version !== AA.version) {
      const $ = AA.image;
      if ($ === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if ($.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        wA(Z, AA, q);
        return;
      }
    }
    e.bindTexture(3553, Z.__webglTexture, 33984 + q);
  }
  function Y(AA, q) {
    const Z = t.get(AA);
    if (AA.version > 0 && Z.__version !== AA.version) {
      wA(Z, AA, q);
      return;
    }
    e.bindTexture(35866, Z.__webglTexture, 33984 + q);
  }
  function rA(AA, q) {
    const Z = t.get(AA);
    if (AA.version > 0 && Z.__version !== AA.version) {
      wA(Z, AA, q);
      return;
    }
    e.bindTexture(32879, Z.__webglTexture, 33984 + q);
  }
  function QA(AA, q) {
    const Z = t.get(AA);
    if (AA.version > 0 && Z.__version !== AA.version) {
      yA(Z, AA, q);
      return;
    }
    e.bindTexture(34067, Z.__webglTexture, 33984 + q);
  }
  const aA = {
    [Bs]: 10497,
    [Jn]: 33071,
    [kC]: 33648
  }, MA = {
    [un]: 9728,
    [NE]: 9984,
    [RC]: 9986,
    [Gi]: 9729,
    [Zc]: 9985,
    [Cs]: 9987
  };
  function hA(AA, q, Z) {
    if (Z ? (g.texParameteri(AA, 10242, aA[q.wrapS]), g.texParameteri(AA, 10243, aA[q.wrapT]), (AA === 32879 || AA === 35866) && g.texParameteri(AA, 32882, aA[q.wrapR]), g.texParameteri(AA, 10240, MA[q.magFilter]), g.texParameteri(AA, 10241, MA[q.minFilter])) : (g.texParameteri(AA, 10242, 33071), g.texParameteri(AA, 10243, 33071), (AA === 32879 || AA === 35866) && g.texParameteri(AA, 32882, 33071), (q.wrapS !== Jn || q.wrapT !== Jn) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), g.texParameteri(AA, 10240, x(q.magFilter)), g.texParameteri(AA, 10241, x(q.minFilter)), q.minFilter !== un && q.minFilter !== Gi && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), A.has("EXT_texture_filter_anisotropic") === !0) {
      const $ = A.get("EXT_texture_filter_anisotropic");
      if (q.magFilter === un || q.minFilter !== RC && q.minFilter !== Cs || q.type === $s && A.has("OES_texture_float_linear") === !1 || s === !1 && q.type === xC && A.has("OES_texture_half_float_linear") === !1)
        return;
      (q.anisotropy > 1 || t.get(q).__currentAnisotropy) && (g.texParameterf(AA, $.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(q.anisotropy, i.getMaxAnisotropy())), t.get(q).__currentAnisotropy = q.anisotropy);
    }
  }
  function fA(AA, q) {
    let Z = !1;
    AA.__webglInit === void 0 && (AA.__webglInit = !0, q.addEventListener("dispose", H));
    const $ = q.source;
    let BA = D.get($);
    BA === void 0 && (BA = {}, D.set($, BA));
    const GA = J(q);
    if (GA !== AA.__cacheKey) {
      BA[GA] === void 0 && (BA[GA] = {
        texture: g.createTexture(),
        usedTimes: 0
      }, r.memory.textures++, Z = !0), BA[GA].usedTimes++;
      const bA = BA[AA.__cacheKey];
      bA !== void 0 && (BA[AA.__cacheKey].usedTimes--, bA.usedTimes === 0 && V(q)), AA.__cacheKey = GA, AA.__webglTexture = BA[GA].texture;
    }
    return Z;
  }
  function wA(AA, q, Z) {
    let $ = 3553;
    (q.isDataArrayTexture || q.isCompressedArrayTexture) && ($ = 35866), q.isData3DTexture && ($ = 32879);
    const BA = fA(AA, q), GA = q.source;
    e.bindTexture($, AA.__webglTexture, 33984 + Z);
    const bA = t.get(GA);
    if (GA.version !== bA.__version || BA === !0) {
      e.activeTexture(33984 + Z), g.pixelStorei(37440, q.flipY), g.pixelStorei(37441, q.premultiplyAlpha), g.pixelStorei(3317, q.unpackAlignment), g.pixelStorei(37443, 0);
      const DA = N(q) && m(q.image) === !1;
      let SA = y(q.image, DA, !1, E);
      SA = O(q, SA);
      const EA = m(SA) || s, mA = n.convert(q.format, q.encoding);
      let YA = n.convert(q.type), ZA = k(q.internalFormat, mA, YA, q.encoding, q.isVideoTexture);
      hA($, q, EA);
      let _A;
      const Se = q.mipmaps, cA = s && q.isVideoTexture !== !0, xA = bA.__version === void 0 || BA === !0, gA = v(q, SA, EA);
      if (q.isDepthTexture)
        ZA = 6402, s ? q.type === $s ? ZA = 36012 : q.type === aB ? ZA = 33190 : q.type === NC ? ZA = 35056 : ZA = 33189 : q.type === $s && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), q.format === EB && ZA === 6402 && q.type !== fy && q.type !== aB && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), q.type = aB, YA = n.convert(q.type)), q.format === LC && ZA === 6402 && (ZA = 34041, q.type !== NC && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), q.type = NC, YA = n.convert(q.type))), xA && (cA ? e.texStorage2D(3553, 1, ZA, SA.width, SA.height) : e.texImage2D(3553, 0, ZA, SA.width, SA.height, 0, mA, YA, null));
      else if (q.isDataTexture)
        if (Se.length > 0 && EA) {
          cA && xA && e.texStorage2D(3553, gA, ZA, Se[0].width, Se[0].height);
          for (let RA = 0, UA = Se.length; RA < UA; RA++)
            _A = Se[RA], cA ? e.texSubImage2D(3553, RA, 0, 0, _A.width, _A.height, mA, YA, _A.data) : e.texImage2D(3553, RA, ZA, _A.width, _A.height, 0, mA, YA, _A.data);
          q.generateMipmaps = !1;
        } else
          cA ? (xA && e.texStorage2D(3553, gA, ZA, SA.width, SA.height), e.texSubImage2D(3553, 0, 0, 0, SA.width, SA.height, mA, YA, SA.data)) : e.texImage2D(3553, 0, ZA, SA.width, SA.height, 0, mA, YA, SA.data);
      else if (q.isCompressedTexture)
        if (q.isCompressedArrayTexture) {
          cA && xA && e.texStorage3D(35866, gA, ZA, Se[0].width, Se[0].height, SA.depth);
          for (let RA = 0, UA = Se.length; RA < UA; RA++)
            _A = Se[RA], q.format !== tr ? mA !== null ? cA ? e.compressedTexSubImage3D(35866, RA, 0, 0, 0, _A.width, _A.height, SA.depth, mA, _A.data, 0, 0) : e.compressedTexImage3D(35866, RA, ZA, _A.width, _A.height, SA.depth, 0, _A.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : cA ? e.texSubImage3D(35866, RA, 0, 0, 0, _A.width, _A.height, SA.depth, mA, YA, _A.data) : e.texImage3D(35866, RA, ZA, _A.width, _A.height, SA.depth, 0, mA, YA, _A.data);
        } else {
          cA && xA && e.texStorage2D(3553, gA, ZA, Se[0].width, Se[0].height);
          for (let RA = 0, UA = Se.length; RA < UA; RA++)
            _A = Se[RA], q.format !== tr ? mA !== null ? cA ? e.compressedTexSubImage2D(3553, RA, 0, 0, _A.width, _A.height, mA, _A.data) : e.compressedTexImage2D(3553, RA, ZA, _A.width, _A.height, 0, _A.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : cA ? e.texSubImage2D(3553, RA, 0, 0, _A.width, _A.height, mA, YA, _A.data) : e.texImage2D(3553, RA, ZA, _A.width, _A.height, 0, mA, YA, _A.data);
        }
      else if (q.isDataArrayTexture)
        cA ? (xA && e.texStorage3D(35866, gA, ZA, SA.width, SA.height, SA.depth), e.texSubImage3D(35866, 0, 0, 0, 0, SA.width, SA.height, SA.depth, mA, YA, SA.data)) : e.texImage3D(35866, 0, ZA, SA.width, SA.height, SA.depth, 0, mA, YA, SA.data);
      else if (q.isData3DTexture)
        cA ? (xA && e.texStorage3D(32879, gA, ZA, SA.width, SA.height, SA.depth), e.texSubImage3D(32879, 0, 0, 0, 0, SA.width, SA.height, SA.depth, mA, YA, SA.data)) : e.texImage3D(32879, 0, ZA, SA.width, SA.height, SA.depth, 0, mA, YA, SA.data);
      else if (q.isFramebufferTexture) {
        if (xA)
          if (cA)
            e.texStorage2D(3553, gA, ZA, SA.width, SA.height);
          else {
            let RA = SA.width, UA = SA.height;
            for (let TA = 0; TA < gA; TA++)
              e.texImage2D(3553, TA, ZA, RA, UA, 0, mA, YA, null), RA >>= 1, UA >>= 1;
          }
      } else if (Se.length > 0 && EA) {
        cA && xA && e.texStorage2D(3553, gA, ZA, Se[0].width, Se[0].height);
        for (let RA = 0, UA = Se.length; RA < UA; RA++)
          _A = Se[RA], cA ? e.texSubImage2D(3553, RA, 0, 0, mA, YA, _A) : e.texImage2D(3553, RA, ZA, mA, YA, _A);
        q.generateMipmaps = !1;
      } else
        cA ? (xA && e.texStorage2D(3553, gA, ZA, SA.width, SA.height), e.texSubImage2D(3553, 0, 0, 0, mA, YA, SA)) : e.texImage2D(3553, 0, ZA, mA, YA, SA);
      F(q, EA) && G($), bA.__version = GA.version, q.onUpdate && q.onUpdate(q);
    }
    AA.__version = q.version;
  }
  function yA(AA, q, Z) {
    if (q.image.length !== 6)
      return;
    const $ = fA(AA, q), BA = q.source;
    e.bindTexture(34067, AA.__webglTexture, 33984 + Z);
    const GA = t.get(BA);
    if (BA.version !== GA.__version || $ === !0) {
      e.activeTexture(33984 + Z), g.pixelStorei(37440, q.flipY), g.pixelStorei(37441, q.premultiplyAlpha), g.pixelStorei(3317, q.unpackAlignment), g.pixelStorei(37443, 0);
      const bA = q.isCompressedTexture || q.image[0].isCompressedTexture, DA = q.image[0] && q.image[0].isDataTexture, SA = [];
      for (let RA = 0; RA < 6; RA++)
        !bA && !DA ? SA[RA] = y(q.image[RA], !1, !0, I) : SA[RA] = DA ? q.image[RA].image : q.image[RA], SA[RA] = O(q, SA[RA]);
      const EA = SA[0], mA = m(EA) || s, YA = n.convert(q.format, q.encoding), ZA = n.convert(q.type), _A = k(q.internalFormat, YA, ZA, q.encoding), Se = s && q.isVideoTexture !== !0, cA = GA.__version === void 0 || $ === !0;
      let xA = v(q, EA, mA);
      hA(34067, q, mA);
      let gA;
      if (bA) {
        Se && cA && e.texStorage2D(34067, xA, _A, EA.width, EA.height);
        for (let RA = 0; RA < 6; RA++) {
          gA = SA[RA].mipmaps;
          for (let UA = 0; UA < gA.length; UA++) {
            const TA = gA[UA];
            q.format !== tr ? YA !== null ? Se ? e.compressedTexSubImage2D(34069 + RA, UA, 0, 0, TA.width, TA.height, YA, TA.data) : e.compressedTexImage2D(34069 + RA, UA, _A, TA.width, TA.height, 0, TA.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Se ? e.texSubImage2D(34069 + RA, UA, 0, 0, TA.width, TA.height, YA, ZA, TA.data) : e.texImage2D(34069 + RA, UA, _A, TA.width, TA.height, 0, YA, ZA, TA.data);
          }
        }
      } else {
        gA = q.mipmaps, Se && cA && (gA.length > 0 && xA++, e.texStorage2D(34067, xA, _A, SA[0].width, SA[0].height));
        for (let RA = 0; RA < 6; RA++)
          if (DA) {
            Se ? e.texSubImage2D(34069 + RA, 0, 0, 0, SA[RA].width, SA[RA].height, YA, ZA, SA[RA].data) : e.texImage2D(34069 + RA, 0, _A, SA[RA].width, SA[RA].height, 0, YA, ZA, SA[RA].data);
            for (let UA = 0; UA < gA.length; UA++) {
              const ge = gA[UA].image[RA].image;
              Se ? e.texSubImage2D(34069 + RA, UA + 1, 0, 0, ge.width, ge.height, YA, ZA, ge.data) : e.texImage2D(34069 + RA, UA + 1, _A, ge.width, ge.height, 0, YA, ZA, ge.data);
            }
          } else {
            Se ? e.texSubImage2D(34069 + RA, 0, 0, 0, YA, ZA, SA[RA]) : e.texImage2D(34069 + RA, 0, _A, YA, ZA, SA[RA]);
            for (let UA = 0; UA < gA.length; UA++) {
              const TA = gA[UA];
              Se ? e.texSubImage2D(34069 + RA, UA + 1, 0, 0, YA, ZA, TA.image[RA]) : e.texImage2D(34069 + RA, UA + 1, _A, YA, ZA, TA.image[RA]);
            }
          }
      }
      F(q, mA) && G(34067), GA.__version = BA.version, q.onUpdate && q.onUpdate(q);
    }
    AA.__version = q.version;
  }
  function kA(AA, q, Z, $, BA) {
    const GA = n.convert(Z.format, Z.encoding), bA = n.convert(Z.type), DA = k(Z.internalFormat, GA, bA, Z.encoding);
    t.get(q).__hasExternalTextures || (BA === 32879 || BA === 35866 ? e.texImage3D(BA, 0, DA, q.width, q.height, q.depth, 0, GA, bA, null) : e.texImage2D(BA, 0, DA, q.width, q.height, 0, GA, bA, null)), e.bindFramebuffer(36160, AA), ie(q) ? c.framebufferTexture2DMultisampleEXT(36160, $, BA, t.get(Z).__webglTexture, 0, Ae(q)) : (BA === 3553 || BA >= 34069 && BA <= 34074) && g.framebufferTexture2D(36160, $, BA, t.get(Z).__webglTexture, 0), e.bindFramebuffer(36160, null);
  }
  function FA(AA, q, Z) {
    if (g.bindRenderbuffer(36161, AA), q.depthBuffer && !q.stencilBuffer) {
      let $ = 33189;
      if (Z || ie(q)) {
        const BA = q.depthTexture;
        BA && BA.isDepthTexture && (BA.type === $s ? $ = 36012 : BA.type === aB && ($ = 33190));
        const GA = Ae(q);
        ie(q) ? c.renderbufferStorageMultisampleEXT(36161, GA, $, q.width, q.height) : g.renderbufferStorageMultisample(36161, GA, $, q.width, q.height);
      } else
        g.renderbufferStorage(36161, $, q.width, q.height);
      g.framebufferRenderbuffer(36160, 36096, 36161, AA);
    } else if (q.depthBuffer && q.stencilBuffer) {
      const $ = Ae(q);
      Z && ie(q) === !1 ? g.renderbufferStorageMultisample(36161, $, 35056, q.width, q.height) : ie(q) ? c.renderbufferStorageMultisampleEXT(36161, $, 35056, q.width, q.height) : g.renderbufferStorage(36161, 34041, q.width, q.height), g.framebufferRenderbuffer(36160, 33306, 36161, AA);
    } else {
      const $ = q.isWebGLMultipleRenderTargets === !0 ? q.texture : [q.texture];
      for (let BA = 0; BA < $.length; BA++) {
        const GA = $[BA], bA = n.convert(GA.format, GA.encoding), DA = n.convert(GA.type), SA = k(GA.internalFormat, bA, DA, GA.encoding), EA = Ae(q);
        Z && ie(q) === !1 ? g.renderbufferStorageMultisample(36161, EA, SA, q.width, q.height) : ie(q) ? c.renderbufferStorageMultisampleEXT(36161, EA, SA, q.width, q.height) : g.renderbufferStorage(36161, SA, q.width, q.height);
      }
    }
    g.bindRenderbuffer(36161, null);
  }
  function dA(AA, q) {
    if (q && q.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported");
    if (e.bindFramebuffer(36160, AA), !(q.depthTexture && q.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!t.get(q.depthTexture).__webglTexture || q.depthTexture.image.width !== q.width || q.depthTexture.image.height !== q.height) && (q.depthTexture.image.width = q.width, q.depthTexture.image.height = q.height, q.depthTexture.needsUpdate = !0), tA(q.depthTexture, 0);
    const $ = t.get(q.depthTexture).__webglTexture, BA = Ae(q);
    if (q.depthTexture.format === EB)
      ie(q) ? c.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, $, 0, BA) : g.framebufferTexture2D(36160, 36096, 3553, $, 0);
    else if (q.depthTexture.format === LC)
      ie(q) ? c.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, $, 0, BA) : g.framebufferTexture2D(36160, 33306, 3553, $, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function vA(AA) {
    const q = t.get(AA), Z = AA.isWebGLCubeRenderTarget === !0;
    if (AA.depthTexture && !q.__autoAllocateDepthBuffer) {
      if (Z)
        throw new Error("target.depthTexture not supported in Cube render targets");
      dA(q.__webglFramebuffer, AA);
    } else if (Z) {
      q.__webglDepthbuffer = [];
      for (let $ = 0; $ < 6; $++)
        e.bindFramebuffer(36160, q.__webglFramebuffer[$]), q.__webglDepthbuffer[$] = g.createRenderbuffer(), FA(q.__webglDepthbuffer[$], AA, !1);
    } else
      e.bindFramebuffer(36160, q.__webglFramebuffer), q.__webglDepthbuffer = g.createRenderbuffer(), FA(q.__webglDepthbuffer, AA, !1);
    e.bindFramebuffer(36160, null);
  }
  function JA(AA, q, Z) {
    const $ = t.get(AA);
    q !== void 0 && kA($.__webglFramebuffer, AA, AA.texture, 36064, 3553), Z !== void 0 && vA(AA);
  }
  function ne(AA) {
    const q = AA.texture, Z = t.get(AA), $ = t.get(q);
    AA.addEventListener("dispose", _), AA.isWebGLMultipleRenderTargets !== !0 && ($.__webglTexture === void 0 && ($.__webglTexture = g.createTexture()), $.__version = q.version, r.memory.textures++);
    const BA = AA.isWebGLCubeRenderTarget === !0, GA = AA.isWebGLMultipleRenderTargets === !0, bA = m(AA) || s;
    if (BA) {
      Z.__webglFramebuffer = [];
      for (let DA = 0; DA < 6; DA++)
        Z.__webglFramebuffer[DA] = g.createFramebuffer();
    } else {
      if (Z.__webglFramebuffer = g.createFramebuffer(), GA)
        if (i.drawBuffers) {
          const DA = AA.texture;
          for (let SA = 0, EA = DA.length; SA < EA; SA++) {
            const mA = t.get(DA[SA]);
            mA.__webglTexture === void 0 && (mA.__webglTexture = g.createTexture(), r.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (s && AA.samples > 0 && ie(AA) === !1) {
        const DA = GA ? q : [q];
        Z.__webglMultisampledFramebuffer = g.createFramebuffer(), Z.__webglColorRenderbuffer = [], e.bindFramebuffer(36160, Z.__webglMultisampledFramebuffer);
        for (let SA = 0; SA < DA.length; SA++) {
          const EA = DA[SA];
          Z.__webglColorRenderbuffer[SA] = g.createRenderbuffer(), g.bindRenderbuffer(36161, Z.__webglColorRenderbuffer[SA]);
          const mA = n.convert(EA.format, EA.encoding), YA = n.convert(EA.type), ZA = k(EA.internalFormat, mA, YA, EA.encoding, AA.isXRRenderTarget === !0), _A = Ae(AA);
          g.renderbufferStorageMultisample(36161, _A, ZA, AA.width, AA.height), g.framebufferRenderbuffer(36160, 36064 + SA, 36161, Z.__webglColorRenderbuffer[SA]);
        }
        g.bindRenderbuffer(36161, null), AA.depthBuffer && (Z.__webglDepthRenderbuffer = g.createRenderbuffer(), FA(Z.__webglDepthRenderbuffer, AA, !0)), e.bindFramebuffer(36160, null);
      }
    }
    if (BA) {
      e.bindTexture(34067, $.__webglTexture), hA(34067, q, bA);
      for (let DA = 0; DA < 6; DA++)
        kA(Z.__webglFramebuffer[DA], AA, q, 36064, 34069 + DA);
      F(q, bA) && G(34067), e.unbindTexture();
    } else if (GA) {
      const DA = AA.texture;
      for (let SA = 0, EA = DA.length; SA < EA; SA++) {
        const mA = DA[SA], YA = t.get(mA);
        e.bindTexture(3553, YA.__webglTexture), hA(3553, mA, bA), kA(Z.__webglFramebuffer, AA, mA, 36064 + SA, 3553), F(mA, bA) && G(3553);
      }
      e.unbindTexture();
    } else {
      let DA = 3553;
      (AA.isWebGL3DRenderTarget || AA.isWebGLArrayRenderTarget) && (s ? DA = AA.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), e.bindTexture(DA, $.__webglTexture), hA(DA, q, bA), kA(Z.__webglFramebuffer, AA, q, 36064, DA), F(q, bA) && G(DA), e.unbindTexture();
    }
    AA.depthBuffer && vA(AA);
  }
  function ee(AA) {
    const q = m(AA) || s, Z = AA.isWebGLMultipleRenderTargets === !0 ? AA.texture : [AA.texture];
    for (let $ = 0, BA = Z.length; $ < BA; $++) {
      const GA = Z[$];
      if (F(GA, q)) {
        const bA = AA.isWebGLCubeRenderTarget ? 34067 : 3553, DA = t.get(GA).__webglTexture;
        e.bindTexture(bA, DA), G(bA), e.unbindTexture();
      }
    }
  }
  function pe(AA) {
    if (s && AA.samples > 0 && ie(AA) === !1) {
      const q = AA.isWebGLMultipleRenderTargets ? AA.texture : [AA.texture], Z = AA.width, $ = AA.height;
      let BA = 16384;
      const GA = [], bA = AA.stencilBuffer ? 33306 : 36096, DA = t.get(AA), SA = AA.isWebGLMultipleRenderTargets === !0;
      if (SA)
        for (let EA = 0; EA < q.length; EA++)
          e.bindFramebuffer(36160, DA.__webglMultisampledFramebuffer), g.framebufferRenderbuffer(36160, 36064 + EA, 36161, null), e.bindFramebuffer(36160, DA.__webglFramebuffer), g.framebufferTexture2D(36009, 36064 + EA, 3553, null, 0);
      e.bindFramebuffer(36008, DA.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, DA.__webglFramebuffer);
      for (let EA = 0; EA < q.length; EA++) {
        GA.push(36064 + EA), AA.depthBuffer && GA.push(bA);
        const mA = DA.__ignoreDepthValues !== void 0 ? DA.__ignoreDepthValues : !1;
        if (mA === !1 && (AA.depthBuffer && (BA |= 256), AA.stencilBuffer && (BA |= 1024)), SA && g.framebufferRenderbuffer(36008, 36064, 36161, DA.__webglColorRenderbuffer[EA]), mA === !0 && (g.invalidateFramebuffer(36008, [bA]), g.invalidateFramebuffer(36009, [bA])), SA) {
          const YA = t.get(q[EA]).__webglTexture;
          g.framebufferTexture2D(36009, 36064, 3553, YA, 0);
        }
        g.blitFramebuffer(0, 0, Z, $, 0, 0, Z, $, BA, 9728), u && g.invalidateFramebuffer(36008, GA);
      }
      if (e.bindFramebuffer(36008, null), e.bindFramebuffer(36009, null), SA)
        for (let EA = 0; EA < q.length; EA++) {
          e.bindFramebuffer(36160, DA.__webglMultisampledFramebuffer), g.framebufferRenderbuffer(36160, 36064 + EA, 36161, DA.__webglColorRenderbuffer[EA]);
          const mA = t.get(q[EA]).__webglTexture;
          e.bindFramebuffer(36160, DA.__webglFramebuffer), g.framebufferTexture2D(36009, 36064 + EA, 3553, mA, 0);
        }
      e.bindFramebuffer(36009, DA.__webglMultisampledFramebuffer);
    }
  }
  function Ae(AA) {
    return Math.min(C, AA.samples);
  }
  function ie(AA) {
    const q = t.get(AA);
    return s && AA.samples > 0 && A.has("WEBGL_multisampled_render_to_texture") === !0 && q.__useRenderToTexture !== !1;
  }
  function de(AA) {
    const q = r.render.frame;
    d.get(AA) !== q && (d.set(AA, q), AA.update());
  }
  function O(AA, q) {
    const Z = AA.encoding, $ = AA.format, BA = AA.type;
    return AA.isCompressedTexture === !0 || AA.isVideoTexture === !0 || AA.format === Bf || Z !== ta && (Z === Ht ? s === !1 ? A.has("EXT_sRGB") === !0 && $ === tr ? (AA.format = Bf, AA.minFilter = Gi, AA.generateMipmaps = !1) : q = my.sRGBToLinear(q) : ($ !== tr || BA !== Va) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", Z)), q;
  }
  this.allocateTextureUnit = P, this.resetTextureUnits = oA, this.setTexture2D = tA, this.setTexture2DArray = Y, this.setTexture3D = rA, this.setTextureCube = QA, this.rebindTextures = JA, this.setupRenderTarget = ne, this.updateRenderTargetMipmap = ee, this.updateMultisampleRenderTarget = pe, this.setupDepthRenderbuffer = vA, this.setupFrameBufferTexture = kA, this.useMultisampledRTT = ie;
}
function Kv(g, A, e) {
  const t = e.isWebGL2;
  function i(n, r = null) {
    let s;
    if (n === Va)
      return 5121;
    if (n === gv)
      return 32819;
    if (n === rv)
      return 32820;
    if (n === tv)
      return 5120;
    if (n === iv)
      return 5122;
    if (n === fy)
      return 5123;
    if (n === nv)
      return 5124;
    if (n === aB)
      return 5125;
    if (n === $s)
      return 5126;
    if (n === xC)
      return t ? 5131 : (s = A.get("OES_texture_half_float"), s !== null ? s.HALF_FLOAT_OES : null);
    if (n === ov)
      return 6406;
    if (n === tr)
      return 6408;
    if (n === sv)
      return 6409;
    if (n === av)
      return 6410;
    if (n === EB)
      return 6402;
    if (n === LC)
      return 34041;
    if (n === Bf)
      return s = A.get("EXT_sRGB"), s !== null ? s.SRGB_ALPHA_EXT : null;
    if (n === Iv)
      return 6403;
    if (n === Bv)
      return 36244;
    if (n === Cv)
      return 33319;
    if (n === Qv)
      return 33320;
    if (n === Ev)
      return 36249;
    if (n === Zd || n === Xd || n === $d || n === Af)
      if (r === Ht)
        if (s = A.get("WEBGL_compressed_texture_s3tc_srgb"), s !== null) {
          if (n === Zd)
            return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === Xd)
            return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === $d)
            return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === Af)
            return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (s = A.get("WEBGL_compressed_texture_s3tc"), s !== null) {
        if (n === Zd)
          return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === Xd)
          return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === $d)
          return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === Af)
          return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (n === cw || n === uw || n === hw || n === dw)
      if (s = A.get("WEBGL_compressed_texture_pvrtc"), s !== null) {
        if (n === cw)
          return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === uw)
          return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === hw)
          return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === dw)
          return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (n === lv)
      return s = A.get("WEBGL_compressed_texture_etc1"), s !== null ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (n === fw || n === pw)
      if (s = A.get("WEBGL_compressed_texture_etc"), s !== null) {
        if (n === fw)
          return r === Ht ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
        if (n === pw)
          return r === Ht ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (n === Dw || n === ww || n === yw || n === mw || n === Sw || n === Mw || n === Rw || n === Nw || n === Fw || n === Gw || n === vw || n === Uw || n === kw || n === xw)
      if (s = A.get("WEBGL_compressed_texture_astc"), s !== null) {
        if (n === Dw)
          return r === Ht ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === ww)
          return r === Ht ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === yw)
          return r === Ht ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === mw)
          return r === Ht ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === Sw)
          return r === Ht ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === Mw)
          return r === Ht ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === Rw)
          return r === Ht ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === Nw)
          return r === Ht ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === Fw)
          return r === Ht ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === Gw)
          return r === Ht ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === vw)
          return r === Ht ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === Uw)
          return r === Ht ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === kw)
          return r === Ht ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === xw)
          return r === Ht ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (n === ef)
      if (s = A.get("EXT_texture_compression_bptc"), s !== null) {
        if (n === ef)
          return r === Ht ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else
        return null;
    if (n === cv || n === Lw || n === Tw || n === Kw)
      if (s = A.get("EXT_texture_compression_rgtc"), s !== null) {
        if (n === ef)
          return s.COMPRESSED_RED_RGTC1_EXT;
        if (n === Lw)
          return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === Tw)
          return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === Kw)
          return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return n === NC ? t ? 34042 : (s = A.get("WEBGL_depth_texture"), s !== null ? s.UNSIGNED_INT_24_8_WEBGL : null) : g[n] !== void 0 ? g[n] : null;
  }
  return { convert: i };
}
class bv extends mn {
  constructor(A = []) {
    super(), this.isArrayCamera = !0, this.cameras = A;
  }
}
class eo extends Xt {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const DJ = { type: "move" };
class h0 {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new eo(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new eo(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new IA(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new IA()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new eo(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new IA(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new IA()), this._grip;
  }
  dispatchEvent(A) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(A), this._grip !== null && this._grip.dispatchEvent(A), this._hand !== null && this._hand.dispatchEvent(A), this;
  }
  connect(A) {
    if (A && A.hand) {
      const e = this._hand;
      if (e)
        for (const t of A.hand.values())
          this._getHandJoint(e, t);
    }
    return this.dispatchEvent({ type: "connected", data: A }), this;
  }
  disconnect(A) {
    return this.dispatchEvent({ type: "disconnected", data: A }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(A, e, t) {
    let i = null, n = null, r = null;
    const s = this._targetRay, B = this._grip, I = this._hand;
    if (A && e.session.visibilityState !== "visible-blurred") {
      if (I && A.hand) {
        r = !0;
        for (const p of A.hand.values()) {
          const D = e.getJointPose(p, t), f = this._getHandJoint(I, p);
          D !== null && (f.matrix.fromArray(D.transform.matrix), f.matrix.decompose(f.position, f.rotation, f.scale), f.jointRadius = D.radius), f.visible = D !== null;
        }
        const E = I.joints["index-finger-tip"], C = I.joints["thumb-tip"], c = E.position.distanceTo(C.position), u = 0.02, d = 5e-3;
        I.inputState.pinching && c > u + d ? (I.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: A.handedness,
          target: this
        })) : !I.inputState.pinching && c <= u - d && (I.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: A.handedness,
          target: this
        }));
      } else
        B !== null && A.gripSpace && (n = e.getPose(A.gripSpace, t), n !== null && (B.matrix.fromArray(n.transform.matrix), B.matrix.decompose(B.position, B.rotation, B.scale), n.linearVelocity ? (B.hasLinearVelocity = !0, B.linearVelocity.copy(n.linearVelocity)) : B.hasLinearVelocity = !1, n.angularVelocity ? (B.hasAngularVelocity = !0, B.angularVelocity.copy(n.angularVelocity)) : B.hasAngularVelocity = !1));
      s !== null && (i = e.getPose(A.targetRaySpace, t), i === null && n !== null && (i = n), i !== null && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), i.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1, i.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1, this.dispatchEvent(DJ)));
    }
    return s !== null && (s.visible = i !== null), B !== null && (B.visible = n !== null), I !== null && (I.visible = r !== null), this;
  }
  // private method
  _getHandJoint(A, e) {
    if (A.joints[e.jointName] === void 0) {
      const t = new eo();
      t.matrixAutoUpdate = !1, t.visible = !1, A.joints[e.jointName] = t, A.add(t);
    }
    return A.joints[e.jointName];
  }
}
class Gy extends xi {
  constructor(A, e, t, i, n, r, s, B, I, E) {
    if (E = E !== void 0 ? E : EB, E !== EB && E !== LC)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    t === void 0 && E === EB && (t = aB), t === void 0 && E === LC && (t = NC), super(null, i, n, r, s, B, E, t, I), this.isDepthTexture = !0, this.image = { width: A, height: e }, this.magFilter = s !== void 0 ? s : un, this.minFilter = B !== void 0 ? B : un, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class wJ extends Za {
  constructor(A, e) {
    super();
    const t = this;
    let i = null, n = 1, r = null, s = "local-floor", B = 1, I = null, E = null, C = null, c = null, u = null, d = null;
    const p = e.getContextAttributes();
    let D = null, f = null;
    const S = [], y = [], m = /* @__PURE__ */ new Set(), N = /* @__PURE__ */ new Map(), F = new mn();
    F.layers.enable(1), F.viewport = new Bi();
    const G = new mn();
    G.layers.enable(2), G.viewport = new Bi();
    const k = [F, G], v = new bv();
    v.layers.enable(1), v.layers.enable(2);
    let x = null, H = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(QA) {
      let aA = S[QA];
      return aA === void 0 && (aA = new h0(), S[QA] = aA), aA.getTargetRaySpace();
    }, this.getControllerGrip = function(QA) {
      let aA = S[QA];
      return aA === void 0 && (aA = new h0(), S[QA] = aA), aA.getGripSpace();
    }, this.getHand = function(QA) {
      let aA = S[QA];
      return aA === void 0 && (aA = new h0(), S[QA] = aA), aA.getHandSpace();
    };
    function _(QA) {
      const aA = y.indexOf(QA.inputSource);
      if (aA === -1)
        return;
      const MA = S[aA];
      MA !== void 0 && MA.dispatchEvent({ type: QA.type, data: QA.inputSource });
    }
    function j() {
      i.removeEventListener("select", _), i.removeEventListener("selectstart", _), i.removeEventListener("selectend", _), i.removeEventListener("squeeze", _), i.removeEventListener("squeezestart", _), i.removeEventListener("squeezeend", _), i.removeEventListener("end", j), i.removeEventListener("inputsourceschange", V);
      for (let QA = 0; QA < S.length; QA++) {
        const aA = y[QA];
        aA !== null && (y[QA] = null, S[QA].disconnect(aA));
      }
      x = null, H = null, A.setRenderTarget(D), u = null, c = null, C = null, i = null, f = null, rA.stop(), t.isPresenting = !1, t.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(QA) {
      n = QA, t.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(QA) {
      s = QA, t.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return I || r;
    }, this.setReferenceSpace = function(QA) {
      I = QA;
    }, this.getBaseLayer = function() {
      return c !== null ? c : u;
    }, this.getBinding = function() {
      return C;
    }, this.getFrame = function() {
      return d;
    }, this.getSession = function() {
      return i;
    }, this.setSession = async function(QA) {
      if (i = QA, i !== null) {
        if (D = A.getRenderTarget(), i.addEventListener("select", _), i.addEventListener("selectstart", _), i.addEventListener("selectend", _), i.addEventListener("squeeze", _), i.addEventListener("squeezestart", _), i.addEventListener("squeezeend", _), i.addEventListener("end", j), i.addEventListener("inputsourceschange", V), p.xrCompatible !== !0 && await e.makeXRCompatible(), i.renderState.layers === void 0 || A.capabilities.isWebGL2 === !1) {
          const aA = {
            antialias: i.renderState.layers === void 0 ? p.antialias : !0,
            alpha: p.alpha,
            depth: p.depth,
            stencil: p.stencil,
            framebufferScaleFactor: n
          };
          u = new XRWebGLLayer(i, e, aA), i.updateRenderState({ baseLayer: u }), f = new Uo(
            u.framebufferWidth,
            u.framebufferHeight,
            {
              format: tr,
              type: Va,
              encoding: A.outputEncoding,
              stencilBuffer: p.stencil
            }
          );
        } else {
          let aA = null, MA = null, hA = null;
          p.depth && (hA = p.stencil ? 35056 : 33190, aA = p.stencil ? LC : EB, MA = p.stencil ? NC : aB);
          const fA = {
            colorFormat: 32856,
            depthFormat: hA,
            scaleFactor: n
          };
          C = new XRWebGLBinding(i, e), c = C.createProjectionLayer(fA), i.updateRenderState({ layers: [c] }), f = new Uo(
            c.textureWidth,
            c.textureHeight,
            {
              format: tr,
              type: Va,
              depthTexture: new Gy(c.textureWidth, c.textureHeight, MA, void 0, void 0, void 0, void 0, void 0, void 0, aA),
              stencilBuffer: p.stencil,
              encoding: A.outputEncoding,
              samples: p.antialias ? 4 : 0
            }
          );
          const wA = A.properties.get(f);
          wA.__ignoreDepthValues = c.ignoreDepthValues;
        }
        f.isXRRenderTarget = !0, this.setFoveation(B), I = null, r = await i.requestReferenceSpace(s), rA.setContext(i), rA.start(), t.isPresenting = !0, t.dispatchEvent({ type: "sessionstart" });
      }
    };
    function V(QA) {
      for (let aA = 0; aA < QA.removed.length; aA++) {
        const MA = QA.removed[aA], hA = y.indexOf(MA);
        hA >= 0 && (y[hA] = null, S[hA].disconnect(MA));
      }
      for (let aA = 0; aA < QA.added.length; aA++) {
        const MA = QA.added[aA];
        let hA = y.indexOf(MA);
        if (hA === -1) {
          for (let wA = 0; wA < S.length; wA++)
            if (wA >= y.length) {
              y.push(MA), hA = wA;
              break;
            } else if (y[wA] === null) {
              y[wA] = MA, hA = wA;
              break;
            }
          if (hA === -1)
            break;
        }
        const fA = S[hA];
        fA && fA.connect(MA);
      }
    }
    const iA = new IA(), eA = new IA();
    function oA(QA, aA, MA) {
      iA.setFromMatrixPosition(aA.matrixWorld), eA.setFromMatrixPosition(MA.matrixWorld);
      const hA = iA.distanceTo(eA), fA = aA.projectionMatrix.elements, wA = MA.projectionMatrix.elements, yA = fA[14] / (fA[10] - 1), kA = fA[14] / (fA[10] + 1), FA = (fA[9] + 1) / fA[5], dA = (fA[9] - 1) / fA[5], vA = (fA[8] - 1) / fA[0], JA = (wA[8] + 1) / wA[0], ne = yA * vA, ee = yA * JA, pe = hA / (-vA + JA), Ae = pe * -vA;
      aA.matrixWorld.decompose(QA.position, QA.quaternion, QA.scale), QA.translateX(Ae), QA.translateZ(pe), QA.matrixWorld.compose(QA.position, QA.quaternion, QA.scale), QA.matrixWorldInverse.copy(QA.matrixWorld).invert();
      const ie = yA + pe, de = kA + pe, O = ne - Ae, AA = ee + (hA - Ae), q = FA * kA / de * ie, Z = dA * kA / de * ie;
      QA.projectionMatrix.makePerspective(O, AA, q, Z, ie, de), QA.projectionMatrixInverse.copy(QA.projectionMatrix).invert();
    }
    function P(QA, aA) {
      aA === null ? QA.matrixWorld.copy(QA.matrix) : QA.matrixWorld.multiplyMatrices(aA.matrixWorld, QA.matrix), QA.matrixWorldInverse.copy(QA.matrixWorld).invert();
    }
    this.updateCamera = function(QA) {
      if (i === null)
        return;
      v.near = G.near = F.near = QA.near, v.far = G.far = F.far = QA.far, (x !== v.near || H !== v.far) && (i.updateRenderState({
        depthNear: v.near,
        depthFar: v.far
      }), x = v.near, H = v.far);
      const aA = QA.parent, MA = v.cameras;
      P(v, aA);
      for (let hA = 0; hA < MA.length; hA++)
        P(MA[hA], aA);
      MA.length === 2 ? oA(v, F, G) : v.projectionMatrix.copy(F.projectionMatrix), J(QA, v, aA);
    };
    function J(QA, aA, MA) {
      MA === null ? QA.matrix.copy(aA.matrixWorld) : (QA.matrix.copy(MA.matrixWorld), QA.matrix.invert(), QA.matrix.multiply(aA.matrixWorld)), QA.matrix.decompose(QA.position, QA.quaternion, QA.scale), QA.updateMatrixWorld(!0);
      const hA = QA.children;
      for (let fA = 0, wA = hA.length; fA < wA; fA++)
        hA[fA].updateMatrixWorld(!0);
      QA.projectionMatrix.copy(aA.projectionMatrix), QA.projectionMatrixInverse.copy(aA.projectionMatrixInverse), QA.isPerspectiveCamera && (QA.fov = GE * 2 * Math.atan(1 / QA.projectionMatrix.elements[5]), QA.zoom = 1);
    }
    this.getCamera = function() {
      return v;
    }, this.getFoveation = function() {
      if (!(c === null && u === null))
        return B;
    }, this.setFoveation = function(QA) {
      B = QA, c !== null && (c.fixedFoveation = QA), u !== null && u.fixedFoveation !== void 0 && (u.fixedFoveation = QA);
    }, this.getPlanes = function() {
      return m;
    };
    let tA = null;
    function Y(QA, aA) {
      if (E = aA.getViewerPose(I || r), d = aA, E !== null) {
        const MA = E.views;
        u !== null && (A.setRenderTargetFramebuffer(f, u.framebuffer), A.setRenderTarget(f));
        let hA = !1;
        MA.length !== v.cameras.length && (v.cameras.length = 0, hA = !0);
        for (let fA = 0; fA < MA.length; fA++) {
          const wA = MA[fA];
          let yA = null;
          if (u !== null)
            yA = u.getViewport(wA);
          else {
            const FA = C.getViewSubImage(c, wA);
            yA = FA.viewport, fA === 0 && (A.setRenderTargetTextures(
              f,
              FA.colorTexture,
              c.ignoreDepthValues ? void 0 : FA.depthStencilTexture
            ), A.setRenderTarget(f));
          }
          let kA = k[fA];
          kA === void 0 && (kA = new mn(), kA.layers.enable(fA), kA.viewport = new Bi(), k[fA] = kA), kA.matrix.fromArray(wA.transform.matrix), kA.matrix.decompose(kA.position, kA.quaternion, kA.scale), kA.projectionMatrix.fromArray(wA.projectionMatrix), kA.projectionMatrixInverse.copy(kA.projectionMatrix).invert(), kA.viewport.set(yA.x, yA.y, yA.width, yA.height), fA === 0 && (v.matrix.copy(kA.matrix), v.matrix.decompose(v.position, v.quaternion, v.scale)), hA === !0 && v.cameras.push(kA);
        }
      }
      for (let MA = 0; MA < S.length; MA++) {
        const hA = y[MA], fA = S[MA];
        hA !== null && fA !== void 0 && fA.update(hA, aA, I || r);
      }
      if (tA && tA(QA, aA), aA.detectedPlanes) {
        t.dispatchEvent({ type: "planesdetected", data: aA.detectedPlanes });
        let MA = null;
        for (const hA of m)
          aA.detectedPlanes.has(hA) || (MA === null && (MA = []), MA.push(hA));
        if (MA !== null)
          for (const hA of MA)
            m.delete(hA), N.delete(hA), t.dispatchEvent({ type: "planeremoved", data: hA });
        for (const hA of aA.detectedPlanes)
          if (!m.has(hA))
            m.add(hA), N.set(hA, aA.lastChangedTime), t.dispatchEvent({ type: "planeadded", data: hA });
          else {
            const fA = N.get(hA);
            hA.lastChangedTime > fA && (N.set(hA, hA.lastChangedTime), t.dispatchEvent({ type: "planechanged", data: hA }));
          }
      }
      d = null;
    }
    const rA = new Uv();
    rA.setAnimationLoop(Y), this.setAnimationLoop = function(QA) {
      tA = QA;
    }, this.dispose = function() {
    };
  }
}
function yJ(g, A) {
  function e(D, f) {
    D.matrixAutoUpdate === !0 && D.updateMatrix(), f.value.copy(D.matrix);
  }
  function t(D, f) {
    f.color.getRGB(D.fogColor.value, Nv(g)), f.isFog ? (D.fogNear.value = f.near, D.fogFar.value = f.far) : f.isFogExp2 && (D.fogDensity.value = f.density);
  }
  function i(D, f, S, y, m) {
    f.isMeshBasicMaterial || f.isMeshLambertMaterial ? n(D, f) : f.isMeshToonMaterial ? (n(D, f), C(D, f)) : f.isMeshPhongMaterial ? (n(D, f), E(D, f)) : f.isMeshStandardMaterial ? (n(D, f), c(D, f), f.isMeshPhysicalMaterial && u(D, f, m)) : f.isMeshMatcapMaterial ? (n(D, f), d(D, f)) : f.isMeshDepthMaterial ? n(D, f) : f.isMeshDistanceMaterial ? (n(D, f), p(D, f)) : f.isMeshNormalMaterial ? n(D, f) : f.isLineBasicMaterial ? (r(D, f), f.isLineDashedMaterial && s(D, f)) : f.isPointsMaterial ? B(D, f, S, y) : f.isSpriteMaterial ? I(D, f) : f.isShadowMaterial ? (D.color.value.copy(f.color), D.opacity.value = f.opacity) : f.isShaderMaterial && (f.uniformsNeedUpdate = !1);
  }
  function n(D, f) {
    D.opacity.value = f.opacity, f.color && D.diffuse.value.copy(f.color), f.emissive && D.emissive.value.copy(f.emissive).multiplyScalar(f.emissiveIntensity), f.map && (D.map.value = f.map, e(f.map, D.mapTransform)), f.alphaMap && (D.alphaMap.value = f.alphaMap, e(f.alphaMap, D.alphaMapTransform)), f.bumpMap && (D.bumpMap.value = f.bumpMap, e(f.bumpMap, D.bumpMapTransform), D.bumpScale.value = f.bumpScale, f.side === ir && (D.bumpScale.value *= -1)), f.normalMap && (D.normalMap.value = f.normalMap, e(f.normalMap, D.normalMapTransform), D.normalScale.value.copy(f.normalScale), f.side === ir && D.normalScale.value.negate()), f.displacementMap && (D.displacementMap.value = f.displacementMap, e(f.displacementMap, D.displacementMapTransform), D.displacementScale.value = f.displacementScale, D.displacementBias.value = f.displacementBias), f.emissiveMap && (D.emissiveMap.value = f.emissiveMap, e(f.emissiveMap, D.emissiveMapTransform)), f.specularMap && (D.specularMap.value = f.specularMap, e(f.specularMap, D.specularMapTransform)), f.alphaTest > 0 && (D.alphaTest.value = f.alphaTest);
    const S = A.get(f).envMap;
    if (S && (D.envMap.value = S, D.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1, D.reflectivity.value = f.reflectivity, D.ior.value = f.ior, D.refractionRatio.value = f.refractionRatio), f.lightMap) {
      D.lightMap.value = f.lightMap;
      const y = g.useLegacyLights === !0 ? Math.PI : 1;
      D.lightMapIntensity.value = f.lightMapIntensity * y, e(f.lightMap, D.lightMapTransform);
    }
    f.aoMap && (D.aoMap.value = f.aoMap, D.aoMapIntensity.value = f.aoMapIntensity, e(f.aoMap, D.aoMapTransform));
  }
  function r(D, f) {
    D.diffuse.value.copy(f.color), D.opacity.value = f.opacity, f.map && (D.map.value = f.map, e(f.map, D.mapTransform));
  }
  function s(D, f) {
    D.dashSize.value = f.dashSize, D.totalSize.value = f.dashSize + f.gapSize, D.scale.value = f.scale;
  }
  function B(D, f, S, y) {
    D.diffuse.value.copy(f.color), D.opacity.value = f.opacity, D.size.value = f.size * S, D.scale.value = y * 0.5, f.map && (D.map.value = f.map, e(f.map, D.uvTransform)), f.alphaMap && (D.alphaMap.value = f.alphaMap), f.alphaTest > 0 && (D.alphaTest.value = f.alphaTest);
  }
  function I(D, f) {
    D.diffuse.value.copy(f.color), D.opacity.value = f.opacity, D.rotation.value = f.rotation, f.map && (D.map.value = f.map, e(f.map, D.mapTransform)), f.alphaMap && (D.alphaMap.value = f.alphaMap), f.alphaTest > 0 && (D.alphaTest.value = f.alphaTest);
  }
  function E(D, f) {
    D.specular.value.copy(f.specular), D.shininess.value = Math.max(f.shininess, 1e-4);
  }
  function C(D, f) {
    f.gradientMap && (D.gradientMap.value = f.gradientMap);
  }
  function c(D, f) {
    D.metalness.value = f.metalness, f.metalnessMap && (D.metalnessMap.value = f.metalnessMap, e(f.metalnessMap, D.metalnessMapTransform)), D.roughness.value = f.roughness, f.roughnessMap && (D.roughnessMap.value = f.roughnessMap, e(f.roughnessMap, D.roughnessMapTransform)), A.get(f).envMap && (D.envMapIntensity.value = f.envMapIntensity);
  }
  function u(D, f, S) {
    D.ior.value = f.ior, f.sheen > 0 && (D.sheenColor.value.copy(f.sheenColor).multiplyScalar(f.sheen), D.sheenRoughness.value = f.sheenRoughness, f.sheenColorMap && (D.sheenColorMap.value = f.sheenColorMap, e(f.sheenColorMap, D.sheenColorMapTransform)), f.sheenRoughnessMap && (D.sheenRoughnessMap.value = f.sheenRoughnessMap, e(f.sheenRoughnessMap, D.sheenRoughnessMapTransform))), f.clearcoat > 0 && (D.clearcoat.value = f.clearcoat, D.clearcoatRoughness.value = f.clearcoatRoughness, f.clearcoatMap && (D.clearcoatMap.value = f.clearcoatMap, e(f.clearcoatMap, D.clearcoatMapTransform)), f.clearcoatRoughnessMap && (D.clearcoatRoughnessMap.value = f.clearcoatRoughnessMap, e(f.clearcoatRoughnessMap, D.clearcoatRoughnessMapTransform)), f.clearcoatNormalMap && (D.clearcoatNormalMap.value = f.clearcoatNormalMap, e(f.clearcoatNormalMap, D.clearcoatNormalMapTransform), D.clearcoatNormalScale.value.copy(f.clearcoatNormalScale), f.side === ir && D.clearcoatNormalScale.value.negate())), f.iridescence > 0 && (D.iridescence.value = f.iridescence, D.iridescenceIOR.value = f.iridescenceIOR, D.iridescenceThicknessMinimum.value = f.iridescenceThicknessRange[0], D.iridescenceThicknessMaximum.value = f.iridescenceThicknessRange[1], f.iridescenceMap && (D.iridescenceMap.value = f.iridescenceMap, e(f.iridescenceMap, D.iridescenceMapTransform)), f.iridescenceThicknessMap && (D.iridescenceThicknessMap.value = f.iridescenceThicknessMap, e(f.iridescenceThicknessMap, D.iridescenceThicknessMapTransform))), f.transmission > 0 && (D.transmission.value = f.transmission, D.transmissionSamplerMap.value = S.texture, D.transmissionSamplerSize.value.set(S.width, S.height), f.transmissionMap && (D.transmissionMap.value = f.transmissionMap, e(f.transmissionMap, D.transmissionMapTransform)), D.thickness.value = f.thickness, f.thicknessMap && (D.thicknessMap.value = f.thicknessMap, e(f.thicknessMap, D.thicknessMapTransform)), D.attenuationDistance.value = f.attenuationDistance, D.attenuationColor.value.copy(f.attenuationColor)), D.specularIntensity.value = f.specularIntensity, D.specularColor.value.copy(f.specularColor), f.specularColorMap && (D.specularColorMap.value = f.specularColorMap, e(f.specularColorMap, D.specularColorMapTransform)), f.specularIntensityMap && (D.specularIntensityMap.value = f.specularIntensityMap, e(f.specularIntensityMap, D.specularIntensityMapTransform));
  }
  function d(D, f) {
    f.matcap && (D.matcap.value = f.matcap);
  }
  function p(D, f) {
    const S = A.get(f).light;
    D.referencePosition.value.setFromMatrixPosition(S.matrixWorld), D.nearDistance.value = S.shadow.camera.near, D.farDistance.value = S.shadow.camera.far;
  }
  return {
    refreshFogUniforms: t,
    refreshMaterialUniforms: i
  };
}
function mJ(g, A, e, t) {
  let i = {}, n = {}, r = [];
  const s = e.isWebGL2 ? g.getParameter(35375) : 0;
  function B(S, y) {
    const m = y.program;
    t.uniformBlockBinding(S, m);
  }
  function I(S, y) {
    let m = i[S.id];
    m === void 0 && (d(S), m = E(S), i[S.id] = m, S.addEventListener("dispose", D));
    const N = y.program;
    t.updateUBOMapping(S, N);
    const F = A.render.frame;
    n[S.id] !== F && (c(S), n[S.id] = F);
  }
  function E(S) {
    const y = C();
    S.__bindingPointIndex = y;
    const m = g.createBuffer(), N = S.__size, F = S.usage;
    return g.bindBuffer(35345, m), g.bufferData(35345, N, F), g.bindBuffer(35345, null), g.bindBufferBase(35345, y, m), m;
  }
  function C() {
    for (let S = 0; S < s; S++)
      if (r.indexOf(S) === -1)
        return r.push(S), S;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function c(S) {
    const y = i[S.id], m = S.uniforms, N = S.__cache;
    g.bindBuffer(35345, y);
    for (let F = 0, G = m.length; F < G; F++) {
      const k = m[F];
      if (u(k, F, N) === !0) {
        const v = k.__offset, x = Array.isArray(k.value) ? k.value : [k.value];
        let H = 0;
        for (let _ = 0; _ < x.length; _++) {
          const j = x[_], V = p(j);
          typeof j == "number" ? (k.__data[0] = j, g.bufferSubData(35345, v + H, k.__data)) : j.isMatrix3 ? (k.__data[0] = j.elements[0], k.__data[1] = j.elements[1], k.__data[2] = j.elements[2], k.__data[3] = j.elements[0], k.__data[4] = j.elements[3], k.__data[5] = j.elements[4], k.__data[6] = j.elements[5], k.__data[7] = j.elements[0], k.__data[8] = j.elements[6], k.__data[9] = j.elements[7], k.__data[10] = j.elements[8], k.__data[11] = j.elements[0]) : (j.toArray(k.__data, H), H += V.storage / Float32Array.BYTES_PER_ELEMENT);
        }
        g.bufferSubData(35345, v, k.__data);
      }
    }
    g.bindBuffer(35345, null);
  }
  function u(S, y, m) {
    const N = S.value;
    if (m[y] === void 0) {
      if (typeof N == "number")
        m[y] = N;
      else {
        const F = Array.isArray(N) ? N : [N], G = [];
        for (let k = 0; k < F.length; k++)
          G.push(F[k].clone());
        m[y] = G;
      }
      return !0;
    } else if (typeof N == "number") {
      if (m[y] !== N)
        return m[y] = N, !0;
    } else {
      const F = Array.isArray(m[y]) ? m[y] : [m[y]], G = Array.isArray(N) ? N : [N];
      for (let k = 0; k < F.length; k++) {
        const v = F[k];
        if (v.equals(G[k]) === !1)
          return v.copy(G[k]), !0;
      }
    }
    return !1;
  }
  function d(S) {
    const y = S.uniforms;
    let m = 0;
    const N = 16;
    let F = 0;
    for (let G = 0, k = y.length; G < k; G++) {
      const v = y[G], x = {
        boundary: 0,
        // bytes
        storage: 0
        // bytes
      }, H = Array.isArray(v.value) ? v.value : [v.value];
      for (let _ = 0, j = H.length; _ < j; _++) {
        const V = H[_], iA = p(V);
        x.boundary += iA.boundary, x.storage += iA.storage;
      }
      if (v.__data = new Float32Array(x.storage / Float32Array.BYTES_PER_ELEMENT), v.__offset = m, G > 0) {
        F = m % N;
        const _ = N - F;
        F !== 0 && _ - x.boundary < 0 && (m += N - F, v.__offset = m);
      }
      m += x.storage;
    }
    return F = m % N, F > 0 && (m += N - F), S.__size = m, S.__cache = {}, this;
  }
  function p(S) {
    const y = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof S == "number" ? (y.boundary = 4, y.storage = 4) : S.isVector2 ? (y.boundary = 8, y.storage = 8) : S.isVector3 || S.isColor ? (y.boundary = 16, y.storage = 12) : S.isVector4 ? (y.boundary = 16, y.storage = 16) : S.isMatrix3 ? (y.boundary = 48, y.storage = 48) : S.isMatrix4 ? (y.boundary = 64, y.storage = 64) : S.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", S), y;
  }
  function D(S) {
    const y = S.target;
    y.removeEventListener("dispose", D);
    const m = r.indexOf(y.__bindingPointIndex);
    r.splice(m, 1), g.deleteBuffer(i[y.id]), delete i[y.id], delete n[y.id];
  }
  function f() {
    for (const S in i)
      g.deleteBuffer(i[S]);
    r = [], i = {}, n = {};
  }
  return {
    bind: B,
    update: I,
    dispose: f
  };
}
function SJ() {
  const g = Kc("canvas");
  return g.style.display = "block", g;
}
class vy {
  constructor(A = {}) {
    const {
      canvas: e = SJ(),
      context: t = null,
      depth: i = !0,
      stencil: n = !0,
      alpha: r = !1,
      antialias: s = !1,
      premultipliedAlpha: B = !0,
      preserveDrawingBuffer: I = !1,
      powerPreference: E = "default",
      failIfMajorPerformanceCaveat: C = !1
    } = A;
    this.isWebGLRenderer = !0;
    let c;
    t !== null ? c = t.getContextAttributes().alpha : c = r;
    let u = null, d = null;
    const p = [], D = [];
    this.domElement = e, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = ta, this.useLegacyLights = !0, this.toneMapping = Is, this.toneMappingExposure = 1;
    const f = this;
    let S = !1, y = 0, m = 0, N = null, F = -1, G = null;
    const k = new Bi(), v = new Bi();
    let x = null, H = e.width, _ = e.height, j = 1, V = null, iA = null;
    const eA = new Bi(0, 0, H, _), oA = new Bi(0, 0, H, _);
    let P = !1;
    const J = new Ff();
    let tA = !1, Y = !1, rA = null;
    const QA = new Ve(), aA = new IA(), MA = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    function hA() {
      return N === null ? j : 1;
    }
    let fA = t;
    function wA(lA, jA) {
      for (let se = 0; se < lA.length; se++) {
        const PA = lA[se], Be = e.getContext(PA, jA);
        if (Be !== null)
          return Be;
      }
      return null;
    }
    try {
      const lA = {
        alpha: !0,
        depth: i,
        stencil: n,
        antialias: s,
        premultipliedAlpha: B,
        preserveDrawingBuffer: I,
        powerPreference: E,
        failIfMajorPerformanceCaveat: C
      };
      if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${yf}`), e.addEventListener("webglcontextlost", _A, !1), e.addEventListener("webglcontextrestored", Se, !1), e.addEventListener("webglcontextcreationerror", cA, !1), fA === null) {
        const jA = ["webgl2", "webgl", "experimental-webgl"];
        if (f.isWebGL1Renderer === !0 && jA.shift(), fA = wA(jA, lA), fA === null)
          throw wA(jA) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      fA.getShaderPrecisionFormat === void 0 && (fA.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (lA) {
      throw console.error("THREE.WebGLRenderer: " + lA.message), lA;
    }
    let yA, kA, FA, dA, vA, JA, ne, ee, pe, Ae, ie, de, O, AA, q, Z, $, BA, GA, bA, DA, SA, EA, mA;
    function YA() {
      yA = new _H(fA), kA = new LH(fA, yA, A), yA.init(kA), SA = new Kv(fA, yA, kA), FA = new fJ(fA, yA, kA), dA = new qH(), vA = new sJ(), JA = new pJ(fA, yA, FA, vA, kA, SA, dA), ne = new KH(f), ee = new HH(f), pe = new i2(fA, kA), EA = new kH(fA, yA, pe, kA), Ae = new JH(fA, pe, dA, EA), ie = new VH(fA, Ae, pe, dA), GA = new zH(fA, kA, JA), Z = new TH(vA), de = new oJ(f, ne, ee, yA, kA, EA, Z), O = new yJ(f, vA), AA = new IJ(), q = new cJ(yA, kA), BA = new UH(f, ne, ee, FA, ie, c, B), $ = new dJ(f, ie, kA), mA = new mJ(fA, dA, kA, FA), bA = new xH(fA, yA, dA, kA), DA = new OH(fA, yA, dA, kA), dA.programs = de.programs, f.capabilities = kA, f.extensions = yA, f.properties = vA, f.renderLists = AA, f.shadowMap = $, f.state = FA, f.info = dA;
    }
    YA();
    const ZA = new wJ(f, fA);
    this.xr = ZA, this.getContext = function() {
      return fA;
    }, this.getContextAttributes = function() {
      return fA.getContextAttributes();
    }, this.forceContextLoss = function() {
      const lA = yA.get("WEBGL_lose_context");
      lA && lA.loseContext();
    }, this.forceContextRestore = function() {
      const lA = yA.get("WEBGL_lose_context");
      lA && lA.restoreContext();
    }, this.getPixelRatio = function() {
      return j;
    }, this.setPixelRatio = function(lA) {
      lA !== void 0 && (j = lA, this.setSize(H, _, !1));
    }, this.getSize = function(lA) {
      return lA.set(H, _);
    }, this.setSize = function(lA, jA, se = !0) {
      if (ZA.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      H = lA, _ = jA, e.width = Math.floor(lA * j), e.height = Math.floor(jA * j), se === !0 && (e.style.width = lA + "px", e.style.height = jA + "px"), this.setViewport(0, 0, lA, jA);
    }, this.getDrawingBufferSize = function(lA) {
      return lA.set(H * j, _ * j).floor();
    }, this.setDrawingBufferSize = function(lA, jA, se) {
      H = lA, _ = jA, j = se, e.width = Math.floor(lA * se), e.height = Math.floor(jA * se), this.setViewport(0, 0, lA, jA);
    }, this.getCurrentViewport = function(lA) {
      return lA.copy(k);
    }, this.getViewport = function(lA) {
      return lA.copy(eA);
    }, this.setViewport = function(lA, jA, se, PA) {
      lA.isVector4 ? eA.set(lA.x, lA.y, lA.z, lA.w) : eA.set(lA, jA, se, PA), FA.viewport(k.copy(eA).multiplyScalar(j).floor());
    }, this.getScissor = function(lA) {
      return lA.copy(oA);
    }, this.setScissor = function(lA, jA, se, PA) {
      lA.isVector4 ? oA.set(lA.x, lA.y, lA.z, lA.w) : oA.set(lA, jA, se, PA), FA.scissor(v.copy(oA).multiplyScalar(j).floor());
    }, this.getScissorTest = function() {
      return P;
    }, this.setScissorTest = function(lA) {
      FA.setScissorTest(P = lA);
    }, this.setOpaqueSort = function(lA) {
      V = lA;
    }, this.setTransparentSort = function(lA) {
      iA = lA;
    }, this.getClearColor = function(lA) {
      return lA.copy(BA.getClearColor());
    }, this.setClearColor = function() {
      BA.setClearColor.apply(BA, arguments);
    }, this.getClearAlpha = function() {
      return BA.getClearAlpha();
    }, this.setClearAlpha = function() {
      BA.setClearAlpha.apply(BA, arguments);
    }, this.clear = function(lA = !0, jA = !0, se = !0) {
      let PA = 0;
      lA && (PA |= 16384), jA && (PA |= 256), se && (PA |= 1024), fA.clear(PA);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      e.removeEventListener("webglcontextlost", _A, !1), e.removeEventListener("webglcontextrestored", Se, !1), e.removeEventListener("webglcontextcreationerror", cA, !1), AA.dispose(), q.dispose(), vA.dispose(), ne.dispose(), ee.dispose(), ie.dispose(), EA.dispose(), mA.dispose(), de.dispose(), ZA.dispose(), ZA.removeEventListener("sessionstart", ge), ZA.removeEventListener("sessionend", Me), rA && (rA.dispose(), rA = null), xe.stop();
    };
    function _A(lA) {
      lA.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), S = !0;
    }
    function Se() {
      console.log("THREE.WebGLRenderer: Context Restored."), S = !1;
      const lA = dA.autoReset, jA = $.enabled, se = $.autoUpdate, PA = $.needsUpdate, Be = $.type;
      YA(), dA.autoReset = lA, $.enabled = jA, $.autoUpdate = se, $.needsUpdate = PA, $.type = Be;
    }
    function cA(lA) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", lA.statusMessage);
    }
    function xA(lA) {
      const jA = lA.target;
      jA.removeEventListener("dispose", xA), gA(jA);
    }
    function gA(lA) {
      RA(lA), vA.remove(lA);
    }
    function RA(lA) {
      const jA = vA.get(lA).programs;
      jA !== void 0 && (jA.forEach(function(se) {
        de.releaseProgram(se);
      }), lA.isShaderMaterial && de.releaseShaderCache(lA));
    }
    this.renderBufferDirect = function(lA, jA, se, PA, Be, At) {
      jA === null && (jA = MA);
      const rt = Be.isMesh && Be.matrixWorld.determinant() < 0, it = vi(lA, jA, se, PA, Be);
      FA.setMaterial(PA, rt);
      let Et = se.index, Bt = 1;
      PA.wireframe === !0 && (Et = Ae.getWireframeAttribute(se), Bt = 2);
      const ft = se.drawRange, tt = se.attributes.position;
      let Ft = ft.start * Bt, ui = (ft.start + ft.count) * Bt;
      At !== null && (Ft = Math.max(Ft, At.start * Bt), ui = Math.min(ui, (At.start + At.count) * Bt)), Et !== null ? (Ft = Math.max(Ft, 0), ui = Math.min(ui, Et.count)) : tt != null && (Ft = Math.max(Ft, 0), ui = Math.min(ui, tt.count));
      const Li = ui - Ft;
      if (Li < 0 || Li === 1 / 0)
        return;
      EA.setup(Be, PA, it, se, Et);
      let $i, hi = bA;
      if (Et !== null && ($i = pe.get(Et), hi = DA, hi.setIndex($i)), Be.isMesh)
        PA.wireframe === !0 ? (FA.setLineWidth(PA.wireframeLinewidth * hA()), hi.setMode(1)) : hi.setMode(4);
      else if (Be.isLine) {
        let pt = PA.linewidth;
        pt === void 0 && (pt = 1), FA.setLineWidth(pt * hA()), Be.isLineSegments ? hi.setMode(1) : Be.isLineLoop ? hi.setMode(2) : hi.setMode(3);
      } else
        Be.isPoints ? hi.setMode(0) : Be.isSprite && hi.setMode(4);
      if (Be.isInstancedMesh)
        hi.renderInstances(Ft, Li, Be.count);
      else if (se.isInstancedBufferGeometry) {
        const pt = se._maxInstanceCount !== void 0 ? se._maxInstanceCount : 1 / 0, Gr = Math.min(se.instanceCount, pt);
        hi.renderInstances(Ft, Li, Gr);
      } else
        hi.render(Ft, Li);
    }, this.compile = function(lA, jA) {
      function se(PA, Be, At) {
        PA.transparent === !0 && PA.side === Rr && PA.forceSinglePass === !1 ? (PA.side = ir, PA.needsUpdate = !0, Nt(PA, Be, At), PA.side = ea, PA.needsUpdate = !0, Nt(PA, Be, At), PA.side = Rr) : Nt(PA, Be, At);
      }
      d = q.get(lA), d.init(), D.push(d), lA.traverseVisible(function(PA) {
        PA.isLight && PA.layers.test(jA.layers) && (d.pushLight(PA), PA.castShadow && d.pushShadow(PA));
      }), d.setupLights(f.useLegacyLights), lA.traverse(function(PA) {
        const Be = PA.material;
        if (Be)
          if (Array.isArray(Be))
            for (let At = 0; At < Be.length; At++) {
              const rt = Be[At];
              se(rt, lA, PA);
            }
          else
            se(Be, lA, PA);
      }), D.pop(), d = null;
    };
    let UA = null;
    function TA(lA) {
      UA && UA(lA);
    }
    function ge() {
      xe.stop();
    }
    function Me() {
      xe.start();
    }
    const xe = new Uv();
    xe.setAnimationLoop(TA), typeof self < "u" && xe.setContext(self), this.setAnimationLoop = function(lA) {
      UA = lA, ZA.setAnimationLoop(lA), lA === null ? xe.stop() : xe.start();
    }, ZA.addEventListener("sessionstart", ge), ZA.addEventListener("sessionend", Me), this.render = function(lA, jA) {
      if (jA !== void 0 && jA.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (S === !0)
        return;
      lA.matrixWorldAutoUpdate === !0 && lA.updateMatrixWorld(), jA.parent === null && jA.matrixWorldAutoUpdate === !0 && jA.updateMatrixWorld(), ZA.enabled === !0 && ZA.isPresenting === !0 && (ZA.cameraAutoUpdate === !0 && ZA.updateCamera(jA), jA = ZA.getCamera()), lA.isScene === !0 && lA.onBeforeRender(f, lA, jA, N), d = q.get(lA, D.length), d.init(), D.push(d), QA.multiplyMatrices(jA.projectionMatrix, jA.matrixWorldInverse), J.setFromProjectionMatrix(QA), Y = this.localClippingEnabled, tA = Z.init(this.clippingPlanes, Y), u = AA.get(lA, p.length), u.init(), p.push(u), we(lA, jA, 0, f.sortObjects), u.finish(), f.sortObjects === !0 && u.sort(V, iA), tA === !0 && Z.beginShadows();
      const se = d.state.shadowsArray;
      if ($.render(se, lA, jA), tA === !0 && Z.endShadows(), this.info.autoReset === !0 && this.info.reset(), BA.render(u, lA), d.setupLights(f.useLegacyLights), jA.isArrayCamera) {
        const PA = jA.cameras;
        for (let Be = 0, At = PA.length; Be < At; Be++) {
          const rt = PA[Be];
          Ee(u, lA, rt, rt.viewport);
        }
      } else
        Ee(u, lA, jA);
      N !== null && (JA.updateMultisampleRenderTarget(N), JA.updateRenderTargetMipmap(N)), lA.isScene === !0 && lA.onAfterRender(f, lA, jA), EA.resetDefaultState(), F = -1, G = null, D.pop(), D.length > 0 ? d = D[D.length - 1] : d = null, p.pop(), p.length > 0 ? u = p[p.length - 1] : u = null;
    };
    function we(lA, jA, se, PA) {
      if (lA.visible === !1)
        return;
      if (lA.layers.test(jA.layers)) {
        if (lA.isGroup)
          se = lA.renderOrder;
        else if (lA.isLOD)
          lA.autoUpdate === !0 && lA.update(jA);
        else if (lA.isLight)
          d.pushLight(lA), lA.castShadow && d.pushShadow(lA);
        else if (lA.isSprite) {
          if (!lA.frustumCulled || J.intersectsSprite(lA)) {
            PA && aA.setFromMatrixPosition(lA.matrixWorld).applyMatrix4(QA);
            const rt = ie.update(lA), it = lA.material;
            it.visible && u.push(lA, rt, it, se, aA.z, null);
          }
        } else if ((lA.isMesh || lA.isLine || lA.isPoints) && (lA.isSkinnedMesh && lA.skeleton.frame !== dA.render.frame && (lA.skeleton.update(), lA.skeleton.frame = dA.render.frame), !lA.frustumCulled || J.intersectsObject(lA))) {
          PA && aA.setFromMatrixPosition(lA.matrixWorld).applyMatrix4(QA);
          const rt = ie.update(lA), it = lA.material;
          if (Array.isArray(it)) {
            const Et = rt.groups;
            for (let Bt = 0, ft = Et.length; Bt < ft; Bt++) {
              const tt = Et[Bt], Ft = it[tt.materialIndex];
              Ft && Ft.visible && u.push(lA, rt, Ft, se, aA.z, tt);
            }
          } else
            it.visible && u.push(lA, rt, it, se, aA.z, null);
        }
      }
      const At = lA.children;
      for (let rt = 0, it = At.length; rt < it; rt++)
        we(At[rt], jA, se, PA);
    }
    function Ee(lA, jA, se, PA) {
      const Be = lA.opaque, At = lA.transmissive, rt = lA.transparent;
      d.setupLightsView(se), tA === !0 && Z.setGlobalState(f.clippingPlanes, se), At.length > 0 && he(Be, At, jA, se), PA && FA.viewport(k.copy(PA)), Be.length > 0 && _e(Be, jA, se), At.length > 0 && _e(At, jA, se), rt.length > 0 && _e(rt, jA, se), FA.buffers.depth.setTest(!0), FA.buffers.depth.setMask(!0), FA.buffers.color.setMask(!0), FA.setPolygonOffset(!1);
    }
    function he(lA, jA, se, PA) {
      if (rA === null) {
        const it = kA.isWebGL2;
        rA = new Uo(1024, 1024, {
          generateMipmaps: !0,
          type: yA.has("EXT_color_buffer_half_float") ? xC : Va,
          minFilter: Cs,
          samples: it && s === !0 ? 4 : 0
        });
      }
      const Be = f.getRenderTarget();
      f.setRenderTarget(rA), f.clear();
      const At = f.toneMapping;
      f.toneMapping = Is, _e(lA, se, PA), JA.updateMultisampleRenderTarget(rA), JA.updateRenderTargetMipmap(rA);
      let rt = !1;
      for (let it = 0, Et = jA.length; it < Et; it++) {
        const Bt = jA[it], ft = Bt.object, tt = Bt.geometry, Ft = Bt.material, ui = Bt.group;
        if (Ft.side === Rr && ft.layers.test(PA.layers)) {
          const Li = Ft.side;
          Ft.side = ir, Ft.needsUpdate = !0, Pe(ft, se, PA, tt, Ft, ui), Ft.side = Li, Ft.needsUpdate = !0, rt = !0;
        }
      }
      rt === !0 && (JA.updateMultisampleRenderTarget(rA), JA.updateRenderTargetMipmap(rA)), f.setRenderTarget(Be), f.toneMapping = At;
    }
    function _e(lA, jA, se) {
      const PA = jA.isScene === !0 ? jA.overrideMaterial : null;
      for (let Be = 0, At = lA.length; Be < At; Be++) {
        const rt = lA[Be], it = rt.object, Et = rt.geometry, Bt = PA === null ? rt.material : PA, ft = rt.group;
        it.layers.test(se.layers) && Pe(it, jA, se, Et, Bt, ft);
      }
    }
    function Pe(lA, jA, se, PA, Be, At) {
      lA.onBeforeRender(f, jA, se, PA, Be, At), lA.modelViewMatrix.multiplyMatrices(se.matrixWorldInverse, lA.matrixWorld), lA.normalMatrix.getNormalMatrix(lA.modelViewMatrix), Be.onBeforeRender(f, jA, se, PA, lA, At), Be.transparent === !0 && Be.side === Rr && Be.forceSinglePass === !1 ? (Be.side = ir, Be.needsUpdate = !0, f.renderBufferDirect(se, jA, PA, Be, lA, At), Be.side = ea, Be.needsUpdate = !0, f.renderBufferDirect(se, jA, PA, Be, lA, At), Be.side = Rr) : f.renderBufferDirect(se, jA, PA, Be, lA, At), lA.onAfterRender(f, jA, se, PA, Be, At);
    }
    function Nt(lA, jA, se) {
      jA.isScene !== !0 && (jA = MA);
      const PA = vA.get(lA), Be = d.state.lights, At = d.state.shadowsArray, rt = Be.state.version, it = de.getParameters(lA, Be.state, At, jA, se), Et = de.getProgramCacheKey(it);
      let Bt = PA.programs;
      PA.environment = lA.isMeshStandardMaterial ? jA.environment : null, PA.fog = jA.fog, PA.envMap = (lA.isMeshStandardMaterial ? ee : ne).get(lA.envMap || PA.environment), Bt === void 0 && (lA.addEventListener("dispose", xA), Bt = /* @__PURE__ */ new Map(), PA.programs = Bt);
      let ft = Bt.get(Et);
      if (ft !== void 0) {
        if (PA.currentProgram === ft && PA.lightsStateVersion === rt)
          return Jt(lA, it), ft;
      } else
        it.uniforms = de.getUniforms(lA), lA.onBuild(se, it, f), lA.onBeforeCompile(it, f), ft = de.acquireProgram(it, Et), Bt.set(Et, ft), PA.uniforms = it.uniforms;
      const tt = PA.uniforms;
      (!lA.isShaderMaterial && !lA.isRawShaderMaterial || lA.clipping === !0) && (tt.clippingPlanes = Z.uniform), Jt(lA, it), PA.needsLights = Ri(lA), PA.lightsStateVersion = rt, PA.needsLights && (tt.ambientLightColor.value = Be.state.ambient, tt.lightProbe.value = Be.state.probe, tt.directionalLights.value = Be.state.directional, tt.directionalLightShadows.value = Be.state.directionalShadow, tt.spotLights.value = Be.state.spot, tt.spotLightShadows.value = Be.state.spotShadow, tt.rectAreaLights.value = Be.state.rectArea, tt.ltc_1.value = Be.state.rectAreaLTC1, tt.ltc_2.value = Be.state.rectAreaLTC2, tt.pointLights.value = Be.state.point, tt.pointLightShadows.value = Be.state.pointShadow, tt.hemisphereLights.value = Be.state.hemi, tt.directionalShadowMap.value = Be.state.directionalShadowMap, tt.directionalShadowMatrix.value = Be.state.directionalShadowMatrix, tt.spotShadowMap.value = Be.state.spotShadowMap, tt.spotLightMatrix.value = Be.state.spotLightMatrix, tt.spotLightMap.value = Be.state.spotLightMap, tt.pointShadowMap.value = Be.state.pointShadowMap, tt.pointShadowMatrix.value = Be.state.pointShadowMatrix);
      const Ft = ft.getUniforms(), ui = gf.seqWithValue(Ft.seq, tt);
      return PA.currentProgram = ft, PA.uniformsList = ui, ft;
    }
    function Jt(lA, jA) {
      const se = vA.get(lA);
      se.outputEncoding = jA.outputEncoding, se.instancing = jA.instancing, se.skinning = jA.skinning, se.morphTargets = jA.morphTargets, se.morphNormals = jA.morphNormals, se.morphColors = jA.morphColors, se.morphTargetsCount = jA.morphTargetsCount, se.numClippingPlanes = jA.numClippingPlanes, se.numIntersection = jA.numClipIntersection, se.vertexAlphas = jA.vertexAlphas, se.vertexTangents = jA.vertexTangents, se.toneMapping = jA.toneMapping;
    }
    function vi(lA, jA, se, PA, Be) {
      jA.isScene !== !0 && (jA = MA), JA.resetTextureUnits();
      const At = jA.fog, rt = PA.isMeshStandardMaterial ? jA.environment : null, it = N === null ? f.outputEncoding : N.isXRRenderTarget === !0 ? N.texture.encoding : ta, Et = (PA.isMeshStandardMaterial ? ee : ne).get(PA.envMap || rt), Bt = PA.vertexColors === !0 && !!se.attributes.color && se.attributes.color.itemSize === 4, ft = !!PA.normalMap && !!se.attributes.tangent, tt = !!se.morphAttributes.position, Ft = !!se.morphAttributes.normal, ui = !!se.morphAttributes.color, Li = PA.toneMapped ? f.toneMapping : Is, $i = se.morphAttributes.position || se.morphAttributes.normal || se.morphAttributes.color, hi = $i !== void 0 ? $i.length : 0, pt = vA.get(PA), Gr = d.state.lights;
      if (tA === !0 && (Y === !0 || lA !== G)) {
        const Mt = lA === G && PA.id === F;
        Z.setState(PA, lA, Mt);
      }
      let Ui = !1;
      PA.version === pt.__version ? (pt.needsLights && pt.lightsStateVersion !== Gr.state.version || pt.outputEncoding !== it || Be.isInstancedMesh && pt.instancing === !1 || !Be.isInstancedMesh && pt.instancing === !0 || Be.isSkinnedMesh && pt.skinning === !1 || !Be.isSkinnedMesh && pt.skinning === !0 || pt.envMap !== Et || PA.fog === !0 && pt.fog !== At || pt.numClippingPlanes !== void 0 && (pt.numClippingPlanes !== Z.numPlanes || pt.numIntersection !== Z.numIntersection) || pt.vertexAlphas !== Bt || pt.vertexTangents !== ft || pt.morphTargets !== tt || pt.morphNormals !== Ft || pt.morphColors !== ui || pt.toneMapping !== Li || kA.isWebGL2 === !0 && pt.morphTargetsCount !== hi) && (Ui = !0) : (Ui = !0, pt.__version = PA.version);
      let Rn = pt.currentProgram;
      Ui === !0 && (Rn = Nt(PA, jA, Be));
      let St = !1, Nn = !1, Wt = !1;
      const ot = Rn.getUniforms(), pi = pt.uniforms;
      if (FA.useProgram(Rn.program) && (St = !0, Nn = !0, Wt = !0), PA.id !== F && (F = PA.id, Nn = !0), St || G !== lA) {
        if (ot.setValue(fA, "projectionMatrix", lA.projectionMatrix), kA.logarithmicDepthBuffer && ot.setValue(
          fA,
          "logDepthBufFC",
          2 / (Math.log(lA.far + 1) / Math.LN2)
        ), G !== lA && (G = lA, Nn = !0, Wt = !0), PA.isShaderMaterial || PA.isMeshPhongMaterial || PA.isMeshToonMaterial || PA.isMeshStandardMaterial || PA.envMap) {
          const Mt = ot.map.cameraPosition;
          Mt !== void 0 && Mt.setValue(
            fA,
            aA.setFromMatrixPosition(lA.matrixWorld)
          );
        }
        (PA.isMeshPhongMaterial || PA.isMeshToonMaterial || PA.isMeshLambertMaterial || PA.isMeshBasicMaterial || PA.isMeshStandardMaterial || PA.isShaderMaterial) && ot.setValue(fA, "isOrthographic", lA.isOrthographicCamera === !0), (PA.isMeshPhongMaterial || PA.isMeshToonMaterial || PA.isMeshLambertMaterial || PA.isMeshBasicMaterial || PA.isMeshStandardMaterial || PA.isShaderMaterial || PA.isShadowMaterial || Be.isSkinnedMesh) && ot.setValue(fA, "viewMatrix", lA.matrixWorldInverse);
      }
      if (Be.isSkinnedMesh) {
        ot.setOptional(fA, Be, "bindMatrix"), ot.setOptional(fA, Be, "bindMatrixInverse");
        const Mt = Be.skeleton;
        Mt && (kA.floatVertexTextures ? (Mt.boneTexture === null && Mt.computeBoneTexture(), ot.setValue(fA, "boneTexture", Mt.boneTexture, JA), ot.setValue(fA, "boneTextureSize", Mt.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      const zi = se.morphAttributes;
      if ((zi.position !== void 0 || zi.normal !== void 0 || zi.color !== void 0 && kA.isWebGL2 === !0) && GA.update(Be, se, Rn), (Nn || pt.receiveShadow !== Be.receiveShadow) && (pt.receiveShadow = Be.receiveShadow, ot.setValue(fA, "receiveShadow", Be.receiveShadow)), PA.isMeshGouraudMaterial && PA.envMap !== null && (pi.envMap.value = Et, pi.flipEnvMap.value = Et.isCubeTexture && Et.isRenderTargetTexture === !1 ? -1 : 1), Nn && (ot.setValue(fA, "toneMappingExposure", f.toneMappingExposure), pt.needsLights && je(pi, Wt), At && PA.fog === !0 && O.refreshFogUniforms(pi, At), O.refreshMaterialUniforms(pi, PA, j, _, rA), gf.upload(fA, pt.uniformsList, pi, JA)), PA.isShaderMaterial && PA.uniformsNeedUpdate === !0 && (gf.upload(fA, pt.uniformsList, pi, JA), PA.uniformsNeedUpdate = !1), PA.isSpriteMaterial && ot.setValue(fA, "center", Be.center), ot.setValue(fA, "modelViewMatrix", Be.modelViewMatrix), ot.setValue(fA, "normalMatrix", Be.normalMatrix), ot.setValue(fA, "modelMatrix", Be.matrixWorld), PA.isShaderMaterial || PA.isRawShaderMaterial) {
        const Mt = PA.uniformsGroups;
        for (let sg = 0, nr = Mt.length; sg < nr; sg++)
          if (kA.isWebGL2) {
            const An = Mt[sg];
            mA.update(An, Rn), mA.bind(An, Rn);
          } else
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return Rn;
    }
    function je(lA, jA) {
      lA.ambientLightColor.needsUpdate = jA, lA.lightProbe.needsUpdate = jA, lA.directionalLights.needsUpdate = jA, lA.directionalLightShadows.needsUpdate = jA, lA.pointLights.needsUpdate = jA, lA.pointLightShadows.needsUpdate = jA, lA.spotLights.needsUpdate = jA, lA.spotLightShadows.needsUpdate = jA, lA.rectAreaLights.needsUpdate = jA, lA.hemisphereLights.needsUpdate = jA;
    }
    function Ri(lA) {
      return lA.isMeshLambertMaterial || lA.isMeshToonMaterial || lA.isMeshPhongMaterial || lA.isMeshStandardMaterial || lA.isShadowMaterial || lA.isShaderMaterial && lA.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return y;
    }, this.getActiveMipmapLevel = function() {
      return m;
    }, this.getRenderTarget = function() {
      return N;
    }, this.setRenderTargetTextures = function(lA, jA, se) {
      vA.get(lA.texture).__webglTexture = jA, vA.get(lA.depthTexture).__webglTexture = se;
      const PA = vA.get(lA);
      PA.__hasExternalTextures = !0, PA.__hasExternalTextures && (PA.__autoAllocateDepthBuffer = se === void 0, PA.__autoAllocateDepthBuffer || yA.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), PA.__useRenderToTexture = !1));
    }, this.setRenderTargetFramebuffer = function(lA, jA) {
      const se = vA.get(lA);
      se.__webglFramebuffer = jA, se.__useDefaultFramebuffer = jA === void 0;
    }, this.setRenderTarget = function(lA, jA = 0, se = 0) {
      N = lA, y = jA, m = se;
      let PA = !0, Be = null, At = !1, rt = !1;
      if (lA) {
        const Et = vA.get(lA);
        Et.__useDefaultFramebuffer !== void 0 ? (FA.bindFramebuffer(36160, null), PA = !1) : Et.__webglFramebuffer === void 0 ? JA.setupRenderTarget(lA) : Et.__hasExternalTextures && JA.rebindTextures(lA, vA.get(lA.texture).__webglTexture, vA.get(lA.depthTexture).__webglTexture);
        const Bt = lA.texture;
        (Bt.isData3DTexture || Bt.isDataArrayTexture || Bt.isCompressedArrayTexture) && (rt = !0);
        const ft = vA.get(lA).__webglFramebuffer;
        lA.isWebGLCubeRenderTarget ? (Be = ft[jA], At = !0) : kA.isWebGL2 && lA.samples > 0 && JA.useMultisampledRTT(lA) === !1 ? Be = vA.get(lA).__webglMultisampledFramebuffer : Be = ft, k.copy(lA.viewport), v.copy(lA.scissor), x = lA.scissorTest;
      } else
        k.copy(eA).multiplyScalar(j).floor(), v.copy(oA).multiplyScalar(j).floor(), x = P;
      if (FA.bindFramebuffer(36160, Be) && kA.drawBuffers && PA && FA.drawBuffers(lA, Be), FA.viewport(k), FA.scissor(v), FA.setScissorTest(x), At) {
        const Et = vA.get(lA.texture);
        fA.framebufferTexture2D(36160, 36064, 34069 + jA, Et.__webglTexture, se);
      } else if (rt) {
        const Et = vA.get(lA.texture), Bt = jA || 0;
        fA.framebufferTextureLayer(36160, 36064, Et.__webglTexture, se || 0, Bt);
      }
      F = -1;
    }, this.readRenderTargetPixels = function(lA, jA, se, PA, Be, At, rt) {
      if (!(lA && lA.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let it = vA.get(lA).__webglFramebuffer;
      if (lA.isWebGLCubeRenderTarget && rt !== void 0 && (it = it[rt]), it) {
        FA.bindFramebuffer(36160, it);
        try {
          const Et = lA.texture, Bt = Et.format, ft = Et.type;
          if (Bt !== tr && SA.convert(Bt) !== fA.getParameter(35739)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const tt = ft === xC && (yA.has("EXT_color_buffer_half_float") || kA.isWebGL2 && yA.has("EXT_color_buffer_float"));
          if (ft !== Va && SA.convert(ft) !== fA.getParameter(35738) && // Edge and Chrome Mac < 52 (#9513)
          !(ft === $s && (kA.isWebGL2 || yA.has("OES_texture_float") || yA.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
          !tt) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          jA >= 0 && jA <= lA.width - PA && se >= 0 && se <= lA.height - Be && fA.readPixels(jA, se, PA, Be, SA.convert(Bt), SA.convert(ft), At);
        } finally {
          const Et = N !== null ? vA.get(N).__webglFramebuffer : null;
          FA.bindFramebuffer(36160, Et);
        }
      }
    }, this.copyFramebufferToTexture = function(lA, jA, se = 0) {
      const PA = Math.pow(2, -se), Be = Math.floor(jA.image.width * PA), At = Math.floor(jA.image.height * PA);
      JA.setTexture2D(jA, 0), fA.copyTexSubImage2D(3553, se, 0, 0, lA.x, lA.y, Be, At), FA.unbindTexture();
    }, this.copyTextureToTexture = function(lA, jA, se, PA = 0) {
      const Be = jA.image.width, At = jA.image.height, rt = SA.convert(se.format), it = SA.convert(se.type);
      JA.setTexture2D(se, 0), fA.pixelStorei(37440, se.flipY), fA.pixelStorei(37441, se.premultiplyAlpha), fA.pixelStorei(3317, se.unpackAlignment), jA.isDataTexture ? fA.texSubImage2D(3553, PA, lA.x, lA.y, Be, At, rt, it, jA.image.data) : jA.isCompressedTexture ? fA.compressedTexSubImage2D(3553, PA, lA.x, lA.y, jA.mipmaps[0].width, jA.mipmaps[0].height, rt, jA.mipmaps[0].data) : fA.texSubImage2D(3553, PA, lA.x, lA.y, rt, it, jA.image), PA === 0 && se.generateMipmaps && fA.generateMipmap(3553), FA.unbindTexture();
    }, this.copyTextureToTexture3D = function(lA, jA, se, PA, Be = 0) {
      if (f.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const At = lA.max.x - lA.min.x + 1, rt = lA.max.y - lA.min.y + 1, it = lA.max.z - lA.min.z + 1, Et = SA.convert(PA.format), Bt = SA.convert(PA.type);
      let ft;
      if (PA.isData3DTexture)
        JA.setTexture3D(PA, 0), ft = 32879;
      else if (PA.isDataArrayTexture)
        JA.setTexture2DArray(PA, 0), ft = 35866;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      fA.pixelStorei(37440, PA.flipY), fA.pixelStorei(37441, PA.premultiplyAlpha), fA.pixelStorei(3317, PA.unpackAlignment);
      const tt = fA.getParameter(3314), Ft = fA.getParameter(32878), ui = fA.getParameter(3316), Li = fA.getParameter(3315), $i = fA.getParameter(32877), hi = se.isCompressedTexture ? se.mipmaps[0] : se.image;
      fA.pixelStorei(3314, hi.width), fA.pixelStorei(32878, hi.height), fA.pixelStorei(3316, lA.min.x), fA.pixelStorei(3315, lA.min.y), fA.pixelStorei(32877, lA.min.z), se.isDataTexture || se.isData3DTexture ? fA.texSubImage3D(ft, Be, jA.x, jA.y, jA.z, At, rt, it, Et, Bt, hi.data) : se.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), fA.compressedTexSubImage3D(ft, Be, jA.x, jA.y, jA.z, At, rt, it, Et, hi.data)) : fA.texSubImage3D(ft, Be, jA.x, jA.y, jA.z, At, rt, it, Et, Bt, hi), fA.pixelStorei(3314, tt), fA.pixelStorei(32878, Ft), fA.pixelStorei(3316, ui), fA.pixelStorei(3315, Li), fA.pixelStorei(32877, $i), Be === 0 && PA.generateMipmaps && fA.generateMipmap(ft), FA.unbindTexture();
    }, this.initTexture = function(lA) {
      lA.isCubeTexture ? JA.setTextureCube(lA, 0) : lA.isData3DTexture ? JA.setTexture3D(lA, 0) : lA.isDataArrayTexture || lA.isCompressedArrayTexture ? JA.setTexture2DArray(lA, 0) : JA.setTexture2D(lA, 0), FA.unbindTexture();
    }, this.resetState = function() {
      y = 0, m = 0, N = null, FA.reset(), EA.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get physicallyCorrectLights() {
    return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights;
  }
  set physicallyCorrectLights(A) {
    console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !A;
  }
}
class Yv extends vy {
}
Yv.prototype.isWebGL1Renderer = !0;
class vf {
  constructor(A, e = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new ke(A), this.density = e;
  }
  clone() {
    return new vf(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class Uf {
  constructor(A, e = 1, t = 1e3) {
    this.isFog = !0, this.name = "", this.color = new ke(A), this.near = e, this.far = t;
  }
  clone() {
    return new Uf(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class UE extends Xt {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(A, e) {
    return super.copy(A, e), A.background !== null && (this.background = A.background.clone()), A.environment !== null && (this.environment = A.environment.clone()), A.fog !== null && (this.fog = A.fog.clone()), this.backgroundBlurriness = A.backgroundBlurriness, this.backgroundIntensity = A.backgroundIntensity, A.overrideMaterial !== null && (this.overrideMaterial = A.overrideMaterial.clone()), this.matrixAutoUpdate = A.matrixAutoUpdate, this;
  }
  toJSON(A) {
    const e = super.toJSON(A);
    return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e;
  }
  get autoUpdate() {
    return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate;
  }
  set autoUpdate(A) {
    console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = A;
  }
}
class eu {
  constructor(A, e) {
    this.isInterleavedBuffer = !0, this.array = A, this.stride = e, this.count = A !== void 0 ? A.length / e : 0, this.usage = Tc, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = io();
  }
  onUploadCallback() {
  }
  set needsUpdate(A) {
    A === !0 && this.version++;
  }
  setUsage(A) {
    return this.usage = A, this;
  }
  copy(A) {
    return this.array = new A.array.constructor(A.array), this.count = A.count, this.stride = A.stride, this.usage = A.usage, this;
  }
  copyAt(A, e, t) {
    A *= this.stride, t *= e.stride;
    for (let i = 0, n = this.stride; i < n; i++)
      this.array[A + i] = e.array[t + i];
    return this;
  }
  set(A, e = 0) {
    return this.array.set(A, e), this;
  }
  clone(A) {
    A.arrayBuffers === void 0 && (A.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = io()), A.arrayBuffers[this.array.buffer._uuid] === void 0 && (A.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const e = new this.array.constructor(A.arrayBuffers[this.array.buffer._uuid]), t = new this.constructor(e, this.stride);
    return t.setUsage(this.usage), t;
  }
  onUpload(A) {
    return this.onUploadCallback = A, this;
  }
  toJSON(A) {
    return A.arrayBuffers === void 0 && (A.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = io()), A.arrayBuffers[this.array.buffer._uuid] === void 0 && (A.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const $g = /* @__PURE__ */ new IA();
class hB {
  constructor(A, e, t, i = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = A, this.itemSize = e, this.offset = t, this.normalized = i;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(A) {
    this.data.needsUpdate = A;
  }
  applyMatrix4(A) {
    for (let e = 0, t = this.data.count; e < t; e++)
      $g.fromBufferAttribute(this, e), $g.applyMatrix4(A), this.setXYZ(e, $g.x, $g.y, $g.z);
    return this;
  }
  applyNormalMatrix(A) {
    for (let e = 0, t = this.count; e < t; e++)
      $g.fromBufferAttribute(this, e), $g.applyNormalMatrix(A), this.setXYZ(e, $g.x, $g.y, $g.z);
    return this;
  }
  transformDirection(A) {
    for (let e = 0, t = this.count; e < t; e++)
      $g.fromBufferAttribute(this, e), $g.transformDirection(A), this.setXYZ(e, $g.x, $g.y, $g.z);
    return this;
  }
  setX(A, e) {
    return this.normalized && (e = _t(e, this.array)), this.data.array[A * this.data.stride + this.offset] = e, this;
  }
  setY(A, e) {
    return this.normalized && (e = _t(e, this.array)), this.data.array[A * this.data.stride + this.offset + 1] = e, this;
  }
  setZ(A, e) {
    return this.normalized && (e = _t(e, this.array)), this.data.array[A * this.data.stride + this.offset + 2] = e, this;
  }
  setW(A, e) {
    return this.normalized && (e = _t(e, this.array)), this.data.array[A * this.data.stride + this.offset + 3] = e, this;
  }
  getX(A) {
    let e = this.data.array[A * this.data.stride + this.offset];
    return this.normalized && (e = $r(e, this.array)), e;
  }
  getY(A) {
    let e = this.data.array[A * this.data.stride + this.offset + 1];
    return this.normalized && (e = $r(e, this.array)), e;
  }
  getZ(A) {
    let e = this.data.array[A * this.data.stride + this.offset + 2];
    return this.normalized && (e = $r(e, this.array)), e;
  }
  getW(A) {
    let e = this.data.array[A * this.data.stride + this.offset + 3];
    return this.normalized && (e = $r(e, this.array)), e;
  }
  setXY(A, e, t) {
    return A = A * this.data.stride + this.offset, this.normalized && (e = _t(e, this.array), t = _t(t, this.array)), this.data.array[A + 0] = e, this.data.array[A + 1] = t, this;
  }
  setXYZ(A, e, t, i) {
    return A = A * this.data.stride + this.offset, this.normalized && (e = _t(e, this.array), t = _t(t, this.array), i = _t(i, this.array)), this.data.array[A + 0] = e, this.data.array[A + 1] = t, this.data.array[A + 2] = i, this;
  }
  setXYZW(A, e, t, i, n) {
    return A = A * this.data.stride + this.offset, this.normalized && (e = _t(e, this.array), t = _t(t, this.array), i = _t(i, this.array), n = _t(n, this.array)), this.data.array[A + 0] = e, this.data.array[A + 1] = t, this.data.array[A + 2] = i, this.data.array[A + 3] = n, this;
  }
  clone(A) {
    if (A === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const e = [];
      for (let t = 0; t < this.count; t++) {
        const i = t * this.data.stride + this.offset;
        for (let n = 0; n < this.itemSize; n++)
          e.push(this.data.array[i + n]);
      }
      return new Pt(new this.array.constructor(e), this.itemSize, this.normalized);
    } else
      return A.interleavedBuffers === void 0 && (A.interleavedBuffers = {}), A.interleavedBuffers[this.data.uuid] === void 0 && (A.interleavedBuffers[this.data.uuid] = this.data.clone(A)), new hB(A.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(A) {
    if (A === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const e = [];
      for (let t = 0; t < this.count; t++) {
        const i = t * this.data.stride + this.offset;
        for (let n = 0; n < this.itemSize; n++)
          e.push(this.data.array[i + n]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: e,
        normalized: this.normalized
      };
    } else
      return A.interleavedBuffers === void 0 && (A.interleavedBuffers = {}), A.interleavedBuffers[this.data.uuid] === void 0 && (A.interleavedBuffers[this.data.uuid] = this.data.toJSON(A)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class Uy extends Sn {
  constructor(A) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new ke(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(A);
  }
  copy(A) {
    return super.copy(A), this.color.copy(A.color), this.map = A.map, this.alphaMap = A.alphaMap, this.rotation = A.rotation, this.sizeAttenuation = A.sizeAttenuation, this.fog = A.fog, this;
  }
}
let iE;
const tc = /* @__PURE__ */ new IA(), nE = /* @__PURE__ */ new IA(), gE = /* @__PURE__ */ new IA(), rE = /* @__PURE__ */ new ue(), ic = /* @__PURE__ */ new ue(), Hv = /* @__PURE__ */ new Ve(), cd = /* @__PURE__ */ new IA(), nc = /* @__PURE__ */ new IA(), ud = /* @__PURE__ */ new IA(), XR = /* @__PURE__ */ new ue(), d0 = /* @__PURE__ */ new ue(), $R = /* @__PURE__ */ new ue();
class _v extends Xt {
  constructor(A) {
    if (super(), this.isSprite = !0, this.type = "Sprite", iE === void 0) {
      iE = new ut();
      const e = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), t = new eu(e, 5);
      iE.setIndex([0, 1, 2, 0, 2, 3]), iE.setAttribute("position", new hB(t, 3, 0, !1)), iE.setAttribute("uv", new hB(t, 2, 3, !1));
    }
    this.geometry = iE, this.material = A !== void 0 ? A : new Uy(), this.center = new ue(0.5, 0.5);
  }
  raycast(A, e) {
    A.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), nE.setFromMatrixScale(this.matrixWorld), Hv.copy(A.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(A.camera.matrixWorldInverse, this.matrixWorld), gE.setFromMatrixPosition(this.modelViewMatrix), A.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && nE.multiplyScalar(-gE.z);
    const t = this.material.rotation;
    let i, n;
    t !== 0 && (n = Math.cos(t), i = Math.sin(t));
    const r = this.center;
    hd(cd.set(-0.5, -0.5, 0), gE, r, nE, i, n), hd(nc.set(0.5, -0.5, 0), gE, r, nE, i, n), hd(ud.set(0.5, 0.5, 0), gE, r, nE, i, n), XR.set(0, 0), d0.set(1, 0), $R.set(1, 1);
    let s = A.ray.intersectTriangle(cd, nc, ud, !1, tc);
    if (s === null && (hd(nc.set(-0.5, 0.5, 0), gE, r, nE, i, n), d0.set(0, 1), s = A.ray.intersectTriangle(cd, ud, nc, !1, tc), s === null))
      return;
    const B = A.ray.origin.distanceTo(tc);
    B < A.near || B > A.far || e.push({
      distance: B,
      point: tc.clone(),
      uv: Sr.getInterpolation(tc, cd, nc, ud, XR, d0, $R, new ue()),
      face: null,
      object: this
    });
  }
  copy(A, e) {
    return super.copy(A, e), A.center !== void 0 && this.center.copy(A.center), this.material = A.material, this;
  }
}
function hd(g, A, e, t, i, n) {
  rE.subVectors(g, e).addScalar(0.5).multiply(t), i !== void 0 ? (ic.x = n * rE.x - i * rE.y, ic.y = i * rE.x + n * rE.y) : ic.copy(rE), g.copy(A), g.x += ic.x, g.y += ic.y, g.applyMatrix4(Hv);
}
const dd = /* @__PURE__ */ new IA(), AN = /* @__PURE__ */ new IA();
class Jv extends Xt {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(A) {
    super.copy(A, !1);
    const e = A.levels;
    for (let t = 0, i = e.length; t < i; t++) {
      const n = e[t];
      this.addLevel(n.object.clone(), n.distance, n.hysteresis);
    }
    return this.autoUpdate = A.autoUpdate, this;
  }
  addLevel(A, e = 0, t = 0) {
    e = Math.abs(e);
    const i = this.levels;
    let n;
    for (n = 0; n < i.length && !(e < i[n].distance); n++)
      ;
    return i.splice(n, 0, { distance: e, hysteresis: t, object: A }), this.add(A), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(A) {
    const e = this.levels;
    if (e.length > 0) {
      let t, i;
      for (t = 1, i = e.length; t < i; t++) {
        let n = e[t].distance;
        if (e[t].object.visible && (n -= n * e[t].hysteresis), A < n)
          break;
      }
      return e[t - 1].object;
    }
    return null;
  }
  raycast(A, e) {
    if (this.levels.length > 0) {
      dd.setFromMatrixPosition(this.matrixWorld);
      const i = A.ray.origin.distanceTo(dd);
      this.getObjectForDistance(i).raycast(A, e);
    }
  }
  update(A) {
    const e = this.levels;
    if (e.length > 1) {
      dd.setFromMatrixPosition(A.matrixWorld), AN.setFromMatrixPosition(this.matrixWorld);
      const t = dd.distanceTo(AN) / A.zoom;
      e[0].object.visible = !0;
      let i, n;
      for (i = 1, n = e.length; i < n; i++) {
        let r = e[i].distance;
        if (e[i].object.visible && (r -= r * e[i].hysteresis), t >= r)
          e[i - 1].object.visible = !1, e[i].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = i - 1; i < n; i++)
        e[i].object.visible = !1;
    }
  }
  toJSON(A) {
    const e = super.toJSON(A);
    this.autoUpdate === !1 && (e.object.autoUpdate = !1), e.object.levels = [];
    const t = this.levels;
    for (let i = 0, n = t.length; i < n; i++) {
      const r = t[i];
      e.object.levels.push({
        object: r.object.uuid,
        distance: r.distance,
        hysteresis: r.hysteresis
      });
    }
    return e;
  }
}
const eN = /* @__PURE__ */ new IA(), tN = /* @__PURE__ */ new Bi(), iN = /* @__PURE__ */ new Bi(), MJ = /* @__PURE__ */ new IA(), nN = /* @__PURE__ */ new Ve(), oE = /* @__PURE__ */ new IA();
class kf extends Xi {
  constructor(A, e) {
    super(A, e), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Ve(), this.bindMatrixInverse = new Ve(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const A = this.geometry;
    this.boundingBox === null && (this.boundingBox = new cs()), this.boundingBox.makeEmpty();
    const e = A.getAttribute("position");
    for (let t = 0; t < e.count; t++)
      oE.fromBufferAttribute(e, t), this.applyBoneTransform(t, oE), this.boundingBox.expandByPoint(oE);
  }
  computeBoundingSphere() {
    const A = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new us()), this.boundingSphere.makeEmpty();
    const e = A.getAttribute("position");
    for (let t = 0; t < e.count; t++)
      oE.fromBufferAttribute(e, t), this.applyBoneTransform(t, oE), this.boundingSphere.expandByPoint(oE);
  }
  copy(A, e) {
    return super.copy(A, e), this.bindMode = A.bindMode, this.bindMatrix.copy(A.bindMatrix), this.bindMatrixInverse.copy(A.bindMatrixInverse), this.skeleton = A.skeleton, this;
  }
  bind(A, e) {
    this.skeleton = A, e === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const A = new Bi(), e = this.geometry.attributes.skinWeight;
    for (let t = 0, i = e.count; t < i; t++) {
      A.fromBufferAttribute(e, t);
      const n = 1 / A.manhattanLength();
      n !== 1 / 0 ? A.multiplyScalar(n) : A.set(1, 0, 0, 0), e.setXYZW(t, A.x, A.y, A.z, A.w);
    }
  }
  updateMatrixWorld(A) {
    super.updateMatrixWorld(A), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(A, e) {
    const t = this.skeleton, i = this.geometry;
    tN.fromBufferAttribute(i.attributes.skinIndex, A), iN.fromBufferAttribute(i.attributes.skinWeight, A), eN.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
    for (let n = 0; n < 4; n++) {
      const r = iN.getComponent(n);
      if (r !== 0) {
        const s = tN.getComponent(n);
        nN.multiplyMatrices(t.bones[s].matrixWorld, t.boneInverses[s]), e.addScaledVector(MJ.copy(eN).applyMatrix4(nN), r);
      }
    }
    return e.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(A, e) {
    return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(A, e);
  }
}
class kE extends Xt {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class wE extends xi {
  constructor(A = null, e = 1, t = 1, i, n, r, s, B, I = un, E = un, C, c) {
    super(null, r, s, B, I, E, i, n, C, c), this.isDataTexture = !0, this.image = { data: A, width: e, height: t }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const gN = /* @__PURE__ */ new Ve(), RJ = /* @__PURE__ */ new Ve();
class YE {
  constructor(A = [], e = []) {
    this.uuid = io(), this.bones = A.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
  }
  init() {
    const A = this.bones, e = this.boneInverses;
    if (this.boneMatrices = new Float32Array(A.length * 16), e.length === 0)
      this.calculateInverses();
    else if (A.length !== e.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let t = 0, i = this.bones.length; t < i; t++)
        this.boneInverses.push(new Ve());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let A = 0, e = this.bones.length; A < e; A++) {
      const t = new Ve();
      this.bones[A] && t.copy(this.bones[A].matrixWorld).invert(), this.boneInverses.push(t);
    }
  }
  pose() {
    for (let A = 0, e = this.bones.length; A < e; A++) {
      const t = this.bones[A];
      t && t.matrixWorld.copy(this.boneInverses[A]).invert();
    }
    for (let A = 0, e = this.bones.length; A < e; A++) {
      const t = this.bones[A];
      t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale));
    }
  }
  update() {
    const A = this.bones, e = this.boneInverses, t = this.boneMatrices, i = this.boneTexture;
    for (let n = 0, r = A.length; n < r; n++) {
      const s = A[n] ? A[n].matrixWorld : RJ;
      gN.multiplyMatrices(s, e[n]), gN.toArray(t, n * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new YE(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let A = Math.sqrt(this.bones.length * 4);
    A = mv(A), A = Math.max(A, 4);
    const e = new Float32Array(A * A * 4);
    e.set(this.boneMatrices);
    const t = new wE(e, A, A, tr, $s);
    return t.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = t, this.boneTextureSize = A, this;
  }
  getBoneByName(A) {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      if (i.name === A)
        return i;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(A, e) {
    this.uuid = A.uuid;
    for (let t = 0, i = A.bones.length; t < i; t++) {
      const n = A.bones[t];
      let r = e[n];
      r === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", n), r = new kE()), this.bones.push(r), this.boneInverses.push(new Ve().fromArray(A.boneInverses[t]));
    }
    return this.init(), this;
  }
  toJSON() {
    const A = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    A.uuid = this.uuid;
    const e = this.bones, t = this.boneInverses;
    for (let i = 0, n = e.length; i < n; i++) {
      const r = e[i];
      A.bones.push(r.uuid);
      const s = t[i];
      A.boneInverses.push(s.toArray());
    }
    return A;
  }
}
class xE extends Pt {
  constructor(A, e, t, i = 1) {
    super(A, e, t), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
  }
  copy(A) {
    return super.copy(A), this.meshPerAttribute = A.meshPerAttribute, this;
  }
  toJSON() {
    const A = super.toJSON();
    return A.meshPerAttribute = this.meshPerAttribute, A.isInstancedBufferAttribute = !0, A;
  }
}
const sE = /* @__PURE__ */ new Ve(), rN = /* @__PURE__ */ new Ve(), fd = [], oN = /* @__PURE__ */ new cs(), NJ = /* @__PURE__ */ new Ve(), rc = /* @__PURE__ */ new Xi(), oc = /* @__PURE__ */ new us();
class ky extends Xi {
  constructor(A, e, t) {
    super(A, e), this.isInstancedMesh = !0, this.instanceMatrix = new xE(new Float32Array(t * 16), 16), this.instanceColor = null, this.count = t, this.boundingBox = null, this.boundingSphere = null;
    for (let i = 0; i < t; i++)
      this.setMatrixAt(i, NJ);
  }
  computeBoundingBox() {
    const A = this.geometry, e = this.count;
    this.boundingBox === null && (this.boundingBox = new cs()), A.boundingBox === null && A.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let t = 0; t < e; t++)
      this.getMatrixAt(t, sE), oN.copy(A.boundingBox).applyMatrix4(sE), this.boundingBox.union(oN);
  }
  computeBoundingSphere() {
    const A = this.geometry, e = this.count;
    this.boundingSphere === null && (this.boundingSphere = new us()), A.boundingSphere === null && A.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let t = 0; t < e; t++)
      this.getMatrixAt(t, sE), oc.copy(A.boundingSphere).applyMatrix4(sE), this.boundingSphere.union(oc);
  }
  copy(A, e) {
    return super.copy(A, e), this.instanceMatrix.copy(A.instanceMatrix), A.instanceColor !== null && (this.instanceColor = A.instanceColor.clone()), this.count = A.count, this;
  }
  getColorAt(A, e) {
    e.fromArray(this.instanceColor.array, A * 3);
  }
  getMatrixAt(A, e) {
    e.fromArray(this.instanceMatrix.array, A * 16);
  }
  raycast(A, e) {
    const t = this.matrixWorld, i = this.count;
    if (rc.geometry = this.geometry, rc.material = this.material, rc.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), oc.copy(this.boundingSphere), oc.applyMatrix4(t), A.ray.intersectsSphere(oc) !== !1))
      for (let n = 0; n < i; n++) {
        this.getMatrixAt(n, sE), rN.multiplyMatrices(t, sE), rc.matrixWorld = rN, rc.raycast(A, fd);
        for (let r = 0, s = fd.length; r < s; r++) {
          const B = fd[r];
          B.instanceId = n, B.object = this, e.push(B);
        }
        fd.length = 0;
      }
  }
  setColorAt(A, e) {
    this.instanceColor === null && (this.instanceColor = new xE(new Float32Array(this.instanceMatrix.count * 3), 3)), e.toArray(this.instanceColor.array, A * 3);
  }
  setMatrixAt(A, e) {
    e.toArray(this.instanceMatrix.array, A * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Mn extends Sn {
  constructor(A) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new ke(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(A);
  }
  copy(A) {
    return super.copy(A), this.color.copy(A.color), this.map = A.map, this.linewidth = A.linewidth, this.linecap = A.linecap, this.linejoin = A.linejoin, this.fog = A.fog, this;
  }
}
const sN = /* @__PURE__ */ new IA(), aN = /* @__PURE__ */ new IA(), IN = /* @__PURE__ */ new Ve(), f0 = /* @__PURE__ */ new Xc(), pd = /* @__PURE__ */ new us();
class Qs extends Xt {
  constructor(A = new ut(), e = new Mn()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = A, this.material = e, this.updateMorphTargets();
  }
  copy(A, e) {
    return super.copy(A, e), this.material = A.material, this.geometry = A.geometry, this;
  }
  computeLineDistances() {
    const A = this.geometry;
    if (A.index === null) {
      const e = A.attributes.position, t = [0];
      for (let i = 1, n = e.count; i < n; i++)
        sN.fromBufferAttribute(e, i - 1), aN.fromBufferAttribute(e, i), t[i] = t[i - 1], t[i] += sN.distanceTo(aN);
      A.setAttribute("lineDistance", new Oe(t, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(A, e) {
    const t = this.geometry, i = this.matrixWorld, n = A.params.Line.threshold, r = t.drawRange;
    if (t.boundingSphere === null && t.computeBoundingSphere(), pd.copy(t.boundingSphere), pd.applyMatrix4(i), pd.radius += n, A.ray.intersectsSphere(pd) === !1)
      return;
    IN.copy(i).invert(), f0.copy(A.ray).applyMatrix4(IN);
    const s = n / ((this.scale.x + this.scale.y + this.scale.z) / 3), B = s * s, I = new IA(), E = new IA(), C = new IA(), c = new IA(), u = this.isLineSegments ? 2 : 1, d = t.index, D = t.attributes.position;
    if (d !== null) {
      const f = Math.max(0, r.start), S = Math.min(d.count, r.start + r.count);
      for (let y = f, m = S - 1; y < m; y += u) {
        const N = d.getX(y), F = d.getX(y + 1);
        if (I.fromBufferAttribute(D, N), E.fromBufferAttribute(D, F), f0.distanceSqToSegment(I, E, c, C) > B)
          continue;
        c.applyMatrix4(this.matrixWorld);
        const k = A.ray.origin.distanceTo(c);
        k < A.near || k > A.far || e.push({
          distance: k,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: C.clone().applyMatrix4(this.matrixWorld),
          index: y,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const f = Math.max(0, r.start), S = Math.min(D.count, r.start + r.count);
      for (let y = f, m = S - 1; y < m; y += u) {
        if (I.fromBufferAttribute(D, y), E.fromBufferAttribute(D, y + 1), f0.distanceSqToSegment(I, E, c, C) > B)
          continue;
        c.applyMatrix4(this.matrixWorld);
        const F = A.ray.origin.distanceTo(c);
        F < A.near || F > A.far || e.push({
          distance: F,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: C.clone().applyMatrix4(this.matrixWorld),
          index: y,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, t = Object.keys(e);
    if (t.length > 0) {
      const i = e[t[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let n = 0, r = i.length; n < r; n++) {
          const s = i[n].name || String(n);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = n;
        }
      }
    }
  }
}
const BN = /* @__PURE__ */ new IA(), CN = /* @__PURE__ */ new IA();
class no extends Qs {
  constructor(A, e) {
    super(A, e), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const A = this.geometry;
    if (A.index === null) {
      const e = A.attributes.position, t = [];
      for (let i = 0, n = e.count; i < n; i += 2)
        BN.fromBufferAttribute(e, i), CN.fromBufferAttribute(e, i + 1), t[i] = i === 0 ? 0 : t[i - 1], t[i + 1] = t[i] + BN.distanceTo(CN);
      A.setAttribute("lineDistance", new Oe(t, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class xy extends Qs {
  constructor(A, e) {
    super(A, e), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class BB extends Sn {
  constructor(A) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new ke(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(A);
  }
  copy(A) {
    return super.copy(A), this.color.copy(A.color), this.map = A.map, this.alphaMap = A.alphaMap, this.size = A.size, this.sizeAttenuation = A.sizeAttenuation, this.fog = A.fog, this;
  }
}
const QN = /* @__PURE__ */ new Ve(), Jw = /* @__PURE__ */ new Xc(), Dd = /* @__PURE__ */ new us(), wd = /* @__PURE__ */ new IA();
class yE extends Xt {
  constructor(A = new ut(), e = new BB()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = A, this.material = e, this.updateMorphTargets();
  }
  copy(A, e) {
    return super.copy(A, e), this.material = A.material, this.geometry = A.geometry, this;
  }
  raycast(A, e) {
    const t = this.geometry, i = this.matrixWorld, n = A.params.Points.threshold, r = t.drawRange;
    if (t.boundingSphere === null && t.computeBoundingSphere(), Dd.copy(t.boundingSphere), Dd.applyMatrix4(i), Dd.radius += n, A.ray.intersectsSphere(Dd) === !1)
      return;
    QN.copy(i).invert(), Jw.copy(A.ray).applyMatrix4(QN);
    const s = n / ((this.scale.x + this.scale.y + this.scale.z) / 3), B = s * s, I = t.index, C = t.attributes.position;
    if (I !== null) {
      const c = Math.max(0, r.start), u = Math.min(I.count, r.start + r.count);
      for (let d = c, p = u; d < p; d++) {
        const D = I.getX(d);
        wd.fromBufferAttribute(C, D), EN(wd, D, B, i, A, e, this);
      }
    } else {
      const c = Math.max(0, r.start), u = Math.min(C.count, r.start + r.count);
      for (let d = c, p = u; d < p; d++)
        wd.fromBufferAttribute(C, d), EN(wd, d, B, i, A, e, this);
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, t = Object.keys(e);
    if (t.length > 0) {
      const i = e[t[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let n = 0, r = i.length; n < r; n++) {
          const s = i[n].name || String(n);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = n;
        }
      }
    }
  }
}
function EN(g, A, e, t, i, n, r) {
  const s = Jw.distanceSqToPoint(g);
  if (s < e) {
    const B = new IA();
    Jw.closestPointToPoint(g, B), B.applyMatrix4(t);
    const I = i.ray.origin.distanceTo(B);
    if (I < i.near || I > i.far)
      return;
    n.push({
      distance: I,
      distanceToRay: Math.sqrt(s),
      point: B,
      index: A,
      face: null,
      object: r
    });
  }
}
class FJ extends xi {
  constructor(A, e, t, i, n, r, s, B, I) {
    super(A, e, t, i, n, r, s, B, I), this.isVideoTexture = !0, this.minFilter = r !== void 0 ? r : Gi, this.magFilter = n !== void 0 ? n : Gi, this.generateMipmaps = !1;
    const E = this;
    function C() {
      E.needsUpdate = !0, A.requestVideoFrameCallback(C);
    }
    "requestVideoFrameCallback" in A && A.requestVideoFrameCallback(C);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const A = this.image;
    "requestVideoFrameCallback" in A === !1 && A.readyState >= A.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class GJ extends xi {
  constructor(A, e, t) {
    super({ width: A, height: e }), this.isFramebufferTexture = !0, this.format = t, this.magFilter = un, this.minFilter = un, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class Ly extends xi {
  constructor(A, e, t, i, n, r, s, B, I, E, C, c) {
    super(null, r, s, B, I, E, i, n, C, c), this.isCompressedTexture = !0, this.image = { width: e, height: t }, this.mipmaps = A, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class vJ extends Ly {
  constructor(A, e, t, i, n, r) {
    super(A, e, t, n, r), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = Jn;
  }
}
class Ov extends xi {
  constructor(A, e, t, i, n, r, s, B, I) {
    super(A, e, t, i, n, r, s, B, I), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class ko {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(A, e) {
    const t = this.getUtoTmapping(A);
    return this.getPoint(t, e);
  }
  // Get sequence of points using getPoint( t )
  getPoints(A = 5) {
    const e = [];
    for (let t = 0; t <= A; t++)
      e.push(this.getPoint(t / A));
    return e;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(A = 5) {
    const e = [];
    for (let t = 0; t <= A; t++)
      e.push(this.getPointAt(t / A));
    return e;
  }
  // Get total curve arc length
  getLength() {
    const A = this.getLengths();
    return A[A.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(A = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === A + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const e = [];
    let t, i = this.getPoint(0), n = 0;
    e.push(0);
    for (let r = 1; r <= A; r++)
      t = this.getPoint(r / A), n += t.distanceTo(i), e.push(n), i = t;
    return this.cacheArcLengths = e, e;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(A, e) {
    const t = this.getLengths();
    let i = 0;
    const n = t.length;
    let r;
    e ? r = e : r = A * t[n - 1];
    let s = 0, B = n - 1, I;
    for (; s <= B; )
      if (i = Math.floor(s + (B - s) / 2), I = t[i] - r, I < 0)
        s = i + 1;
      else if (I > 0)
        B = i - 1;
      else {
        B = i;
        break;
      }
    if (i = B, t[i] === r)
      return i / (n - 1);
    const E = t[i], c = t[i + 1] - E, u = (r - E) / c;
    return (i + u) / (n - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(A, e) {
    let i = A - 1e-4, n = A + 1e-4;
    i < 0 && (i = 0), n > 1 && (n = 1);
    const r = this.getPoint(i), s = this.getPoint(n), B = e || (r.isVector2 ? new ue() : new IA());
    return B.copy(s).sub(r).normalize(), B;
  }
  getTangentAt(A, e) {
    const t = this.getUtoTmapping(A);
    return this.getTangent(t, e);
  }
  computeFrenetFrames(A, e) {
    const t = new IA(), i = [], n = [], r = [], s = new IA(), B = new Ve();
    for (let u = 0; u <= A; u++) {
      const d = u / A;
      i[u] = this.getTangentAt(d, new IA());
    }
    n[0] = new IA(), r[0] = new IA();
    let I = Number.MAX_VALUE;
    const E = Math.abs(i[0].x), C = Math.abs(i[0].y), c = Math.abs(i[0].z);
    E <= I && (I = E, t.set(1, 0, 0)), C <= I && (I = C, t.set(0, 1, 0)), c <= I && t.set(0, 0, 1), s.crossVectors(i[0], t).normalize(), n[0].crossVectors(i[0], s), r[0].crossVectors(i[0], n[0]);
    for (let u = 1; u <= A; u++) {
      if (n[u] = n[u - 1].clone(), r[u] = r[u - 1].clone(), s.crossVectors(i[u - 1], i[u]), s.length() > Number.EPSILON) {
        s.normalize();
        const d = Math.acos(yn(i[u - 1].dot(i[u]), -1, 1));
        n[u].applyMatrix4(B.makeRotationAxis(s, d));
      }
      r[u].crossVectors(i[u], n[u]);
    }
    if (e === !0) {
      let u = Math.acos(yn(n[0].dot(n[A]), -1, 1));
      u /= A, i[0].dot(s.crossVectors(n[0], n[A])) > 0 && (u = -u);
      for (let d = 1; d <= A; d++)
        n[d].applyMatrix4(B.makeRotationAxis(i[d], u * d)), r[d].crossVectors(i[d], n[d]);
    }
    return {
      tangents: i,
      normals: n,
      binormals: r
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(A) {
    return this.arcLengthDivisions = A.arcLengthDivisions, this;
  }
  toJSON() {
    const A = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return A.arcLengthDivisions = this.arcLengthDivisions, A.type = this.type, A;
  }
  fromJSON(A) {
    return this.arcLengthDivisions = A.arcLengthDivisions, this;
  }
}
class tu extends ko {
  constructor(A = 0, e = 0, t = 1, i = 1, n = 0, r = Math.PI * 2, s = !1, B = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = A, this.aY = e, this.xRadius = t, this.yRadius = i, this.aStartAngle = n, this.aEndAngle = r, this.aClockwise = s, this.aRotation = B;
  }
  getPoint(A, e) {
    const t = e || new ue(), i = Math.PI * 2;
    let n = this.aEndAngle - this.aStartAngle;
    const r = Math.abs(n) < Number.EPSILON;
    for (; n < 0; )
      n += i;
    for (; n > i; )
      n -= i;
    n < Number.EPSILON && (r ? n = 0 : n = i), this.aClockwise === !0 && !r && (n === i ? n = -i : n = n - i);
    const s = this.aStartAngle + A * n;
    let B = this.aX + this.xRadius * Math.cos(s), I = this.aY + this.yRadius * Math.sin(s);
    if (this.aRotation !== 0) {
      const E = Math.cos(this.aRotation), C = Math.sin(this.aRotation), c = B - this.aX, u = I - this.aY;
      B = c * E - u * C + this.aX, I = c * C + u * E + this.aY;
    }
    return t.set(B, I);
  }
  copy(A) {
    return super.copy(A), this.aX = A.aX, this.aY = A.aY, this.xRadius = A.xRadius, this.yRadius = A.yRadius, this.aStartAngle = A.aStartAngle, this.aEndAngle = A.aEndAngle, this.aClockwise = A.aClockwise, this.aRotation = A.aRotation, this;
  }
  toJSON() {
    const A = super.toJSON();
    return A.aX = this.aX, A.aY = this.aY, A.xRadius = this.xRadius, A.yRadius = this.yRadius, A.aStartAngle = this.aStartAngle, A.aEndAngle = this.aEndAngle, A.aClockwise = this.aClockwise, A.aRotation = this.aRotation, A;
  }
  fromJSON(A) {
    return super.fromJSON(A), this.aX = A.aX, this.aY = A.aY, this.xRadius = A.xRadius, this.yRadius = A.yRadius, this.aStartAngle = A.aStartAngle, this.aEndAngle = A.aEndAngle, this.aClockwise = A.aClockwise, this.aRotation = A.aRotation, this;
  }
}
class qv extends tu {
  constructor(A, e, t, i, n, r) {
    super(A, e, t, t, i, n, r), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function Ty() {
  let g = 0, A = 0, e = 0, t = 0;
  function i(n, r, s, B) {
    g = n, A = s, e = -3 * n + 3 * r - 2 * s - B, t = 2 * n - 2 * r + s + B;
  }
  return {
    initCatmullRom: function(n, r, s, B, I) {
      i(r, s, I * (s - n), I * (B - r));
    },
    initNonuniformCatmullRom: function(n, r, s, B, I, E, C) {
      let c = (r - n) / I - (s - n) / (I + E) + (s - r) / E, u = (s - r) / E - (B - r) / (E + C) + (B - s) / C;
      c *= E, u *= E, i(r, s, c, u);
    },
    calc: function(n) {
      const r = n * n, s = r * n;
      return g + A * n + e * r + t * s;
    }
  };
}
const yd = /* @__PURE__ */ new IA(), p0 = /* @__PURE__ */ new Ty(), D0 = /* @__PURE__ */ new Ty(), w0 = /* @__PURE__ */ new Ty();
class Pv extends ko {
  constructor(A = [], e = !1, t = "centripetal", i = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = A, this.closed = e, this.curveType = t, this.tension = i;
  }
  getPoint(A, e = new IA()) {
    const t = e, i = this.points, n = i.length, r = (n - (this.closed ? 0 : 1)) * A;
    let s = Math.floor(r), B = r - s;
    this.closed ? s += s > 0 ? 0 : (Math.floor(Math.abs(s) / n) + 1) * n : B === 0 && s === n - 1 && (s = n - 2, B = 1);
    let I, E;
    this.closed || s > 0 ? I = i[(s - 1) % n] : (yd.subVectors(i[0], i[1]).add(i[0]), I = yd);
    const C = i[s % n], c = i[(s + 1) % n];
    if (this.closed || s + 2 < n ? E = i[(s + 2) % n] : (yd.subVectors(i[n - 1], i[n - 2]).add(i[n - 1]), E = yd), this.curveType === "centripetal" || this.curveType === "chordal") {
      const u = this.curveType === "chordal" ? 0.5 : 0.25;
      let d = Math.pow(I.distanceToSquared(C), u), p = Math.pow(C.distanceToSquared(c), u), D = Math.pow(c.distanceToSquared(E), u);
      p < 1e-4 && (p = 1), d < 1e-4 && (d = p), D < 1e-4 && (D = p), p0.initNonuniformCatmullRom(I.x, C.x, c.x, E.x, d, p, D), D0.initNonuniformCatmullRom(I.y, C.y, c.y, E.y, d, p, D), w0.initNonuniformCatmullRom(I.z, C.z, c.z, E.z, d, p, D);
    } else
      this.curveType === "catmullrom" && (p0.initCatmullRom(I.x, C.x, c.x, E.x, this.tension), D0.initCatmullRom(I.y, C.y, c.y, E.y, this.tension), w0.initCatmullRom(I.z, C.z, c.z, E.z, this.tension));
    return t.set(
      p0.calc(B),
      D0.calc(B),
      w0.calc(B)
    ), t;
  }
  copy(A) {
    super.copy(A), this.points = [];
    for (let e = 0, t = A.points.length; e < t; e++) {
      const i = A.points[e];
      this.points.push(i.clone());
    }
    return this.closed = A.closed, this.curveType = A.curveType, this.tension = A.tension, this;
  }
  toJSON() {
    const A = super.toJSON();
    A.points = [];
    for (let e = 0, t = this.points.length; e < t; e++) {
      const i = this.points[e];
      A.points.push(i.toArray());
    }
    return A.closed = this.closed, A.curveType = this.curveType, A.tension = this.tension, A;
  }
  fromJSON(A) {
    super.fromJSON(A), this.points = [];
    for (let e = 0, t = A.points.length; e < t; e++) {
      const i = A.points[e];
      this.points.push(new IA().fromArray(i));
    }
    return this.closed = A.closed, this.curveType = A.curveType, this.tension = A.tension, this;
  }
}
function lN(g, A, e, t, i) {
  const n = (t - A) * 0.5, r = (i - e) * 0.5, s = g * g, B = g * s;
  return (2 * e - 2 * t + n + r) * B + (-3 * e + 3 * t - 2 * n - r) * s + n * g + e;
}
function UJ(g, A) {
  const e = 1 - g;
  return e * e * A;
}
function kJ(g, A) {
  return 2 * (1 - g) * g * A;
}
function xJ(g, A) {
  return g * g * A;
}
function Rc(g, A, e, t) {
  return UJ(g, A) + kJ(g, e) + xJ(g, t);
}
function LJ(g, A) {
  const e = 1 - g;
  return e * e * e * A;
}
function TJ(g, A) {
  const e = 1 - g;
  return 3 * e * e * g * A;
}
function KJ(g, A) {
  return 3 * (1 - g) * g * g * A;
}
function bJ(g, A) {
  return g * g * g * A;
}
function Nc(g, A, e, t, i) {
  return LJ(g, A) + TJ(g, e) + KJ(g, t) + bJ(g, i);
}
class Ky extends ko {
  constructor(A = new ue(), e = new ue(), t = new ue(), i = new ue()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = A, this.v1 = e, this.v2 = t, this.v3 = i;
  }
  getPoint(A, e = new ue()) {
    const t = e, i = this.v0, n = this.v1, r = this.v2, s = this.v3;
    return t.set(
      Nc(A, i.x, n.x, r.x, s.x),
      Nc(A, i.y, n.y, r.y, s.y)
    ), t;
  }
  copy(A) {
    return super.copy(A), this.v0.copy(A.v0), this.v1.copy(A.v1), this.v2.copy(A.v2), this.v3.copy(A.v3), this;
  }
  toJSON() {
    const A = super.toJSON();
    return A.v0 = this.v0.toArray(), A.v1 = this.v1.toArray(), A.v2 = this.v2.toArray(), A.v3 = this.v3.toArray(), A;
  }
  fromJSON(A) {
    return super.fromJSON(A), this.v0.fromArray(A.v0), this.v1.fromArray(A.v1), this.v2.fromArray(A.v2), this.v3.fromArray(A.v3), this;
  }
}
class Wv extends ko {
  constructor(A = new IA(), e = new IA(), t = new IA(), i = new IA()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = A, this.v1 = e, this.v2 = t, this.v3 = i;
  }
  getPoint(A, e = new IA()) {
    const t = e, i = this.v0, n = this.v1, r = this.v2, s = this.v3;
    return t.set(
      Nc(A, i.x, n.x, r.x, s.x),
      Nc(A, i.y, n.y, r.y, s.y),
      Nc(A, i.z, n.z, r.z, s.z)
    ), t;
  }
  copy(A) {
    return super.copy(A), this.v0.copy(A.v0), this.v1.copy(A.v1), this.v2.copy(A.v2), this.v3.copy(A.v3), this;
  }
  toJSON() {
    const A = super.toJSON();
    return A.v0 = this.v0.toArray(), A.v1 = this.v1.toArray(), A.v2 = this.v2.toArray(), A.v3 = this.v3.toArray(), A;
  }
  fromJSON(A) {
    return super.fromJSON(A), this.v0.fromArray(A.v0), this.v1.fromArray(A.v1), this.v2.fromArray(A.v2), this.v3.fromArray(A.v3), this;
  }
}
class xf extends ko {
  constructor(A = new ue(), e = new ue()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = A, this.v2 = e;
  }
  getPoint(A, e = new ue()) {
    const t = e;
    return A === 1 ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(A).add(this.v1)), t;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(A, e) {
    return this.getPoint(A, e);
  }
  getTangent(A, e = new ue()) {
    return e.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(A, e) {
    return this.getTangent(A, e);
  }
  copy(A) {
    return super.copy(A), this.v1.copy(A.v1), this.v2.copy(A.v2), this;
  }
  toJSON() {
    const A = super.toJSON();
    return A.v1 = this.v1.toArray(), A.v2 = this.v2.toArray(), A;
  }
  fromJSON(A) {
    return super.fromJSON(A), this.v1.fromArray(A.v1), this.v2.fromArray(A.v2), this;
  }
}
class zv extends ko {
  constructor(A = new IA(), e = new IA()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = A, this.v2 = e;
  }
  getPoint(A, e = new IA()) {
    const t = e;
    return A === 1 ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(A).add(this.v1)), t;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(A, e) {
    return this.getPoint(A, e);
  }
  getTangent(A, e = new IA()) {
    return e.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(A, e) {
    return this.getTangent(A, e);
  }
  copy(A) {
    return super.copy(A), this.v1.copy(A.v1), this.v2.copy(A.v2), this;
  }
  toJSON() {
    const A = super.toJSON();
    return A.v1 = this.v1.toArray(), A.v2 = this.v2.toArray(), A;
  }
  fromJSON(A) {
    return super.fromJSON(A), this.v1.fromArray(A.v1), this.v2.fromArray(A.v2), this;
  }
}
class by extends ko {
  constructor(A = new ue(), e = new ue(), t = new ue()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = A, this.v1 = e, this.v2 = t;
  }
  getPoint(A, e = new ue()) {
    const t = e, i = this.v0, n = this.v1, r = this.v2;
    return t.set(
      Rc(A, i.x, n.x, r.x),
      Rc(A, i.y, n.y, r.y)
    ), t;
  }
  copy(A) {
    return super.copy(A), this.v0.copy(A.v0), this.v1.copy(A.v1), this.v2.copy(A.v2), this;
  }
  toJSON() {
    const A = super.toJSON();
    return A.v0 = this.v0.toArray(), A.v1 = this.v1.toArray(), A.v2 = this.v2.toArray(), A;
  }
  fromJSON(A) {
    return super.fromJSON(A), this.v0.fromArray(A.v0), this.v1.fromArray(A.v1), this.v2.fromArray(A.v2), this;
  }
}
class Yy extends ko {
  constructor(A = new IA(), e = new IA(), t = new IA()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = A, this.v1 = e, this.v2 = t;
  }
  getPoint(A, e = new IA()) {
    const t = e, i = this.v0, n = this.v1, r = this.v2;
    return t.set(
      Rc(A, i.x, n.x, r.x),
      Rc(A, i.y, n.y, r.y),
      Rc(A, i.z, n.z, r.z)
    ), t;
  }
  copy(A) {
    return super.copy(A), this.v0.copy(A.v0), this.v1.copy(A.v1), this.v2.copy(A.v2), this;
  }
  toJSON() {
    const A = super.toJSON();
    return A.v0 = this.v0.toArray(), A.v1 = this.v1.toArray(), A.v2 = this.v2.toArray(), A;
  }
  fromJSON(A) {
    return super.fromJSON(A), this.v0.fromArray(A.v0), this.v1.fromArray(A.v1), this.v2.fromArray(A.v2), this;
  }
}
class Hy extends ko {
  constructor(A = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = A;
  }
  getPoint(A, e = new ue()) {
    const t = e, i = this.points, n = (i.length - 1) * A, r = Math.floor(n), s = n - r, B = i[r === 0 ? r : r - 1], I = i[r], E = i[r > i.length - 2 ? i.length - 1 : r + 1], C = i[r > i.length - 3 ? i.length - 1 : r + 2];
    return t.set(
      lN(s, B.x, I.x, E.x, C.x),
      lN(s, B.y, I.y, E.y, C.y)
    ), t;
  }
  copy(A) {
    super.copy(A), this.points = [];
    for (let e = 0, t = A.points.length; e < t; e++) {
      const i = A.points[e];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const A = super.toJSON();
    A.points = [];
    for (let e = 0, t = this.points.length; e < t; e++) {
      const i = this.points[e];
      A.points.push(i.toArray());
    }
    return A;
  }
  fromJSON(A) {
    super.fromJSON(A), this.points = [];
    for (let e = 0, t = A.points.length; e < t; e++) {
      const i = A.points[e];
      this.points.push(new ue().fromArray(i));
    }
    return this;
  }
}
var _y = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: qv,
  CatmullRomCurve3: Pv,
  CubicBezierCurve: Ky,
  CubicBezierCurve3: Wv,
  EllipseCurve: tu,
  LineCurve: xf,
  LineCurve3: zv,
  QuadraticBezierCurve: by,
  QuadraticBezierCurve3: Yy,
  SplineCurve: Hy
});
class Vv extends ko {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(A) {
    this.curves.push(A);
  }
  closePath() {
    const A = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
    A.equals(e) || this.curves.push(new xf(e, A));
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(A, e) {
    const t = A * this.getLength(), i = this.getCurveLengths();
    let n = 0;
    for (; n < i.length; ) {
      if (i[n] >= t) {
        const r = i[n] - t, s = this.curves[n], B = s.getLength(), I = B === 0 ? 0 : 1 - r / B;
        return s.getPointAt(I, e);
      }
      n++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const A = this.getCurveLengths();
    return A[A.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const A = [];
    let e = 0;
    for (let t = 0, i = this.curves.length; t < i; t++)
      e += this.curves[t].getLength(), A.push(e);
    return this.cacheLengths = A, A;
  }
  getSpacedPoints(A = 40) {
    const e = [];
    for (let t = 0; t <= A; t++)
      e.push(this.getPoint(t / A));
    return this.autoClose && e.push(e[0]), e;
  }
  getPoints(A = 12) {
    const e = [];
    let t;
    for (let i = 0, n = this.curves; i < n.length; i++) {
      const r = n[i], s = r.isEllipseCurve ? A * 2 : r.isLineCurve || r.isLineCurve3 ? 1 : r.isSplineCurve ? A * r.points.length : A, B = r.getPoints(s);
      for (let I = 0; I < B.length; I++) {
        const E = B[I];
        t && t.equals(E) || (e.push(E), t = E);
      }
    }
    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
  }
  copy(A) {
    super.copy(A), this.curves = [];
    for (let e = 0, t = A.curves.length; e < t; e++) {
      const i = A.curves[e];
      this.curves.push(i.clone());
    }
    return this.autoClose = A.autoClose, this;
  }
  toJSON() {
    const A = super.toJSON();
    A.autoClose = this.autoClose, A.curves = [];
    for (let e = 0, t = this.curves.length; e < t; e++) {
      const i = this.curves[e];
      A.curves.push(i.toJSON());
    }
    return A;
  }
  fromJSON(A) {
    super.fromJSON(A), this.autoClose = A.autoClose, this.curves = [];
    for (let e = 0, t = A.curves.length; e < t; e++) {
      const i = A.curves[e];
      this.curves.push(new _y[i.type]().fromJSON(i));
    }
    return this;
  }
}
class bc extends Vv {
  constructor(A) {
    super(), this.type = "Path", this.currentPoint = new ue(), A && this.setFromPoints(A);
  }
  setFromPoints(A) {
    this.moveTo(A[0].x, A[0].y);
    for (let e = 1, t = A.length; e < t; e++)
      this.lineTo(A[e].x, A[e].y);
    return this;
  }
  moveTo(A, e) {
    return this.currentPoint.set(A, e), this;
  }
  lineTo(A, e) {
    const t = new xf(this.currentPoint.clone(), new ue(A, e));
    return this.curves.push(t), this.currentPoint.set(A, e), this;
  }
  quadraticCurveTo(A, e, t, i) {
    const n = new by(
      this.currentPoint.clone(),
      new ue(A, e),
      new ue(t, i)
    );
    return this.curves.push(n), this.currentPoint.set(t, i), this;
  }
  bezierCurveTo(A, e, t, i, n, r) {
    const s = new Ky(
      this.currentPoint.clone(),
      new ue(A, e),
      new ue(t, i),
      new ue(n, r)
    );
    return this.curves.push(s), this.currentPoint.set(n, r), this;
  }
  splineThru(A) {
    const e = [this.currentPoint.clone()].concat(A), t = new Hy(e);
    return this.curves.push(t), this.currentPoint.copy(A[A.length - 1]), this;
  }
  arc(A, e, t, i, n, r) {
    const s = this.currentPoint.x, B = this.currentPoint.y;
    return this.absarc(
      A + s,
      e + B,
      t,
      i,
      n,
      r
    ), this;
  }
  absarc(A, e, t, i, n, r) {
    return this.absellipse(A, e, t, t, i, n, r), this;
  }
  ellipse(A, e, t, i, n, r, s, B) {
    const I = this.currentPoint.x, E = this.currentPoint.y;
    return this.absellipse(A + I, e + E, t, i, n, r, s, B), this;
  }
  absellipse(A, e, t, i, n, r, s, B) {
    const I = new tu(A, e, t, i, n, r, s, B);
    if (this.curves.length > 0) {
      const C = I.getPoint(0);
      C.equals(this.currentPoint) || this.lineTo(C.x, C.y);
    }
    this.curves.push(I);
    const E = I.getPoint(1);
    return this.currentPoint.copy(E), this;
  }
  copy(A) {
    return super.copy(A), this.currentPoint.copy(A.currentPoint), this;
  }
  toJSON() {
    const A = super.toJSON();
    return A.currentPoint = this.currentPoint.toArray(), A;
  }
  fromJSON(A) {
    return super.fromJSON(A), this.currentPoint.fromArray(A.currentPoint), this;
  }
}
class HE extends ut {
  constructor(A = [new ue(0, -0.5), new ue(0.5, 0), new ue(0, 0.5)], e = 12, t = 0, i = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: A,
      segments: e,
      phiStart: t,
      phiLength: i
    }, e = Math.floor(e), i = yn(i, 0, Math.PI * 2);
    const n = [], r = [], s = [], B = [], I = [], E = 1 / e, C = new IA(), c = new ue(), u = new IA(), d = new IA(), p = new IA();
    let D = 0, f = 0;
    for (let S = 0; S <= A.length - 1; S++)
      switch (S) {
        case 0:
          D = A[S + 1].x - A[S].x, f = A[S + 1].y - A[S].y, u.x = f * 1, u.y = -D, u.z = f * 0, p.copy(u), u.normalize(), B.push(u.x, u.y, u.z);
          break;
        case A.length - 1:
          B.push(p.x, p.y, p.z);
          break;
        default:
          D = A[S + 1].x - A[S].x, f = A[S + 1].y - A[S].y, u.x = f * 1, u.y = -D, u.z = f * 0, d.copy(u), u.x += p.x, u.y += p.y, u.z += p.z, u.normalize(), B.push(u.x, u.y, u.z), p.copy(d);
      }
    for (let S = 0; S <= e; S++) {
      const y = t + S * E * i, m = Math.sin(y), N = Math.cos(y);
      for (let F = 0; F <= A.length - 1; F++) {
        C.x = A[F].x * m, C.y = A[F].y, C.z = A[F].x * N, r.push(C.x, C.y, C.z), c.x = S / e, c.y = F / (A.length - 1), s.push(c.x, c.y);
        const G = B[3 * F + 0] * m, k = B[3 * F + 1], v = B[3 * F + 0] * N;
        I.push(G, k, v);
      }
    }
    for (let S = 0; S < e; S++)
      for (let y = 0; y < A.length - 1; y++) {
        const m = y + S * A.length, N = m, F = m + A.length, G = m + A.length + 1, k = m + 1;
        n.push(N, F, k), n.push(G, k, F);
      }
    this.setIndex(n), this.setAttribute("position", new Oe(r, 3)), this.setAttribute("uv", new Oe(s, 2)), this.setAttribute("normal", new Oe(I, 3));
  }
  copy(A) {
    return super.copy(A), this.parameters = Object.assign({}, A.parameters), this;
  }
  static fromJSON(A) {
    return new HE(A.points, A.segments, A.phiStart, A.phiLength);
  }
}
class iu extends HE {
  constructor(A = 1, e = 1, t = 4, i = 8) {
    const n = new bc();
    n.absarc(0, -e / 2, A, Math.PI * 1.5, 0), n.absarc(0, e / 2, A, 0, Math.PI * 0.5), super(n.getPoints(t), i), this.type = "CapsuleGeometry", this.parameters = {
      radius: A,
      height: e,
      capSegments: t,
      radialSegments: i
    };
  }
  static fromJSON(A) {
    return new iu(A.radius, A.length, A.capSegments, A.radialSegments);
  }
}
class nu extends ut {
  constructor(A = 1, e = 32, t = 0, i = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: A,
      segments: e,
      thetaStart: t,
      thetaLength: i
    }, e = Math.max(3, e);
    const n = [], r = [], s = [], B = [], I = new IA(), E = new ue();
    r.push(0, 0, 0), s.push(0, 0, 1), B.push(0.5, 0.5);
    for (let C = 0, c = 3; C <= e; C++, c += 3) {
      const u = t + C / e * i;
      I.x = A * Math.cos(u), I.y = A * Math.sin(u), r.push(I.x, I.y, I.z), s.push(0, 0, 1), E.x = (r[c] / A + 1) / 2, E.y = (r[c + 1] / A + 1) / 2, B.push(E.x, E.y);
    }
    for (let C = 1; C <= e; C++)
      n.push(C, C + 1, 0);
    this.setIndex(n), this.setAttribute("position", new Oe(r, 3)), this.setAttribute("normal", new Oe(s, 3)), this.setAttribute("uv", new Oe(B, 2));
  }
  copy(A) {
    return super.copy(A), this.parameters = Object.assign({}, A.parameters), this;
  }
  static fromJSON(A) {
    return new nu(A.radius, A.segments, A.thetaStart, A.thetaLength);
  }
}
class WC extends ut {
  constructor(A = 1, e = 1, t = 1, i = 32, n = 1, r = !1, s = 0, B = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: A,
      radiusBottom: e,
      height: t,
      radialSegments: i,
      heightSegments: n,
      openEnded: r,
      thetaStart: s,
      thetaLength: B
    };
    const I = this;
    i = Math.floor(i), n = Math.floor(n);
    const E = [], C = [], c = [], u = [];
    let d = 0;
    const p = [], D = t / 2;
    let f = 0;
    S(), r === !1 && (A > 0 && y(!0), e > 0 && y(!1)), this.setIndex(E), this.setAttribute("position", new Oe(C, 3)), this.setAttribute("normal", new Oe(c, 3)), this.setAttribute("uv", new Oe(u, 2));
    function S() {
      const m = new IA(), N = new IA();
      let F = 0;
      const G = (e - A) / t;
      for (let k = 0; k <= n; k++) {
        const v = [], x = k / n, H = x * (e - A) + A;
        for (let _ = 0; _ <= i; _++) {
          const j = _ / i, V = j * B + s, iA = Math.sin(V), eA = Math.cos(V);
          N.x = H * iA, N.y = -x * t + D, N.z = H * eA, C.push(N.x, N.y, N.z), m.set(iA, G, eA).normalize(), c.push(m.x, m.y, m.z), u.push(j, 1 - x), v.push(d++);
        }
        p.push(v);
      }
      for (let k = 0; k < i; k++)
        for (let v = 0; v < n; v++) {
          const x = p[v][k], H = p[v + 1][k], _ = p[v + 1][k + 1], j = p[v][k + 1];
          E.push(x, H, j), E.push(H, _, j), F += 6;
        }
      I.addGroup(f, F, 0), f += F;
    }
    function y(m) {
      const N = d, F = new ue(), G = new IA();
      let k = 0;
      const v = m === !0 ? A : e, x = m === !0 ? 1 : -1;
      for (let _ = 1; _ <= i; _++)
        C.push(0, D * x, 0), c.push(0, x, 0), u.push(0.5, 0.5), d++;
      const H = d;
      for (let _ = 0; _ <= i; _++) {
        const V = _ / i * B + s, iA = Math.cos(V), eA = Math.sin(V);
        G.x = v * eA, G.y = D * x, G.z = v * iA, C.push(G.x, G.y, G.z), c.push(0, x, 0), F.x = iA * 0.5 + 0.5, F.y = eA * 0.5 * x + 0.5, u.push(F.x, F.y), d++;
      }
      for (let _ = 0; _ < i; _++) {
        const j = N + _, V = H + _;
        m === !0 ? E.push(V, V + 1, j) : E.push(V + 1, V, j), k += 3;
      }
      I.addGroup(f, k, m === !0 ? 1 : 2), f += k;
    }
  }
  copy(A) {
    return super.copy(A), this.parameters = Object.assign({}, A.parameters), this;
  }
  static fromJSON(A) {
    return new WC(A.radiusTop, A.radiusBottom, A.height, A.radialSegments, A.heightSegments, A.openEnded, A.thetaStart, A.thetaLength);
  }
}
class gu extends WC {
  constructor(A = 1, e = 1, t = 32, i = 1, n = !1, r = 0, s = Math.PI * 2) {
    super(0, A, e, t, i, n, r, s), this.type = "ConeGeometry", this.parameters = {
      radius: A,
      height: e,
      radialSegments: t,
      heightSegments: i,
      openEnded: n,
      thetaStart: r,
      thetaLength: s
    };
  }
  static fromJSON(A) {
    return new gu(A.radius, A.height, A.radialSegments, A.heightSegments, A.openEnded, A.thetaStart, A.thetaLength);
  }
}
class AI extends ut {
  constructor(A = [], e = [], t = 1, i = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: A,
      indices: e,
      radius: t,
      detail: i
    };
    const n = [], r = [];
    s(i), I(t), E(), this.setAttribute("position", new Oe(n, 3)), this.setAttribute("normal", new Oe(n.slice(), 3)), this.setAttribute("uv", new Oe(r, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function s(S) {
      const y = new IA(), m = new IA(), N = new IA();
      for (let F = 0; F < e.length; F += 3)
        u(e[F + 0], y), u(e[F + 1], m), u(e[F + 2], N), B(y, m, N, S);
    }
    function B(S, y, m, N) {
      const F = N + 1, G = [];
      for (let k = 0; k <= F; k++) {
        G[k] = [];
        const v = S.clone().lerp(m, k / F), x = y.clone().lerp(m, k / F), H = F - k;
        for (let _ = 0; _ <= H; _++)
          _ === 0 && k === F ? G[k][_] = v : G[k][_] = v.clone().lerp(x, _ / H);
      }
      for (let k = 0; k < F; k++)
        for (let v = 0; v < 2 * (F - k) - 1; v++) {
          const x = Math.floor(v / 2);
          v % 2 === 0 ? (c(G[k][x + 1]), c(G[k + 1][x]), c(G[k][x])) : (c(G[k][x + 1]), c(G[k + 1][x + 1]), c(G[k + 1][x]));
        }
    }
    function I(S) {
      const y = new IA();
      for (let m = 0; m < n.length; m += 3)
        y.x = n[m + 0], y.y = n[m + 1], y.z = n[m + 2], y.normalize().multiplyScalar(S), n[m + 0] = y.x, n[m + 1] = y.y, n[m + 2] = y.z;
    }
    function E() {
      const S = new IA();
      for (let y = 0; y < n.length; y += 3) {
        S.x = n[y + 0], S.y = n[y + 1], S.z = n[y + 2];
        const m = D(S) / 2 / Math.PI + 0.5, N = f(S) / Math.PI + 0.5;
        r.push(m, 1 - N);
      }
      d(), C();
    }
    function C() {
      for (let S = 0; S < r.length; S += 6) {
        const y = r[S + 0], m = r[S + 2], N = r[S + 4], F = Math.max(y, m, N), G = Math.min(y, m, N);
        F > 0.9 && G < 0.1 && (y < 0.2 && (r[S + 0] += 1), m < 0.2 && (r[S + 2] += 1), N < 0.2 && (r[S + 4] += 1));
      }
    }
    function c(S) {
      n.push(S.x, S.y, S.z);
    }
    function u(S, y) {
      const m = S * 3;
      y.x = A[m + 0], y.y = A[m + 1], y.z = A[m + 2];
    }
    function d() {
      const S = new IA(), y = new IA(), m = new IA(), N = new IA(), F = new ue(), G = new ue(), k = new ue();
      for (let v = 0, x = 0; v < n.length; v += 9, x += 6) {
        S.set(n[v + 0], n[v + 1], n[v + 2]), y.set(n[v + 3], n[v + 4], n[v + 5]), m.set(n[v + 6], n[v + 7], n[v + 8]), F.set(r[x + 0], r[x + 1]), G.set(r[x + 2], r[x + 3]), k.set(r[x + 4], r[x + 5]), N.copy(S).add(y).add(m).divideScalar(3);
        const H = D(N);
        p(F, x + 0, S, H), p(G, x + 2, y, H), p(k, x + 4, m, H);
      }
    }
    function p(S, y, m, N) {
      N < 0 && S.x === 1 && (r[y] = S.x - 1), m.x === 0 && m.z === 0 && (r[y] = N / 2 / Math.PI + 0.5);
    }
    function D(S) {
      return Math.atan2(S.z, -S.x);
    }
    function f(S) {
      return Math.atan2(-S.y, Math.sqrt(S.x * S.x + S.z * S.z));
    }
  }
  copy(A) {
    return super.copy(A), this.parameters = Object.assign({}, A.parameters), this;
  }
  static fromJSON(A) {
    return new AI(A.vertices, A.indices, A.radius, A.details);
  }
}
class ru extends AI {
  constructor(A = 1, e = 0) {
    const t = (1 + Math.sqrt(5)) / 2, i = 1 / t, n = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -i,
      -t,
      0,
      -i,
      t,
      0,
      i,
      -t,
      0,
      i,
      t,
      // (1/, , 0)
      -i,
      -t,
      0,
      -i,
      t,
      0,
      i,
      -t,
      0,
      i,
      t,
      0,
      // (, 0, 1/)
      -t,
      0,
      -i,
      t,
      0,
      -i,
      -t,
      0,
      i,
      t,
      0,
      i
    ], r = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(n, r, A, e), this.type = "DodecahedronGeometry", this.parameters = {
      radius: A,
      detail: e
    };
  }
  static fromJSON(A) {
    return new ru(A.radius, A.detail);
  }
}
const md = /* @__PURE__ */ new IA(), Sd = /* @__PURE__ */ new IA(), y0 = /* @__PURE__ */ new IA(), Md = /* @__PURE__ */ new Sr();
class Jy extends ut {
  constructor(A = null, e = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: A,
      thresholdAngle: e
    }, A !== null) {
      const i = Math.pow(10, 4), n = Math.cos(FC * e), r = A.getIndex(), s = A.getAttribute("position"), B = r ? r.count : s.count, I = [0, 0, 0], E = ["a", "b", "c"], C = new Array(3), c = {}, u = [];
      for (let d = 0; d < B; d += 3) {
        r ? (I[0] = r.getX(d), I[1] = r.getX(d + 1), I[2] = r.getX(d + 2)) : (I[0] = d, I[1] = d + 1, I[2] = d + 2);
        const { a: p, b: D, c: f } = Md;
        if (p.fromBufferAttribute(s, I[0]), D.fromBufferAttribute(s, I[1]), f.fromBufferAttribute(s, I[2]), Md.getNormal(y0), C[0] = `${Math.round(p.x * i)},${Math.round(p.y * i)},${Math.round(p.z * i)}`, C[1] = `${Math.round(D.x * i)},${Math.round(D.y * i)},${Math.round(D.z * i)}`, C[2] = `${Math.round(f.x * i)},${Math.round(f.y * i)},${Math.round(f.z * i)}`, !(C[0] === C[1] || C[1] === C[2] || C[2] === C[0]))
          for (let S = 0; S < 3; S++) {
            const y = (S + 1) % 3, m = C[S], N = C[y], F = Md[E[S]], G = Md[E[y]], k = `${m}_${N}`, v = `${N}_${m}`;
            v in c && c[v] ? (y0.dot(c[v].normal) <= n && (u.push(F.x, F.y, F.z), u.push(G.x, G.y, G.z)), c[v] = null) : k in c || (c[k] = {
              index0: I[S],
              index1: I[y],
              normal: y0.clone()
            });
          }
      }
      for (const d in c)
        if (c[d]) {
          const { index0: p, index1: D } = c[d];
          md.fromBufferAttribute(s, p), Sd.fromBufferAttribute(s, D), u.push(md.x, md.y, md.z), u.push(Sd.x, Sd.y, Sd.z);
        }
      this.setAttribute("position", new Oe(u, 3));
    }
  }
  copy(A) {
    return super.copy(A), this.parameters = Object.assign({}, A.parameters), this;
  }
}
class vC extends bc {
  constructor(A) {
    super(A), this.uuid = io(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(A) {
    const e = [];
    for (let t = 0, i = this.holes.length; t < i; t++)
      e[t] = this.holes[t].getPoints(A);
    return e;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(A) {
    return {
      shape: this.getPoints(A),
      holes: this.getPointsHoles(A)
    };
  }
  copy(A) {
    super.copy(A), this.holes = [];
    for (let e = 0, t = A.holes.length; e < t; e++) {
      const i = A.holes[e];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const A = super.toJSON();
    A.uuid = this.uuid, A.holes = [];
    for (let e = 0, t = this.holes.length; e < t; e++) {
      const i = this.holes[e];
      A.holes.push(i.toJSON());
    }
    return A;
  }
  fromJSON(A) {
    super.fromJSON(A), this.uuid = A.uuid, this.holes = [];
    for (let e = 0, t = A.holes.length; e < t; e++) {
      const i = A.holes[e];
      this.holes.push(new bc().fromJSON(i));
    }
    return this;
  }
}
const YJ = {
  triangulate: function(g, A, e = 2) {
    const t = A && A.length, i = t ? A[0] * e : g.length;
    let n = jv(g, 0, i, e, !0);
    const r = [];
    if (!n || n.next === n.prev)
      return r;
    let s, B, I, E, C, c, u;
    if (t && (n = qJ(g, A, n, e)), g.length > 80 * e) {
      s = I = g[0], B = E = g[1];
      for (let d = e; d < i; d += e)
        C = g[d], c = g[d + 1], C < s && (s = C), c < B && (B = c), C > I && (I = C), c > E && (E = c);
      u = Math.max(I - s, E - B), u = u !== 0 ? 32767 / u : 0;
    }
    return Yc(n, r, e, s, B, u, 0), r;
  }
};
function jv(g, A, e, t, i) {
  let n, r;
  if (i === t1(g, A, e, t) > 0)
    for (n = A; n < e; n += t)
      r = cN(n, g[n], g[n + 1], r);
  else
    for (n = e - t; n >= A; n -= t)
      r = cN(n, g[n], g[n + 1], r);
  return r && Lf(r, r.next) && (_c(r), r = r.next), r;
}
function KC(g, A) {
  if (!g)
    return g;
  A || (A = g);
  let e = g, t;
  do
    if (t = !1, !e.steiner && (Lf(e, e.next) || hn(e.prev, e, e.next) === 0)) {
      if (_c(e), e = A = e.prev, e === e.next)
        break;
      t = !0;
    } else
      e = e.next;
  while (t || e !== A);
  return A;
}
function Yc(g, A, e, t, i, n, r) {
  if (!g)
    return;
  !r && n && jJ(g, t, i, n);
  let s = g, B, I;
  for (; g.prev !== g.next; ) {
    if (B = g.prev, I = g.next, n ? _J(g, t, i, n) : HJ(g)) {
      A.push(B.i / e | 0), A.push(g.i / e | 0), A.push(I.i / e | 0), _c(g), g = I.next, s = I.next;
      continue;
    }
    if (g = I, g === s) {
      r ? r === 1 ? (g = JJ(KC(g), A, e), Yc(g, A, e, t, i, n, 2)) : r === 2 && OJ(g, A, e, t, i, n) : Yc(KC(g), A, e, t, i, n, 1);
      break;
    }
  }
}
function HJ(g) {
  const A = g.prev, e = g, t = g.next;
  if (hn(A, e, t) >= 0)
    return !1;
  const i = A.x, n = e.x, r = t.x, s = A.y, B = e.y, I = t.y, E = i < n ? i < r ? i : r : n < r ? n : r, C = s < B ? s < I ? s : I : B < I ? B : I, c = i > n ? i > r ? i : r : n > r ? n : r, u = s > B ? s > I ? s : I : B > I ? B : I;
  let d = t.next;
  for (; d !== A; ) {
    if (d.x >= E && d.x <= c && d.y >= C && d.y <= u && fE(i, s, n, B, r, I, d.x, d.y) && hn(d.prev, d, d.next) >= 0)
      return !1;
    d = d.next;
  }
  return !0;
}
function _J(g, A, e, t) {
  const i = g.prev, n = g, r = g.next;
  if (hn(i, n, r) >= 0)
    return !1;
  const s = i.x, B = n.x, I = r.x, E = i.y, C = n.y, c = r.y, u = s < B ? s < I ? s : I : B < I ? B : I, d = E < C ? E < c ? E : c : C < c ? C : c, p = s > B ? s > I ? s : I : B > I ? B : I, D = E > C ? E > c ? E : c : C > c ? C : c, f = Ow(u, d, A, e, t), S = Ow(p, D, A, e, t);
  let y = g.prevZ, m = g.nextZ;
  for (; y && y.z >= f && m && m.z <= S; ) {
    if (y.x >= u && y.x <= p && y.y >= d && y.y <= D && y !== i && y !== r && fE(s, E, B, C, I, c, y.x, y.y) && hn(y.prev, y, y.next) >= 0 || (y = y.prevZ, m.x >= u && m.x <= p && m.y >= d && m.y <= D && m !== i && m !== r && fE(s, E, B, C, I, c, m.x, m.y) && hn(m.prev, m, m.next) >= 0))
      return !1;
    m = m.nextZ;
  }
  for (; y && y.z >= f; ) {
    if (y.x >= u && y.x <= p && y.y >= d && y.y <= D && y !== i && y !== r && fE(s, E, B, C, I, c, y.x, y.y) && hn(y.prev, y, y.next) >= 0)
      return !1;
    y = y.prevZ;
  }
  for (; m && m.z <= S; ) {
    if (m.x >= u && m.x <= p && m.y >= d && m.y <= D && m !== i && m !== r && fE(s, E, B, C, I, c, m.x, m.y) && hn(m.prev, m, m.next) >= 0)
      return !1;
    m = m.nextZ;
  }
  return !0;
}
function JJ(g, A, e) {
  let t = g;
  do {
    const i = t.prev, n = t.next.next;
    !Lf(i, n) && Zv(i, t, t.next, n) && Hc(i, n) && Hc(n, i) && (A.push(i.i / e | 0), A.push(t.i / e | 0), A.push(n.i / e | 0), _c(t), _c(t.next), t = g = n), t = t.next;
  } while (t !== g);
  return KC(t);
}
function OJ(g, A, e, t, i, n) {
  let r = g;
  do {
    let s = r.next.next;
    for (; s !== r.prev; ) {
      if (r.i !== s.i && $J(r, s)) {
        let B = Xv(r, s);
        r = KC(r, r.next), B = KC(B, B.next), Yc(r, A, e, t, i, n, 0), Yc(B, A, e, t, i, n, 0);
        return;
      }
      s = s.next;
    }
    r = r.next;
  } while (r !== g);
}
function qJ(g, A, e, t) {
  const i = [];
  let n, r, s, B, I;
  for (n = 0, r = A.length; n < r; n++)
    s = A[n] * t, B = n < r - 1 ? A[n + 1] * t : g.length, I = jv(g, s, B, t, !1), I === I.next && (I.steiner = !0), i.push(XJ(I));
  for (i.sort(PJ), n = 0; n < i.length; n++)
    e = WJ(i[n], e);
  return e;
}
function PJ(g, A) {
  return g.x - A.x;
}
function WJ(g, A) {
  const e = zJ(g, A);
  if (!e)
    return A;
  const t = Xv(e, g);
  return KC(t, t.next), KC(e, e.next);
}
function zJ(g, A) {
  let e = A, t = -1 / 0, i;
  const n = g.x, r = g.y;
  do {
    if (r <= e.y && r >= e.next.y && e.next.y !== e.y) {
      const c = e.x + (r - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (c <= n && c > t && (t = c, i = e.x < e.next.x ? e : e.next, c === n))
        return i;
    }
    e = e.next;
  } while (e !== A);
  if (!i)
    return null;
  const s = i, B = i.x, I = i.y;
  let E = 1 / 0, C;
  e = i;
  do
    n >= e.x && e.x >= B && n !== e.x && fE(r < I ? n : t, r, B, I, r < I ? t : n, r, e.x, e.y) && (C = Math.abs(r - e.y) / (n - e.x), Hc(e, g) && (C < E || C === E && (e.x > i.x || e.x === i.x && VJ(i, e))) && (i = e, E = C)), e = e.next;
  while (e !== s);
  return i;
}
function VJ(g, A) {
  return hn(g.prev, g, A.prev) < 0 && hn(A.next, g, g.next) < 0;
}
function jJ(g, A, e, t) {
  let i = g;
  do
    i.z === 0 && (i.z = Ow(i.x, i.y, A, e, t)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== g);
  i.prevZ.nextZ = null, i.prevZ = null, ZJ(i);
}
function ZJ(g) {
  let A, e, t, i, n, r, s, B, I = 1;
  do {
    for (e = g, g = null, n = null, r = 0; e; ) {
      for (r++, t = e, s = 0, A = 0; A < I && (s++, t = t.nextZ, !!t); A++)
        ;
      for (B = I; s > 0 || B > 0 && t; )
        s !== 0 && (B === 0 || !t || e.z <= t.z) ? (i = e, e = e.nextZ, s--) : (i = t, t = t.nextZ, B--), n ? n.nextZ = i : g = i, i.prevZ = n, n = i;
      e = t;
    }
    n.nextZ = null, I *= 2;
  } while (r > 1);
  return g;
}
function Ow(g, A, e, t, i) {
  return g = (g - e) * i | 0, A = (A - t) * i | 0, g = (g | g << 8) & 16711935, g = (g | g << 4) & 252645135, g = (g | g << 2) & 858993459, g = (g | g << 1) & 1431655765, A = (A | A << 8) & 16711935, A = (A | A << 4) & 252645135, A = (A | A << 2) & 858993459, A = (A | A << 1) & 1431655765, g | A << 1;
}
function XJ(g) {
  let A = g, e = g;
  do
    (A.x < e.x || A.x === e.x && A.y < e.y) && (e = A), A = A.next;
  while (A !== g);
  return e;
}
function fE(g, A, e, t, i, n, r, s) {
  return (i - r) * (A - s) >= (g - r) * (n - s) && (g - r) * (t - s) >= (e - r) * (A - s) && (e - r) * (n - s) >= (i - r) * (t - s);
}
function $J(g, A) {
  return g.next.i !== A.i && g.prev.i !== A.i && !A1(g, A) && // dones't intersect other edges
  (Hc(g, A) && Hc(A, g) && e1(g, A) && // locally visible
  (hn(g.prev, g, A.prev) || hn(g, A.prev, A)) || // does not create opposite-facing sectors
  Lf(g, A) && hn(g.prev, g, g.next) > 0 && hn(A.prev, A, A.next) > 0);
}
function hn(g, A, e) {
  return (A.y - g.y) * (e.x - A.x) - (A.x - g.x) * (e.y - A.y);
}
function Lf(g, A) {
  return g.x === A.x && g.y === A.y;
}
function Zv(g, A, e, t) {
  const i = Nd(hn(g, A, e)), n = Nd(hn(g, A, t)), r = Nd(hn(e, t, g)), s = Nd(hn(e, t, A));
  return !!(i !== n && r !== s || i === 0 && Rd(g, e, A) || n === 0 && Rd(g, t, A) || r === 0 && Rd(e, g, t) || s === 0 && Rd(e, A, t));
}
function Rd(g, A, e) {
  return A.x <= Math.max(g.x, e.x) && A.x >= Math.min(g.x, e.x) && A.y <= Math.max(g.y, e.y) && A.y >= Math.min(g.y, e.y);
}
function Nd(g) {
  return g > 0 ? 1 : g < 0 ? -1 : 0;
}
function A1(g, A) {
  let e = g;
  do {
    if (e.i !== g.i && e.next.i !== g.i && e.i !== A.i && e.next.i !== A.i && Zv(e, e.next, g, A))
      return !0;
    e = e.next;
  } while (e !== g);
  return !1;
}
function Hc(g, A) {
  return hn(g.prev, g, g.next) < 0 ? hn(g, A, g.next) >= 0 && hn(g, g.prev, A) >= 0 : hn(g, A, g.prev) < 0 || hn(g, g.next, A) < 0;
}
function e1(g, A) {
  let e = g, t = !1;
  const i = (g.x + A.x) / 2, n = (g.y + A.y) / 2;
  do
    e.y > n != e.next.y > n && e.next.y !== e.y && i < (e.next.x - e.x) * (n - e.y) / (e.next.y - e.y) + e.x && (t = !t), e = e.next;
  while (e !== g);
  return t;
}
function Xv(g, A) {
  const e = new qw(g.i, g.x, g.y), t = new qw(A.i, A.x, A.y), i = g.next, n = A.prev;
  return g.next = A, A.prev = g, e.next = i, i.prev = e, t.next = e, e.prev = t, n.next = t, t.prev = n, t;
}
function cN(g, A, e, t) {
  const i = new qw(g, A, e);
  return t ? (i.next = t.next, i.prev = t, t.next.prev = i, t.next = i) : (i.prev = i, i.next = i), i;
}
function _c(g) {
  g.next.prev = g.prev, g.prev.next = g.next, g.prevZ && (g.prevZ.nextZ = g.nextZ), g.nextZ && (g.nextZ.prevZ = g.prevZ);
}
function qw(g, A, e) {
  this.i = g, this.x = A, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function t1(g, A, e, t) {
  let i = 0;
  for (let n = A, r = e - t; n < e; n += t)
    i += (g[r] - g[n]) * (g[n + 1] + g[r + 1]), r = n;
  return i;
}
class Aa {
  // calculate area of the contour polygon
  static area(A) {
    const e = A.length;
    let t = 0;
    for (let i = e - 1, n = 0; n < e; i = n++)
      t += A[i].x * A[n].y - A[n].x * A[i].y;
    return t * 0.5;
  }
  static isClockWise(A) {
    return Aa.area(A) < 0;
  }
  static triangulateShape(A, e) {
    const t = [], i = [], n = [];
    uN(A), hN(t, A);
    let r = A.length;
    e.forEach(uN);
    for (let B = 0; B < e.length; B++)
      i.push(r), r += e[B].length, hN(t, e[B]);
    const s = YJ.triangulate(t, i);
    for (let B = 0; B < s.length; B += 3)
      n.push(s.slice(B, B + 3));
    return n;
  }
}
function uN(g) {
  const A = g.length;
  A > 2 && g[A - 1].equals(g[0]) && g.pop();
}
function hN(g, A) {
  for (let e = 0; e < A.length; e++)
    g.push(A[e].x), g.push(A[e].y);
}
class ou extends ut {
  constructor(A = new vC([new ue(0.5, 0.5), new ue(-0.5, 0.5), new ue(-0.5, -0.5), new ue(0.5, -0.5)]), e = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: A,
      options: e
    }, A = Array.isArray(A) ? A : [A];
    const t = this, i = [], n = [];
    for (let s = 0, B = A.length; s < B; s++) {
      const I = A[s];
      r(I);
    }
    this.setAttribute("position", new Oe(i, 3)), this.setAttribute("uv", new Oe(n, 2)), this.computeVertexNormals();
    function r(s) {
      const B = [], I = e.curveSegments !== void 0 ? e.curveSegments : 12, E = e.steps !== void 0 ? e.steps : 1, C = e.depth !== void 0 ? e.depth : 1;
      let c = e.bevelEnabled !== void 0 ? e.bevelEnabled : !0, u = e.bevelThickness !== void 0 ? e.bevelThickness : 0.2, d = e.bevelSize !== void 0 ? e.bevelSize : u - 0.1, p = e.bevelOffset !== void 0 ? e.bevelOffset : 0, D = e.bevelSegments !== void 0 ? e.bevelSegments : 3;
      const f = e.extrudePath, S = e.UVGenerator !== void 0 ? e.UVGenerator : i1;
      let y, m = !1, N, F, G, k;
      f && (y = f.getSpacedPoints(E), m = !0, c = !1, N = f.computeFrenetFrames(E, !1), F = new IA(), G = new IA(), k = new IA()), c || (D = 0, u = 0, d = 0, p = 0);
      const v = s.extractPoints(I);
      let x = v.shape;
      const H = v.holes;
      if (!Aa.isClockWise(x)) {
        x = x.reverse();
        for (let dA = 0, vA = H.length; dA < vA; dA++) {
          const JA = H[dA];
          Aa.isClockWise(JA) && (H[dA] = JA.reverse());
        }
      }
      const j = Aa.triangulateShape(x, H), V = x;
      for (let dA = 0, vA = H.length; dA < vA; dA++) {
        const JA = H[dA];
        x = x.concat(JA);
      }
      function iA(dA, vA, JA) {
        return vA || console.error("THREE.ExtrudeGeometry: vec does not exist"), dA.clone().addScaledVector(vA, JA);
      }
      const eA = x.length, oA = j.length;
      function P(dA, vA, JA) {
        let ne, ee, pe;
        const Ae = dA.x - vA.x, ie = dA.y - vA.y, de = JA.x - dA.x, O = JA.y - dA.y, AA = Ae * Ae + ie * ie, q = Ae * O - ie * de;
        if (Math.abs(q) > Number.EPSILON) {
          const Z = Math.sqrt(AA), $ = Math.sqrt(de * de + O * O), BA = vA.x - ie / Z, GA = vA.y + Ae / Z, bA = JA.x - O / $, DA = JA.y + de / $, SA = ((bA - BA) * O - (DA - GA) * de) / (Ae * O - ie * de);
          ne = BA + Ae * SA - dA.x, ee = GA + ie * SA - dA.y;
          const EA = ne * ne + ee * ee;
          if (EA <= 2)
            return new ue(ne, ee);
          pe = Math.sqrt(EA / 2);
        } else {
          let Z = !1;
          Ae > Number.EPSILON ? de > Number.EPSILON && (Z = !0) : Ae < -Number.EPSILON ? de < -Number.EPSILON && (Z = !0) : Math.sign(ie) === Math.sign(O) && (Z = !0), Z ? (ne = -ie, ee = Ae, pe = Math.sqrt(AA)) : (ne = Ae, ee = ie, pe = Math.sqrt(AA / 2));
        }
        return new ue(ne / pe, ee / pe);
      }
      const J = [];
      for (let dA = 0, vA = V.length, JA = vA - 1, ne = dA + 1; dA < vA; dA++, JA++, ne++)
        JA === vA && (JA = 0), ne === vA && (ne = 0), J[dA] = P(V[dA], V[JA], V[ne]);
      const tA = [];
      let Y, rA = J.concat();
      for (let dA = 0, vA = H.length; dA < vA; dA++) {
        const JA = H[dA];
        Y = [];
        for (let ne = 0, ee = JA.length, pe = ee - 1, Ae = ne + 1; ne < ee; ne++, pe++, Ae++)
          pe === ee && (pe = 0), Ae === ee && (Ae = 0), Y[ne] = P(JA[ne], JA[pe], JA[Ae]);
        tA.push(Y), rA = rA.concat(Y);
      }
      for (let dA = 0; dA < D; dA++) {
        const vA = dA / D, JA = u * Math.cos(vA * Math.PI / 2), ne = d * Math.sin(vA * Math.PI / 2) + p;
        for (let ee = 0, pe = V.length; ee < pe; ee++) {
          const Ae = iA(V[ee], J[ee], ne);
          fA(Ae.x, Ae.y, -JA);
        }
        for (let ee = 0, pe = H.length; ee < pe; ee++) {
          const Ae = H[ee];
          Y = tA[ee];
          for (let ie = 0, de = Ae.length; ie < de; ie++) {
            const O = iA(Ae[ie], Y[ie], ne);
            fA(O.x, O.y, -JA);
          }
        }
      }
      const QA = d + p;
      for (let dA = 0; dA < eA; dA++) {
        const vA = c ? iA(x[dA], rA[dA], QA) : x[dA];
        m ? (G.copy(N.normals[0]).multiplyScalar(vA.x), F.copy(N.binormals[0]).multiplyScalar(vA.y), k.copy(y[0]).add(G).add(F), fA(k.x, k.y, k.z)) : fA(vA.x, vA.y, 0);
      }
      for (let dA = 1; dA <= E; dA++)
        for (let vA = 0; vA < eA; vA++) {
          const JA = c ? iA(x[vA], rA[vA], QA) : x[vA];
          m ? (G.copy(N.normals[dA]).multiplyScalar(JA.x), F.copy(N.binormals[dA]).multiplyScalar(JA.y), k.copy(y[dA]).add(G).add(F), fA(k.x, k.y, k.z)) : fA(JA.x, JA.y, C / E * dA);
        }
      for (let dA = D - 1; dA >= 0; dA--) {
        const vA = dA / D, JA = u * Math.cos(vA * Math.PI / 2), ne = d * Math.sin(vA * Math.PI / 2) + p;
        for (let ee = 0, pe = V.length; ee < pe; ee++) {
          const Ae = iA(V[ee], J[ee], ne);
          fA(Ae.x, Ae.y, C + JA);
        }
        for (let ee = 0, pe = H.length; ee < pe; ee++) {
          const Ae = H[ee];
          Y = tA[ee];
          for (let ie = 0, de = Ae.length; ie < de; ie++) {
            const O = iA(Ae[ie], Y[ie], ne);
            m ? fA(O.x, O.y + y[E - 1].y, y[E - 1].x + JA) : fA(O.x, O.y, C + JA);
          }
        }
      }
      aA(), MA();
      function aA() {
        const dA = i.length / 3;
        if (c) {
          let vA = 0, JA = eA * vA;
          for (let ne = 0; ne < oA; ne++) {
            const ee = j[ne];
            wA(ee[2] + JA, ee[1] + JA, ee[0] + JA);
          }
          vA = E + D * 2, JA = eA * vA;
          for (let ne = 0; ne < oA; ne++) {
            const ee = j[ne];
            wA(ee[0] + JA, ee[1] + JA, ee[2] + JA);
          }
        } else {
          for (let vA = 0; vA < oA; vA++) {
            const JA = j[vA];
            wA(JA[2], JA[1], JA[0]);
          }
          for (let vA = 0; vA < oA; vA++) {
            const JA = j[vA];
            wA(JA[0] + eA * E, JA[1] + eA * E, JA[2] + eA * E);
          }
        }
        t.addGroup(dA, i.length / 3 - dA, 0);
      }
      function MA() {
        const dA = i.length / 3;
        let vA = 0;
        hA(V, vA), vA += V.length;
        for (let JA = 0, ne = H.length; JA < ne; JA++) {
          const ee = H[JA];
          hA(ee, vA), vA += ee.length;
        }
        t.addGroup(dA, i.length / 3 - dA, 1);
      }
      function hA(dA, vA) {
        let JA = dA.length;
        for (; --JA >= 0; ) {
          const ne = JA;
          let ee = JA - 1;
          ee < 0 && (ee = dA.length - 1);
          for (let pe = 0, Ae = E + D * 2; pe < Ae; pe++) {
            const ie = eA * pe, de = eA * (pe + 1), O = vA + ne + ie, AA = vA + ee + ie, q = vA + ee + de, Z = vA + ne + de;
            yA(O, AA, q, Z);
          }
        }
      }
      function fA(dA, vA, JA) {
        B.push(dA), B.push(vA), B.push(JA);
      }
      function wA(dA, vA, JA) {
        kA(dA), kA(vA), kA(JA);
        const ne = i.length / 3, ee = S.generateTopUV(t, i, ne - 3, ne - 2, ne - 1);
        FA(ee[0]), FA(ee[1]), FA(ee[2]);
      }
      function yA(dA, vA, JA, ne) {
        kA(dA), kA(vA), kA(ne), kA(vA), kA(JA), kA(ne);
        const ee = i.length / 3, pe = S.generateSideWallUV(t, i, ee - 6, ee - 3, ee - 2, ee - 1);
        FA(pe[0]), FA(pe[1]), FA(pe[3]), FA(pe[1]), FA(pe[2]), FA(pe[3]);
      }
      function kA(dA) {
        i.push(B[dA * 3 + 0]), i.push(B[dA * 3 + 1]), i.push(B[dA * 3 + 2]);
      }
      function FA(dA) {
        n.push(dA.x), n.push(dA.y);
      }
    }
  }
  copy(A) {
    return super.copy(A), this.parameters = Object.assign({}, A.parameters), this;
  }
  toJSON() {
    const A = super.toJSON(), e = this.parameters.shapes, t = this.parameters.options;
    return n1(e, t, A);
  }
  static fromJSON(A, e) {
    const t = [];
    for (let n = 0, r = A.shapes.length; n < r; n++) {
      const s = e[A.shapes[n]];
      t.push(s);
    }
    const i = A.options.extrudePath;
    return i !== void 0 && (A.options.extrudePath = new _y[i.type]().fromJSON(i)), new ou(t, A.options);
  }
}
const i1 = {
  generateTopUV: function(g, A, e, t, i) {
    const n = A[e * 3], r = A[e * 3 + 1], s = A[t * 3], B = A[t * 3 + 1], I = A[i * 3], E = A[i * 3 + 1];
    return [
      new ue(n, r),
      new ue(s, B),
      new ue(I, E)
    ];
  },
  generateSideWallUV: function(g, A, e, t, i, n) {
    const r = A[e * 3], s = A[e * 3 + 1], B = A[e * 3 + 2], I = A[t * 3], E = A[t * 3 + 1], C = A[t * 3 + 2], c = A[i * 3], u = A[i * 3 + 1], d = A[i * 3 + 2], p = A[n * 3], D = A[n * 3 + 1], f = A[n * 3 + 2];
    return Math.abs(s - E) < Math.abs(r - I) ? [
      new ue(r, 1 - B),
      new ue(I, 1 - C),
      new ue(c, 1 - d),
      new ue(p, 1 - f)
    ] : [
      new ue(s, 1 - B),
      new ue(E, 1 - C),
      new ue(u, 1 - d),
      new ue(D, 1 - f)
    ];
  }
};
function n1(g, A, e) {
  if (e.shapes = [], Array.isArray(g))
    for (let t = 0, i = g.length; t < i; t++) {
      const n = g[t];
      e.shapes.push(n.uuid);
    }
  else
    e.shapes.push(g.uuid);
  return e.options = Object.assign({}, A), A.extrudePath !== void 0 && (e.options.extrudePath = A.extrudePath.toJSON()), e;
}
class su extends AI {
  constructor(A = 1, e = 0) {
    const t = (1 + Math.sqrt(5)) / 2, i = [
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      0,
      0,
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      t,
      0,
      -1,
      t,
      0,
      1,
      -t,
      0,
      -1,
      -t,
      0,
      1
    ], n = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(i, n, A, e), this.type = "IcosahedronGeometry", this.parameters = {
      radius: A,
      detail: e
    };
  }
  static fromJSON(A) {
    return new su(A.radius, A.detail);
  }
}
class _E extends AI {
  constructor(A = 1, e = 0) {
    const t = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], i = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(t, i, A, e), this.type = "OctahedronGeometry", this.parameters = {
      radius: A,
      detail: e
    };
  }
  static fromJSON(A) {
    return new _E(A.radius, A.detail);
  }
}
class au extends ut {
  constructor(A = 0.5, e = 1, t = 32, i = 1, n = 0, r = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: A,
      outerRadius: e,
      thetaSegments: t,
      phiSegments: i,
      thetaStart: n,
      thetaLength: r
    }, t = Math.max(3, t), i = Math.max(1, i);
    const s = [], B = [], I = [], E = [];
    let C = A;
    const c = (e - A) / i, u = new IA(), d = new ue();
    for (let p = 0; p <= i; p++) {
      for (let D = 0; D <= t; D++) {
        const f = n + D / t * r;
        u.x = C * Math.cos(f), u.y = C * Math.sin(f), B.push(u.x, u.y, u.z), I.push(0, 0, 1), d.x = (u.x / e + 1) / 2, d.y = (u.y / e + 1) / 2, E.push(d.x, d.y);
      }
      C += c;
    }
    for (let p = 0; p < i; p++) {
      const D = p * (t + 1);
      for (let f = 0; f < t; f++) {
        const S = f + D, y = S, m = S + t + 1, N = S + t + 2, F = S + 1;
        s.push(y, m, F), s.push(m, N, F);
      }
    }
    this.setIndex(s), this.setAttribute("position", new Oe(B, 3)), this.setAttribute("normal", new Oe(I, 3)), this.setAttribute("uv", new Oe(E, 2));
  }
  copy(A) {
    return super.copy(A), this.parameters = Object.assign({}, A.parameters), this;
  }
  static fromJSON(A) {
    return new au(A.innerRadius, A.outerRadius, A.thetaSegments, A.phiSegments, A.thetaStart, A.thetaLength);
  }
}
class Iu extends ut {
  constructor(A = new vC([new ue(0, 0.5), new ue(-0.5, -0.5), new ue(0.5, -0.5)]), e = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: A,
      curveSegments: e
    };
    const t = [], i = [], n = [], r = [];
    let s = 0, B = 0;
    if (Array.isArray(A) === !1)
      I(A);
    else
      for (let E = 0; E < A.length; E++)
        I(A[E]), this.addGroup(s, B, E), s += B, B = 0;
    this.setIndex(t), this.setAttribute("position", new Oe(i, 3)), this.setAttribute("normal", new Oe(n, 3)), this.setAttribute("uv", new Oe(r, 2));
    function I(E) {
      const C = i.length / 3, c = E.extractPoints(e);
      let u = c.shape;
      const d = c.holes;
      Aa.isClockWise(u) === !1 && (u = u.reverse());
      for (let D = 0, f = d.length; D < f; D++) {
        const S = d[D];
        Aa.isClockWise(S) === !0 && (d[D] = S.reverse());
      }
      const p = Aa.triangulateShape(u, d);
      for (let D = 0, f = d.length; D < f; D++) {
        const S = d[D];
        u = u.concat(S);
      }
      for (let D = 0, f = u.length; D < f; D++) {
        const S = u[D];
        i.push(S.x, S.y, 0), n.push(0, 0, 1), r.push(S.x, S.y);
      }
      for (let D = 0, f = p.length; D < f; D++) {
        const S = p[D], y = S[0] + C, m = S[1] + C, N = S[2] + C;
        t.push(y, m, N), B += 3;
      }
    }
  }
  copy(A) {
    return super.copy(A), this.parameters = Object.assign({}, A.parameters), this;
  }
  toJSON() {
    const A = super.toJSON(), e = this.parameters.shapes;
    return g1(e, A);
  }
  static fromJSON(A, e) {
    const t = [];
    for (let i = 0, n = A.shapes.length; i < n; i++) {
      const r = e[A.shapes[i]];
      t.push(r);
    }
    return new Iu(t, A.curveSegments);
  }
}
function g1(g, A) {
  if (A.shapes = [], Array.isArray(g))
    for (let e = 0, t = g.length; e < t; e++) {
      const i = g[e];
      A.shapes.push(i.uuid);
    }
  else
    A.shapes.push(g.uuid);
  return A;
}
class JE extends ut {
  constructor(A = 1, e = 32, t = 16, i = 0, n = Math.PI * 2, r = 0, s = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: A,
      widthSegments: e,
      heightSegments: t,
      phiStart: i,
      phiLength: n,
      thetaStart: r,
      thetaLength: s
    }, e = Math.max(3, Math.floor(e)), t = Math.max(2, Math.floor(t));
    const B = Math.min(r + s, Math.PI);
    let I = 0;
    const E = [], C = new IA(), c = new IA(), u = [], d = [], p = [], D = [];
    for (let f = 0; f <= t; f++) {
      const S = [], y = f / t;
      let m = 0;
      f === 0 && r === 0 ? m = 0.5 / e : f === t && B === Math.PI && (m = -0.5 / e);
      for (let N = 0; N <= e; N++) {
        const F = N / e;
        C.x = -A * Math.cos(i + F * n) * Math.sin(r + y * s), C.y = A * Math.cos(r + y * s), C.z = A * Math.sin(i + F * n) * Math.sin(r + y * s), d.push(C.x, C.y, C.z), c.copy(C).normalize(), p.push(c.x, c.y, c.z), D.push(F + m, 1 - y), S.push(I++);
      }
      E.push(S);
    }
    for (let f = 0; f < t; f++)
      for (let S = 0; S < e; S++) {
        const y = E[f][S + 1], m = E[f][S], N = E[f + 1][S], F = E[f + 1][S + 1];
        (f !== 0 || r > 0) && u.push(y, m, F), (f !== t - 1 || B < Math.PI) && u.push(m, N, F);
      }
    this.setIndex(u), this.setAttribute("position", new Oe(d, 3)), this.setAttribute("normal", new Oe(p, 3)), this.setAttribute("uv", new Oe(D, 2));
  }
  copy(A) {
    return super.copy(A), this.parameters = Object.assign({}, A.parameters), this;
  }
  static fromJSON(A) {
    return new JE(A.radius, A.widthSegments, A.heightSegments, A.phiStart, A.phiLength, A.thetaStart, A.thetaLength);
  }
}
class Bu extends AI {
  constructor(A = 1, e = 0) {
    const t = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], i = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(t, i, A, e), this.type = "TetrahedronGeometry", this.parameters = {
      radius: A,
      detail: e
    };
  }
  static fromJSON(A) {
    return new Bu(A.radius, A.detail);
  }
}
class Cu extends ut {
  constructor(A = 1, e = 0.4, t = 12, i = 48, n = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: A,
      tube: e,
      radialSegments: t,
      tubularSegments: i,
      arc: n
    }, t = Math.floor(t), i = Math.floor(i);
    const r = [], s = [], B = [], I = [], E = new IA(), C = new IA(), c = new IA();
    for (let u = 0; u <= t; u++)
      for (let d = 0; d <= i; d++) {
        const p = d / i * n, D = u / t * Math.PI * 2;
        C.x = (A + e * Math.cos(D)) * Math.cos(p), C.y = (A + e * Math.cos(D)) * Math.sin(p), C.z = e * Math.sin(D), s.push(C.x, C.y, C.z), E.x = A * Math.cos(p), E.y = A * Math.sin(p), c.subVectors(C, E).normalize(), B.push(c.x, c.y, c.z), I.push(d / i), I.push(u / t);
      }
    for (let u = 1; u <= t; u++)
      for (let d = 1; d <= i; d++) {
        const p = (i + 1) * u + d - 1, D = (i + 1) * (u - 1) + d - 1, f = (i + 1) * (u - 1) + d, S = (i + 1) * u + d;
        r.push(p, D, S), r.push(D, f, S);
      }
    this.setIndex(r), this.setAttribute("position", new Oe(s, 3)), this.setAttribute("normal", new Oe(B, 3)), this.setAttribute("uv", new Oe(I, 2));
  }
  copy(A) {
    return super.copy(A), this.parameters = Object.assign({}, A.parameters), this;
  }
  static fromJSON(A) {
    return new Cu(A.radius, A.tube, A.radialSegments, A.tubularSegments, A.arc);
  }
}
class Qu extends ut {
  constructor(A = 1, e = 0.4, t = 64, i = 8, n = 2, r = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: A,
      tube: e,
      tubularSegments: t,
      radialSegments: i,
      p: n,
      q: r
    }, t = Math.floor(t), i = Math.floor(i);
    const s = [], B = [], I = [], E = [], C = new IA(), c = new IA(), u = new IA(), d = new IA(), p = new IA(), D = new IA(), f = new IA();
    for (let y = 0; y <= t; ++y) {
      const m = y / t * n * Math.PI * 2;
      S(m, n, r, A, u), S(m + 0.01, n, r, A, d), D.subVectors(d, u), f.addVectors(d, u), p.crossVectors(D, f), f.crossVectors(p, D), p.normalize(), f.normalize();
      for (let N = 0; N <= i; ++N) {
        const F = N / i * Math.PI * 2, G = -e * Math.cos(F), k = e * Math.sin(F);
        C.x = u.x + (G * f.x + k * p.x), C.y = u.y + (G * f.y + k * p.y), C.z = u.z + (G * f.z + k * p.z), B.push(C.x, C.y, C.z), c.subVectors(C, u).normalize(), I.push(c.x, c.y, c.z), E.push(y / t), E.push(N / i);
      }
    }
    for (let y = 1; y <= t; y++)
      for (let m = 1; m <= i; m++) {
        const N = (i + 1) * (y - 1) + (m - 1), F = (i + 1) * y + (m - 1), G = (i + 1) * y + m, k = (i + 1) * (y - 1) + m;
        s.push(N, F, k), s.push(F, G, k);
      }
    this.setIndex(s), this.setAttribute("position", new Oe(B, 3)), this.setAttribute("normal", new Oe(I, 3)), this.setAttribute("uv", new Oe(E, 2));
    function S(y, m, N, F, G) {
      const k = Math.cos(y), v = Math.sin(y), x = N / m * y, H = Math.cos(x);
      G.x = F * (2 + H) * 0.5 * k, G.y = F * (2 + H) * v * 0.5, G.z = F * Math.sin(x) * 0.5;
    }
  }
  copy(A) {
    return super.copy(A), this.parameters = Object.assign({}, A.parameters), this;
  }
  static fromJSON(A) {
    return new Qu(A.radius, A.tube, A.tubularSegments, A.radialSegments, A.p, A.q);
  }
}
class Eu extends ut {
  constructor(A = new Yy(new IA(-1, -1, 0), new IA(-1, 1, 0), new IA(1, 1, 0)), e = 64, t = 1, i = 8, n = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: A,
      tubularSegments: e,
      radius: t,
      radialSegments: i,
      closed: n
    };
    const r = A.computeFrenetFrames(e, n);
    this.tangents = r.tangents, this.normals = r.normals, this.binormals = r.binormals;
    const s = new IA(), B = new IA(), I = new ue();
    let E = new IA();
    const C = [], c = [], u = [], d = [];
    p(), this.setIndex(d), this.setAttribute("position", new Oe(C, 3)), this.setAttribute("normal", new Oe(c, 3)), this.setAttribute("uv", new Oe(u, 2));
    function p() {
      for (let y = 0; y < e; y++)
        D(y);
      D(n === !1 ? e : 0), S(), f();
    }
    function D(y) {
      E = A.getPointAt(y / e, E);
      const m = r.normals[y], N = r.binormals[y];
      for (let F = 0; F <= i; F++) {
        const G = F / i * Math.PI * 2, k = Math.sin(G), v = -Math.cos(G);
        B.x = v * m.x + k * N.x, B.y = v * m.y + k * N.y, B.z = v * m.z + k * N.z, B.normalize(), c.push(B.x, B.y, B.z), s.x = E.x + t * B.x, s.y = E.y + t * B.y, s.z = E.z + t * B.z, C.push(s.x, s.y, s.z);
      }
    }
    function f() {
      for (let y = 1; y <= e; y++)
        for (let m = 1; m <= i; m++) {
          const N = (i + 1) * (y - 1) + (m - 1), F = (i + 1) * y + (m - 1), G = (i + 1) * y + m, k = (i + 1) * (y - 1) + m;
          d.push(N, F, k), d.push(F, G, k);
        }
    }
    function S() {
      for (let y = 0; y <= e; y++)
        for (let m = 0; m <= i; m++)
          I.x = y / e, I.y = m / i, u.push(I.x, I.y);
    }
  }
  copy(A) {
    return super.copy(A), this.parameters = Object.assign({}, A.parameters), this;
  }
  toJSON() {
    const A = super.toJSON();
    return A.path = this.parameters.path.toJSON(), A;
  }
  static fromJSON(A) {
    return new Eu(
      new _y[A.path.type]().fromJSON(A.path),
      A.tubularSegments,
      A.radius,
      A.radialSegments,
      A.closed
    );
  }
}
class $v extends ut {
  constructor(A = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: A
    }, A !== null) {
      const e = [], t = /* @__PURE__ */ new Set(), i = new IA(), n = new IA();
      if (A.index !== null) {
        const r = A.attributes.position, s = A.index;
        let B = A.groups;
        B.length === 0 && (B = [{ start: 0, count: s.count, materialIndex: 0 }]);
        for (let I = 0, E = B.length; I < E; ++I) {
          const C = B[I], c = C.start, u = C.count;
          for (let d = c, p = c + u; d < p; d += 3)
            for (let D = 0; D < 3; D++) {
              const f = s.getX(d + D), S = s.getX(d + (D + 1) % 3);
              i.fromBufferAttribute(r, f), n.fromBufferAttribute(r, S), dN(i, n, t) === !0 && (e.push(i.x, i.y, i.z), e.push(n.x, n.y, n.z));
            }
        }
      } else {
        const r = A.attributes.position;
        for (let s = 0, B = r.count / 3; s < B; s++)
          for (let I = 0; I < 3; I++) {
            const E = 3 * s + I, C = 3 * s + (I + 1) % 3;
            i.fromBufferAttribute(r, E), n.fromBufferAttribute(r, C), dN(i, n, t) === !0 && (e.push(i.x, i.y, i.z), e.push(n.x, n.y, n.z));
          }
      }
      this.setAttribute("position", new Oe(e, 3));
    }
  }
  copy(A) {
    return super.copy(A), this.parameters = Object.assign({}, A.parameters), this;
  }
}
function dN(g, A, e) {
  const t = `${g.x},${g.y},${g.z}-${A.x},${A.y},${A.z}`, i = `${A.x},${A.y},${A.z}-${g.x},${g.y},${g.z}`;
  return e.has(t) === !0 || e.has(i) === !0 ? !1 : (e.add(t), e.add(i), !0);
}
var fN = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: Xa,
  CapsuleGeometry: iu,
  CircleGeometry: nu,
  ConeGeometry: gu,
  CylinderGeometry: WC,
  DodecahedronGeometry: ru,
  EdgesGeometry: Jy,
  ExtrudeGeometry: ou,
  IcosahedronGeometry: su,
  LatheGeometry: HE,
  OctahedronGeometry: _E,
  PlaneGeometry: PC,
  PolyhedronGeometry: AI,
  RingGeometry: au,
  ShapeGeometry: Iu,
  SphereGeometry: JE,
  TetrahedronGeometry: Bu,
  TorusGeometry: Cu,
  TorusKnotGeometry: Qu,
  TubeGeometry: Eu,
  WireframeGeometry: $v
});
class AU extends Sn {
  constructor(A) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new ke(0), this.transparent = !0, this.fog = !0, this.setValues(A);
  }
  copy(A) {
    return super.copy(A), this.color.copy(A.color), this.fog = A.fog, this;
  }
}
class eU extends ia {
  constructor(A) {
    super(A), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class lu extends Sn {
  constructor(A) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new ke(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ke(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fB, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(A);
  }
  copy(A) {
    return super.copy(A), this.defines = { STANDARD: "" }, this.color.copy(A.color), this.roughness = A.roughness, this.metalness = A.metalness, this.map = A.map, this.lightMap = A.lightMap, this.lightMapIntensity = A.lightMapIntensity, this.aoMap = A.aoMap, this.aoMapIntensity = A.aoMapIntensity, this.emissive.copy(A.emissive), this.emissiveMap = A.emissiveMap, this.emissiveIntensity = A.emissiveIntensity, this.bumpMap = A.bumpMap, this.bumpScale = A.bumpScale, this.normalMap = A.normalMap, this.normalMapType = A.normalMapType, this.normalScale.copy(A.normalScale), this.displacementMap = A.displacementMap, this.displacementScale = A.displacementScale, this.displacementBias = A.displacementBias, this.roughnessMap = A.roughnessMap, this.metalnessMap = A.metalnessMap, this.alphaMap = A.alphaMap, this.envMap = A.envMap, this.envMapIntensity = A.envMapIntensity, this.wireframe = A.wireframe, this.wireframeLinewidth = A.wireframeLinewidth, this.wireframeLinecap = A.wireframeLinecap, this.wireframeLinejoin = A.wireframeLinejoin, this.flatShading = A.flatShading, this.fog = A.fog, this;
  }
}
class eI extends lu {
  constructor(A) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ue(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return yn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(e) {
        this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new ke(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new ke(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new ke(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(A);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(A) {
    this._sheen > 0 != A > 0 && this.version++, this._sheen = A;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(A) {
    this._clearcoat > 0 != A > 0 && this.version++, this._clearcoat = A;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(A) {
    this._iridescence > 0 != A > 0 && this.version++, this._iridescence = A;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(A) {
    this._transmission > 0 != A > 0 && this.version++, this._transmission = A;
  }
  copy(A) {
    return super.copy(A), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.clearcoat = A.clearcoat, this.clearcoatMap = A.clearcoatMap, this.clearcoatRoughness = A.clearcoatRoughness, this.clearcoatRoughnessMap = A.clearcoatRoughnessMap, this.clearcoatNormalMap = A.clearcoatNormalMap, this.clearcoatNormalScale.copy(A.clearcoatNormalScale), this.ior = A.ior, this.iridescence = A.iridescence, this.iridescenceMap = A.iridescenceMap, this.iridescenceIOR = A.iridescenceIOR, this.iridescenceThicknessRange = [...A.iridescenceThicknessRange], this.iridescenceThicknessMap = A.iridescenceThicknessMap, this.sheen = A.sheen, this.sheenColor.copy(A.sheenColor), this.sheenColorMap = A.sheenColorMap, this.sheenRoughness = A.sheenRoughness, this.sheenRoughnessMap = A.sheenRoughnessMap, this.transmission = A.transmission, this.transmissionMap = A.transmissionMap, this.thickness = A.thickness, this.thicknessMap = A.thicknessMap, this.attenuationDistance = A.attenuationDistance, this.attenuationColor.copy(A.attenuationColor), this.specularIntensity = A.specularIntensity, this.specularIntensityMap = A.specularIntensityMap, this.specularColor.copy(A.specularColor), this.specularColorMap = A.specularColorMap, this;
  }
}
class UC extends Sn {
  constructor(A) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new ke(16777215), this.specular = new ke(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ke(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fB, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = jc, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(A);
  }
  copy(A) {
    return super.copy(A), this.color.copy(A.color), this.specular.copy(A.specular), this.shininess = A.shininess, this.map = A.map, this.lightMap = A.lightMap, this.lightMapIntensity = A.lightMapIntensity, this.aoMap = A.aoMap, this.aoMapIntensity = A.aoMapIntensity, this.emissive.copy(A.emissive), this.emissiveMap = A.emissiveMap, this.emissiveIntensity = A.emissiveIntensity, this.bumpMap = A.bumpMap, this.bumpScale = A.bumpScale, this.normalMap = A.normalMap, this.normalMapType = A.normalMapType, this.normalScale.copy(A.normalScale), this.displacementMap = A.displacementMap, this.displacementScale = A.displacementScale, this.displacementBias = A.displacementBias, this.specularMap = A.specularMap, this.alphaMap = A.alphaMap, this.envMap = A.envMap, this.combine = A.combine, this.reflectivity = A.reflectivity, this.refractionRatio = A.refractionRatio, this.wireframe = A.wireframe, this.wireframeLinewidth = A.wireframeLinewidth, this.wireframeLinecap = A.wireframeLinecap, this.wireframeLinejoin = A.wireframeLinejoin, this.flatShading = A.flatShading, this.fog = A.fog, this;
  }
}
class tU extends Sn {
  constructor(A) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new ke(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ke(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fB, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(A);
  }
  copy(A) {
    return super.copy(A), this.color.copy(A.color), this.map = A.map, this.gradientMap = A.gradientMap, this.lightMap = A.lightMap, this.lightMapIntensity = A.lightMapIntensity, this.aoMap = A.aoMap, this.aoMapIntensity = A.aoMapIntensity, this.emissive.copy(A.emissive), this.emissiveMap = A.emissiveMap, this.emissiveIntensity = A.emissiveIntensity, this.bumpMap = A.bumpMap, this.bumpScale = A.bumpScale, this.normalMap = A.normalMap, this.normalMapType = A.normalMapType, this.normalScale.copy(A.normalScale), this.displacementMap = A.displacementMap, this.displacementScale = A.displacementScale, this.displacementBias = A.displacementBias, this.alphaMap = A.alphaMap, this.wireframe = A.wireframe, this.wireframeLinewidth = A.wireframeLinewidth, this.wireframeLinecap = A.wireframeLinecap, this.wireframeLinejoin = A.wireframeLinejoin, this.fog = A.fog, this;
  }
}
class Oy extends Sn {
  constructor(A) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fB, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(A);
  }
  copy(A) {
    return super.copy(A), this.bumpMap = A.bumpMap, this.bumpScale = A.bumpScale, this.normalMap = A.normalMap, this.normalMapType = A.normalMapType, this.normalScale.copy(A.normalScale), this.displacementMap = A.displacementMap, this.displacementScale = A.displacementScale, this.displacementBias = A.displacementBias, this.wireframe = A.wireframe, this.wireframeLinewidth = A.wireframeLinewidth, this.flatShading = A.flatShading, this;
  }
}
class qy extends Sn {
  constructor(A) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new ke(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ke(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fB, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = jc, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(A);
  }
  copy(A) {
    return super.copy(A), this.color.copy(A.color), this.map = A.map, this.lightMap = A.lightMap, this.lightMapIntensity = A.lightMapIntensity, this.aoMap = A.aoMap, this.aoMapIntensity = A.aoMapIntensity, this.emissive.copy(A.emissive), this.emissiveMap = A.emissiveMap, this.emissiveIntensity = A.emissiveIntensity, this.bumpMap = A.bumpMap, this.bumpScale = A.bumpScale, this.normalMap = A.normalMap, this.normalMapType = A.normalMapType, this.normalScale.copy(A.normalScale), this.displacementMap = A.displacementMap, this.displacementScale = A.displacementScale, this.displacementBias = A.displacementBias, this.specularMap = A.specularMap, this.alphaMap = A.alphaMap, this.envMap = A.envMap, this.combine = A.combine, this.reflectivity = A.reflectivity, this.refractionRatio = A.refractionRatio, this.wireframe = A.wireframe, this.wireframeLinewidth = A.wireframeLinewidth, this.wireframeLinecap = A.wireframeLinecap, this.wireframeLinejoin = A.wireframeLinejoin, this.flatShading = A.flatShading, this.fog = A.fog, this;
  }
}
class iU extends Sn {
  constructor(A) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new ke(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fB, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(A);
  }
  copy(A) {
    return super.copy(A), this.defines = { MATCAP: "" }, this.color.copy(A.color), this.matcap = A.matcap, this.map = A.map, this.bumpMap = A.bumpMap, this.bumpScale = A.bumpScale, this.normalMap = A.normalMap, this.normalMapType = A.normalMapType, this.normalScale.copy(A.normalScale), this.displacementMap = A.displacementMap, this.displacementScale = A.displacementScale, this.displacementBias = A.displacementBias, this.alphaMap = A.alphaMap, this.flatShading = A.flatShading, this.fog = A.fog, this;
  }
}
class nU extends Mn {
  constructor(A) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(A);
  }
  copy(A) {
    return super.copy(A), this.scale = A.scale, this.dashSize = A.dashSize, this.gapSize = A.gapSize, this;
  }
}
function No(g, A, e) {
  return Py(g) ? new g.constructor(g.subarray(A, e !== void 0 ? e : g.length)) : g.slice(A, e);
}
function mC(g, A, e) {
  return !g || // let 'undefined' and 'null' pass
  !e && g.constructor === A ? g : typeof A.BYTES_PER_ELEMENT == "number" ? new A(g) : Array.prototype.slice.call(g);
}
function Py(g) {
  return ArrayBuffer.isView(g) && !(g instanceof DataView);
}
function gU(g) {
  function A(i, n) {
    return g[i] - g[n];
  }
  const e = g.length, t = new Array(e);
  for (let i = 0; i !== e; ++i)
    t[i] = i;
  return t.sort(A), t;
}
function Pw(g, A, e) {
  const t = g.length, i = new g.constructor(t);
  for (let n = 0, r = 0; r !== t; ++n) {
    const s = e[n] * A;
    for (let B = 0; B !== A; ++B)
      i[r++] = g[s + B];
  }
  return i;
}
function Wy(g, A, e, t) {
  let i = 1, n = g[0];
  for (; n !== void 0 && n[t] === void 0; )
    n = g[i++];
  if (n === void 0)
    return;
  let r = n[t];
  if (r !== void 0)
    if (Array.isArray(r))
      do
        r = n[t], r !== void 0 && (A.push(n.time), e.push.apply(e, r)), n = g[i++];
      while (n !== void 0);
    else if (r.toArray !== void 0)
      do
        r = n[t], r !== void 0 && (A.push(n.time), r.toArray(e, e.length)), n = g[i++];
      while (n !== void 0);
    else
      do
        r = n[t], r !== void 0 && (A.push(n.time), e.push(r)), n = g[i++];
      while (n !== void 0);
}
function r1(g, A, e, t, i = 30) {
  const n = g.clone();
  n.name = A;
  const r = [];
  for (let B = 0; B < n.tracks.length; ++B) {
    const I = n.tracks[B], E = I.getValueSize(), C = [], c = [];
    for (let u = 0; u < I.times.length; ++u) {
      const d = I.times[u] * i;
      if (!(d < e || d >= t)) {
        C.push(I.times[u]);
        for (let p = 0; p < E; ++p)
          c.push(I.values[u * E + p]);
      }
    }
    C.length !== 0 && (I.times = mC(C, I.times.constructor), I.values = mC(c, I.values.constructor), r.push(I));
  }
  n.tracks = r;
  let s = 1 / 0;
  for (let B = 0; B < n.tracks.length; ++B)
    s > n.tracks[B].times[0] && (s = n.tracks[B].times[0]);
  for (let B = 0; B < n.tracks.length; ++B)
    n.tracks[B].shift(-1 * s);
  return n.resetDuration(), n;
}
function o1(g, A = 0, e = g, t = 30) {
  t <= 0 && (t = 30);
  const i = e.tracks.length, n = A / t;
  for (let r = 0; r < i; ++r) {
    const s = e.tracks[r], B = s.ValueTypeName;
    if (B === "bool" || B === "string")
      continue;
    const I = g.tracks.find(function(f) {
      return f.name === s.name && f.ValueTypeName === B;
    });
    if (I === void 0)
      continue;
    let E = 0;
    const C = s.getValueSize();
    s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (E = C / 3);
    let c = 0;
    const u = I.getValueSize();
    I.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
    const d = s.times.length - 1;
    let p;
    if (n <= s.times[0]) {
      const f = E, S = C - E;
      p = No(s.values, f, S);
    } else if (n >= s.times[d]) {
      const f = d * C + E, S = f + C - E;
      p = No(s.values, f, S);
    } else {
      const f = s.createInterpolant(), S = E, y = C - E;
      f.evaluate(n), p = No(f.resultBuffer, S, y);
    }
    B === "quaternion" && new On().fromArray(p).normalize().conjugate().toArray(p);
    const D = I.times.length;
    for (let f = 0; f < D; ++f) {
      const S = f * u + c;
      if (B === "quaternion")
        On.multiplyQuaternionsFlat(
          I.values,
          S,
          p,
          0,
          I.values,
          S
        );
      else {
        const y = u - c * 2;
        for (let m = 0; m < y; ++m)
          I.values[S + m] -= p[m];
      }
    }
  }
  return g.blendMode = py, g;
}
const s1 = {
  arraySlice: No,
  convertArray: mC,
  isTypedArray: Py,
  getKeyframeOrder: gU,
  sortedArray: Pw,
  flattenJSON: Wy,
  subclip: r1,
  makeClipAdditive: o1
};
class OE {
  constructor(A, e, t, i) {
    this.parameterPositions = A, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new e.constructor(t), this.sampleValues = e, this.valueSize = t, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(A) {
    const e = this.parameterPositions;
    let t = this._cachedIndex, i = e[t], n = e[t - 1];
    A: {
      e: {
        let r;
        t: {
          i:
            if (!(A < i)) {
              for (let s = t + 2; ; ) {
                if (i === void 0) {
                  if (A < n)
                    break i;
                  return t = e.length, this._cachedIndex = t, this.copySampleValue_(t - 1);
                }
                if (t === s)
                  break;
                if (n = i, i = e[++t], A < i)
                  break e;
              }
              r = e.length;
              break t;
            }
          if (!(A >= n)) {
            const s = e[1];
            A < s && (t = 2, n = s);
            for (let B = t - 2; ; ) {
              if (n === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (t === B)
                break;
              if (i = n, n = e[--t - 1], A >= n)
                break e;
            }
            r = t, t = 0;
            break t;
          }
          break A;
        }
        for (; t < r; ) {
          const s = t + r >>> 1;
          A < e[s] ? r = s : t = s + 1;
        }
        if (i = e[t], n = e[t - 1], n === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (i === void 0)
          return t = e.length, this._cachedIndex = t, this.copySampleValue_(t - 1);
      }
      this._cachedIndex = t, this.intervalChanged_(t, n, i);
    }
    return this.interpolate_(t, n, A, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(A) {
    const e = this.resultBuffer, t = this.sampleValues, i = this.valueSize, n = A * i;
    for (let r = 0; r !== i; ++r)
      e[r] = t[n + r];
    return e;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class rU extends OE {
  constructor(A, e, t, i) {
    super(A, e, t, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: wC,
      endingEnd: wC
    };
  }
  intervalChanged_(A, e, t) {
    const i = this.parameterPositions;
    let n = A - 2, r = A + 1, s = i[n], B = i[r];
    if (s === void 0)
      switch (this.getSettings_().endingStart) {
        case yC:
          n = A, s = 2 * e - t;
          break;
        case Lc:
          n = i.length - 2, s = e + i[n] - i[n + 1];
          break;
        default:
          n = A, s = t;
      }
    if (B === void 0)
      switch (this.getSettings_().endingEnd) {
        case yC:
          r = A, B = 2 * t - e;
          break;
        case Lc:
          r = 1, B = t + i[1] - i[0];
          break;
        default:
          r = A - 1, B = e;
      }
    const I = (t - e) * 0.5, E = this.valueSize;
    this._weightPrev = I / (e - s), this._weightNext = I / (B - t), this._offsetPrev = n * E, this._offsetNext = r * E;
  }
  interpolate_(A, e, t, i) {
    const n = this.resultBuffer, r = this.sampleValues, s = this.valueSize, B = A * s, I = B - s, E = this._offsetPrev, C = this._offsetNext, c = this._weightPrev, u = this._weightNext, d = (t - e) / (i - e), p = d * d, D = p * d, f = -c * D + 2 * c * p - c * d, S = (1 + c) * D + (-1.5 - 2 * c) * p + (-0.5 + c) * d + 1, y = (-1 - u) * D + (1.5 + u) * p + 0.5 * d, m = u * D - u * p;
    for (let N = 0; N !== s; ++N)
      n[N] = f * r[E + N] + S * r[I + N] + y * r[B + N] + m * r[C + N];
    return n;
  }
}
class zy extends OE {
  constructor(A, e, t, i) {
    super(A, e, t, i);
  }
  interpolate_(A, e, t, i) {
    const n = this.resultBuffer, r = this.sampleValues, s = this.valueSize, B = A * s, I = B - s, E = (t - e) / (i - e), C = 1 - E;
    for (let c = 0; c !== s; ++c)
      n[c] = r[I + c] * C + r[B + c] * E;
    return n;
  }
}
class oU extends OE {
  constructor(A, e, t, i) {
    super(A, e, t, i);
  }
  interpolate_(A) {
    return this.copySampleValue_(A - 1);
  }
}
class hs {
  constructor(A, e, t, i) {
    if (A === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (e === void 0 || e.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + A);
    this.name = A, this.times = mC(e, this.TimeBufferType), this.values = mC(t, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(A) {
    const e = A.constructor;
    let t;
    if (e.toJSON !== this.toJSON)
      t = e.toJSON(A);
    else {
      t = {
        name: A.name,
        times: mC(A.times, Array),
        values: mC(A.values, Array)
      };
      const i = A.getInterpolation();
      i !== A.DefaultInterpolation && (t.interpolation = i);
    }
    return t.type = A.ValueTypeName, t;
  }
  InterpolantFactoryMethodDiscrete(A) {
    return new oU(this.times, this.values, this.getValueSize(), A);
  }
  InterpolantFactoryMethodLinear(A) {
    return new zy(this.times, this.values, this.getValueSize(), A);
  }
  InterpolantFactoryMethodSmooth(A) {
    return new rU(this.times, this.values, this.getValueSize(), A);
  }
  setInterpolation(A) {
    let e;
    switch (A) {
      case TC:
        e = this.InterpolantFactoryMethodDiscrete;
        break;
      case uB:
        e = this.InterpolantFactoryMethodLinear;
        break;
      case tf:
        e = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (e === void 0) {
      const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (A !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(t);
      return console.warn("THREE.KeyframeTrack:", t), this;
    }
    return this.createInterpolant = e, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return TC;
      case this.InterpolantFactoryMethodLinear:
        return uB;
      case this.InterpolantFactoryMethodSmooth:
        return tf;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(A) {
    if (A !== 0) {
      const e = this.times;
      for (let t = 0, i = e.length; t !== i; ++t)
        e[t] += A;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(A) {
    if (A !== 1) {
      const e = this.times;
      for (let t = 0, i = e.length; t !== i; ++t)
        e[t] *= A;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(A, e) {
    const t = this.times, i = t.length;
    let n = 0, r = i - 1;
    for (; n !== i && t[n] < A; )
      ++n;
    for (; r !== -1 && t[r] > e; )
      --r;
    if (++r, n !== 0 || r !== i) {
      n >= r && (r = Math.max(r, 1), n = r - 1);
      const s = this.getValueSize();
      this.times = No(t, n, r), this.values = No(this.values, n * s, r * s);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let A = !0;
    const e = this.getValueSize();
    e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), A = !1);
    const t = this.times, i = this.values, n = t.length;
    n === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), A = !1);
    let r = null;
    for (let s = 0; s !== n; s++) {
      const B = t[s];
      if (typeof B == "number" && isNaN(B)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, s, B), A = !1;
        break;
      }
      if (r !== null && r > B) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, s, B, r), A = !1;
        break;
      }
      r = B;
    }
    if (i !== void 0 && Py(i))
      for (let s = 0, B = i.length; s !== B; ++s) {
        const I = i[s];
        if (isNaN(I)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, s, I), A = !1;
          break;
        }
      }
    return A;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const A = No(this.times), e = No(this.values), t = this.getValueSize(), i = this.getInterpolation() === tf, n = A.length - 1;
    let r = 1;
    for (let s = 1; s < n; ++s) {
      let B = !1;
      const I = A[s], E = A[s + 1];
      if (I !== E && (s !== 1 || I !== A[0]))
        if (i)
          B = !0;
        else {
          const C = s * t, c = C - t, u = C + t;
          for (let d = 0; d !== t; ++d) {
            const p = e[C + d];
            if (p !== e[c + d] || p !== e[u + d]) {
              B = !0;
              break;
            }
          }
        }
      if (B) {
        if (s !== r) {
          A[r] = A[s];
          const C = s * t, c = r * t;
          for (let u = 0; u !== t; ++u)
            e[c + u] = e[C + u];
        }
        ++r;
      }
    }
    if (n > 0) {
      A[r] = A[n];
      for (let s = n * t, B = r * t, I = 0; I !== t; ++I)
        e[B + I] = e[s + I];
      ++r;
    }
    return r !== A.length ? (this.times = No(A, 0, r), this.values = No(e, 0, r * t)) : (this.times = A, this.values = e), this;
  }
  clone() {
    const A = No(this.times, 0), e = No(this.values, 0), t = this.constructor, i = new t(this.name, A, e);
    return i.createInterpolant = this.createInterpolant, i;
  }
}
hs.prototype.TimeBufferType = Float32Array;
hs.prototype.ValueBufferType = Float32Array;
hs.prototype.DefaultInterpolation = uB;
class zC extends hs {
}
zC.prototype.ValueTypeName = "bool";
zC.prototype.ValueBufferType = Array;
zC.prototype.DefaultInterpolation = TC;
zC.prototype.InterpolantFactoryMethodLinear = void 0;
zC.prototype.InterpolantFactoryMethodSmooth = void 0;
class Vy extends hs {
}
Vy.prototype.ValueTypeName = "color";
class bC extends hs {
}
bC.prototype.ValueTypeName = "number";
class sU extends OE {
  constructor(A, e, t, i) {
    super(A, e, t, i);
  }
  interpolate_(A, e, t, i) {
    const n = this.resultBuffer, r = this.sampleValues, s = this.valueSize, B = (t - e) / (i - e);
    let I = A * s;
    for (let E = I + s; I !== E; I += 4)
      On.slerpFlat(n, 0, r, I - s, r, I, B);
    return n;
  }
}
class ja extends hs {
  InterpolantFactoryMethodLinear(A) {
    return new sU(this.times, this.values, this.getValueSize(), A);
  }
}
ja.prototype.ValueTypeName = "quaternion";
ja.prototype.DefaultInterpolation = uB;
ja.prototype.InterpolantFactoryMethodSmooth = void 0;
class VC extends hs {
}
VC.prototype.ValueTypeName = "string";
VC.prototype.ValueBufferType = Array;
VC.prototype.DefaultInterpolation = TC;
VC.prototype.InterpolantFactoryMethodLinear = void 0;
VC.prototype.InterpolantFactoryMethodSmooth = void 0;
class YC extends hs {
}
YC.prototype.ValueTypeName = "vector";
class HC {
  constructor(A, e = -1, t, i = Mf) {
    this.name = A, this.tracks = t, this.duration = e, this.blendMode = i, this.uuid = io(), this.duration < 0 && this.resetDuration();
  }
  static parse(A) {
    const e = [], t = A.tracks, i = 1 / (A.fps || 1);
    for (let r = 0, s = t.length; r !== s; ++r)
      e.push(I1(t[r]).scale(i));
    const n = new this(A.name, A.duration, e, A.blendMode);
    return n.uuid = A.uuid, n;
  }
  static toJSON(A) {
    const e = [], t = A.tracks, i = {
      name: A.name,
      duration: A.duration,
      tracks: e,
      uuid: A.uuid,
      blendMode: A.blendMode
    };
    for (let n = 0, r = t.length; n !== r; ++n)
      e.push(hs.toJSON(t[n]));
    return i;
  }
  static CreateFromMorphTargetSequence(A, e, t, i) {
    const n = e.length, r = [];
    for (let s = 0; s < n; s++) {
      let B = [], I = [];
      B.push(
        (s + n - 1) % n,
        s,
        (s + 1) % n
      ), I.push(0, 1, 0);
      const E = gU(B);
      B = Pw(B, 1, E), I = Pw(I, 1, E), !i && B[0] === 0 && (B.push(n), I.push(I[0])), r.push(
        new bC(
          ".morphTargetInfluences[" + e[s].name + "]",
          B,
          I
        ).scale(1 / t)
      );
    }
    return new this(A, -1, r);
  }
  static findByName(A, e) {
    let t = A;
    if (!Array.isArray(A)) {
      const i = A;
      t = i.geometry && i.geometry.animations || i.animations;
    }
    for (let i = 0; i < t.length; i++)
      if (t[i].name === e)
        return t[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(A, e, t) {
    const i = {}, n = /^([\w-]*?)([\d]+)$/;
    for (let s = 0, B = A.length; s < B; s++) {
      const I = A[s], E = I.name.match(n);
      if (E && E.length > 1) {
        const C = E[1];
        let c = i[C];
        c || (i[C] = c = []), c.push(I);
      }
    }
    const r = [];
    for (const s in i)
      r.push(this.CreateFromMorphTargetSequence(s, i[s], e, t));
    return r;
  }
  // parse the animation.hierarchy format
  static parseAnimation(A, e) {
    if (!A)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const t = function(C, c, u, d, p) {
      if (u.length !== 0) {
        const D = [], f = [];
        Wy(u, D, f, d), D.length !== 0 && p.push(new C(c, D, f));
      }
    }, i = [], n = A.name || "default", r = A.fps || 30, s = A.blendMode;
    let B = A.length || -1;
    const I = A.hierarchy || [];
    for (let C = 0; C < I.length; C++) {
      const c = I[C].keys;
      if (!(!c || c.length === 0))
        if (c[0].morphTargets) {
          const u = {};
          let d;
          for (d = 0; d < c.length; d++)
            if (c[d].morphTargets)
              for (let p = 0; p < c[d].morphTargets.length; p++)
                u[c[d].morphTargets[p]] = -1;
          for (const p in u) {
            const D = [], f = [];
            for (let S = 0; S !== c[d].morphTargets.length; ++S) {
              const y = c[d];
              D.push(y.time), f.push(y.morphTarget === p ? 1 : 0);
            }
            i.push(new bC(".morphTargetInfluence[" + p + "]", D, f));
          }
          B = u.length * r;
        } else {
          const u = ".bones[" + e[C].name + "]";
          t(
            YC,
            u + ".position",
            c,
            "pos",
            i
          ), t(
            ja,
            u + ".quaternion",
            c,
            "rot",
            i
          ), t(
            YC,
            u + ".scale",
            c,
            "scl",
            i
          );
        }
    }
    return i.length === 0 ? null : new this(n, B, i, s);
  }
  resetDuration() {
    const A = this.tracks;
    let e = 0;
    for (let t = 0, i = A.length; t !== i; ++t) {
      const n = this.tracks[t];
      e = Math.max(e, n.times[n.times.length - 1]);
    }
    return this.duration = e, this;
  }
  trim() {
    for (let A = 0; A < this.tracks.length; A++)
      this.tracks[A].trim(0, this.duration);
    return this;
  }
  validate() {
    let A = !0;
    for (let e = 0; e < this.tracks.length; e++)
      A = A && this.tracks[e].validate();
    return A;
  }
  optimize() {
    for (let A = 0; A < this.tracks.length; A++)
      this.tracks[A].optimize();
    return this;
  }
  clone() {
    const A = [];
    for (let e = 0; e < this.tracks.length; e++)
      A.push(this.tracks[e].clone());
    return new this.constructor(this.name, this.duration, A, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function a1(g) {
  switch (g.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return bC;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return YC;
    case "color":
      return Vy;
    case "quaternion":
      return ja;
    case "bool":
    case "boolean":
      return zC;
    case "string":
      return VC;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + g);
}
function I1(g) {
  if (g.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const A = a1(g.type);
  if (g.times === void 0) {
    const e = [], t = [];
    Wy(g.keys, e, t, "value"), g.times = e, g.values = t;
  }
  return A.parse !== void 0 ? A.parse(g) : new A(g.name, g.times, g.values, g.interpolation);
}
const _C = {
  enabled: !1,
  files: {},
  add: function(g, A) {
    this.enabled !== !1 && (this.files[g] = A);
  },
  get: function(g) {
    if (this.enabled !== !1)
      return this.files[g];
  },
  remove: function(g) {
    delete this.files[g];
  },
  clear: function() {
    this.files = {};
  }
};
class jy {
  constructor(A, e, t) {
    const i = this;
    let n = !1, r = 0, s = 0, B;
    const I = [];
    this.onStart = void 0, this.onLoad = A, this.onProgress = e, this.onError = t, this.itemStart = function(E) {
      s++, n === !1 && i.onStart !== void 0 && i.onStart(E, r, s), n = !0;
    }, this.itemEnd = function(E) {
      r++, i.onProgress !== void 0 && i.onProgress(E, r, s), r === s && (n = !1, i.onLoad !== void 0 && i.onLoad());
    }, this.itemError = function(E) {
      i.onError !== void 0 && i.onError(E);
    }, this.resolveURL = function(E) {
      return B ? B(E) : E;
    }, this.setURLModifier = function(E) {
      return B = E, this;
    }, this.addHandler = function(E, C) {
      return I.push(E, C), this;
    }, this.removeHandler = function(E) {
      const C = I.indexOf(E);
      return C !== -1 && I.splice(C, 2), this;
    }, this.getHandler = function(E) {
      for (let C = 0, c = I.length; C < c; C += 2) {
        const u = I[C], d = I[C + 1];
        if (u.global && (u.lastIndex = 0), u.test(E))
          return d;
      }
      return null;
    };
  }
}
const pE = /* @__PURE__ */ new jy();
let Hg = class {
  constructor(A) {
    this.manager = A !== void 0 ? A : pE, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(A, e) {
    const t = this;
    return new Promise(function(i, n) {
      t.load(A, i, e, n);
    });
  }
  parse() {
  }
  setCrossOrigin(A) {
    return this.crossOrigin = A, this;
  }
  setWithCredentials(A) {
    return this.withCredentials = A, this;
  }
  setPath(A) {
    return this.path = A, this;
  }
  setResourcePath(A) {
    return this.resourcePath = A, this;
  }
  setRequestHeader(A) {
    return this.requestHeader = A, this;
  }
};
const Oa = {};
class B1 extends Error {
  constructor(A, e) {
    super(A), this.response = e;
  }
}
class go extends Hg {
  constructor(A) {
    super(A);
  }
  load(A, e, t, i) {
    A === void 0 && (A = ""), this.path !== void 0 && (A = this.path + A), A = this.manager.resolveURL(A);
    const n = _C.get(A);
    if (n !== void 0)
      return this.manager.itemStart(A), setTimeout(() => {
        e && e(n), this.manager.itemEnd(A);
      }, 0), n;
    if (Oa[A] !== void 0) {
      Oa[A].push({
        onLoad: e,
        onProgress: t,
        onError: i
      });
      return;
    }
    Oa[A] = [], Oa[A].push({
      onLoad: e,
      onProgress: t,
      onError: i
    });
    const r = new Request(A, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), s = this.mimeType, B = this.responseType;
    fetch(r).then((I) => {
      if (I.status === 200 || I.status === 0) {
        if (I.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || I.body === void 0 || I.body.getReader === void 0)
          return I;
        const E = Oa[A], C = I.body.getReader(), c = I.headers.get("Content-Length") || I.headers.get("X-File-Size"), u = c ? parseInt(c) : 0, d = u !== 0;
        let p = 0;
        const D = new ReadableStream({
          start(f) {
            S();
            function S() {
              C.read().then(({ done: y, value: m }) => {
                if (y)
                  f.close();
                else {
                  p += m.byteLength;
                  const N = new ProgressEvent("progress", { lengthComputable: d, loaded: p, total: u });
                  for (let F = 0, G = E.length; F < G; F++) {
                    const k = E[F];
                    k.onProgress && k.onProgress(N);
                  }
                  f.enqueue(m), S();
                }
              });
            }
          }
        });
        return new Response(D);
      } else
        throw new B1(`fetch for "${I.url}" responded with ${I.status}: ${I.statusText}`, I);
    }).then((I) => {
      switch (B) {
        case "arraybuffer":
          return I.arrayBuffer();
        case "blob":
          return I.blob();
        case "document":
          return I.text().then((E) => new DOMParser().parseFromString(E, s));
        case "json":
          return I.json();
        default:
          if (s === void 0)
            return I.text();
          {
            const C = /charset="?([^;"\s]*)"?/i.exec(s), c = C && C[1] ? C[1].toLowerCase() : void 0, u = new TextDecoder(c);
            return I.arrayBuffer().then((d) => u.decode(d));
          }
      }
    }).then((I) => {
      _C.add(A, I);
      const E = Oa[A];
      delete Oa[A];
      for (let C = 0, c = E.length; C < c; C++) {
        const u = E[C];
        u.onLoad && u.onLoad(I);
      }
    }).catch((I) => {
      const E = Oa[A];
      if (E === void 0)
        throw this.manager.itemError(A), I;
      delete Oa[A];
      for (let C = 0, c = E.length; C < c; C++) {
        const u = E[C];
        u.onError && u.onError(I);
      }
      this.manager.itemError(A);
    }).finally(() => {
      this.manager.itemEnd(A);
    }), this.manager.itemStart(A);
  }
  setResponseType(A) {
    return this.responseType = A, this;
  }
  setMimeType(A) {
    return this.mimeType = A, this;
  }
}
class C1 extends Hg {
  constructor(A) {
    super(A);
  }
  load(A, e, t, i) {
    const n = this, r = new go(this.manager);
    r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(A, function(s) {
      try {
        e(n.parse(JSON.parse(s)));
      } catch (B) {
        i ? i(B) : console.error(B), n.manager.itemError(A);
      }
    }, t, i);
  }
  parse(A) {
    const e = [];
    for (let t = 0; t < A.length; t++) {
      const i = HC.parse(A[t]);
      e.push(i);
    }
    return e;
  }
}
class Q1 extends Hg {
  constructor(A) {
    super(A);
  }
  load(A, e, t, i) {
    const n = this, r = [], s = new Ly(), B = new go(this.manager);
    B.setPath(this.path), B.setResponseType("arraybuffer"), B.setRequestHeader(this.requestHeader), B.setWithCredentials(n.withCredentials);
    let I = 0;
    function E(C) {
      B.load(A[C], function(c) {
        const u = n.parse(c, !0);
        r[C] = {
          width: u.width,
          height: u.height,
          format: u.format,
          mipmaps: u.mipmaps
        }, I += 1, I === 6 && (u.mipmapCount === 1 && (s.minFilter = Gi), s.image = r, s.format = u.format, s.needsUpdate = !0, e && e(s));
      }, t, i);
    }
    if (Array.isArray(A))
      for (let C = 0, c = A.length; C < c; ++C)
        E(C);
    else
      B.load(A, function(C) {
        const c = n.parse(C, !0);
        if (c.isCubemap) {
          const u = c.mipmaps.length / c.mipmapCount;
          for (let d = 0; d < u; d++) {
            r[d] = { mipmaps: [] };
            for (let p = 0; p < c.mipmapCount; p++)
              r[d].mipmaps.push(c.mipmaps[d * c.mipmapCount + p]), r[d].format = c.format, r[d].width = c.width, r[d].height = c.height;
          }
          s.image = r;
        } else
          s.image.width = c.width, s.image.height = c.height, s.mipmaps = c.mipmaps;
        c.mipmapCount === 1 && (s.minFilter = Gi), s.format = c.format, s.needsUpdate = !0, e && e(s);
      }, t, i);
    return s;
  }
}
class Jc extends Hg {
  constructor(A) {
    super(A);
  }
  load(A, e, t, i) {
    this.path !== void 0 && (A = this.path + A), A = this.manager.resolveURL(A);
    const n = this, r = _C.get(A);
    if (r !== void 0)
      return n.manager.itemStart(A), setTimeout(function() {
        e && e(r), n.manager.itemEnd(A);
      }, 0), r;
    const s = Kc("img");
    function B() {
      E(), _C.add(A, this), e && e(this), n.manager.itemEnd(A);
    }
    function I(C) {
      E(), i && i(C), n.manager.itemError(A), n.manager.itemEnd(A);
    }
    function E() {
      s.removeEventListener("load", B, !1), s.removeEventListener("error", I, !1);
    }
    return s.addEventListener("load", B, !1), s.addEventListener("error", I, !1), A.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (s.crossOrigin = this.crossOrigin), n.manager.itemStart(A), s.src = A, s;
  }
}
class E1 extends Hg {
  constructor(A) {
    super(A);
  }
  load(A, e, t, i) {
    const n = new Au(), r = new Jc(this.manager);
    r.setCrossOrigin(this.crossOrigin), r.setPath(this.path);
    let s = 0;
    function B(I) {
      r.load(A[I], function(E) {
        n.images[I] = E, s++, s === 6 && (n.needsUpdate = !0, e && e(n));
      }, void 0, i);
    }
    for (let I = 0; I < A.length; ++I)
      B(I);
    return n;
  }
}
class l1 extends Hg {
  constructor(A) {
    super(A);
  }
  load(A, e, t, i) {
    const n = this, r = new wE(), s = new go(this.manager);
    return s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setPath(this.path), s.setWithCredentials(n.withCredentials), s.load(A, function(B) {
      const I = n.parse(B);
      I && (I.image !== void 0 ? r.image = I.image : I.data !== void 0 && (r.image.width = I.width, r.image.height = I.height, r.image.data = I.data), r.wrapS = I.wrapS !== void 0 ? I.wrapS : Jn, r.wrapT = I.wrapT !== void 0 ? I.wrapT : Jn, r.magFilter = I.magFilter !== void 0 ? I.magFilter : Gi, r.minFilter = I.minFilter !== void 0 ? I.minFilter : Gi, r.anisotropy = I.anisotropy !== void 0 ? I.anisotropy : 1, I.encoding !== void 0 && (r.encoding = I.encoding), I.flipY !== void 0 && (r.flipY = I.flipY), I.format !== void 0 && (r.format = I.format), I.type !== void 0 && (r.type = I.type), I.mipmaps !== void 0 && (r.mipmaps = I.mipmaps, r.minFilter = Cs), I.mipmapCount === 1 && (r.minFilter = Gi), I.generateMipmaps !== void 0 && (r.generateMipmaps = I.generateMipmaps), r.needsUpdate = !0, e && e(r, I));
    }, t, i), r;
  }
}
class Tf extends Hg {
  constructor(A) {
    super(A);
  }
  load(A, e, t, i) {
    const n = new xi(), r = new Jc(this.manager);
    return r.setCrossOrigin(this.crossOrigin), r.setPath(this.path), r.load(A, function(s) {
      n.image = s, n.needsUpdate = !0, e !== void 0 && e(n);
    }, t, i), n;
  }
}
class pB extends Xt {
  constructor(A, e = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new ke(A), this.intensity = e;
  }
  dispose() {
  }
  copy(A, e) {
    return super.copy(A, e), this.color.copy(A.color), this.intensity = A.intensity, this;
  }
  toJSON(A) {
    const e = super.toJSON(A);
    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), e;
  }
}
class aU extends pB {
  constructor(A, e, t) {
    super(A, t), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Xt.DEFAULT_UP), this.updateMatrix(), this.groundColor = new ke(e);
  }
  copy(A, e) {
    return super.copy(A, e), this.groundColor.copy(A.groundColor), this;
  }
}
const m0 = /* @__PURE__ */ new Ve(), pN = /* @__PURE__ */ new IA(), DN = /* @__PURE__ */ new IA();
class Zy {
  constructor(A) {
    this.camera = A, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ue(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ve(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Ff(), this._frameExtents = new ue(1, 1), this._viewportCount = 1, this._viewports = [
      new Bi(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(A) {
    const e = this.camera, t = this.matrix;
    pN.setFromMatrixPosition(A.matrixWorld), e.position.copy(pN), DN.setFromMatrixPosition(A.target.matrixWorld), e.lookAt(DN), e.updateMatrixWorld(), m0.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(m0), t.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), t.multiply(m0);
  }
  getViewport(A) {
    return this._viewports[A];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(A) {
    return this.camera = A.camera.clone(), this.bias = A.bias, this.radius = A.radius, this.mapSize.copy(A.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const A = {};
    return this.bias !== 0 && (A.bias = this.bias), this.normalBias !== 0 && (A.normalBias = this.normalBias), this.radius !== 1 && (A.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (A.mapSize = this.mapSize.toArray()), A.camera = this.camera.toJSON(!1).object, delete A.camera.matrix, A;
  }
}
class c1 extends Zy {
  constructor() {
    super(new mn(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(A) {
    const e = this.camera, t = GE * 2 * A.angle * this.focus, i = this.mapSize.width / this.mapSize.height, n = A.distance || e.far;
    (t !== e.fov || i !== e.aspect || n !== e.far) && (e.fov = t, e.aspect = i, e.far = n, e.updateProjectionMatrix()), super.updateMatrices(A);
  }
  copy(A) {
    return super.copy(A), this.focus = A.focus, this;
  }
}
class Kf extends pB {
  constructor(A, e, t = 0, i = Math.PI / 3, n = 0, r = 2) {
    super(A, e), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Xt.DEFAULT_UP), this.updateMatrix(), this.target = new Xt(), this.distance = t, this.angle = i, this.penumbra = n, this.decay = r, this.map = null, this.shadow = new c1();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(A) {
    this.intensity = A / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(A, e) {
    return super.copy(A, e), this.distance = A.distance, this.angle = A.angle, this.penumbra = A.penumbra, this.decay = A.decay, this.target = A.target.clone(), this.shadow = A.shadow.clone(), this;
  }
}
const wN = /* @__PURE__ */ new Ve(), sc = /* @__PURE__ */ new IA(), S0 = /* @__PURE__ */ new IA();
class u1 extends Zy {
  constructor() {
    super(new mn(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new ue(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Bi(2, 1, 1, 1),
      // negative X
      new Bi(0, 1, 1, 1),
      // positive Z
      new Bi(3, 1, 1, 1),
      // negative Z
      new Bi(1, 1, 1, 1),
      // positive Y
      new Bi(3, 0, 1, 1),
      // negative Y
      new Bi(1, 0, 1, 1)
    ], this._cubeDirections = [
      new IA(1, 0, 0),
      new IA(-1, 0, 0),
      new IA(0, 0, 1),
      new IA(0, 0, -1),
      new IA(0, 1, 0),
      new IA(0, -1, 0)
    ], this._cubeUps = [
      new IA(0, 1, 0),
      new IA(0, 1, 0),
      new IA(0, 1, 0),
      new IA(0, 1, 0),
      new IA(0, 0, 1),
      new IA(0, 0, -1)
    ];
  }
  updateMatrices(A, e = 0) {
    const t = this.camera, i = this.matrix, n = A.distance || t.far;
    n !== t.far && (t.far = n, t.updateProjectionMatrix()), sc.setFromMatrixPosition(A.matrixWorld), t.position.copy(sc), S0.copy(t.position), S0.add(this._cubeDirections[e]), t.up.copy(this._cubeUps[e]), t.lookAt(S0), t.updateMatrixWorld(), i.makeTranslation(-sc.x, -sc.y, -sc.z), wN.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(wN);
  }
}
class Oc extends pB {
  constructor(A, e, t = 0, i = 2) {
    super(A, e), this.isPointLight = !0, this.type = "PointLight", this.distance = t, this.decay = i, this.shadow = new u1();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(A) {
    this.intensity = A / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(A, e) {
    return super.copy(A, e), this.distance = A.distance, this.decay = A.decay, this.shadow = A.shadow.clone(), this;
  }
}
class h1 extends Zy {
  constructor() {
    super(new $a(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class bf extends pB {
  constructor(A, e) {
    super(A, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Xt.DEFAULT_UP), this.updateMatrix(), this.target = new Xt(), this.shadow = new h1();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(A) {
    return super.copy(A), this.target = A.target.clone(), this.shadow = A.shadow.clone(), this;
  }
}
class Xy extends pB {
  constructor(A, e) {
    super(A, e), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class IU extends pB {
  constructor(A, e, t = 10, i = 10) {
    super(A, e), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = t, this.height = i;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(A) {
    this.intensity = A / (this.width * this.height * Math.PI);
  }
  copy(A) {
    return super.copy(A), this.width = A.width, this.height = A.height, this;
  }
  toJSON(A) {
    const e = super.toJSON(A);
    return e.object.width = this.width, e.object.height = this.height, e;
  }
}
class BU {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let A = 0; A < 9; A++)
      this.coefficients.push(new IA());
  }
  set(A) {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].copy(A[e]);
    return this;
  }
  zero() {
    for (let A = 0; A < 9; A++)
      this.coefficients[A].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(A, e) {
    const t = A.x, i = A.y, n = A.z, r = this.coefficients;
    return e.copy(r[0]).multiplyScalar(0.282095), e.addScaledVector(r[1], 0.488603 * i), e.addScaledVector(r[2], 0.488603 * n), e.addScaledVector(r[3], 0.488603 * t), e.addScaledVector(r[4], 1.092548 * (t * i)), e.addScaledVector(r[5], 1.092548 * (i * n)), e.addScaledVector(r[6], 0.315392 * (3 * n * n - 1)), e.addScaledVector(r[7], 1.092548 * (t * n)), e.addScaledVector(r[8], 0.546274 * (t * t - i * i)), e;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(A, e) {
    const t = A.x, i = A.y, n = A.z, r = this.coefficients;
    return e.copy(r[0]).multiplyScalar(0.886227), e.addScaledVector(r[1], 2 * 0.511664 * i), e.addScaledVector(r[2], 2 * 0.511664 * n), e.addScaledVector(r[3], 2 * 0.511664 * t), e.addScaledVector(r[4], 2 * 0.429043 * t * i), e.addScaledVector(r[5], 2 * 0.429043 * i * n), e.addScaledVector(r[6], 0.743125 * n * n - 0.247708), e.addScaledVector(r[7], 2 * 0.429043 * t * n), e.addScaledVector(r[8], 0.429043 * (t * t - i * i)), e;
  }
  add(A) {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].add(A.coefficients[e]);
    return this;
  }
  addScaledSH(A, e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].addScaledVector(A.coefficients[t], e);
    return this;
  }
  scale(A) {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].multiplyScalar(A);
    return this;
  }
  lerp(A, e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].lerp(A.coefficients[t], e);
    return this;
  }
  equals(A) {
    for (let e = 0; e < 9; e++)
      if (!this.coefficients[e].equals(A.coefficients[e]))
        return !1;
    return !0;
  }
  copy(A) {
    return this.set(A.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(A, e = 0) {
    const t = this.coefficients;
    for (let i = 0; i < 9; i++)
      t[i].fromArray(A, e + i * 3);
    return this;
  }
  toArray(A = [], e = 0) {
    const t = this.coefficients;
    for (let i = 0; i < 9; i++)
      t[i].toArray(A, e + i * 3);
    return A;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(A, e) {
    const t = A.x, i = A.y, n = A.z;
    e[0] = 0.282095, e[1] = 0.488603 * i, e[2] = 0.488603 * n, e[3] = 0.488603 * t, e[4] = 1.092548 * t * i, e[5] = 1.092548 * i * n, e[6] = 0.315392 * (3 * n * n - 1), e[7] = 1.092548 * t * n, e[8] = 0.546274 * (t * t - i * i);
  }
}
class Yf extends pB {
  constructor(A = new BU(), e = 1) {
    super(void 0, e), this.isLightProbe = !0, this.sh = A;
  }
  copy(A) {
    return super.copy(A), this.sh.copy(A.sh), this;
  }
  fromJSON(A) {
    return this.intensity = A.intensity, this.sh.fromArray(A.sh), this;
  }
  toJSON(A) {
    const e = super.toJSON(A);
    return e.object.sh = this.sh.toArray(), e;
  }
}
class Hf extends Hg {
  constructor(A) {
    super(A), this.textures = {};
  }
  load(A, e, t, i) {
    const n = this, r = new go(n.manager);
    r.setPath(n.path), r.setRequestHeader(n.requestHeader), r.setWithCredentials(n.withCredentials), r.load(A, function(s) {
      try {
        e(n.parse(JSON.parse(s)));
      } catch (B) {
        i ? i(B) : console.error(B), n.manager.itemError(A);
      }
    }, t, i);
  }
  parse(A) {
    const e = this.textures;
    function t(n) {
      return e[n] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", n), e[n];
    }
    const i = Hf.createMaterialFromType(A.type);
    if (A.uuid !== void 0 && (i.uuid = A.uuid), A.name !== void 0 && (i.name = A.name), A.color !== void 0 && i.color !== void 0 && i.color.setHex(A.color), A.roughness !== void 0 && (i.roughness = A.roughness), A.metalness !== void 0 && (i.metalness = A.metalness), A.sheen !== void 0 && (i.sheen = A.sheen), A.sheenColor !== void 0 && (i.sheenColor = new ke().setHex(A.sheenColor)), A.sheenRoughness !== void 0 && (i.sheenRoughness = A.sheenRoughness), A.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(A.emissive), A.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(A.specular), A.specularIntensity !== void 0 && (i.specularIntensity = A.specularIntensity), A.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(A.specularColor), A.shininess !== void 0 && (i.shininess = A.shininess), A.clearcoat !== void 0 && (i.clearcoat = A.clearcoat), A.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = A.clearcoatRoughness), A.iridescence !== void 0 && (i.iridescence = A.iridescence), A.iridescenceIOR !== void 0 && (i.iridescenceIOR = A.iridescenceIOR), A.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = A.iridescenceThicknessRange), A.transmission !== void 0 && (i.transmission = A.transmission), A.thickness !== void 0 && (i.thickness = A.thickness), A.attenuationDistance !== void 0 && (i.attenuationDistance = A.attenuationDistance), A.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(A.attenuationColor), A.fog !== void 0 && (i.fog = A.fog), A.flatShading !== void 0 && (i.flatShading = A.flatShading), A.blending !== void 0 && (i.blending = A.blending), A.combine !== void 0 && (i.combine = A.combine), A.side !== void 0 && (i.side = A.side), A.shadowSide !== void 0 && (i.shadowSide = A.shadowSide), A.opacity !== void 0 && (i.opacity = A.opacity), A.transparent !== void 0 && (i.transparent = A.transparent), A.alphaTest !== void 0 && (i.alphaTest = A.alphaTest), A.depthTest !== void 0 && (i.depthTest = A.depthTest), A.depthWrite !== void 0 && (i.depthWrite = A.depthWrite), A.colorWrite !== void 0 && (i.colorWrite = A.colorWrite), A.stencilWrite !== void 0 && (i.stencilWrite = A.stencilWrite), A.stencilWriteMask !== void 0 && (i.stencilWriteMask = A.stencilWriteMask), A.stencilFunc !== void 0 && (i.stencilFunc = A.stencilFunc), A.stencilRef !== void 0 && (i.stencilRef = A.stencilRef), A.stencilFuncMask !== void 0 && (i.stencilFuncMask = A.stencilFuncMask), A.stencilFail !== void 0 && (i.stencilFail = A.stencilFail), A.stencilZFail !== void 0 && (i.stencilZFail = A.stencilZFail), A.stencilZPass !== void 0 && (i.stencilZPass = A.stencilZPass), A.wireframe !== void 0 && (i.wireframe = A.wireframe), A.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = A.wireframeLinewidth), A.wireframeLinecap !== void 0 && (i.wireframeLinecap = A.wireframeLinecap), A.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = A.wireframeLinejoin), A.rotation !== void 0 && (i.rotation = A.rotation), A.linewidth !== 1 && (i.linewidth = A.linewidth), A.dashSize !== void 0 && (i.dashSize = A.dashSize), A.gapSize !== void 0 && (i.gapSize = A.gapSize), A.scale !== void 0 && (i.scale = A.scale), A.polygonOffset !== void 0 && (i.polygonOffset = A.polygonOffset), A.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = A.polygonOffsetFactor), A.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = A.polygonOffsetUnits), A.dithering !== void 0 && (i.dithering = A.dithering), A.alphaToCoverage !== void 0 && (i.alphaToCoverage = A.alphaToCoverage), A.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = A.premultipliedAlpha), A.forceSinglePass !== void 0 && (i.forceSinglePass = A.forceSinglePass), A.visible !== void 0 && (i.visible = A.visible), A.toneMapped !== void 0 && (i.toneMapped = A.toneMapped), A.userData !== void 0 && (i.userData = A.userData), A.vertexColors !== void 0 && (typeof A.vertexColors == "number" ? i.vertexColors = A.vertexColors > 0 : i.vertexColors = A.vertexColors), A.uniforms !== void 0)
      for (const n in A.uniforms) {
        const r = A.uniforms[n];
        switch (i.uniforms[n] = {}, r.type) {
          case "t":
            i.uniforms[n].value = t(r.value);
            break;
          case "c":
            i.uniforms[n].value = new ke().setHex(r.value);
            break;
          case "v2":
            i.uniforms[n].value = new ue().fromArray(r.value);
            break;
          case "v3":
            i.uniforms[n].value = new IA().fromArray(r.value);
            break;
          case "v4":
            i.uniforms[n].value = new Bi().fromArray(r.value);
            break;
          case "m3":
            i.uniforms[n].value = new kt().fromArray(r.value);
            break;
          case "m4":
            i.uniforms[n].value = new Ve().fromArray(r.value);
            break;
          default:
            i.uniforms[n].value = r.value;
        }
      }
    if (A.defines !== void 0 && (i.defines = A.defines), A.vertexShader !== void 0 && (i.vertexShader = A.vertexShader), A.fragmentShader !== void 0 && (i.fragmentShader = A.fragmentShader), A.glslVersion !== void 0 && (i.glslVersion = A.glslVersion), A.extensions !== void 0)
      for (const n in A.extensions)
        i.extensions[n] = A.extensions[n];
    if (A.size !== void 0 && (i.size = A.size), A.sizeAttenuation !== void 0 && (i.sizeAttenuation = A.sizeAttenuation), A.map !== void 0 && (i.map = t(A.map)), A.matcap !== void 0 && (i.matcap = t(A.matcap)), A.alphaMap !== void 0 && (i.alphaMap = t(A.alphaMap)), A.bumpMap !== void 0 && (i.bumpMap = t(A.bumpMap)), A.bumpScale !== void 0 && (i.bumpScale = A.bumpScale), A.normalMap !== void 0 && (i.normalMap = t(A.normalMap)), A.normalMapType !== void 0 && (i.normalMapType = A.normalMapType), A.normalScale !== void 0) {
      let n = A.normalScale;
      Array.isArray(n) === !1 && (n = [n, n]), i.normalScale = new ue().fromArray(n);
    }
    return A.displacementMap !== void 0 && (i.displacementMap = t(A.displacementMap)), A.displacementScale !== void 0 && (i.displacementScale = A.displacementScale), A.displacementBias !== void 0 && (i.displacementBias = A.displacementBias), A.roughnessMap !== void 0 && (i.roughnessMap = t(A.roughnessMap)), A.metalnessMap !== void 0 && (i.metalnessMap = t(A.metalnessMap)), A.emissiveMap !== void 0 && (i.emissiveMap = t(A.emissiveMap)), A.emissiveIntensity !== void 0 && (i.emissiveIntensity = A.emissiveIntensity), A.specularMap !== void 0 && (i.specularMap = t(A.specularMap)), A.specularIntensityMap !== void 0 && (i.specularIntensityMap = t(A.specularIntensityMap)), A.specularColorMap !== void 0 && (i.specularColorMap = t(A.specularColorMap)), A.envMap !== void 0 && (i.envMap = t(A.envMap)), A.envMapIntensity !== void 0 && (i.envMapIntensity = A.envMapIntensity), A.reflectivity !== void 0 && (i.reflectivity = A.reflectivity), A.refractionRatio !== void 0 && (i.refractionRatio = A.refractionRatio), A.lightMap !== void 0 && (i.lightMap = t(A.lightMap)), A.lightMapIntensity !== void 0 && (i.lightMapIntensity = A.lightMapIntensity), A.aoMap !== void 0 && (i.aoMap = t(A.aoMap)), A.aoMapIntensity !== void 0 && (i.aoMapIntensity = A.aoMapIntensity), A.gradientMap !== void 0 && (i.gradientMap = t(A.gradientMap)), A.clearcoatMap !== void 0 && (i.clearcoatMap = t(A.clearcoatMap)), A.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = t(A.clearcoatRoughnessMap)), A.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = t(A.clearcoatNormalMap)), A.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new ue().fromArray(A.clearcoatNormalScale)), A.iridescenceMap !== void 0 && (i.iridescenceMap = t(A.iridescenceMap)), A.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = t(A.iridescenceThicknessMap)), A.transmissionMap !== void 0 && (i.transmissionMap = t(A.transmissionMap)), A.thicknessMap !== void 0 && (i.thicknessMap = t(A.thicknessMap)), A.sheenColorMap !== void 0 && (i.sheenColorMap = t(A.sheenColorMap)), A.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = t(A.sheenRoughnessMap)), i;
  }
  setTextures(A) {
    return this.textures = A, this;
  }
  static createMaterialFromType(A) {
    const e = {
      ShadowMaterial: AU,
      SpriteMaterial: Uy,
      RawShaderMaterial: eU,
      ShaderMaterial: ia,
      PointsMaterial: BB,
      MeshPhysicalMaterial: eI,
      MeshStandardMaterial: lu,
      MeshPhongMaterial: UC,
      MeshToonMaterial: tU,
      MeshNormalMaterial: Oy,
      MeshLambertMaterial: qy,
      MeshDepthMaterial: Ny,
      MeshDistanceMaterial: Fy,
      MeshBasicMaterial: Ao,
      MeshMatcapMaterial: iU,
      LineDashedMaterial: nU,
      LineBasicMaterial: Mn,
      Material: Sn
    };
    return new e[A]();
  }
}
class JC {
  static decodeText(A) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(A);
    let e = "";
    for (let t = 0, i = A.length; t < i; t++)
      e += String.fromCharCode(A[t]);
    try {
      return decodeURIComponent(escape(e));
    } catch {
      return e;
    }
  }
  static extractUrlBase(A) {
    const e = A.lastIndexOf("/");
    return e === -1 ? "./" : A.slice(0, e + 1);
  }
  static resolveURL(A, e) {
    return typeof A != "string" || A === "" ? "" : (/^https?:\/\//i.test(e) && /^\//.test(A) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(A) || /^data:.*,.*$/i.test(A) || /^blob:.*$/i.test(A) ? A : e + A);
  }
}
class CU extends ut {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(A) {
    return super.copy(A), this.instanceCount = A.instanceCount, this;
  }
  toJSON() {
    const A = super.toJSON();
    return A.instanceCount = this.instanceCount, A.isInstancedBufferGeometry = !0, A;
  }
}
class QU extends Hg {
  constructor(A) {
    super(A);
  }
  load(A, e, t, i) {
    const n = this, r = new go(n.manager);
    r.setPath(n.path), r.setRequestHeader(n.requestHeader), r.setWithCredentials(n.withCredentials), r.load(A, function(s) {
      try {
        e(n.parse(JSON.parse(s)));
      } catch (B) {
        i ? i(B) : console.error(B), n.manager.itemError(A);
      }
    }, t, i);
  }
  parse(A) {
    const e = {}, t = {};
    function i(u, d) {
      if (e[d] !== void 0)
        return e[d];
      const D = u.interleavedBuffers[d], f = n(u, D.buffer), S = hE(D.type, f), y = new eu(S, D.stride);
      return y.uuid = D.uuid, e[d] = y, y;
    }
    function n(u, d) {
      if (t[d] !== void 0)
        return t[d];
      const D = u.arrayBuffers[d], f = new Uint32Array(D).buffer;
      return t[d] = f, f;
    }
    const r = A.isInstancedBufferGeometry ? new CU() : new ut(), s = A.data.index;
    if (s !== void 0) {
      const u = hE(s.type, s.array);
      r.setIndex(new Pt(u, 1));
    }
    const B = A.data.attributes;
    for (const u in B) {
      const d = B[u];
      let p;
      if (d.isInterleavedBufferAttribute) {
        const D = i(A.data, d.data);
        p = new hB(D, d.itemSize, d.offset, d.normalized);
      } else {
        const D = hE(d.type, d.array), f = d.isInstancedBufferAttribute ? xE : Pt;
        p = new f(D, d.itemSize, d.normalized);
      }
      d.name !== void 0 && (p.name = d.name), d.usage !== void 0 && p.setUsage(d.usage), d.updateRange !== void 0 && (p.updateRange.offset = d.updateRange.offset, p.updateRange.count = d.updateRange.count), r.setAttribute(u, p);
    }
    const I = A.data.morphAttributes;
    if (I)
      for (const u in I) {
        const d = I[u], p = [];
        for (let D = 0, f = d.length; D < f; D++) {
          const S = d[D];
          let y;
          if (S.isInterleavedBufferAttribute) {
            const m = i(A.data, S.data);
            y = new hB(m, S.itemSize, S.offset, S.normalized);
          } else {
            const m = hE(S.type, S.array);
            y = new Pt(m, S.itemSize, S.normalized);
          }
          S.name !== void 0 && (y.name = S.name), p.push(y);
        }
        r.morphAttributes[u] = p;
      }
    A.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
    const C = A.data.groups || A.data.drawcalls || A.data.offsets;
    if (C !== void 0)
      for (let u = 0, d = C.length; u !== d; ++u) {
        const p = C[u];
        r.addGroup(p.start, p.count, p.materialIndex);
      }
    const c = A.data.boundingSphere;
    if (c !== void 0) {
      const u = new IA();
      c.center !== void 0 && u.fromArray(c.center), r.boundingSphere = new us(u, c.radius);
    }
    return A.name && (r.name = A.name), A.userData && (r.userData = A.userData), r;
  }
}
class d1 extends Hg {
  constructor(A) {
    super(A);
  }
  load(A, e, t, i) {
    const n = this, r = this.path === "" ? JC.extractUrlBase(A) : this.path;
    this.resourcePath = this.resourcePath || r;
    const s = new go(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(A, function(B) {
      let I = null;
      try {
        I = JSON.parse(B);
      } catch (C) {
        i !== void 0 && i(C), console.error("THREE:ObjectLoader: Can't parse " + A + ".", C.message);
        return;
      }
      const E = I.metadata;
      if (E === void 0 || E.type === void 0 || E.type.toLowerCase() === "geometry") {
        i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + A)), console.error("THREE.ObjectLoader: Can't load " + A);
        return;
      }
      n.parse(I, e);
    }, t, i);
  }
  async loadAsync(A, e) {
    const t = this, i = this.path === "" ? JC.extractUrlBase(A) : this.path;
    this.resourcePath = this.resourcePath || i;
    const n = new go(this.manager);
    n.setPath(this.path), n.setRequestHeader(this.requestHeader), n.setWithCredentials(this.withCredentials);
    const r = await n.loadAsync(A, e), s = JSON.parse(r), B = s.metadata;
    if (B === void 0 || B.type === void 0 || B.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + A);
    return await t.parseAsync(s);
  }
  parse(A, e) {
    const t = this.parseAnimations(A.animations), i = this.parseShapes(A.shapes), n = this.parseGeometries(A.geometries, i), r = this.parseImages(A.images, function() {
      e !== void 0 && e(I);
    }), s = this.parseTextures(A.textures, r), B = this.parseMaterials(A.materials, s), I = this.parseObject(A.object, n, B, s, t), E = this.parseSkeletons(A.skeletons, I);
    if (this.bindSkeletons(I, E), e !== void 0) {
      let C = !1;
      for (const c in r)
        if (r[c].data instanceof HTMLImageElement) {
          C = !0;
          break;
        }
      C === !1 && e(I);
    }
    return I;
  }
  async parseAsync(A) {
    const e = this.parseAnimations(A.animations), t = this.parseShapes(A.shapes), i = this.parseGeometries(A.geometries, t), n = await this.parseImagesAsync(A.images), r = this.parseTextures(A.textures, n), s = this.parseMaterials(A.materials, r), B = this.parseObject(A.object, i, s, r, e), I = this.parseSkeletons(A.skeletons, B);
    return this.bindSkeletons(B, I), B;
  }
  parseShapes(A) {
    const e = {};
    if (A !== void 0)
      for (let t = 0, i = A.length; t < i; t++) {
        const n = new vC().fromJSON(A[t]);
        e[n.uuid] = n;
      }
    return e;
  }
  parseSkeletons(A, e) {
    const t = {}, i = {};
    if (e.traverse(function(n) {
      n.isBone && (i[n.uuid] = n);
    }), A !== void 0)
      for (let n = 0, r = A.length; n < r; n++) {
        const s = new YE().fromJSON(A[n], i);
        t[s.uuid] = s;
      }
    return t;
  }
  parseGeometries(A, e) {
    const t = {};
    if (A !== void 0) {
      const i = new QU();
      for (let n = 0, r = A.length; n < r; n++) {
        let s;
        const B = A[n];
        switch (B.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            s = i.parse(B);
            break;
          default:
            B.type in fN ? s = fN[B.type].fromJSON(B, e) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${B.type}"`);
        }
        s.uuid = B.uuid, B.name !== void 0 && (s.name = B.name), B.userData !== void 0 && (s.userData = B.userData), t[B.uuid] = s;
      }
    }
    return t;
  }
  parseMaterials(A, e) {
    const t = {}, i = {};
    if (A !== void 0) {
      const n = new Hf();
      n.setTextures(e);
      for (let r = 0, s = A.length; r < s; r++) {
        const B = A[r];
        t[B.uuid] === void 0 && (t[B.uuid] = n.parse(B)), i[B.uuid] = t[B.uuid];
      }
    }
    return i;
  }
  parseAnimations(A) {
    const e = {};
    if (A !== void 0)
      for (let t = 0; t < A.length; t++) {
        const i = A[t], n = HC.parse(i);
        e[n.uuid] = n;
      }
    return e;
  }
  parseImages(A, e) {
    const t = this, i = {};
    let n;
    function r(B) {
      return t.manager.itemStart(B), n.load(B, function() {
        t.manager.itemEnd(B);
      }, void 0, function() {
        t.manager.itemError(B), t.manager.itemEnd(B);
      });
    }
    function s(B) {
      if (typeof B == "string") {
        const I = B, E = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(I) ? I : t.resourcePath + I;
        return r(E);
      } else
        return B.data ? {
          data: hE(B.type, B.data),
          width: B.width,
          height: B.height
        } : null;
    }
    if (A !== void 0 && A.length > 0) {
      const B = new jy(e);
      n = new Jc(B), n.setCrossOrigin(this.crossOrigin);
      for (let I = 0, E = A.length; I < E; I++) {
        const C = A[I], c = C.url;
        if (Array.isArray(c)) {
          const u = [];
          for (let d = 0, p = c.length; d < p; d++) {
            const D = c[d], f = s(D);
            f !== null && (f instanceof HTMLImageElement ? u.push(f) : u.push(new wE(f.data, f.width, f.height)));
          }
          i[C.uuid] = new IB(u);
        } else {
          const u = s(C.url);
          i[C.uuid] = new IB(u);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(A) {
    const e = this, t = {};
    let i;
    async function n(r) {
      if (typeof r == "string") {
        const s = r, B = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(s) ? s : e.resourcePath + s;
        return await i.loadAsync(B);
      } else
        return r.data ? {
          data: hE(r.type, r.data),
          width: r.width,
          height: r.height
        } : null;
    }
    if (A !== void 0 && A.length > 0) {
      i = new Jc(this.manager), i.setCrossOrigin(this.crossOrigin);
      for (let r = 0, s = A.length; r < s; r++) {
        const B = A[r], I = B.url;
        if (Array.isArray(I)) {
          const E = [];
          for (let C = 0, c = I.length; C < c; C++) {
            const u = I[C], d = await n(u);
            d !== null && (d instanceof HTMLImageElement ? E.push(d) : E.push(new wE(d.data, d.width, d.height)));
          }
          t[B.uuid] = new IB(E);
        } else {
          const E = await n(B.url);
          t[B.uuid] = new IB(E);
        }
      }
    }
    return t;
  }
  parseTextures(A, e) {
    function t(n, r) {
      return typeof n == "number" ? n : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", n), r[n]);
    }
    const i = {};
    if (A !== void 0)
      for (let n = 0, r = A.length; n < r; n++) {
        const s = A[n];
        s.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), e[s.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", s.image);
        const B = e[s.image], I = B.data;
        let E;
        Array.isArray(I) ? (E = new Au(), I.length === 6 && (E.needsUpdate = !0)) : (I && I.data ? E = new wE() : E = new xi(), I && (E.needsUpdate = !0)), E.source = B, E.uuid = s.uuid, s.name !== void 0 && (E.name = s.name), s.mapping !== void 0 && (E.mapping = t(s.mapping, f1)), s.channel !== void 0 && (E.channel = s.channel), s.offset !== void 0 && E.offset.fromArray(s.offset), s.repeat !== void 0 && E.repeat.fromArray(s.repeat), s.center !== void 0 && E.center.fromArray(s.center), s.rotation !== void 0 && (E.rotation = s.rotation), s.wrap !== void 0 && (E.wrapS = t(s.wrap[0], yN), E.wrapT = t(s.wrap[1], yN)), s.format !== void 0 && (E.format = s.format), s.internalFormat !== void 0 && (E.internalFormat = s.internalFormat), s.type !== void 0 && (E.type = s.type), s.encoding !== void 0 && (E.encoding = s.encoding), s.minFilter !== void 0 && (E.minFilter = t(s.minFilter, mN)), s.magFilter !== void 0 && (E.magFilter = t(s.magFilter, mN)), s.anisotropy !== void 0 && (E.anisotropy = s.anisotropy), s.flipY !== void 0 && (E.flipY = s.flipY), s.generateMipmaps !== void 0 && (E.generateMipmaps = s.generateMipmaps), s.premultiplyAlpha !== void 0 && (E.premultiplyAlpha = s.premultiplyAlpha), s.unpackAlignment !== void 0 && (E.unpackAlignment = s.unpackAlignment), s.userData !== void 0 && (E.userData = s.userData), i[s.uuid] = E;
      }
    return i;
  }
  parseObject(A, e, t, i, n) {
    let r;
    function s(c) {
      return e[c] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", c), e[c];
    }
    function B(c) {
      if (c !== void 0) {
        if (Array.isArray(c)) {
          const u = [];
          for (let d = 0, p = c.length; d < p; d++) {
            const D = c[d];
            t[D] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", D), u.push(t[D]);
          }
          return u;
        }
        return t[c] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", c), t[c];
      }
    }
    function I(c) {
      return i[c] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", c), i[c];
    }
    let E, C;
    switch (A.type) {
      case "Scene":
        r = new UE(), A.background !== void 0 && (Number.isInteger(A.background) ? r.background = new ke(A.background) : r.background = I(A.background)), A.environment !== void 0 && (r.environment = I(A.environment)), A.fog !== void 0 && (A.fog.type === "Fog" ? r.fog = new Uf(A.fog.color, A.fog.near, A.fog.far) : A.fog.type === "FogExp2" && (r.fog = new vf(A.fog.color, A.fog.density))), A.backgroundBlurriness !== void 0 && (r.backgroundBlurriness = A.backgroundBlurriness), A.backgroundIntensity !== void 0 && (r.backgroundIntensity = A.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        r = new mn(A.fov, A.aspect, A.near, A.far), A.focus !== void 0 && (r.focus = A.focus), A.zoom !== void 0 && (r.zoom = A.zoom), A.filmGauge !== void 0 && (r.filmGauge = A.filmGauge), A.filmOffset !== void 0 && (r.filmOffset = A.filmOffset), A.view !== void 0 && (r.view = Object.assign({}, A.view));
        break;
      case "OrthographicCamera":
        r = new $a(A.left, A.right, A.top, A.bottom, A.near, A.far), A.zoom !== void 0 && (r.zoom = A.zoom), A.view !== void 0 && (r.view = Object.assign({}, A.view));
        break;
      case "AmbientLight":
        r = new Xy(A.color, A.intensity);
        break;
      case "DirectionalLight":
        r = new bf(A.color, A.intensity);
        break;
      case "PointLight":
        r = new Oc(A.color, A.intensity, A.distance, A.decay);
        break;
      case "RectAreaLight":
        r = new IU(A.color, A.intensity, A.width, A.height);
        break;
      case "SpotLight":
        r = new Kf(A.color, A.intensity, A.distance, A.angle, A.penumbra, A.decay);
        break;
      case "HemisphereLight":
        r = new aU(A.color, A.groundColor, A.intensity);
        break;
      case "LightProbe":
        r = new Yf().fromJSON(A);
        break;
      case "SkinnedMesh":
        E = s(A.geometry), C = B(A.material), r = new kf(E, C), A.bindMode !== void 0 && (r.bindMode = A.bindMode), A.bindMatrix !== void 0 && r.bindMatrix.fromArray(A.bindMatrix), A.skeleton !== void 0 && (r.skeleton = A.skeleton);
        break;
      case "Mesh":
        E = s(A.geometry), C = B(A.material), r = new Xi(E, C);
        break;
      case "InstancedMesh":
        E = s(A.geometry), C = B(A.material);
        const c = A.count, u = A.instanceMatrix, d = A.instanceColor;
        r = new ky(E, C, c), r.instanceMatrix = new xE(new Float32Array(u.array), 16), d !== void 0 && (r.instanceColor = new xE(new Float32Array(d.array), d.itemSize));
        break;
      case "LOD":
        r = new Jv();
        break;
      case "Line":
        r = new Qs(s(A.geometry), B(A.material));
        break;
      case "LineLoop":
        r = new xy(s(A.geometry), B(A.material));
        break;
      case "LineSegments":
        r = new no(s(A.geometry), B(A.material));
        break;
      case "PointCloud":
      case "Points":
        r = new yE(s(A.geometry), B(A.material));
        break;
      case "Sprite":
        r = new _v(B(A.material));
        break;
      case "Group":
        r = new eo();
        break;
      case "Bone":
        r = new kE();
        break;
      default:
        r = new Xt();
    }
    if (r.uuid = A.uuid, A.name !== void 0 && (r.name = A.name), A.matrix !== void 0 ? (r.matrix.fromArray(A.matrix), A.matrixAutoUpdate !== void 0 && (r.matrixAutoUpdate = A.matrixAutoUpdate), r.matrixAutoUpdate && r.matrix.decompose(r.position, r.quaternion, r.scale)) : (A.position !== void 0 && r.position.fromArray(A.position), A.rotation !== void 0 && r.rotation.fromArray(A.rotation), A.quaternion !== void 0 && r.quaternion.fromArray(A.quaternion), A.scale !== void 0 && r.scale.fromArray(A.scale)), A.up !== void 0 && r.up.fromArray(A.up), A.castShadow !== void 0 && (r.castShadow = A.castShadow), A.receiveShadow !== void 0 && (r.receiveShadow = A.receiveShadow), A.shadow && (A.shadow.bias !== void 0 && (r.shadow.bias = A.shadow.bias), A.shadow.normalBias !== void 0 && (r.shadow.normalBias = A.shadow.normalBias), A.shadow.radius !== void 0 && (r.shadow.radius = A.shadow.radius), A.shadow.mapSize !== void 0 && r.shadow.mapSize.fromArray(A.shadow.mapSize), A.shadow.camera !== void 0 && (r.shadow.camera = this.parseObject(A.shadow.camera))), A.visible !== void 0 && (r.visible = A.visible), A.frustumCulled !== void 0 && (r.frustumCulled = A.frustumCulled), A.renderOrder !== void 0 && (r.renderOrder = A.renderOrder), A.userData !== void 0 && (r.userData = A.userData), A.layers !== void 0 && (r.layers.mask = A.layers), A.children !== void 0) {
      const c = A.children;
      for (let u = 0; u < c.length; u++)
        r.add(this.parseObject(c[u], e, t, i, n));
    }
    if (A.animations !== void 0) {
      const c = A.animations;
      for (let u = 0; u < c.length; u++) {
        const d = c[u];
        r.animations.push(n[d]);
      }
    }
    if (A.type === "LOD") {
      A.autoUpdate !== void 0 && (r.autoUpdate = A.autoUpdate);
      const c = A.levels;
      for (let u = 0; u < c.length; u++) {
        const d = c[u], p = r.getObjectByProperty("uuid", d.object);
        p !== void 0 && r.addLevel(p, d.distance, d.hysteresis);
      }
    }
    return r;
  }
  bindSkeletons(A, e) {
    Object.keys(e).length !== 0 && A.traverse(function(t) {
      if (t.isSkinnedMesh === !0 && t.skeleton !== void 0) {
        const i = e[t.skeleton];
        i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", t.skeleton) : t.bind(i, t.bindMatrix);
      }
    });
  }
}
const f1 = {
  UVMapping: Sf,
  CubeReflectionMapping: lB,
  CubeRefractionMapping: cB,
  EquirectangularReflectionMapping: RE,
  EquirectangularRefractionMapping: xc,
  CubeUVReflectionMapping: KE
}, yN = {
  RepeatWrapping: Bs,
  ClampToEdgeWrapping: Jn,
  MirroredRepeatWrapping: kC
}, mN = {
  NearestFilter: un,
  NearestMipmapNearestFilter: NE,
  NearestMipmapLinearFilter: RC,
  LinearFilter: Gi,
  LinearMipmapNearestFilter: Zc,
  LinearMipmapLinearFilter: Cs
};
class EU extends Hg {
  constructor(A) {
    super(A), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(A) {
    return this.options = A, this;
  }
  load(A, e, t, i) {
    A === void 0 && (A = ""), this.path !== void 0 && (A = this.path + A), A = this.manager.resolveURL(A);
    const n = this, r = _C.get(A);
    if (r !== void 0)
      return n.manager.itemStart(A), setTimeout(function() {
        e && e(r), n.manager.itemEnd(A);
      }, 0), r;
    const s = {};
    s.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", s.headers = this.requestHeader, fetch(A, s).then(function(B) {
      return B.blob();
    }).then(function(B) {
      return createImageBitmap(B, Object.assign(n.options, { colorSpaceConversion: "none" }));
    }).then(function(B) {
      _C.add(A, B), e && e(B), n.manager.itemEnd(A);
    }).catch(function(B) {
      i && i(B), n.manager.itemError(A), n.manager.itemEnd(A);
    }), n.manager.itemStart(A);
  }
}
let Fd;
class $y {
  static getContext() {
    return Fd === void 0 && (Fd = new (window.AudioContext || window.webkitAudioContext)()), Fd;
  }
  static setContext(A) {
    Fd = A;
  }
}
class p1 extends Hg {
  constructor(A) {
    super(A);
  }
  load(A, e, t, i) {
    const n = this, r = new go(this.manager);
    r.setResponseType("arraybuffer"), r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(A, function(s) {
      try {
        const B = s.slice(0);
        $y.getContext().decodeAudioData(B, function(E) {
          e(E);
        });
      } catch (B) {
        i ? i(B) : console.error(B), n.manager.itemError(A);
      }
    }, t, i);
  }
}
class D1 extends Yf {
  constructor(A, e, t = 1) {
    super(void 0, t), this.isHemisphereLightProbe = !0;
    const i = new ke().set(A), n = new ke().set(e), r = new IA(i.r, i.g, i.b), s = new IA(n.r, n.g, n.b), B = Math.sqrt(Math.PI), I = B * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(r).add(s).multiplyScalar(B), this.sh.coefficients[1].copy(r).sub(s).multiplyScalar(I);
  }
}
class w1 extends Yf {
  constructor(A, e = 1) {
    super(void 0, e), this.isAmbientLightProbe = !0;
    const t = new ke().set(A);
    this.sh.coefficients[0].set(t.r, t.g, t.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
const SN = /* @__PURE__ */ new Ve(), MN = /* @__PURE__ */ new Ve(), CC = /* @__PURE__ */ new Ve();
class y1 {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new mn(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new mn(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(A) {
    const e = this._cache;
    if (e.focus !== A.focus || e.fov !== A.fov || e.aspect !== A.aspect * this.aspect || e.near !== A.near || e.far !== A.far || e.zoom !== A.zoom || e.eyeSep !== this.eyeSep) {
      e.focus = A.focus, e.fov = A.fov, e.aspect = A.aspect * this.aspect, e.near = A.near, e.far = A.far, e.zoom = A.zoom, e.eyeSep = this.eyeSep, CC.copy(A.projectionMatrix);
      const i = e.eyeSep / 2, n = i * e.near / e.focus, r = e.near * Math.tan(FC * e.fov * 0.5) / e.zoom;
      let s, B;
      MN.elements[12] = -i, SN.elements[12] = i, s = -r * e.aspect + n, B = r * e.aspect + n, CC.elements[0] = 2 * e.near / (B - s), CC.elements[8] = (B + s) / (B - s), this.cameraL.projectionMatrix.copy(CC), s = -r * e.aspect - n, B = r * e.aspect - n, CC.elements[0] = 2 * e.near / (B - s), CC.elements[8] = (B + s) / (B - s), this.cameraR.projectionMatrix.copy(CC);
    }
    this.cameraL.matrixWorld.copy(A.matrixWorld).multiply(MN), this.cameraR.matrixWorld.copy(A.matrixWorld).multiply(SN);
  }
}
class Am {
  constructor(A = !0) {
    this.autoStart = A, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = RN(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let A = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const e = RN();
      A = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += A;
    }
    return A;
  }
}
function RN() {
  return (typeof performance > "u" ? Date : performance).now();
}
const QC = /* @__PURE__ */ new IA(), NN = /* @__PURE__ */ new On(), m1 = /* @__PURE__ */ new IA(), EC = /* @__PURE__ */ new IA();
class S1 extends Xt {
  constructor() {
    super(), this.type = "AudioListener", this.context = $y.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Am();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(A) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = A, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(A) {
    return this.gain.gain.setTargetAtTime(A, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(A) {
    super.updateMatrixWorld(A);
    const e = this.context.listener, t = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(QC, NN, m1), EC.set(0, 0, -1).applyQuaternion(NN), e.positionX) {
      const i = this.context.currentTime + this.timeDelta;
      e.positionX.linearRampToValueAtTime(QC.x, i), e.positionY.linearRampToValueAtTime(QC.y, i), e.positionZ.linearRampToValueAtTime(QC.z, i), e.forwardX.linearRampToValueAtTime(EC.x, i), e.forwardY.linearRampToValueAtTime(EC.y, i), e.forwardZ.linearRampToValueAtTime(EC.z, i), e.upX.linearRampToValueAtTime(t.x, i), e.upY.linearRampToValueAtTime(t.y, i), e.upZ.linearRampToValueAtTime(t.z, i);
    } else
      e.setPosition(QC.x, QC.y, QC.z), e.setOrientation(EC.x, EC.y, EC.z, t.x, t.y, t.z);
  }
}
class lU extends Xt {
  constructor(A) {
    super(), this.type = "Audio", this.listener = A, this.context = A.context, this.gain = this.context.createGain(), this.gain.connect(A.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(A) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = A, this.connect(), this;
  }
  setMediaElementSource(A) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(A), this.connect(), this;
  }
  setMediaStreamSource(A) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(A), this.connect(), this;
  }
  setBuffer(A) {
    return this.buffer = A, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(A = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + A;
    const e = this.context.createBufferSource();
    return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let A = 1, e = this.filters.length; A < e; A++)
        this.filters[A - 1].connect(this.filters[A]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let A = 1, e = this.filters.length; A < e; A++)
        this.filters[A - 1].disconnect(this.filters[A]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else
      this.source.disconnect(this.getOutput());
    return this._connected = !1, this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(A) {
    return A || (A = []), this._connected === !0 ? (this.disconnect(), this.filters = A.slice(), this.connect()) : this.filters = A.slice(), this;
  }
  setDetune(A) {
    if (this.detune = A, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(A) {
    return this.setFilters(A ? [A] : []);
  }
  setPlaybackRate(A) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = A, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(A) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = A, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(A) {
    return this.loopStart = A, this;
  }
  setLoopEnd(A) {
    return this.loopEnd = A, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(A) {
    return this.gain.gain.setTargetAtTime(A, this.context.currentTime, 0.01), this;
  }
}
const lC = /* @__PURE__ */ new IA(), FN = /* @__PURE__ */ new On(), M1 = /* @__PURE__ */ new IA(), cC = /* @__PURE__ */ new IA();
class R1 extends lU {
  constructor(A) {
    super(A), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(A) {
    return this.panner.refDistance = A, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(A) {
    return this.panner.rolloffFactor = A, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(A) {
    return this.panner.distanceModel = A, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(A) {
    return this.panner.maxDistance = A, this;
  }
  setDirectionalCone(A, e, t) {
    return this.panner.coneInnerAngle = A, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = t, this;
  }
  updateMatrixWorld(A) {
    if (super.updateMatrixWorld(A), this.hasPlaybackControl === !0 && this.isPlaying === !1)
      return;
    this.matrixWorld.decompose(lC, FN, M1), cC.set(0, 0, 1).applyQuaternion(FN);
    const e = this.panner;
    if (e.positionX) {
      const t = this.context.currentTime + this.listener.timeDelta;
      e.positionX.linearRampToValueAtTime(lC.x, t), e.positionY.linearRampToValueAtTime(lC.y, t), e.positionZ.linearRampToValueAtTime(lC.z, t), e.orientationX.linearRampToValueAtTime(cC.x, t), e.orientationY.linearRampToValueAtTime(cC.y, t), e.orientationZ.linearRampToValueAtTime(cC.z, t);
    } else
      e.setPosition(lC.x, lC.y, lC.z), e.setOrientation(cC.x, cC.y, cC.z);
  }
}
class N1 {
  constructor(A, e = 2048) {
    this.analyser = A.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), A.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let A = 0;
    const e = this.getFrequencyData();
    for (let t = 0; t < e.length; t++)
      A += e[t];
    return A / e.length;
  }
}
class cU {
  constructor(A, e, t) {
    this.binding = A, this.valueSize = t;
    let i, n, r;
    switch (e) {
      case "quaternion":
        i = this._slerp, n = this._slerpAdditive, r = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(t * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        i = this._select, n = this._select, r = this._setAdditiveIdentityOther, this.buffer = new Array(t * 5);
        break;
      default:
        i = this._lerp, n = this._lerpAdditive, r = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(t * 5);
    }
    this._mixBufferRegion = i, this._mixBufferRegionAdditive = n, this._setIdentity = r, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(A, e) {
    const t = this.buffer, i = this.valueSize, n = A * i + i;
    let r = this.cumulativeWeight;
    if (r === 0) {
      for (let s = 0; s !== i; ++s)
        t[n + s] = t[s];
      r = e;
    } else {
      r += e;
      const s = e / r;
      this._mixBufferRegion(t, n, 0, s, i);
    }
    this.cumulativeWeight = r;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(A) {
    const e = this.buffer, t = this.valueSize, i = t * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, A, t), this.cumulativeWeightAdditive += A;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(A) {
    const e = this.valueSize, t = this.buffer, i = A * e + e, n = this.cumulativeWeight, r = this.cumulativeWeightAdditive, s = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, n < 1) {
      const B = e * this._origIndex;
      this._mixBufferRegion(
        t,
        i,
        B,
        1 - n,
        e
      );
    }
    r > 0 && this._mixBufferRegionAdditive(t, i, this._addIndex * e, 1, e);
    for (let B = e, I = e + e; B !== I; ++B)
      if (t[B] !== t[B + e]) {
        s.setValue(t, i);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const A = this.binding, e = this.buffer, t = this.valueSize, i = t * this._origIndex;
    A.getValue(e, i);
    for (let n = t, r = i; n !== r; ++n)
      e[n] = e[i + n % t];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const A = this.valueSize * 3;
    this.binding.setValue(this.buffer, A);
  }
  _setAdditiveIdentityNumeric() {
    const A = this._addIndex * this.valueSize, e = A + this.valueSize;
    for (let t = A; t < e; t++)
      this.buffer[t] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const A = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize;
    for (let t = 0; t < this.valueSize; t++)
      this.buffer[e + t] = this.buffer[A + t];
  }
  // mix functions
  _select(A, e, t, i, n) {
    if (i >= 0.5)
      for (let r = 0; r !== n; ++r)
        A[e + r] = A[t + r];
  }
  _slerp(A, e, t, i) {
    On.slerpFlat(A, e, A, e, A, t, i);
  }
  _slerpAdditive(A, e, t, i, n) {
    const r = this._workIndex * n;
    On.multiplyQuaternionsFlat(A, r, A, e, A, t), On.slerpFlat(A, e, A, e, A, r, i);
  }
  _lerp(A, e, t, i, n) {
    const r = 1 - i;
    for (let s = 0; s !== n; ++s) {
      const B = e + s;
      A[B] = A[B] * r + A[t + s] * i;
    }
  }
  _lerpAdditive(A, e, t, i, n) {
    for (let r = 0; r !== n; ++r) {
      const s = e + r;
      A[s] = A[s] + A[t + r] * i;
    }
  }
}
const em = "\\[\\]\\.:\\/", F1 = new RegExp("[" + em + "]", "g"), tm = "[^" + em + "]", G1 = "[^" + em.replace("\\.", "") + "]", v1 = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", tm), U1 = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", G1), k1 = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", tm), x1 = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", tm), L1 = new RegExp(
  "^" + v1 + U1 + k1 + x1 + "$"
), T1 = ["material", "materials", "bones", "map"];
class K1 {
  constructor(A, e, t) {
    const i = t || xt.parseTrackName(e);
    this._targetGroup = A, this._bindings = A.subscribe_(e, i);
  }
  getValue(A, e) {
    this.bind();
    const t = this._targetGroup.nCachedObjects_, i = this._bindings[t];
    i !== void 0 && i.getValue(A, e);
  }
  setValue(A, e) {
    const t = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = t.length; i !== n; ++i)
      t[i].setValue(A, e);
  }
  bind() {
    const A = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, t = A.length; e !== t; ++e)
      A[e].bind();
  }
  unbind() {
    const A = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, t = A.length; e !== t; ++e)
      A[e].unbind();
  }
}
class xt {
  constructor(A, e, t) {
    this.path = e, this.parsedPath = t || xt.parseTrackName(e), this.node = xt.findNode(A, this.parsedPath.nodeName), this.rootNode = A, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(A, e, t) {
    return A && A.isAnimationObjectGroup ? new xt.Composite(A, e, t) : new xt(A, e, t);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(A) {
    return A.replace(/\s/g, "_").replace(F1, "");
  }
  static parseTrackName(A) {
    const e = L1.exec(A);
    if (e === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + A);
    const t = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: e[2],
      objectName: e[3],
      objectIndex: e[4],
      propertyName: e[5],
      // required
      propertyIndex: e[6]
    }, i = t.nodeName && t.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const n = t.nodeName.substring(i + 1);
      T1.indexOf(n) !== -1 && (t.nodeName = t.nodeName.substring(0, i), t.objectName = n);
    }
    if (t.propertyName === null || t.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + A);
    return t;
  }
  static findNode(A, e) {
    if (e === void 0 || e === "" || e === "." || e === -1 || e === A.name || e === A.uuid)
      return A;
    if (A.skeleton) {
      const t = A.skeleton.getBoneByName(e);
      if (t !== void 0)
        return t;
    }
    if (A.children) {
      const t = function(n) {
        for (let r = 0; r < n.length; r++) {
          const s = n[r];
          if (s.name === e || s.uuid === e)
            return s;
          const B = t(s.children);
          if (B)
            return B;
        }
        return null;
      }, i = t(A.children);
      if (i)
        return i;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(A, e) {
    A[e] = this.targetObject[this.propertyName];
  }
  _getValue_array(A, e) {
    const t = this.resolvedProperty;
    for (let i = 0, n = t.length; i !== n; ++i)
      A[e++] = t[i];
  }
  _getValue_arrayElement(A, e) {
    A[e] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(A, e) {
    this.resolvedProperty.toArray(A, e);
  }
  // Direct
  _setValue_direct(A, e) {
    this.targetObject[this.propertyName] = A[e];
  }
  _setValue_direct_setNeedsUpdate(A, e) {
    this.targetObject[this.propertyName] = A[e], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(A, e) {
    this.targetObject[this.propertyName] = A[e], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(A, e) {
    const t = this.resolvedProperty;
    for (let i = 0, n = t.length; i !== n; ++i)
      t[i] = A[e++];
  }
  _setValue_array_setNeedsUpdate(A, e) {
    const t = this.resolvedProperty;
    for (let i = 0, n = t.length; i !== n; ++i)
      t[i] = A[e++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(A, e) {
    const t = this.resolvedProperty;
    for (let i = 0, n = t.length; i !== n; ++i)
      t[i] = A[e++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(A, e) {
    this.resolvedProperty[this.propertyIndex] = A[e];
  }
  _setValue_arrayElement_setNeedsUpdate(A, e) {
    this.resolvedProperty[this.propertyIndex] = A[e], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(A, e) {
    this.resolvedProperty[this.propertyIndex] = A[e], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(A, e) {
    this.resolvedProperty.fromArray(A, e);
  }
  _setValue_fromArray_setNeedsUpdate(A, e) {
    this.resolvedProperty.fromArray(A, e), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(A, e) {
    this.resolvedProperty.fromArray(A, e), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(A, e) {
    this.bind(), this.getValue(A, e);
  }
  _setValue_unbound(A, e) {
    this.bind(), this.setValue(A, e);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let A = this.node;
    const e = this.parsedPath, t = e.objectName, i = e.propertyName;
    let n = e.propertyIndex;
    if (A || (A = xt.findNode(this.rootNode, e.nodeName), this.node = A), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !A) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (t) {
      let I = e.objectIndex;
      switch (t) {
        case "materials":
          if (!A.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!A.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          A = A.material.materials;
          break;
        case "bones":
          if (!A.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          A = A.skeleton.bones;
          for (let E = 0; E < A.length; E++)
            if (A[E].name === I) {
              I = E;
              break;
            }
          break;
        case "map":
          if ("map" in A) {
            A = A.map;
            break;
          }
          if (!A.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!A.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          A = A.material.map;
          break;
        default:
          if (A[t] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          A = A[t];
      }
      if (I !== void 0) {
        if (A[I] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, A);
          return;
        }
        A = A[I];
      }
    }
    const r = A[i];
    if (r === void 0) {
      const I = e.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + I + "." + i + " but it wasn't found.", A);
      return;
    }
    let s = this.Versioning.None;
    this.targetObject = A, A.needsUpdate !== void 0 ? s = this.Versioning.NeedsUpdate : A.matrixWorldNeedsUpdate !== void 0 && (s = this.Versioning.MatrixWorldNeedsUpdate);
    let B = this.BindingType.Direct;
    if (n !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!A.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!A.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        A.morphTargetDictionary[n] !== void 0 && (n = A.morphTargetDictionary[n]);
      }
      B = this.BindingType.ArrayElement, this.resolvedProperty = r, this.propertyIndex = n;
    } else
      r.fromArray !== void 0 && r.toArray !== void 0 ? (B = this.BindingType.HasFromToArray, this.resolvedProperty = r) : Array.isArray(r) ? (B = this.BindingType.EntireArray, this.resolvedProperty = r) : this.propertyName = i;
    this.getValue = this.GetterByBindingType[B], this.setValue = this.SetterByBindingTypeAndVersioning[B][s];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
xt.Composite = K1;
xt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
xt.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
xt.prototype.GetterByBindingType = [
  xt.prototype._getValue_direct,
  xt.prototype._getValue_array,
  xt.prototype._getValue_arrayElement,
  xt.prototype._getValue_toArray
];
xt.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    xt.prototype._setValue_direct,
    xt.prototype._setValue_direct_setNeedsUpdate,
    xt.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    xt.prototype._setValue_array,
    xt.prototype._setValue_array_setNeedsUpdate,
    xt.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    xt.prototype._setValue_arrayElement,
    xt.prototype._setValue_arrayElement_setNeedsUpdate,
    xt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    xt.prototype._setValue_fromArray,
    xt.prototype._setValue_fromArray_setNeedsUpdate,
    xt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class b1 {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = io(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const A = {};
    this._indicesByUUID = A;
    for (let t = 0, i = arguments.length; t !== i; ++t)
      A[arguments[t].uuid] = t;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const e = this;
    this.stats = {
      objects: {
        get total() {
          return e._objects.length;
        },
        get inUse() {
          return this.total - e.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return e._bindings.length;
      }
    };
  }
  add() {
    const A = this._objects, e = this._indicesByUUID, t = this._paths, i = this._parsedPaths, n = this._bindings, r = n.length;
    let s, B = A.length, I = this.nCachedObjects_;
    for (let E = 0, C = arguments.length; E !== C; ++E) {
      const c = arguments[E], u = c.uuid;
      let d = e[u];
      if (d === void 0) {
        d = B++, e[u] = d, A.push(c);
        for (let p = 0, D = r; p !== D; ++p)
          n[p].push(new xt(c, t[p], i[p]));
      } else if (d < I) {
        s = A[d];
        const p = --I, D = A[p];
        e[D.uuid] = d, A[d] = D, e[u] = p, A[p] = c;
        for (let f = 0, S = r; f !== S; ++f) {
          const y = n[f], m = y[p];
          let N = y[d];
          y[d] = m, N === void 0 && (N = new xt(c, t[f], i[f])), y[p] = N;
        }
      } else
        A[d] !== s && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = I;
  }
  remove() {
    const A = this._objects, e = this._indicesByUUID, t = this._bindings, i = t.length;
    let n = this.nCachedObjects_;
    for (let r = 0, s = arguments.length; r !== s; ++r) {
      const B = arguments[r], I = B.uuid, E = e[I];
      if (E !== void 0 && E >= n) {
        const C = n++, c = A[C];
        e[c.uuid] = E, A[E] = c, e[I] = C, A[C] = B;
        for (let u = 0, d = i; u !== d; ++u) {
          const p = t[u], D = p[C], f = p[E];
          p[E] = D, p[C] = f;
        }
      }
    }
    this.nCachedObjects_ = n;
  }
  // remove & forget
  uncache() {
    const A = this._objects, e = this._indicesByUUID, t = this._bindings, i = t.length;
    let n = this.nCachedObjects_, r = A.length;
    for (let s = 0, B = arguments.length; s !== B; ++s) {
      const I = arguments[s], E = I.uuid, C = e[E];
      if (C !== void 0)
        if (delete e[E], C < n) {
          const c = --n, u = A[c], d = --r, p = A[d];
          e[u.uuid] = C, A[C] = u, e[p.uuid] = c, A[c] = p, A.pop();
          for (let D = 0, f = i; D !== f; ++D) {
            const S = t[D], y = S[c], m = S[d];
            S[C] = y, S[c] = m, S.pop();
          }
        } else {
          const c = --r, u = A[c];
          c > 0 && (e[u.uuid] = C), A[C] = u, A.pop();
          for (let d = 0, p = i; d !== p; ++d) {
            const D = t[d];
            D[C] = D[c], D.pop();
          }
        }
    }
    this.nCachedObjects_ = n;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(A, e) {
    const t = this._bindingsIndicesByPath;
    let i = t[A];
    const n = this._bindings;
    if (i !== void 0)
      return n[i];
    const r = this._paths, s = this._parsedPaths, B = this._objects, I = B.length, E = this.nCachedObjects_, C = new Array(I);
    i = n.length, t[A] = i, r.push(A), s.push(e), n.push(C);
    for (let c = E, u = B.length; c !== u; ++c) {
      const d = B[c];
      C[c] = new xt(d, A, e);
    }
    return C;
  }
  unsubscribe_(A) {
    const e = this._bindingsIndicesByPath, t = e[A];
    if (t !== void 0) {
      const i = this._paths, n = this._parsedPaths, r = this._bindings, s = r.length - 1, B = r[s], I = A[s];
      e[I] = t, r[t] = B, r.pop(), n[t] = n[s], n.pop(), i[t] = i[s], i.pop();
    }
  }
}
class uU {
  constructor(A, e, t = null, i = e.blendMode) {
    this._mixer = A, this._clip = e, this._localRoot = t, this.blendMode = i;
    const n = e.tracks, r = n.length, s = new Array(r), B = {
      endingStart: wC,
      endingEnd: wC
    };
    for (let I = 0; I !== r; ++I) {
      const E = n[I].createInterpolant(null);
      s[I] = E, E.settings = B;
    }
    this._interpolantSettings = B, this._interpolants = s, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = hv, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(A) {
    return this._startTime = A, this;
  }
  setLoop(A, e) {
    return this.loop = A, this.repetitions = e, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(A) {
    return this.weight = A, this._effectiveWeight = this.enabled ? A : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(A) {
    return this._scheduleFading(A, 0, 1);
  }
  fadeOut(A) {
    return this._scheduleFading(A, 1, 0);
  }
  crossFadeFrom(A, e, t) {
    if (A.fadeOut(e), this.fadeIn(e), t) {
      const i = this._clip.duration, n = A._clip.duration, r = n / i, s = i / n;
      A.warp(1, r, e), this.warp(s, 1, e);
    }
    return this;
  }
  crossFadeTo(A, e, t) {
    return A.crossFadeFrom(this, e, t);
  }
  stopFading() {
    const A = this._weightInterpolant;
    return A !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(A)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(A) {
    return this.timeScale = A, this._effectiveTimeScale = this.paused ? 0 : A, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(A) {
    return this.timeScale = this._clip.duration / A, this.stopWarping();
  }
  syncWith(A) {
    return this.time = A.time, this.timeScale = A.timeScale, this.stopWarping();
  }
  halt(A) {
    return this.warp(this._effectiveTimeScale, 0, A);
  }
  warp(A, e, t) {
    const i = this._mixer, n = i.time, r = this.timeScale;
    let s = this._timeScaleInterpolant;
    s === null && (s = i._lendControlInterpolant(), this._timeScaleInterpolant = s);
    const B = s.parameterPositions, I = s.sampleValues;
    return B[0] = n, B[1] = n + t, I[0] = A / r, I[1] = e / r, this;
  }
  stopWarping() {
    const A = this._timeScaleInterpolant;
    return A !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(A)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(A, e, t, i) {
    if (!this.enabled) {
      this._updateWeight(A);
      return;
    }
    const n = this._startTime;
    if (n !== null) {
      const B = (A - n) * t;
      B < 0 || t === 0 ? e = 0 : (this._startTime = null, e = t * B);
    }
    e *= this._updateTimeScale(A);
    const r = this._updateTime(e), s = this._updateWeight(A);
    if (s > 0) {
      const B = this._interpolants, I = this._propertyBindings;
      switch (this.blendMode) {
        case py:
          for (let E = 0, C = B.length; E !== C; ++E)
            B[E].evaluate(r), I[E].accumulateAdditive(s);
          break;
        case Mf:
        default:
          for (let E = 0, C = B.length; E !== C; ++E)
            B[E].evaluate(r), I[E].accumulate(i, s);
      }
    }
  }
  _updateWeight(A) {
    let e = 0;
    if (this.enabled) {
      e = this.weight;
      const t = this._weightInterpolant;
      if (t !== null) {
        const i = t.evaluate(A)[0];
        e *= i, A > t.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = e, e;
  }
  _updateTimeScale(A) {
    let e = 0;
    if (!this.paused) {
      e = this.timeScale;
      const t = this._timeScaleInterpolant;
      if (t !== null) {
        const i = t.evaluate(A)[0];
        e *= i, A > t.parameterPositions[1] && (this.stopWarping(), e === 0 ? this.paused = !0 : this.timeScale = e);
      }
    }
    return this._effectiveTimeScale = e, e;
  }
  _updateTime(A) {
    const e = this._clip.duration, t = this.loop;
    let i = this.time + A, n = this._loopCount;
    const r = t === dv;
    if (A === 0)
      return n === -1 ? i : r && (n & 1) === 1 ? e - i : i;
    if (t === uv) {
      n === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      A: {
        if (i >= e)
          i = e;
        else if (i < 0)
          i = 0;
        else {
          this.time = i;
          break A;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: A < 0 ? -1 : 1
        });
      }
    } else {
      if (n === -1 && (A >= 0 ? (n = 0, this._setEndings(!0, this.repetitions === 0, r)) : this._setEndings(this.repetitions === 0, !0, r)), i >= e || i < 0) {
        const s = Math.floor(i / e);
        i -= e * s, n += Math.abs(s);
        const B = this.repetitions - n;
        if (B <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = A > 0 ? e : 0, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: A > 0 ? 1 : -1
          });
        else {
          if (B === 1) {
            const I = A < 0;
            this._setEndings(I, !I, r);
          } else
            this._setEndings(!1, !1, r);
          this._loopCount = n, this.time = i, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: s
          });
        }
      } else
        this.time = i;
      if (r && (n & 1) === 1)
        return e - i;
    }
    return i;
  }
  _setEndings(A, e, t) {
    const i = this._interpolantSettings;
    t ? (i.endingStart = yC, i.endingEnd = yC) : (A ? i.endingStart = this.zeroSlopeAtStart ? yC : wC : i.endingStart = Lc, e ? i.endingEnd = this.zeroSlopeAtEnd ? yC : wC : i.endingEnd = Lc);
  }
  _scheduleFading(A, e, t) {
    const i = this._mixer, n = i.time;
    let r = this._weightInterpolant;
    r === null && (r = i._lendControlInterpolant(), this._weightInterpolant = r);
    const s = r.parameterPositions, B = r.sampleValues;
    return s[0] = n, B[0] = e, s[1] = n + A, B[1] = t, this;
  }
}
const Y1 = new Float32Array(1);
class H1 extends Za {
  constructor(A) {
    super(), this._root = A, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(A, e) {
    const t = A._localRoot || this._root, i = A._clip.tracks, n = i.length, r = A._propertyBindings, s = A._interpolants, B = t.uuid, I = this._bindingsByRootAndName;
    let E = I[B];
    E === void 0 && (E = {}, I[B] = E);
    for (let C = 0; C !== n; ++C) {
      const c = i[C], u = c.name;
      let d = E[u];
      if (d !== void 0)
        ++d.referenceCount, r[C] = d;
      else {
        if (d = r[C], d !== void 0) {
          d._cacheIndex === null && (++d.referenceCount, this._addInactiveBinding(d, B, u));
          continue;
        }
        const p = e && e._propertyBindings[C].binding.parsedPath;
        d = new cU(
          xt.create(t, u, p),
          c.ValueTypeName,
          c.getValueSize()
        ), ++d.referenceCount, this._addInactiveBinding(d, B, u), r[C] = d;
      }
      s[C].resultBuffer = d.buffer;
    }
  }
  _activateAction(A) {
    if (!this._isActiveAction(A)) {
      if (A._cacheIndex === null) {
        const t = (A._localRoot || this._root).uuid, i = A._clip.uuid, n = this._actionsByClip[i];
        this._bindAction(
          A,
          n && n.knownActions[0]
        ), this._addInactiveAction(A, i, t);
      }
      const e = A._propertyBindings;
      for (let t = 0, i = e.length; t !== i; ++t) {
        const n = e[t];
        n.useCount++ === 0 && (this._lendBinding(n), n.saveOriginalState());
      }
      this._lendAction(A);
    }
  }
  _deactivateAction(A) {
    if (this._isActiveAction(A)) {
      const e = A._propertyBindings;
      for (let t = 0, i = e.length; t !== i; ++t) {
        const n = e[t];
        --n.useCount === 0 && (n.restoreOriginalState(), this._takeBackBinding(n));
      }
      this._takeBackAction(A);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const A = this;
    this.stats = {
      actions: {
        get total() {
          return A._actions.length;
        },
        get inUse() {
          return A._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return A._bindings.length;
        },
        get inUse() {
          return A._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return A._controlInterpolants.length;
        },
        get inUse() {
          return A._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(A) {
    const e = A._cacheIndex;
    return e !== null && e < this._nActiveActions;
  }
  _addInactiveAction(A, e, t) {
    const i = this._actions, n = this._actionsByClip;
    let r = n[e];
    if (r === void 0)
      r = {
        knownActions: [A],
        actionByRoot: {}
      }, A._byClipCacheIndex = 0, n[e] = r;
    else {
      const s = r.knownActions;
      A._byClipCacheIndex = s.length, s.push(A);
    }
    A._cacheIndex = i.length, i.push(A), r.actionByRoot[t] = A;
  }
  _removeInactiveAction(A) {
    const e = this._actions, t = e[e.length - 1], i = A._cacheIndex;
    t._cacheIndex = i, e[i] = t, e.pop(), A._cacheIndex = null;
    const n = A._clip.uuid, r = this._actionsByClip, s = r[n], B = s.knownActions, I = B[B.length - 1], E = A._byClipCacheIndex;
    I._byClipCacheIndex = E, B[E] = I, B.pop(), A._byClipCacheIndex = null;
    const C = s.actionByRoot, c = (A._localRoot || this._root).uuid;
    delete C[c], B.length === 0 && delete r[n], this._removeInactiveBindingsForAction(A);
  }
  _removeInactiveBindingsForAction(A) {
    const e = A._propertyBindings;
    for (let t = 0, i = e.length; t !== i; ++t) {
      const n = e[t];
      --n.referenceCount === 0 && this._removeInactiveBinding(n);
    }
  }
  _lendAction(A) {
    const e = this._actions, t = A._cacheIndex, i = this._nActiveActions++, n = e[i];
    A._cacheIndex = i, e[i] = A, n._cacheIndex = t, e[t] = n;
  }
  _takeBackAction(A) {
    const e = this._actions, t = A._cacheIndex, i = --this._nActiveActions, n = e[i];
    A._cacheIndex = i, e[i] = A, n._cacheIndex = t, e[t] = n;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(A, e, t) {
    const i = this._bindingsByRootAndName, n = this._bindings;
    let r = i[e];
    r === void 0 && (r = {}, i[e] = r), r[t] = A, A._cacheIndex = n.length, n.push(A);
  }
  _removeInactiveBinding(A) {
    const e = this._bindings, t = A.binding, i = t.rootNode.uuid, n = t.path, r = this._bindingsByRootAndName, s = r[i], B = e[e.length - 1], I = A._cacheIndex;
    B._cacheIndex = I, e[I] = B, e.pop(), delete s[n], Object.keys(s).length === 0 && delete r[i];
  }
  _lendBinding(A) {
    const e = this._bindings, t = A._cacheIndex, i = this._nActiveBindings++, n = e[i];
    A._cacheIndex = i, e[i] = A, n._cacheIndex = t, e[t] = n;
  }
  _takeBackBinding(A) {
    const e = this._bindings, t = A._cacheIndex, i = --this._nActiveBindings, n = e[i];
    A._cacheIndex = i, e[i] = A, n._cacheIndex = t, e[t] = n;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const A = this._controlInterpolants, e = this._nActiveControlInterpolants++;
    let t = A[e];
    return t === void 0 && (t = new zy(
      new Float32Array(2),
      new Float32Array(2),
      1,
      Y1
    ), t.__cacheIndex = e, A[e] = t), t;
  }
  _takeBackControlInterpolant(A) {
    const e = this._controlInterpolants, t = A.__cacheIndex, i = --this._nActiveControlInterpolants, n = e[i];
    A.__cacheIndex = i, e[i] = A, n.__cacheIndex = t, e[t] = n;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(A, e, t) {
    const i = e || this._root, n = i.uuid;
    let r = typeof A == "string" ? HC.findByName(i, A) : A;
    const s = r !== null ? r.uuid : A, B = this._actionsByClip[s];
    let I = null;
    if (t === void 0 && (r !== null ? t = r.blendMode : t = Mf), B !== void 0) {
      const C = B.actionByRoot[n];
      if (C !== void 0 && C.blendMode === t)
        return C;
      I = B.knownActions[0], r === null && (r = I._clip);
    }
    if (r === null)
      return null;
    const E = new uU(this, r, e, t);
    return this._bindAction(E, I), this._addInactiveAction(E, s, n), E;
  }
  // get an existing action
  existingAction(A, e) {
    const t = e || this._root, i = t.uuid, n = typeof A == "string" ? HC.findByName(t, A) : A, r = n ? n.uuid : A, s = this._actionsByClip[r];
    return s !== void 0 && s.actionByRoot[i] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const A = this._actions, e = this._nActiveActions;
    for (let t = e - 1; t >= 0; --t)
      A[t].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(A) {
    A *= this.timeScale;
    const e = this._actions, t = this._nActiveActions, i = this.time += A, n = Math.sign(A), r = this._accuIndex ^= 1;
    for (let I = 0; I !== t; ++I)
      e[I]._update(i, A, n, r);
    const s = this._bindings, B = this._nActiveBindings;
    for (let I = 0; I !== B; ++I)
      s[I].apply(r);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(A) {
    this.time = 0;
    for (let e = 0; e < this._actions.length; e++)
      this._actions[e].time = 0;
    return this.update(A);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(A) {
    const e = this._actions, t = A.uuid, i = this._actionsByClip, n = i[t];
    if (n !== void 0) {
      const r = n.knownActions;
      for (let s = 0, B = r.length; s !== B; ++s) {
        const I = r[s];
        this._deactivateAction(I);
        const E = I._cacheIndex, C = e[e.length - 1];
        I._cacheIndex = null, I._byClipCacheIndex = null, C._cacheIndex = E, e[E] = C, e.pop(), this._removeInactiveBindingsForAction(I);
      }
      delete i[t];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(A) {
    const e = A.uuid, t = this._actionsByClip;
    for (const r in t) {
      const s = t[r].actionByRoot, B = s[e];
      B !== void 0 && (this._deactivateAction(B), this._removeInactiveAction(B));
    }
    const i = this._bindingsByRootAndName, n = i[e];
    if (n !== void 0)
      for (const r in n) {
        const s = n[r];
        s.restoreOriginalState(), this._removeInactiveBinding(s);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(A, e) {
    const t = this.existingAction(A, e);
    t !== null && (this._deactivateAction(t), this._removeInactiveAction(t));
  }
}
class im {
  constructor(A) {
    this.value = A;
  }
  clone() {
    return new im(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let _1 = 0;
class J1 extends Za {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: _1++ }), this.name = "", this.usage = Tc, this.uniforms = [];
  }
  add(A) {
    return this.uniforms.push(A), this;
  }
  remove(A) {
    const e = this.uniforms.indexOf(A);
    return e !== -1 && this.uniforms.splice(e, 1), this;
  }
  setName(A) {
    return this.name = A, this;
  }
  setUsage(A) {
    return this.usage = A, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(A) {
    this.name = A.name, this.usage = A.usage;
    const e = A.uniforms;
    this.uniforms.length = 0;
    for (let t = 0, i = e.length; t < i; t++)
      this.uniforms.push(e[t].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class O1 extends eu {
  constructor(A, e, t = 1) {
    super(A, e), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = t;
  }
  copy(A) {
    return super.copy(A), this.meshPerAttribute = A.meshPerAttribute, this;
  }
  clone(A) {
    const e = super.clone(A);
    return e.meshPerAttribute = this.meshPerAttribute, e;
  }
  toJSON(A) {
    const e = super.toJSON(A);
    return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e;
  }
}
class q1 {
  constructor(A, e, t, i, n) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = A, this.type = e, this.itemSize = t, this.elementSize = i, this.count = n, this.version = 0;
  }
  set needsUpdate(A) {
    A === !0 && this.version++;
  }
  setBuffer(A) {
    return this.buffer = A, this;
  }
  setType(A, e) {
    return this.type = A, this.elementSize = e, this;
  }
  setItemSize(A) {
    return this.itemSize = A, this;
  }
  setCount(A) {
    return this.count = A, this;
  }
}
class nm {
  constructor(A, e, t = 0, i = 1 / 0) {
    this.ray = new Xc(A, e), this.near = t, this.far = i, this.camera = null, this.layers = new GC(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(A, e) {
    this.ray.set(A, e);
  }
  setFromCamera(A, e) {
    e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(A.x, A.y, 0.5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(A.x, A.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type);
  }
  intersectObject(A, e = !0, t = []) {
    return Ww(A, this, t, e), t.sort(GN), t;
  }
  intersectObjects(A, e = !0, t = []) {
    for (let i = 0, n = A.length; i < n; i++)
      Ww(A[i], this, t, e);
    return t.sort(GN), t;
  }
}
function GN(g, A) {
  return g.distance - A.distance;
}
function Ww(g, A, e, t) {
  if (g.layers.test(A.layers) && g.raycast(A, e), t === !0) {
    const i = g.children;
    for (let n = 0, r = i.length; n < r; n++)
      Ww(i[n], A, e, !0);
  }
}
class P1 {
  constructor(A = 1, e = 0, t = 0) {
    return this.radius = A, this.phi = e, this.theta = t, this;
  }
  set(A, e, t) {
    return this.radius = A, this.phi = e, this.theta = t, this;
  }
  copy(A) {
    return this.radius = A.radius, this.phi = A.phi, this.theta = A.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(A) {
    return this.setFromCartesianCoords(A.x, A.y, A.z);
  }
  setFromCartesianCoords(A, e, t) {
    return this.radius = Math.sqrt(A * A + e * e + t * t), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(A, t), this.phi = Math.acos(yn(e / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class W1 {
  constructor(A = 1, e = 0, t = 0) {
    return this.radius = A, this.theta = e, this.y = t, this;
  }
  set(A, e, t) {
    return this.radius = A, this.theta = e, this.y = t, this;
  }
  copy(A) {
    return this.radius = A.radius, this.theta = A.theta, this.y = A.y, this;
  }
  setFromVector3(A) {
    return this.setFromCartesianCoords(A.x, A.y, A.z);
  }
  setFromCartesianCoords(A, e, t) {
    return this.radius = Math.sqrt(A * A + t * t), this.theta = Math.atan2(A, t), this.y = e, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const vN = /* @__PURE__ */ new ue();
class z1 {
  constructor(A = new ue(1 / 0, 1 / 0), e = new ue(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = A, this.max = e;
  }
  set(A, e) {
    return this.min.copy(A), this.max.copy(e), this;
  }
  setFromPoints(A) {
    this.makeEmpty();
    for (let e = 0, t = A.length; e < t; e++)
      this.expandByPoint(A[e]);
    return this;
  }
  setFromCenterAndSize(A, e) {
    const t = vN.copy(e).multiplyScalar(0.5);
    return this.min.copy(A).sub(t), this.max.copy(A).add(t), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(A) {
    return this.min.copy(A.min), this.max.copy(A.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(A) {
    return this.isEmpty() ? A.set(0, 0) : A.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(A) {
    return this.isEmpty() ? A.set(0, 0) : A.subVectors(this.max, this.min);
  }
  expandByPoint(A) {
    return this.min.min(A), this.max.max(A), this;
  }
  expandByVector(A) {
    return this.min.sub(A), this.max.add(A), this;
  }
  expandByScalar(A) {
    return this.min.addScalar(-A), this.max.addScalar(A), this;
  }
  containsPoint(A) {
    return !(A.x < this.min.x || A.x > this.max.x || A.y < this.min.y || A.y > this.max.y);
  }
  containsBox(A) {
    return this.min.x <= A.min.x && A.max.x <= this.max.x && this.min.y <= A.min.y && A.max.y <= this.max.y;
  }
  getParameter(A, e) {
    return e.set(
      (A.x - this.min.x) / (this.max.x - this.min.x),
      (A.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(A) {
    return !(A.max.x < this.min.x || A.min.x > this.max.x || A.max.y < this.min.y || A.min.y > this.max.y);
  }
  clampPoint(A, e) {
    return e.copy(A).clamp(this.min, this.max);
  }
  distanceToPoint(A) {
    return this.clampPoint(A, vN).distanceTo(A);
  }
  intersect(A) {
    return this.min.max(A.min), this.max.min(A.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(A) {
    return this.min.min(A.min), this.max.max(A.max), this;
  }
  translate(A) {
    return this.min.add(A), this.max.add(A), this;
  }
  equals(A) {
    return A.min.equals(this.min) && A.max.equals(this.max);
  }
}
const UN = /* @__PURE__ */ new IA(), Gd = /* @__PURE__ */ new IA();
class V1 {
  constructor(A = new IA(), e = new IA()) {
    this.start = A, this.end = e;
  }
  set(A, e) {
    return this.start.copy(A), this.end.copy(e), this;
  }
  copy(A) {
    return this.start.copy(A.start), this.end.copy(A.end), this;
  }
  getCenter(A) {
    return A.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(A) {
    return A.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(A, e) {
    return this.delta(e).multiplyScalar(A).add(this.start);
  }
  closestPointToPointParameter(A, e) {
    UN.subVectors(A, this.start), Gd.subVectors(this.end, this.start);
    const t = Gd.dot(Gd);
    let n = Gd.dot(UN) / t;
    return e && (n = yn(n, 0, 1)), n;
  }
  closestPointToPoint(A, e, t) {
    const i = this.closestPointToPointParameter(A, e);
    return this.delta(t).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(A) {
    return this.start.applyMatrix4(A), this.end.applyMatrix4(A), this;
  }
  equals(A) {
    return A.start.equals(this.start) && A.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const kN = /* @__PURE__ */ new IA();
class j1 extends Xt {
  constructor(A, e) {
    super(), this.light = A, this.matrix = A.matrixWorld, this.matrixAutoUpdate = !1, this.color = e, this.type = "SpotLightHelper";
    const t = new ut(), i = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let r = 0, s = 1, B = 32; r < B; r++, s++) {
      const I = r / B * Math.PI * 2, E = s / B * Math.PI * 2;
      i.push(
        Math.cos(I),
        Math.sin(I),
        1,
        Math.cos(E),
        Math.sin(E),
        1
      );
    }
    t.setAttribute("position", new Oe(i, 3));
    const n = new Mn({ fog: !1, toneMapped: !1 });
    this.cone = new no(t, n), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
    const A = this.light.distance ? this.light.distance : 1e3, e = A * Math.tan(this.light.angle);
    this.cone.scale.set(e, e, A), kN.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(kN), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const XI = /* @__PURE__ */ new IA(), vd = /* @__PURE__ */ new Ve(), M0 = /* @__PURE__ */ new Ve();
class Z1 extends no {
  constructor(A) {
    const e = hU(A), t = new ut(), i = [], n = [], r = new ke(0, 0, 1), s = new ke(0, 1, 0);
    for (let I = 0; I < e.length; I++) {
      const E = e[I];
      E.parent && E.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), n.push(r.r, r.g, r.b), n.push(s.r, s.g, s.b));
    }
    t.setAttribute("position", new Oe(i, 3)), t.setAttribute("color", new Oe(n, 3));
    const B = new Mn({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(t, B), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = A, this.bones = e, this.matrix = A.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(A) {
    const e = this.bones, t = this.geometry, i = t.getAttribute("position");
    M0.copy(this.root.matrixWorld).invert();
    for (let n = 0, r = 0; n < e.length; n++) {
      const s = e[n];
      s.parent && s.parent.isBone && (vd.multiplyMatrices(M0, s.matrixWorld), XI.setFromMatrixPosition(vd), i.setXYZ(r, XI.x, XI.y, XI.z), vd.multiplyMatrices(M0, s.parent.matrixWorld), XI.setFromMatrixPosition(vd), i.setXYZ(r + 1, XI.x, XI.y, XI.z), r += 2);
    }
    t.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(A);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function hU(g) {
  const A = [];
  g.isBone === !0 && A.push(g);
  for (let e = 0; e < g.children.length; e++)
    A.push.apply(A, hU(g.children[e]));
  return A;
}
class X1 extends Xi {
  constructor(A, e, t) {
    const i = new JE(e, 4, 2), n = new Ao({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, n), this.light = A, this.color = t, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const $1 = /* @__PURE__ */ new IA(), xN = /* @__PURE__ */ new ke(), LN = /* @__PURE__ */ new ke();
class AO extends Xt {
  constructor(A, e, t) {
    super(), this.light = A, this.matrix = A.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "HemisphereLightHelper";
    const i = new _E(e);
    i.rotateY(Math.PI * 0.5), this.material = new Ao({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const n = i.getAttribute("position"), r = new Float32Array(n.count * 3);
    i.setAttribute("color", new Pt(r, 3)), this.add(new Xi(i, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const A = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const e = A.geometry.getAttribute("color");
      xN.copy(this.light.color), LN.copy(this.light.groundColor);
      for (let t = 0, i = e.count; t < i; t++) {
        const n = t < i / 2 ? xN : LN;
        e.setXYZ(t, n.r, n.g, n.b);
      }
      e.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), A.lookAt($1.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class eO extends no {
  constructor(A = 10, e = 10, t = 4473924, i = 8947848) {
    t = new ke(t), i = new ke(i);
    const n = e / 2, r = A / e, s = A / 2, B = [], I = [];
    for (let c = 0, u = 0, d = -s; c <= e; c++, d += r) {
      B.push(-s, 0, d, s, 0, d), B.push(d, 0, -s, d, 0, s);
      const p = c === n ? t : i;
      p.toArray(I, u), u += 3, p.toArray(I, u), u += 3, p.toArray(I, u), u += 3, p.toArray(I, u), u += 3;
    }
    const E = new ut();
    E.setAttribute("position", new Oe(B, 3)), E.setAttribute("color", new Oe(I, 3));
    const C = new Mn({ vertexColors: !0, toneMapped: !1 });
    super(E, C), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class tO extends no {
  constructor(A = 10, e = 16, t = 8, i = 64, n = 4473924, r = 8947848) {
    n = new ke(n), r = new ke(r);
    const s = [], B = [];
    if (e > 1)
      for (let C = 0; C < e; C++) {
        const c = C / e * (Math.PI * 2), u = Math.sin(c) * A, d = Math.cos(c) * A;
        s.push(0, 0, 0), s.push(u, 0, d);
        const p = C & 1 ? n : r;
        B.push(p.r, p.g, p.b), B.push(p.r, p.g, p.b);
      }
    for (let C = 0; C < t; C++) {
      const c = C & 1 ? n : r, u = A - A / t * C;
      for (let d = 0; d < i; d++) {
        let p = d / i * (Math.PI * 2), D = Math.sin(p) * u, f = Math.cos(p) * u;
        s.push(D, 0, f), B.push(c.r, c.g, c.b), p = (d + 1) / i * (Math.PI * 2), D = Math.sin(p) * u, f = Math.cos(p) * u, s.push(D, 0, f), B.push(c.r, c.g, c.b);
      }
    }
    const I = new ut();
    I.setAttribute("position", new Oe(s, 3)), I.setAttribute("color", new Oe(B, 3));
    const E = new Mn({ vertexColors: !0, toneMapped: !1 });
    super(I, E), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const TN = /* @__PURE__ */ new IA(), Ud = /* @__PURE__ */ new IA(), KN = /* @__PURE__ */ new IA();
class iO extends Xt {
  constructor(A, e, t) {
    super(), this.light = A, this.matrix = A.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "DirectionalLightHelper", e === void 0 && (e = 1);
    let i = new ut();
    i.setAttribute("position", new Oe([
      -e,
      e,
      0,
      e,
      e,
      0,
      e,
      -e,
      0,
      -e,
      -e,
      0,
      -e,
      e,
      0
    ], 3));
    const n = new Mn({ fog: !1, toneMapped: !1 });
    this.lightPlane = new Qs(i, n), this.add(this.lightPlane), i = new ut(), i.setAttribute("position", new Oe([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Qs(i, n), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), TN.setFromMatrixPosition(this.light.matrixWorld), Ud.setFromMatrixPosition(this.light.target.matrixWorld), KN.subVectors(Ud, TN), this.lightPlane.lookAt(Ud), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Ud), this.targetLine.scale.z = KN.length();
  }
}
const kd = /* @__PURE__ */ new IA(), wn = /* @__PURE__ */ new $c();
class nO extends no {
  constructor(A) {
    const e = new ut(), t = new Mn({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], n = [], r = {};
    s("n1", "n2"), s("n2", "n4"), s("n4", "n3"), s("n3", "n1"), s("f1", "f2"), s("f2", "f4"), s("f4", "f3"), s("f3", "f1"), s("n1", "f1"), s("n2", "f2"), s("n3", "f3"), s("n4", "f4"), s("p", "n1"), s("p", "n2"), s("p", "n3"), s("p", "n4"), s("u1", "u2"), s("u2", "u3"), s("u3", "u1"), s("c", "t"), s("p", "c"), s("cn1", "cn2"), s("cn3", "cn4"), s("cf1", "cf2"), s("cf3", "cf4");
    function s(d, p) {
      B(d), B(p);
    }
    function B(d) {
      i.push(0, 0, 0), n.push(0, 0, 0), r[d] === void 0 && (r[d] = []), r[d].push(i.length / 3 - 1);
    }
    e.setAttribute("position", new Oe(i, 3)), e.setAttribute("color", new Oe(n, 3)), super(e, t), this.type = "CameraHelper", this.camera = A, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = A.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = r, this.update();
    const I = new ke(16755200), E = new ke(16711680), C = new ke(43775), c = new ke(16777215), u = new ke(3355443);
    this.setColors(I, E, C, c, u);
  }
  setColors(A, e, t, i, n) {
    const s = this.geometry.getAttribute("color");
    s.setXYZ(0, A.r, A.g, A.b), s.setXYZ(1, A.r, A.g, A.b), s.setXYZ(2, A.r, A.g, A.b), s.setXYZ(3, A.r, A.g, A.b), s.setXYZ(4, A.r, A.g, A.b), s.setXYZ(5, A.r, A.g, A.b), s.setXYZ(6, A.r, A.g, A.b), s.setXYZ(7, A.r, A.g, A.b), s.setXYZ(8, A.r, A.g, A.b), s.setXYZ(9, A.r, A.g, A.b), s.setXYZ(10, A.r, A.g, A.b), s.setXYZ(11, A.r, A.g, A.b), s.setXYZ(12, A.r, A.g, A.b), s.setXYZ(13, A.r, A.g, A.b), s.setXYZ(14, A.r, A.g, A.b), s.setXYZ(15, A.r, A.g, A.b), s.setXYZ(16, A.r, A.g, A.b), s.setXYZ(17, A.r, A.g, A.b), s.setXYZ(18, A.r, A.g, A.b), s.setXYZ(19, A.r, A.g, A.b), s.setXYZ(20, A.r, A.g, A.b), s.setXYZ(21, A.r, A.g, A.b), s.setXYZ(22, A.r, A.g, A.b), s.setXYZ(23, A.r, A.g, A.b), s.setXYZ(24, e.r, e.g, e.b), s.setXYZ(25, e.r, e.g, e.b), s.setXYZ(26, e.r, e.g, e.b), s.setXYZ(27, e.r, e.g, e.b), s.setXYZ(28, e.r, e.g, e.b), s.setXYZ(29, e.r, e.g, e.b), s.setXYZ(30, e.r, e.g, e.b), s.setXYZ(31, e.r, e.g, e.b), s.setXYZ(32, t.r, t.g, t.b), s.setXYZ(33, t.r, t.g, t.b), s.setXYZ(34, t.r, t.g, t.b), s.setXYZ(35, t.r, t.g, t.b), s.setXYZ(36, t.r, t.g, t.b), s.setXYZ(37, t.r, t.g, t.b), s.setXYZ(38, i.r, i.g, i.b), s.setXYZ(39, i.r, i.g, i.b), s.setXYZ(40, n.r, n.g, n.b), s.setXYZ(41, n.r, n.g, n.b), s.setXYZ(42, n.r, n.g, n.b), s.setXYZ(43, n.r, n.g, n.b), s.setXYZ(44, n.r, n.g, n.b), s.setXYZ(45, n.r, n.g, n.b), s.setXYZ(46, n.r, n.g, n.b), s.setXYZ(47, n.r, n.g, n.b), s.setXYZ(48, n.r, n.g, n.b), s.setXYZ(49, n.r, n.g, n.b), s.needsUpdate = !0;
  }
  update() {
    const A = this.geometry, e = this.pointMap, t = 1, i = 1;
    wn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Tn("c", e, A, wn, 0, 0, -1), Tn("t", e, A, wn, 0, 0, 1), Tn("n1", e, A, wn, -t, -i, -1), Tn("n2", e, A, wn, t, -i, -1), Tn("n3", e, A, wn, -t, i, -1), Tn("n4", e, A, wn, t, i, -1), Tn("f1", e, A, wn, -t, -i, 1), Tn("f2", e, A, wn, t, -i, 1), Tn("f3", e, A, wn, -t, i, 1), Tn("f4", e, A, wn, t, i, 1), Tn("u1", e, A, wn, t * 0.7, i * 1.1, -1), Tn("u2", e, A, wn, -t * 0.7, i * 1.1, -1), Tn("u3", e, A, wn, 0, i * 2, -1), Tn("cf1", e, A, wn, -t, 0, 1), Tn("cf2", e, A, wn, t, 0, 1), Tn("cf3", e, A, wn, 0, -i, 1), Tn("cf4", e, A, wn, 0, i, 1), Tn("cn1", e, A, wn, -t, 0, -1), Tn("cn2", e, A, wn, t, 0, -1), Tn("cn3", e, A, wn, 0, -i, -1), Tn("cn4", e, A, wn, 0, i, -1), A.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Tn(g, A, e, t, i, n, r) {
  kd.set(i, n, r).unproject(t);
  const s = A[g];
  if (s !== void 0) {
    const B = e.getAttribute("position");
    for (let I = 0, E = s.length; I < E; I++)
      B.setXYZ(s[I], kd.x, kd.y, kd.z);
  }
}
const xd = /* @__PURE__ */ new cs();
class gO extends no {
  constructor(A, e = 16776960) {
    const t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(8 * 3), n = new ut();
    n.setIndex(new Pt(t, 1)), n.setAttribute("position", new Pt(i, 3)), super(n, new Mn({ color: e, toneMapped: !1 })), this.object = A, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(A) {
    if (A !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && xd.setFromObject(this.object), xd.isEmpty())
      return;
    const e = xd.min, t = xd.max, i = this.geometry.attributes.position, n = i.array;
    n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = e.x, n[4] = t.y, n[5] = t.z, n[6] = e.x, n[7] = e.y, n[8] = t.z, n[9] = t.x, n[10] = e.y, n[11] = t.z, n[12] = t.x, n[13] = t.y, n[14] = e.z, n[15] = e.x, n[16] = t.y, n[17] = e.z, n[18] = e.x, n[19] = e.y, n[20] = e.z, n[21] = t.x, n[22] = e.y, n[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(A) {
    return this.object = A, this.update(), this;
  }
  copy(A, e) {
    return super.copy(A, e), this.object = A.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class rO extends no {
  constructor(A, e = 16776960) {
    const t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], n = new ut();
    n.setIndex(new Pt(t, 1)), n.setAttribute("position", new Oe(i, 3)), super(n, new Mn({ color: e, toneMapped: !1 })), this.box = A, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(A) {
    const e = this.box;
    e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(A));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class oO extends Qs {
  constructor(A, e = 1, t = 16776960) {
    const i = t, n = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], r = new ut();
    r.setAttribute("position", new Oe(n, 3)), r.computeBoundingSphere(), super(r, new Mn({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = A, this.size = e;
    const s = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], B = new ut();
    B.setAttribute("position", new Oe(s, 3)), B.computeBoundingSphere(), this.add(new Xi(B, new Ao({ color: i, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(A) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(A);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const bN = /* @__PURE__ */ new IA();
let Ld, R0;
class sO extends Xt {
  // dir is assumed to be normalized
  constructor(A = new IA(0, 0, 1), e = new IA(0, 0, 0), t = 1, i = 16776960, n = t * 0.2, r = n * 0.2) {
    super(), this.type = "ArrowHelper", Ld === void 0 && (Ld = new ut(), Ld.setAttribute("position", new Oe([0, 0, 0, 0, 1, 0], 3)), R0 = new WC(0, 0.5, 1, 5, 1), R0.translate(0, -0.5, 0)), this.position.copy(e), this.line = new Qs(Ld, new Mn({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Xi(R0, new Ao({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(A), this.setLength(t, n, r);
  }
  setDirection(A) {
    if (A.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (A.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      bN.set(A.z, 0, -A.x).normalize();
      const e = Math.acos(A.y);
      this.quaternion.setFromAxisAngle(bN, e);
    }
  }
  setLength(A, e = A * 0.2, t = e * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, A - e), 1), this.line.updateMatrix(), this.cone.scale.set(t, e, t), this.cone.position.y = A, this.cone.updateMatrix();
  }
  setColor(A) {
    this.line.material.color.set(A), this.cone.material.color.set(A);
  }
  copy(A) {
    return super.copy(A, !1), this.line.copy(A.line), this.cone.copy(A.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class aO extends no {
  constructor(A = 1) {
    const e = [
      0,
      0,
      0,
      A,
      0,
      0,
      0,
      0,
      0,
      0,
      A,
      0,
      0,
      0,
      0,
      0,
      0,
      A
    ], t = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], i = new ut();
    i.setAttribute("position", new Oe(e, 3)), i.setAttribute("color", new Oe(t, 3));
    const n = new Mn({ vertexColors: !0, toneMapped: !1 });
    super(i, n), this.type = "AxesHelper";
  }
  setColors(A, e, t) {
    const i = new ke(), n = this.geometry.attributes.color.array;
    return i.set(A), i.toArray(n, 0), i.toArray(n, 3), i.set(e), i.toArray(n, 6), i.toArray(n, 9), i.set(t), i.toArray(n, 12), i.toArray(n, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class IO {
  constructor() {
    this.type = "ShapePath", this.color = new ke(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(A, e) {
    return this.currentPath = new bc(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(A, e), this;
  }
  lineTo(A, e) {
    return this.currentPath.lineTo(A, e), this;
  }
  quadraticCurveTo(A, e, t, i) {
    return this.currentPath.quadraticCurveTo(A, e, t, i), this;
  }
  bezierCurveTo(A, e, t, i, n, r) {
    return this.currentPath.bezierCurveTo(A, e, t, i, n, r), this;
  }
  splineThru(A) {
    return this.currentPath.splineThru(A), this;
  }
  toShapes(A) {
    function e(f) {
      const S = [];
      for (let y = 0, m = f.length; y < m; y++) {
        const N = f[y], F = new vC();
        F.curves = N.curves, S.push(F);
      }
      return S;
    }
    function t(f, S) {
      const y = S.length;
      let m = !1;
      for (let N = y - 1, F = 0; F < y; N = F++) {
        let G = S[N], k = S[F], v = k.x - G.x, x = k.y - G.y;
        if (Math.abs(x) > Number.EPSILON) {
          if (x < 0 && (G = S[F], v = -v, k = S[N], x = -x), f.y < G.y || f.y > k.y)
            continue;
          if (f.y === G.y) {
            if (f.x === G.x)
              return !0;
          } else {
            const H = x * (f.x - G.x) - v * (f.y - G.y);
            if (H === 0)
              return !0;
            if (H < 0)
              continue;
            m = !m;
          }
        } else {
          if (f.y !== G.y)
            continue;
          if (k.x <= f.x && f.x <= G.x || G.x <= f.x && f.x <= k.x)
            return !0;
        }
      }
      return m;
    }
    const i = Aa.isClockWise, n = this.subPaths;
    if (n.length === 0)
      return [];
    let r, s, B;
    const I = [];
    if (n.length === 1)
      return s = n[0], B = new vC(), B.curves = s.curves, I.push(B), I;
    let E = !i(n[0].getPoints());
    E = A ? !E : E;
    const C = [], c = [];
    let u = [], d = 0, p;
    c[d] = void 0, u[d] = [];
    for (let f = 0, S = n.length; f < S; f++)
      s = n[f], p = s.getPoints(), r = i(p), r = A ? !r : r, r ? (!E && c[d] && d++, c[d] = { s: new vC(), p }, c[d].s.curves = s.curves, E && d++, u[d] = []) : u[d].push({ h: s, p: p[0] });
    if (!c[0])
      return e(n);
    if (c.length > 1) {
      let f = !1, S = 0;
      for (let y = 0, m = c.length; y < m; y++)
        C[y] = [];
      for (let y = 0, m = c.length; y < m; y++) {
        const N = u[y];
        for (let F = 0; F < N.length; F++) {
          const G = N[F];
          let k = !0;
          for (let v = 0; v < c.length; v++)
            t(G.p, c[v].p) && (y !== v && S++, k ? (k = !1, C[v].push(G)) : f = !0);
          k && C[y].push(G);
        }
      }
      S > 0 && f === !1 && (u = C);
    }
    let D;
    for (let f = 0, S = c.length; f < S; f++) {
      B = c[f].s, I.push(B), D = u[f];
      for (let y = 0, m = D.length; y < m; y++)
        B.holes.push(D[y].h);
    }
    return I;
  }
}
class BO extends Xa {
  // @deprecated, r144
  constructor(A, e, t, i, n, r) {
    console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."), super(A, e, t, i, n, r);
  }
}
class CO extends iu {
  // @deprecated, r144
  constructor(A, e, t, i) {
    console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."), super(A, e, t, i);
  }
}
class QO extends nu {
  // @deprecated, r144
  constructor(A, e, t, i) {
    console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."), super(A, e, t, i);
  }
}
class EO extends gu {
  // @deprecated, r144
  constructor(A, e, t, i, n, r, s) {
    console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."), super(A, e, t, i, n, r, s);
  }
}
class lO extends WC {
  // @deprecated, r144
  constructor(A, e, t, i, n, r, s, B) {
    console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."), super(A, e, t, i, n, r, s, B);
  }
}
class cO extends ru {
  // @deprecated, r144
  constructor(A, e) {
    console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."), super(A, e);
  }
}
class uO extends ou {
  // @deprecated, r144
  constructor(A, e) {
    console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."), super(A, e);
  }
}
class hO extends su {
  // @deprecated, r144
  constructor(A, e) {
    console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."), super(A, e);
  }
}
class dO extends HE {
  // @deprecated, r144
  constructor(A, e, t, i) {
    console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."), super(A, e, t, i);
  }
}
class fO extends _E {
  // @deprecated, r144
  constructor(A, e) {
    console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."), super(A, e);
  }
}
class pO extends PC {
  // @deprecated, r144
  constructor(A, e, t, i) {
    console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."), super(A, e, t, i);
  }
}
class DO extends AI {
  // @deprecated, r144
  constructor(A, e, t, i) {
    console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."), super(A, e, t, i);
  }
}
class wO extends au {
  // @deprecated, r144
  constructor(A, e, t, i, n, r) {
    console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."), super(A, e, t, i, n, r);
  }
}
class yO extends Iu {
  // @deprecated, r144
  constructor(A, e) {
    console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."), super(A, e);
  }
}
class mO extends JE {
  // @deprecated, r144
  constructor(A, e, t, i, n, r, s) {
    console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."), super(A, e, t, i, n, r, s);
  }
}
class SO extends Bu {
  // @deprecated, r144
  constructor(A, e) {
    console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."), super(A, e);
  }
}
class MO extends Cu {
  // @deprecated, r144
  constructor(A, e, t, i, n) {
    console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."), super(A, e, t, i, n);
  }
}
class RO extends Qu {
  // @deprecated, r144
  constructor(A, e, t, i, n, r) {
    console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."), super(A, e, t, i, n, r);
  }
}
class NO extends Eu {
  // @deprecated, r144
  constructor(A, e, t, i, n) {
    console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."), super(A, e, t, i, n);
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: yf
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = yf);
const dU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: dy,
  AddEquation: fC,
  AddOperation: ZG,
  AdditiveAnimationBlendMode: py,
  AdditiveBlending: Bw,
  AlphaFormat: ov,
  AlwaysDepth: OG,
  AlwaysStencilFunc: yv,
  AmbientLight: Xy,
  AmbientLightProbe: w1,
  AnimationAction: uU,
  AnimationClip: HC,
  AnimationLoader: C1,
  AnimationMixer: H1,
  AnimationObjectGroup: b1,
  AnimationUtils: s1,
  ArcCurve: qv,
  ArrayCamera: bv,
  ArrowHelper: sO,
  Audio: lU,
  AudioAnalyser: N1,
  AudioContext: $y,
  AudioListener: S1,
  AudioLoader: p1,
  AxesHelper: aO,
  BackSide: ir,
  BasicDepthPacking: pv,
  BasicShadowMap: FG,
  Bone: kE,
  BooleanKeyframeTrack: zC,
  Box2: z1,
  Box3: cs,
  Box3Helper: rO,
  BoxBufferGeometry: BO,
  BoxGeometry: Xa,
  BoxHelper: gO,
  BufferAttribute: Pt,
  BufferGeometry: ut,
  BufferGeometryLoader: QU,
  ByteType: tv,
  Cache: _C,
  Camera: $c,
  CameraHelper: nO,
  CanvasTexture: Ov,
  CapsuleBufferGeometry: CO,
  CapsuleGeometry: iu,
  CatmullRomCurve3: Pv,
  CineonToneMapping: Av,
  CircleBufferGeometry: QO,
  CircleGeometry: nu,
  ClampToEdgeWrapping: Jn,
  Clock: Am,
  Color: ke,
  ColorKeyframeTrack: Vy,
  ColorManagement: pr,
  CompressedArrayTexture: vJ,
  CompressedTexture: Ly,
  CompressedTextureLoader: Q1,
  ConeBufferGeometry: EO,
  ConeGeometry: gu,
  CubeCamera: Gv,
  CubeReflectionMapping: lB,
  CubeRefractionMapping: cB,
  CubeTexture: Au,
  CubeTextureLoader: E1,
  CubeUVReflectionMapping: KE,
  CubicBezierCurve: Ky,
  CubicBezierCurve3: Wv,
  CubicInterpolant: rU,
  CullFaceBack: Iw,
  CullFaceFront: NG,
  CullFaceFrontBack: UK,
  CullFaceNone: RG,
  Curve: ko,
  CurvePath: Vv,
  CustomBlending: GG,
  CustomToneMapping: ev,
  CylinderBufferGeometry: lO,
  CylinderGeometry: WC,
  Cylindrical: W1,
  Data3DTexture: Sy,
  DataArrayTexture: Rf,
  DataTexture: wE,
  DataTextureLoader: l1,
  DataUtils: _b,
  DecrementStencilOp: JK,
  DecrementWrapStencilOp: qK,
  DefaultLoadingManager: pE,
  DepthFormat: EB,
  DepthStencilFormat: LC,
  DepthTexture: Gy,
  DirectionalLight: bf,
  DirectionalLightHelper: iO,
  DiscreteInterpolant: oU,
  DisplayP3ColorSpace: wy,
  DodecahedronBufferGeometry: cO,
  DodecahedronGeometry: ru,
  DoubleSide: Rr,
  DstAlphaFactor: KG,
  DstColorFactor: YG,
  DynamicCopyUsage: rb,
  DynamicDrawUsage: Ab,
  DynamicReadUsage: ib,
  EdgesGeometry: Jy,
  EllipseCurve: tu,
  EqualDepth: PG,
  EqualStencilFunc: VK,
  EquirectangularReflectionMapping: RE,
  EquirectangularRefractionMapping: xc,
  Euler: Nr,
  EventDispatcher: Za,
  ExtrudeBufferGeometry: uO,
  ExtrudeGeometry: ou,
  FileLoader: go,
  Float16BufferAttribute: zb,
  Float32BufferAttribute: Oe,
  Float64BufferAttribute: Vb,
  FloatType: $s,
  Fog: Uf,
  FogExp2: vf,
  FramebufferTexture: GJ,
  FrontSide: ea,
  Frustum: Ff,
  GLBufferAttribute: q1,
  GLSL1: sb,
  GLSL3: bw,
  GreaterDepth: zG,
  GreaterEqualDepth: WG,
  GreaterEqualStencilFunc: $K,
  GreaterStencilFunc: ZK,
  GridHelper: eO,
  Group: eo,
  HalfFloatType: xC,
  HemisphereLight: aU,
  HemisphereLightHelper: AO,
  HemisphereLightProbe: D1,
  IcosahedronBufferGeometry: hO,
  IcosahedronGeometry: su,
  ImageBitmapLoader: EU,
  ImageLoader: Jc,
  ImageUtils: my,
  IncrementStencilOp: _K,
  IncrementWrapStencilOp: OK,
  InstancedBufferAttribute: xE,
  InstancedBufferGeometry: CU,
  InstancedInterleavedBuffer: O1,
  InstancedMesh: ky,
  Int16BufferAttribute: Pb,
  Int32BufferAttribute: Wb,
  Int8BufferAttribute: Jb,
  IntType: nv,
  InterleavedBuffer: eu,
  InterleavedBufferAttribute: hB,
  Interpolant: OE,
  InterpolateDiscrete: TC,
  InterpolateLinear: uB,
  InterpolateSmooth: tf,
  InvertStencilOp: PK,
  KeepStencilOp: nf,
  KeyframeTrack: hs,
  LOD: Jv,
  LatheBufferGeometry: dO,
  LatheGeometry: HE,
  Layers: GC,
  LessDepth: qG,
  LessEqualDepth: af,
  LessEqualStencilFunc: jK,
  LessStencilFunc: zK,
  Light: pB,
  LightProbe: Yf,
  Line: Qs,
  Line3: V1,
  LineBasicMaterial: Mn,
  LineCurve: xf,
  LineCurve3: zv,
  LineDashedMaterial: nU,
  LineLoop: xy,
  LineSegments: no,
  LinearEncoding: ta,
  LinearFilter: Gi,
  LinearInterpolant: zy,
  LinearMipMapLinearFilter: KK,
  LinearMipMapNearestFilter: TK,
  LinearMipmapLinearFilter: Cs,
  LinearMipmapNearestFilter: Zc,
  LinearSRGBColorSpace: FE,
  LinearToneMapping: XG,
  Loader: Hg,
  LoaderUtils: JC,
  LoadingManager: jy,
  LoopOnce: uv,
  LoopPingPong: dv,
  LoopRepeat: hv,
  LuminanceAlphaFormat: av,
  LuminanceFormat: sv,
  MOUSE: GK,
  Material: Sn,
  MaterialLoader: Hf,
  MathUtils: bg,
  Matrix3: kt,
  Matrix4: Ve,
  MaxEquation: lw,
  Mesh: Xi,
  MeshBasicMaterial: Ao,
  MeshDepthMaterial: Ny,
  MeshDistanceMaterial: Fy,
  MeshLambertMaterial: qy,
  MeshMatcapMaterial: iU,
  MeshNormalMaterial: Oy,
  MeshPhongMaterial: UC,
  MeshPhysicalMaterial: eI,
  MeshStandardMaterial: lu,
  MeshToonMaterial: tU,
  MinEquation: Ew,
  MirroredRepeatWrapping: kC,
  MixOperation: jG,
  MultiplyBlending: Qw,
  MultiplyOperation: jc,
  NearestFilter: un,
  NearestMipMapLinearFilter: LK,
  NearestMipMapNearestFilter: xK,
  NearestMipmapLinearFilter: RC,
  NearestMipmapNearestFilter: NE,
  NeverDepth: JG,
  NeverStencilFunc: WK,
  NoBlending: Wa,
  NoColorSpace: bK,
  NoToneMapping: Is,
  NormalAnimationBlendMode: Mf,
  NormalBlending: MC,
  NotEqualDepth: VG,
  NotEqualStencilFunc: XK,
  NumberKeyframeTrack: bC,
  Object3D: Xt,
  ObjectLoader: d1,
  ObjectSpaceNormalMap: wv,
  OctahedronBufferGeometry: fO,
  OctahedronGeometry: _E,
  OneFactor: xG,
  OneMinusDstAlphaFactor: bG,
  OneMinusDstColorFactor: HG,
  OneMinusSrcAlphaFactor: hy,
  OneMinusSrcColorFactor: TG,
  OrthographicCamera: $a,
  PCFShadowMap: mf,
  PCFSoftShadowMap: Sc,
  PMREMGenerator: Hw,
  Path: bc,
  PerspectiveCamera: mn,
  Plane: rB,
  PlaneBufferGeometry: pO,
  PlaneGeometry: PC,
  PlaneHelper: oO,
  PointLight: Oc,
  PointLightHelper: X1,
  Points: yE,
  PointsMaterial: BB,
  PolarGridHelper: tO,
  PolyhedronBufferGeometry: DO,
  PolyhedronGeometry: AI,
  PositionalAudio: R1,
  PropertyBinding: xt,
  PropertyMixer: cU,
  QuadraticBezierCurve: by,
  QuadraticBezierCurve3: Yy,
  Quaternion: On,
  QuaternionKeyframeTrack: ja,
  QuaternionLinearInterpolant: sU,
  RED_GREEN_RGTC2_Format: Tw,
  RED_RGTC1_Format: cv,
  REVISION: yf,
  RGBADepthPacking: Dv,
  RGBAFormat: tr,
  RGBAIntegerFormat: Ev,
  RGBA_ASTC_10x10_Format: Uw,
  RGBA_ASTC_10x5_Format: Fw,
  RGBA_ASTC_10x6_Format: Gw,
  RGBA_ASTC_10x8_Format: vw,
  RGBA_ASTC_12x10_Format: kw,
  RGBA_ASTC_12x12_Format: xw,
  RGBA_ASTC_4x4_Format: Dw,
  RGBA_ASTC_5x4_Format: ww,
  RGBA_ASTC_5x5_Format: yw,
  RGBA_ASTC_6x5_Format: mw,
  RGBA_ASTC_6x6_Format: Sw,
  RGBA_ASTC_8x5_Format: Mw,
  RGBA_ASTC_8x6_Format: Rw,
  RGBA_ASTC_8x8_Format: Nw,
  RGBA_BPTC_Format: ef,
  RGBA_ETC2_EAC_Format: pw,
  RGBA_PVRTC_2BPPV1_Format: dw,
  RGBA_PVRTC_4BPPV1_Format: hw,
  RGBA_S3TC_DXT1_Format: Xd,
  RGBA_S3TC_DXT3_Format: $d,
  RGBA_S3TC_DXT5_Format: Af,
  RGB_ETC1_Format: lv,
  RGB_ETC2_Format: fw,
  RGB_PVRTC_2BPPV1_Format: uw,
  RGB_PVRTC_4BPPV1_Format: cw,
  RGB_S3TC_DXT1_Format: Zd,
  RGFormat: Cv,
  RGIntegerFormat: Qv,
  RawShaderMaterial: eU,
  Ray: Xc,
  Raycaster: nm,
  RectAreaLight: IU,
  RedFormat: Iv,
  RedIntegerFormat: Bv,
  ReinhardToneMapping: $G,
  RepeatWrapping: Bs,
  ReplaceStencilOp: HK,
  ReverseSubtractEquation: UG,
  RingBufferGeometry: wO,
  RingGeometry: au,
  SIGNED_RED_GREEN_RGTC2_Format: Kw,
  SIGNED_RED_RGTC1_Format: Lw,
  SRGBColorSpace: ss,
  Scene: UE,
  ShaderChunk: Yt,
  ShaderLib: as,
  ShaderMaterial: ia,
  ShadowMaterial: AU,
  Shape: vC,
  ShapeBufferGeometry: yO,
  ShapeGeometry: Iu,
  ShapePath: IO,
  ShapeUtils: Aa,
  ShortType: iv,
  Skeleton: YE,
  SkeletonHelper: Z1,
  SkinnedMesh: kf,
  Source: IB,
  Sphere: us,
  SphereBufferGeometry: mO,
  SphereGeometry: JE,
  Spherical: P1,
  SphericalHarmonics3: BU,
  SplineCurve: Hy,
  SpotLight: Kf,
  SpotLightHelper: j1,
  Sprite: _v,
  SpriteMaterial: Uy,
  SrcAlphaFactor: uy,
  SrcAlphaSaturateFactor: _G,
  SrcColorFactor: LG,
  StaticCopyUsage: gb,
  StaticDrawUsage: Tc,
  StaticReadUsage: tb,
  StereoCamera: y1,
  StreamCopyUsage: ob,
  StreamDrawUsage: eb,
  StreamReadUsage: nb,
  StringKeyframeTrack: VC,
  SubtractEquation: vG,
  SubtractiveBlending: Cw,
  TOUCH: vK,
  TangentSpaceNormalMap: fB,
  TetrahedronBufferGeometry: SO,
  TetrahedronGeometry: Bu,
  Texture: xi,
  TextureLoader: Tf,
  TorusBufferGeometry: MO,
  TorusGeometry: Cu,
  TorusKnotBufferGeometry: RO,
  TorusKnotGeometry: Qu,
  Triangle: Sr,
  TriangleFanDrawMode: If,
  TriangleStripDrawMode: Dy,
  TrianglesDrawMode: fv,
  TubeBufferGeometry: NO,
  TubeGeometry: Eu,
  TwoPassDoubleSide: kK,
  UVMapping: Sf,
  Uint16BufferAttribute: Nf,
  Uint32BufferAttribute: My,
  Uint8BufferAttribute: Ob,
  Uint8ClampedBufferAttribute: qb,
  Uniform: im,
  UniformsGroup: J1,
  UniformsLib: be,
  UniformsUtils: Fv,
  UnsignedByteType: Va,
  UnsignedInt248Type: NC,
  UnsignedIntType: aB,
  UnsignedShort4444Type: gv,
  UnsignedShort5551Type: rv,
  UnsignedShortType: fy,
  VSMShadowMap: DC,
  Vector2: ue,
  Vector3: IA,
  Vector4: Bi,
  VectorKeyframeTrack: YC,
  VideoTexture: FJ,
  WebGL1Renderer: Yv,
  WebGL3DRenderTarget: Gb,
  WebGLArrayRenderTarget: Fb,
  WebGLCubeRenderTarget: vv,
  WebGLMultipleRenderTargets: vb,
  WebGLRenderTarget: Uo,
  WebGLRenderer: vy,
  WebGLUtils: Kv,
  WireframeGeometry: $v,
  WrapAroundEnding: Lc,
  ZeroCurvatureEnding: wC,
  ZeroFactor: kG,
  ZeroSlopeEnding: yC,
  ZeroStencilOp: YK,
  _SRGBAFormat: Bf,
  sRGBEncoding: Ht
}, Symbol.toStringTag, { value: "Module" }));
function FO() {
  for (var g = 0, A, e, t = ""; g < arguments.length; )
    (A = arguments[g++]) && (e = fU(A)) && (t && (t += " "), t += e);
  return t;
}
function fU(g) {
  if (typeof g == "string")
    return g;
  for (var A, e = "", t = 0; t < g.length; t++)
    g[t] && (A = fU(g[t])) && (e && (e += " "), e += A);
  return e;
}
var gm = "-";
function GO(g) {
  var A = UO(g);
  function e(i) {
    var n = i.split(gm);
    return n[0] === "" && n.length !== 1 && n.shift(), pU(n, A) || vO(i);
  }
  function t(i) {
    return g.conflictingClassGroups[i] || [];
  }
  return {
    getClassGroupId: e,
    getConflictingClassGroupIds: t
  };
}
function pU(g, A) {
  if (g.length === 0)
    return A.classGroupId;
  var e = g[0], t = A.nextPart.get(e), i = t ? pU(g.slice(1), t) : void 0;
  if (i)
    return i;
  if (A.validators.length !== 0) {
    var n = g.join(gm);
    return A.validators.find(function(r) {
      var s = r.validator;
      return s(n);
    })?.classGroupId;
  }
}
var YN = /^\[(.+)\]$/;
function vO(g) {
  if (YN.test(g)) {
    var A = YN.exec(g)[1], e = A?.substring(0, A.indexOf(":"));
    if (e)
      return "arbitrary.." + e;
  }
}
function UO(g) {
  var A = g.theme, e = g.prefix, t = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  }, i = xO(Object.entries(g.classGroups), e);
  return i.forEach(function(n) {
    var r = n[0], s = n[1];
    zw(s, t, r, A);
  }), t;
}
function zw(g, A, e, t) {
  g.forEach(function(i) {
    if (typeof i == "string") {
      var n = i === "" ? A : HN(A, i);
      n.classGroupId = e;
      return;
    }
    if (typeof i == "function") {
      if (kO(i)) {
        zw(i(t), A, e, t);
        return;
      }
      A.validators.push({
        validator: i,
        classGroupId: e
      });
      return;
    }
    Object.entries(i).forEach(function(r) {
      var s = r[0], B = r[1];
      zw(B, HN(A, s), e, t);
    });
  });
}
function HN(g, A) {
  var e = g;
  return A.split(gm).forEach(function(t) {
    e.nextPart.has(t) || e.nextPart.set(t, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), e = e.nextPart.get(t);
  }), e;
}
function kO(g) {
  return g.isThemeGetter;
}
function xO(g, A) {
  return A ? g.map(function(e) {
    var t = e[0], i = e[1], n = i.map(function(r) {
      return typeof r == "string" ? A + r : typeof r == "object" ? Object.fromEntries(Object.entries(r).map(function(s) {
        var B = s[0], I = s[1];
        return [A + B, I];
      })) : r;
    });
    return [t, n];
  }) : g;
}
function LO(g) {
  if (g < 1)
    return {
      get: function() {
      },
      set: function() {
      }
    };
  var A = 0, e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map();
  function i(n, r) {
    e.set(n, r), A++, A > g && (A = 0, t = e, e = /* @__PURE__ */ new Map());
  }
  return {
    get: function(r) {
      var s = e.get(r);
      if (s !== void 0)
        return s;
      if ((s = t.get(r)) !== void 0)
        return i(r, s), s;
    },
    set: function(r, s) {
      e.has(r) ? e.set(r, s) : i(r, s);
    }
  };
}
var DU = "!";
function TO(g) {
  var A = g.separator || ":";
  return function(t) {
    for (var i = 0, n = [], r = 0, s = 0; s < t.length; s++) {
      var B = t[s];
      i === 0 && B === A[0] && (A.length === 1 || t.slice(s, s + A.length) === A) && (n.push(t.slice(r, s)), r = s + A.length), B === "[" ? i++ : B === "]" && i--;
    }
    var I = n.length === 0 ? t : t.substring(r), E = I.startsWith(DU), C = E ? I.substring(1) : I;
    return {
      modifiers: n,
      hasImportantModifier: E,
      baseClassName: C
    };
  };
}
function KO(g) {
  if (g.length <= 1)
    return g;
  var A = [], e = [];
  return g.forEach(function(t) {
    var i = t[0] === "[";
    i ? (A.push.apply(A, e.sort().concat([t])), e = []) : e.push(t);
  }), A.push.apply(A, e.sort()), A;
}
function bO(g) {
  return {
    cache: LO(g.cacheSize),
    splitModifiers: TO(g),
    ...GO(g)
  };
}
var YO = /\s+/;
function HO(g, A) {
  var e = A.splitModifiers, t = A.getClassGroupId, i = A.getConflictingClassGroupIds, n = /* @__PURE__ */ new Set();
  return g.trim().split(YO).map(function(r) {
    var s = e(r), B = s.modifiers, I = s.hasImportantModifier, E = s.baseClassName, C = t(E);
    if (!C)
      return {
        isTailwindClass: !1,
        originalClassName: r
      };
    var c = KO(B).join(":"), u = I ? c + DU : c;
    return {
      isTailwindClass: !0,
      modifierId: u,
      classGroupId: C,
      originalClassName: r
    };
  }).reverse().filter(function(r) {
    if (!r.isTailwindClass)
      return !0;
    var s = r.modifierId, B = r.classGroupId, I = s + B;
    return n.has(I) ? !1 : (n.add(I), i(B).forEach(function(E) {
      return n.add(s + E);
    }), !0);
  }).reverse().map(function(r) {
    return r.originalClassName;
  }).join(" ");
}
function _O() {
  for (var g = arguments.length, A = new Array(g), e = 0; e < g; e++)
    A[e] = arguments[e];
  var t, i, n, r = s;
  function s(I) {
    var E = A[0], C = A.slice(1), c = C.reduce(function(u, d) {
      return d(u);
    }, E());
    return t = bO(c), i = t.cache.get, n = t.cache.set, r = B, B(I);
  }
  function B(I) {
    var E = i(I);
    if (E)
      return E;
    var C = HO(I, t);
    return n(I, C), C;
  }
  return function() {
    return r(FO.apply(null, arguments));
  };
}
function Ji(g) {
  var A = function(t) {
    return t[g] || [];
  };
  return A.isThemeGetter = !0, A;
}
var wU = /^\[(?:([a-z-]+):)?(.+)\]$/i, JO = /^\d+\/\d+$/, OO = /* @__PURE__ */ new Set(["px", "full", "screen"]), qO = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, PO = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))/, WO = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
function rs(g) {
  return SC(g) || OO.has(g) || JO.test(g) || nB(g);
}
function nB(g) {
  return jC(g, "length", $O);
}
function zO(g) {
  return jC(g, "size", yU);
}
function VO(g) {
  return jC(g, "position", yU);
}
function jO(g) {
  return jC(g, "url", A3);
}
function Td(g) {
  return jC(g, "number", SC);
}
function SC(g) {
  return !Number.isNaN(Number(g));
}
function ZO(g) {
  return g.endsWith("%") && SC(g.slice(0, -1));
}
function ac(g) {
  return _N(g) || jC(g, "number", _N);
}
function Kn(g) {
  return wU.test(g);
}
function Ic() {
  return !0;
}
function $I(g) {
  return qO.test(g);
}
function XO(g) {
  return jC(g, "", e3);
}
function jC(g, A, e) {
  var t = wU.exec(g);
  return t ? t[1] ? t[1] === A : e(t[2]) : !1;
}
function $O(g) {
  return PO.test(g);
}
function yU() {
  return !1;
}
function A3(g) {
  return g.startsWith("url(");
}
function _N(g) {
  return Number.isInteger(Number(g));
}
function e3(g) {
  return WO.test(g);
}
function t3() {
  var g = Ji("colors"), A = Ji("spacing"), e = Ji("blur"), t = Ji("brightness"), i = Ji("borderColor"), n = Ji("borderRadius"), r = Ji("borderSpacing"), s = Ji("borderWidth"), B = Ji("contrast"), I = Ji("grayscale"), E = Ji("hueRotate"), C = Ji("invert"), c = Ji("gap"), u = Ji("gradientColorStops"), d = Ji("gradientColorStopPositions"), p = Ji("inset"), D = Ji("margin"), f = Ji("opacity"), S = Ji("padding"), y = Ji("saturate"), m = Ji("scale"), N = Ji("sepia"), F = Ji("skew"), G = Ji("space"), k = Ji("translate"), v = function() {
    return ["auto", "contain", "none"];
  }, x = function() {
    return ["auto", "hidden", "clip", "visible", "scroll"];
  }, H = function() {
    return ["auto", A];
  }, _ = function() {
    return ["", rs];
  }, j = function() {
    return ["auto", SC, Kn];
  }, V = function() {
    return ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  }, iA = function() {
    return ["solid", "dashed", "dotted", "double", "none"];
  }, eA = function() {
    return ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
  }, oA = function() {
    return ["start", "end", "center", "between", "around", "evenly", "stretch"];
  }, P = function() {
    return ["", "0", Kn];
  }, J = function() {
    return ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  }, tA = function() {
    return [SC, Td];
  }, Y = function() {
    return [SC, Kn];
  };
  return {
    cacheSize: 500,
    theme: {
      colors: [Ic],
      spacing: [rs],
      blur: ["none", "", $I, nB],
      brightness: tA(),
      borderColor: [g],
      borderRadius: ["none", "", "full", $I, nB],
      borderSpacing: [A],
      borderWidth: _(),
      contrast: tA(),
      grayscale: P(),
      hueRotate: Y(),
      invert: P(),
      gap: [A],
      gradientColorStops: [g],
      gradientColorStopPositions: [ZO, nB],
      inset: H(),
      margin: H(),
      opacity: tA(),
      padding: [A],
      saturate: tA(),
      scale: tA(),
      sepia: P(),
      skew: Y(),
      space: [A],
      translate: [A]
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", Kn]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [$I]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": J()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": J()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [].concat(V(), [Kn])
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: x()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": x()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": x()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: v()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": v()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": v()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [p]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [p]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [p]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [p]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [p]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [p]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [p]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [p]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [p]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", ac]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [A]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", Kn]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: P()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: P()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", ac]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Ic]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: [ac]
        }, Kn]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": j()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": j()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Ic]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [ac]
        }, Kn]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": j()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": j()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", Kn]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", Kn]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [c]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [c]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [c]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal"].concat(oA())
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal"].concat(oA(), ["baseline"])
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [].concat(oA(), ["baseline"])
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [S]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [S]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [S]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [S]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [S]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [S]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [S]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [S]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [S]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [D]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [D]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [D]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [D]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [D]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [D]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [D]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [D]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [D]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [G]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [G]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", A]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": ["min", "max", "fit", rs]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": ["0", "none", "full", "min", "max", "fit", "prose", {
          screen: [$I]
        }, $I, nB]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [A, "auto", "min", "max", "fit"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["min", "max", "fit", rs]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [A, "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", $I, nB]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Td]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Ic]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", nB]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", SC, Td]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", rs]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Kn]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", Kn]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [g]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [f]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [g]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [f]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [].concat(iA(), ["wavy"])
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", rs]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", rs]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [g]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: [A]
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", nB]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Kn]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [f]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [].concat(V(), [VO])
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", zO]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, jO]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [g]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [d]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [d]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [d]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [u]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [u]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [u]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [n]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [n]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [n]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [n]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [n]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [n]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [n]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [n]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [n]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [n]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [n]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [n]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [n]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [n]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [n]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [s]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [s]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [s]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [s]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [s]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [s]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [s]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [s]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [s]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [f]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [].concat(iA(), ["hidden"])
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [s]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [s]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [f]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: iA()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [i]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [i]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [i]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [i]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [i]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [i]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [i]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [i]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [""].concat(iA())
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [rs]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [rs]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [g]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: _()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [g]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [f]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [rs]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [g]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", $I, XO]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Ic]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [f]
      }],
      /**
       * Mix Beldn Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": eA()
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": eA()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [e]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [t]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [B]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", $I, Kn]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [I]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [E]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [C]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [y]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [N]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [e]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [t]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [B]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [I]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [E]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [C]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [f]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [y]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [N]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [r]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [r]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [r]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Kn]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: Y()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", Kn]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: Y()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", Kn]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [m]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [m]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [m]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [ac, Kn]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [k]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [k]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [F]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [F]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Kn]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", g]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: ["appearance-none"],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Kn]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [g]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": [A]
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": [A]
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": [A]
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": [A]
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": [A]
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": [A]
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": [A]
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": [A]
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": [A]
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": [A]
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": [A]
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": [A]
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": [A]
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": [A]
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": [A]
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": [A]
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": [A]
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": [A]
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "pinch-zoom", "manipulation", {
          pan: ["x", "left", "right", "y", "up", "down"]
        }]
      }],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Kn]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [g, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [rs, Td]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [g, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"]
    }
  };
}
var i3 = /* @__PURE__ */ _O(t3);
const Kd = ({
  title: g,
  icon: A,
  children: e,
  className: t,
  expanded: i = !1
}) => {
  const [n, r] = cn(i), s = () => r((B) => !B);
  return /* @__PURE__ */ Wi(
    "div",
    {
      className: i3(
        ` ms-p-3 ms-mb-2 ms-rounded-md ${n ? "ms-bg-gray-100" : ""}`,
        t
      ),
      children: [
        /* @__PURE__ */ Wi(
          "div",
          {
            className: "ms-text-left ms-cursor-pointer ms-items-center ms-select-none ms-flex ms-justify-between",
            onClick: s,
            children: [
              /* @__PURE__ */ Wi("div", { className: "ms-flex ms-items-center ms-space-x-2", children: [
                /* @__PURE__ */ fe("h5", { className: "ms-text-sm ms-font-medium", children: g }),
                /* @__PURE__ */ fe(
                  "svg",
                  {
                    xmlns: "http://www.w3.org/2000/svg",
                    viewBox: "0 0 20 20",
                    fill: "currentColor",
                    className: `ms-w-5 ms-h-5 ms-transition-all ms-duration-200 ${n ? "ms--rotate-0" : "ms-rotate-180"}`,
                    children: /* @__PURE__ */ fe(
                      "path",
                      {
                        fillRule: "evenodd",
                        d: "M14.77 12.79a.75.75 0 01-1.06-.02L10 8.832 6.29 12.77a.75.75 0 11-1.08-1.04l4.25-4.5a.75.75 0 011.08 0l4.25 4.5a.75.75 0 01-.02 1.06z",
                        clipRule: "evenodd"
                      }
                    )
                  }
                )
              ] }),
              A
            ]
          }
        ),
        /* @__PURE__ */ fe(
          "div",
          {
            className: ` ms-pt-2 ms-overflow-hidden ${n ? "ms-h-auto" : "ms-h-0"}`,
            children: e
          }
        )
      ]
    }
  );
}, JN = ({ icon: g, onClick: A }) => /* @__PURE__ */ fe(
  "button",
  {
    type: "button",
    className: "ms-rounded-md ms-border ms-bg-white ms-border-gray-400 hover:ms-border-gray-600 ms-p-1",
    onClick: A,
    children: g
  }
), n3 = () => /* @__PURE__ */ Wi(Df, { children: [
  /* @__PURE__ */ fe("ambientLight", { color: "white", intensity: 0.6 }),
  /* @__PURE__ */ fe("pointLight", { intensity: 1.2, position: [2, 20, 6], color: "white" }),
  /* @__PURE__ */ fe("pointLight", { intensity: 1.2, position: [-10, 8, 6], color: "white" })
] });
function OC() {
  return OC = Object.assign ? Object.assign.bind() : function(g) {
    for (var A = 1; A < arguments.length; A++) {
      var e = arguments[A];
      for (var t in e)
        Object.prototype.hasOwnProperty.call(e, t) && (g[t] = e[t]);
    }
    return g;
  }, OC.apply(this, arguments);
}
function mU(g) {
  return g && g.__esModule && Object.prototype.hasOwnProperty.call(g, "default") ? g.default : g;
}
var Vw, bd = mG;
if (process.env.NODE_ENV === "production")
  Vw = bd.createRoot, bd.hydrateRoot;
else {
  var ON = bd.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  Vw = function(g, A) {
    ON.usingClientEntryPoint = !0;
    try {
      return bd.createRoot(g, A);
    } finally {
      ON.usingClientEntryPoint = !1;
    }
  };
}
var CB = {}, g3 = {
  get exports() {
    return CB;
  },
  set exports(g) {
    CB = g;
  }
}, AB = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qN;
function r3() {
  return qN || (qN = 1, AB.ConcurrentRoot = 1, AB.ContinuousEventPriority = 4, AB.DefaultEventPriority = 16, AB.DiscreteEventPriority = 1, AB.IdleEventPriority = 536870912, AB.LegacyRoot = 0), AB;
}
var eB = {};
/**
 * @license React
 * react-reconciler-constants.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var PN;
function o3() {
  return PN || (PN = 1, process.env.NODE_ENV !== "production" && function() {
    var g = (
      /*                        */
      1
    ), A = (
      /*            */
      4
    ), e = (
      /*                    */
      16
    ), t = (
      /*                       */
      536870912
    ), i = g, n = A, r = e, s = t, B = 0, I = 1;
    eB.ConcurrentRoot = I, eB.ContinuousEventPriority = n, eB.DefaultEventPriority = r, eB.DiscreteEventPriority = i, eB.IdleEventPriority = s, eB.LegacyRoot = B;
  }()), eB;
}
(function(g) {
  process.env.NODE_ENV === "production" ? g.exports = r3() : g.exports = o3();
})(g3);
function s3(g) {
  let A;
  const e = /* @__PURE__ */ new Set(), t = (I, E) => {
    const C = typeof I == "function" ? I(A) : I;
    if (C !== A) {
      const c = A;
      A = E ? C : Object.assign({}, A, C), e.forEach((u) => u(A, c));
    }
  }, i = () => A, n = (I, E = i, C = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let c = E(A);
    function u() {
      const d = E(A);
      if (!C(c, d)) {
        const p = c;
        I(c = d, p);
      }
    }
    return e.add(u), () => e.delete(u);
  }, B = { setState: t, getState: i, subscribe: (I, E, C) => E || C ? n(I, E, C) : (e.add(I), () => e.delete(I)), destroy: () => e.clear() };
  return A = g(t, i, B), B;
}
const a3 = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), WN = a3 ? gi : cy;
function SU(g) {
  const A = typeof g == "function" ? s3(g) : g, e = (t = A.getState, i = Object.is) => {
    const [, n] = wf((D) => D + 1, 0), r = A.getState(), s = Dt(r), B = Dt(t), I = Dt(i), E = Dt(!1), C = Dt();
    C.current === void 0 && (C.current = t(r));
    let c, u = !1;
    (s.current !== r || B.current !== t || I.current !== i || E.current) && (c = t(r), u = !i(C.current, c)), WN(() => {
      u && (C.current = c), s.current = r, B.current = t, I.current = i, E.current = !1;
    });
    const d = Dt(r);
    WN(() => {
      const D = () => {
        try {
          const S = A.getState(), y = B.current(S);
          I.current(C.current, y) || (s.current = S, C.current = y, n());
        } catch {
          E.current = !0, n();
        }
      }, f = A.subscribe(D);
      return A.getState() !== d.current && D(), f;
    }, []);
    const p = u ? c : C.current;
    return yK(p), p;
  };
  return Object.assign(e, A), e[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const t = [e, A];
    return {
      next() {
        const i = t.length <= 0;
        return { value: t.shift(), done: i };
      }
    };
  }, e;
}
var jw = {}, I3 = {
  get exports() {
    return jw;
  },
  set exports(g) {
    jw = g;
  }
}, Cf = {}, B3 = {
  get exports() {
    return Cf;
  },
  set exports(g) {
    Cf = g;
  }
}, N0 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zN;
function C3() {
  return zN || (zN = 1, function(g) {
    function A(P, J) {
      var tA = P.length;
      P.push(J);
      A:
        for (; 0 < tA; ) {
          var Y = tA - 1 >>> 1, rA = P[Y];
          if (0 < i(rA, J))
            P[Y] = J, P[tA] = rA, tA = Y;
          else
            break A;
        }
    }
    function e(P) {
      return P.length === 0 ? null : P[0];
    }
    function t(P) {
      if (P.length === 0)
        return null;
      var J = P[0], tA = P.pop();
      if (tA !== J) {
        P[0] = tA;
        A:
          for (var Y = 0, rA = P.length, QA = rA >>> 1; Y < QA; ) {
            var aA = 2 * (Y + 1) - 1, MA = P[aA], hA = aA + 1, fA = P[hA];
            if (0 > i(MA, tA))
              hA < rA && 0 > i(fA, MA) ? (P[Y] = fA, P[hA] = tA, Y = hA) : (P[Y] = MA, P[aA] = tA, Y = aA);
            else if (hA < rA && 0 > i(fA, tA))
              P[Y] = fA, P[hA] = tA, Y = hA;
            else
              break A;
          }
      }
      return J;
    }
    function i(P, J) {
      var tA = P.sortIndex - J.sortIndex;
      return tA !== 0 ? tA : P.id - J.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var n = performance;
      g.unstable_now = function() {
        return n.now();
      };
    } else {
      var r = Date, s = r.now();
      g.unstable_now = function() {
        return r.now() - s;
      };
    }
    var B = [], I = [], E = 1, C = null, c = 3, u = !1, d = !1, p = !1, D = typeof setTimeout == "function" ? setTimeout : null, f = typeof clearTimeout == "function" ? clearTimeout : null, S = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function y(P) {
      for (var J = e(I); J !== null; ) {
        if (J.callback === null)
          t(I);
        else if (J.startTime <= P)
          t(I), J.sortIndex = J.expirationTime, A(B, J);
        else
          break;
        J = e(I);
      }
    }
    function m(P) {
      if (p = !1, y(P), !d)
        if (e(B) !== null)
          d = !0, eA(N);
        else {
          var J = e(I);
          J !== null && oA(m, J.startTime - P);
        }
    }
    function N(P, J) {
      d = !1, p && (p = !1, f(k), k = -1), u = !0;
      var tA = c;
      try {
        for (y(J), C = e(B); C !== null && (!(C.expirationTime > J) || P && !H()); ) {
          var Y = C.callback;
          if (typeof Y == "function") {
            C.callback = null, c = C.priorityLevel;
            var rA = Y(C.expirationTime <= J);
            J = g.unstable_now(), typeof rA == "function" ? C.callback = rA : C === e(B) && t(B), y(J);
          } else
            t(B);
          C = e(B);
        }
        if (C !== null)
          var QA = !0;
        else {
          var aA = e(I);
          aA !== null && oA(m, aA.startTime - J), QA = !1;
        }
        return QA;
      } finally {
        C = null, c = tA, u = !1;
      }
    }
    var F = !1, G = null, k = -1, v = 5, x = -1;
    function H() {
      return !(g.unstable_now() - x < v);
    }
    function _() {
      if (G !== null) {
        var P = g.unstable_now();
        x = P;
        var J = !0;
        try {
          J = G(!0, P);
        } finally {
          J ? j() : (F = !1, G = null);
        }
      } else
        F = !1;
    }
    var j;
    if (typeof S == "function")
      j = function() {
        S(_);
      };
    else if (typeof MessageChannel < "u") {
      var V = new MessageChannel(), iA = V.port2;
      V.port1.onmessage = _, j = function() {
        iA.postMessage(null);
      };
    } else
      j = function() {
        D(_, 0);
      };
    function eA(P) {
      G = P, F || (F = !0, j());
    }
    function oA(P, J) {
      k = D(function() {
        P(g.unstable_now());
      }, J);
    }
    g.unstable_IdlePriority = 5, g.unstable_ImmediatePriority = 1, g.unstable_LowPriority = 4, g.unstable_NormalPriority = 3, g.unstable_Profiling = null, g.unstable_UserBlockingPriority = 2, g.unstable_cancelCallback = function(P) {
      P.callback = null;
    }, g.unstable_continueExecution = function() {
      d || u || (d = !0, eA(N));
    }, g.unstable_forceFrameRate = function(P) {
      0 > P || 125 < P ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : v = 0 < P ? Math.floor(1e3 / P) : 5;
    }, g.unstable_getCurrentPriorityLevel = function() {
      return c;
    }, g.unstable_getFirstCallbackNode = function() {
      return e(B);
    }, g.unstable_next = function(P) {
      switch (c) {
        case 1:
        case 2:
        case 3:
          var J = 3;
          break;
        default:
          J = c;
      }
      var tA = c;
      c = J;
      try {
        return P();
      } finally {
        c = tA;
      }
    }, g.unstable_pauseExecution = function() {
    }, g.unstable_requestPaint = function() {
    }, g.unstable_runWithPriority = function(P, J) {
      switch (P) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          P = 3;
      }
      var tA = c;
      c = P;
      try {
        return J();
      } finally {
        c = tA;
      }
    }, g.unstable_scheduleCallback = function(P, J, tA) {
      var Y = g.unstable_now();
      switch (typeof tA == "object" && tA !== null ? (tA = tA.delay, tA = typeof tA == "number" && 0 < tA ? Y + tA : Y) : tA = Y, P) {
        case 1:
          var rA = -1;
          break;
        case 2:
          rA = 250;
          break;
        case 5:
          rA = 1073741823;
          break;
        case 4:
          rA = 1e4;
          break;
        default:
          rA = 5e3;
      }
      return rA = tA + rA, P = { id: E++, callback: J, priorityLevel: P, startTime: tA, expirationTime: rA, sortIndex: -1 }, tA > Y ? (P.sortIndex = tA, A(I, P), e(B) === null && P === e(I) && (p ? (f(k), k = -1) : p = !0, oA(m, tA - Y))) : (P.sortIndex = rA, A(B, P), d || u || (d = !0, eA(N))), P;
    }, g.unstable_shouldYield = H, g.unstable_wrapCallback = function(P) {
      var J = c;
      return function() {
        var tA = c;
        c = J;
        try {
          return P.apply(this, arguments);
        } finally {
          c = tA;
        }
      };
    };
  }(N0)), N0;
}
var F0 = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VN;
function Q3() {
  return VN || (VN = 1, function(g) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var A = !1, e = !1, t = 5;
      function i(EA, mA) {
        var YA = EA.length;
        EA.push(mA), s(EA, mA, YA);
      }
      function n(EA) {
        return EA.length === 0 ? null : EA[0];
      }
      function r(EA) {
        if (EA.length === 0)
          return null;
        var mA = EA[0], YA = EA.pop();
        return YA !== mA && (EA[0] = YA, B(EA, YA, 0)), mA;
      }
      function s(EA, mA, YA) {
        for (var ZA = YA; ZA > 0; ) {
          var _A = ZA - 1 >>> 1, Se = EA[_A];
          if (I(Se, mA) > 0)
            EA[_A] = mA, EA[ZA] = Se, ZA = _A;
          else
            return;
        }
      }
      function B(EA, mA, YA) {
        for (var ZA = YA, _A = EA.length, Se = _A >>> 1; ZA < Se; ) {
          var cA = (ZA + 1) * 2 - 1, xA = EA[cA], gA = cA + 1, RA = EA[gA];
          if (I(xA, mA) < 0)
            gA < _A && I(RA, xA) < 0 ? (EA[ZA] = RA, EA[gA] = mA, ZA = gA) : (EA[ZA] = xA, EA[cA] = mA, ZA = cA);
          else if (gA < _A && I(RA, mA) < 0)
            EA[ZA] = RA, EA[gA] = mA, ZA = gA;
          else
            return;
        }
      }
      function I(EA, mA) {
        var YA = EA.sortIndex - mA.sortIndex;
        return YA !== 0 ? YA : EA.id - mA.id;
      }
      var E = 1, C = 2, c = 3, u = 4, d = 5;
      function p(EA, mA) {
      }
      var D = typeof performance == "object" && typeof performance.now == "function";
      if (D) {
        var f = performance;
        g.unstable_now = function() {
          return f.now();
        };
      } else {
        var S = Date, y = S.now();
        g.unstable_now = function() {
          return S.now() - y;
        };
      }
      var m = 1073741823, N = -1, F = 250, G = 5e3, k = 1e4, v = m, x = [], H = [], _ = 1, j = null, V = c, iA = !1, eA = !1, oA = !1, P = typeof setTimeout == "function" ? setTimeout : null, J = typeof clearTimeout == "function" ? clearTimeout : null, tA = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function Y(EA) {
        for (var mA = n(H); mA !== null; ) {
          if (mA.callback === null)
            r(H);
          else if (mA.startTime <= EA)
            r(H), mA.sortIndex = mA.expirationTime, i(x, mA);
          else
            return;
          mA = n(H);
        }
      }
      function rA(EA) {
        if (oA = !1, Y(EA), !eA)
          if (n(x) !== null)
            eA = !0, BA(QA);
          else {
            var mA = n(H);
            mA !== null && GA(rA, mA.startTime - EA);
          }
      }
      function QA(EA, mA) {
        eA = !1, oA && (oA = !1, bA()), iA = !0;
        var YA = V;
        try {
          var ZA;
          if (!e)
            return aA(EA, mA);
        } finally {
          j = null, V = YA, iA = !1;
        }
      }
      function aA(EA, mA) {
        var YA = mA;
        for (Y(YA), j = n(x); j !== null && !A && !(j.expirationTime > YA && (!EA || ie())); ) {
          var ZA = j.callback;
          if (typeof ZA == "function") {
            j.callback = null, V = j.priorityLevel;
            var _A = j.expirationTime <= YA, Se = ZA(_A);
            YA = g.unstable_now(), typeof Se == "function" ? j.callback = Se : j === n(x) && r(x), Y(YA);
          } else
            r(x);
          j = n(x);
        }
        if (j !== null)
          return !0;
        var cA = n(H);
        return cA !== null && GA(rA, cA.startTime - YA), !1;
      }
      function MA(EA, mA) {
        switch (EA) {
          case E:
          case C:
          case c:
          case u:
          case d:
            break;
          default:
            EA = c;
        }
        var YA = V;
        V = EA;
        try {
          return mA();
        } finally {
          V = YA;
        }
      }
      function hA(EA) {
        var mA;
        switch (V) {
          case E:
          case C:
          case c:
            mA = c;
            break;
          default:
            mA = V;
            break;
        }
        var YA = V;
        V = mA;
        try {
          return EA();
        } finally {
          V = YA;
        }
      }
      function fA(EA) {
        var mA = V;
        return function() {
          var YA = V;
          V = mA;
          try {
            return EA.apply(this, arguments);
          } finally {
            V = YA;
          }
        };
      }
      function wA(EA, mA, YA) {
        var ZA = g.unstable_now(), _A;
        if (typeof YA == "object" && YA !== null) {
          var Se = YA.delay;
          typeof Se == "number" && Se > 0 ? _A = ZA + Se : _A = ZA;
        } else
          _A = ZA;
        var cA;
        switch (EA) {
          case E:
            cA = N;
            break;
          case C:
            cA = F;
            break;
          case d:
            cA = v;
            break;
          case u:
            cA = k;
            break;
          case c:
          default:
            cA = G;
            break;
        }
        var xA = _A + cA, gA = {
          id: _++,
          callback: mA,
          priorityLevel: EA,
          startTime: _A,
          expirationTime: xA,
          sortIndex: -1
        };
        return _A > ZA ? (gA.sortIndex = _A, i(H, gA), n(x) === null && gA === n(H) && (oA ? bA() : oA = !0, GA(rA, _A - ZA))) : (gA.sortIndex = xA, i(x, gA), !eA && !iA && (eA = !0, BA(QA))), gA;
      }
      function yA() {
      }
      function kA() {
        !eA && !iA && (eA = !0, BA(QA));
      }
      function FA() {
        return n(x);
      }
      function dA(EA) {
        EA.callback = null;
      }
      function vA() {
        return V;
      }
      var JA = !1, ne = null, ee = -1, pe = t, Ae = -1;
      function ie() {
        var EA = g.unstable_now() - Ae;
        return !(EA < pe);
      }
      function de() {
      }
      function O(EA) {
        if (EA < 0 || EA > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        EA > 0 ? pe = Math.floor(1e3 / EA) : pe = t;
      }
      var AA = function() {
        if (ne !== null) {
          var EA = g.unstable_now();
          Ae = EA;
          var mA = !0, YA = !0;
          try {
            YA = ne(mA, EA);
          } finally {
            YA ? q() : (JA = !1, ne = null);
          }
        } else
          JA = !1;
      }, q;
      if (typeof tA == "function")
        q = function() {
          tA(AA);
        };
      else if (typeof MessageChannel < "u") {
        var Z = new MessageChannel(), $ = Z.port2;
        Z.port1.onmessage = AA, q = function() {
          $.postMessage(null);
        };
      } else
        q = function() {
          P(AA, 0);
        };
      function BA(EA) {
        ne = EA, JA || (JA = !0, q());
      }
      function GA(EA, mA) {
        ee = P(function() {
          EA(g.unstable_now());
        }, mA);
      }
      function bA() {
        J(ee), ee = -1;
      }
      var DA = de, SA = null;
      g.unstable_IdlePriority = d, g.unstable_ImmediatePriority = E, g.unstable_LowPriority = u, g.unstable_NormalPriority = c, g.unstable_Profiling = SA, g.unstable_UserBlockingPriority = C, g.unstable_cancelCallback = dA, g.unstable_continueExecution = kA, g.unstable_forceFrameRate = O, g.unstable_getCurrentPriorityLevel = vA, g.unstable_getFirstCallbackNode = FA, g.unstable_next = hA, g.unstable_pauseExecution = yA, g.unstable_requestPaint = DA, g.unstable_runWithPriority = MA, g.unstable_scheduleCallback = wA, g.unstable_shouldYield = ie, g.unstable_wrapCallback = fA, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(F0)), F0;
}
var jN;
function MU() {
  return jN || (jN = 1, function(g) {
    process.env.NODE_ENV === "production" ? g.exports = C3() : g.exports = Q3();
  }(B3)), Cf;
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var G0, ZN;
function E3() {
  return ZN || (ZN = 1, G0 = function(A) {
    var e = {}, t = qi, i = MU(), n = Object.assign;
    function r(Q) {
      for (var l = "https://reactjs.org/docs/error-decoder.html?invariant=" + Q, M = 1; M < arguments.length; M++)
        l += "&args[]=" + encodeURIComponent(arguments[M]);
      return "Minified React error #" + Q + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var s = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, B = Symbol.for("react.element"), I = Symbol.for("react.portal"), E = Symbol.for("react.fragment"), C = Symbol.for("react.strict_mode"), c = Symbol.for("react.profiler"), u = Symbol.for("react.provider"), d = Symbol.for("react.context"), p = Symbol.for("react.forward_ref"), D = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), S = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), N = Symbol.iterator;
    function F(Q) {
      return Q === null || typeof Q != "object" ? null : (Q = N && Q[N] || Q["@@iterator"], typeof Q == "function" ? Q : null);
    }
    function G(Q) {
      if (Q == null)
        return null;
      if (typeof Q == "function")
        return Q.displayName || Q.name || null;
      if (typeof Q == "string")
        return Q;
      switch (Q) {
        case E:
          return "Fragment";
        case I:
          return "Portal";
        case c:
          return "Profiler";
        case C:
          return "StrictMode";
        case D:
          return "Suspense";
        case f:
          return "SuspenseList";
      }
      if (typeof Q == "object")
        switch (Q.$$typeof) {
          case d:
            return (Q.displayName || "Context") + ".Consumer";
          case u:
            return (Q._context.displayName || "Context") + ".Provider";
          case p:
            var l = Q.render;
            return Q = Q.displayName, Q || (Q = l.displayName || l.name || "", Q = Q !== "" ? "ForwardRef(" + Q + ")" : "ForwardRef"), Q;
          case S:
            return l = Q.displayName || null, l !== null ? l : G(Q.type) || "Memo";
          case y:
            l = Q._payload, Q = Q._init;
            try {
              return G(Q(l));
            } catch {
            }
        }
      return null;
    }
    function k(Q) {
      var l = Q.type;
      switch (Q.tag) {
        case 24:
          return "Cache";
        case 9:
          return (l.displayName || "Context") + ".Consumer";
        case 10:
          return (l._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return Q = l.render, Q = Q.displayName || Q.name || "", l.displayName || (Q !== "" ? "ForwardRef(" + Q + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return l;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return G(l);
        case 8:
          return l === C ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if (typeof l == "function")
            return l.displayName || l.name || null;
          if (typeof l == "string")
            return l;
      }
      return null;
    }
    function v(Q) {
      var l = Q, M = Q;
      if (Q.alternate)
        for (; l.return; )
          l = l.return;
      else {
        Q = l;
        do
          l = Q, l.flags & 4098 && (M = l.return), Q = l.return;
        while (Q);
      }
      return l.tag === 3 ? M : null;
    }
    function x(Q) {
      if (v(Q) !== Q)
        throw Error(r(188));
    }
    function H(Q) {
      var l = Q.alternate;
      if (!l) {
        if (l = v(Q), l === null)
          throw Error(r(188));
        return l !== Q ? null : Q;
      }
      for (var M = Q, U = l; ; ) {
        var K = M.return;
        if (K === null)
          break;
        var z = K.alternate;
        if (z === null) {
          if (U = K.return, U !== null) {
            M = U;
            continue;
          }
          break;
        }
        if (K.child === z.child) {
          for (z = K.child; z; ) {
            if (z === M)
              return x(K), Q;
            if (z === U)
              return x(K), l;
            z = z.sibling;
          }
          throw Error(r(188));
        }
        if (M.return !== U.return)
          M = K, U = z;
        else {
          for (var uA = !1, HA = K.child; HA; ) {
            if (HA === M) {
              uA = !0, M = K, U = z;
              break;
            }
            if (HA === U) {
              uA = !0, U = K, M = z;
              break;
            }
            HA = HA.sibling;
          }
          if (!uA) {
            for (HA = z.child; HA; ) {
              if (HA === M) {
                uA = !0, M = z, U = K;
                break;
              }
              if (HA === U) {
                uA = !0, U = z, M = K;
                break;
              }
              HA = HA.sibling;
            }
            if (!uA)
              throw Error(r(189));
          }
        }
        if (M.alternate !== U)
          throw Error(r(190));
      }
      if (M.tag !== 3)
        throw Error(r(188));
      return M.stateNode.current === M ? Q : l;
    }
    function _(Q) {
      return Q = H(Q), Q !== null ? j(Q) : null;
    }
    function j(Q) {
      if (Q.tag === 5 || Q.tag === 6)
        return Q;
      for (Q = Q.child; Q !== null; ) {
        var l = j(Q);
        if (l !== null)
          return l;
        Q = Q.sibling;
      }
      return null;
    }
    function V(Q) {
      if (Q.tag === 5 || Q.tag === 6)
        return Q;
      for (Q = Q.child; Q !== null; ) {
        if (Q.tag !== 4) {
          var l = V(Q);
          if (l !== null)
            return l;
        }
        Q = Q.sibling;
      }
      return null;
    }
    var iA = Array.isArray, eA = A.getPublicInstance, oA = A.getRootHostContext, P = A.getChildHostContext, J = A.prepareForCommit, tA = A.resetAfterCommit, Y = A.createInstance, rA = A.appendInitialChild, QA = A.finalizeInitialChildren, aA = A.prepareUpdate, MA = A.shouldSetTextContent, hA = A.createTextInstance, fA = A.scheduleTimeout, wA = A.cancelTimeout, yA = A.noTimeout, kA = A.isPrimaryRenderer, FA = A.supportsMutation, dA = A.supportsPersistence, vA = A.supportsHydration, JA = A.getInstanceFromNode, ne = A.preparePortalMount, ee = A.getCurrentEventPriority, pe = A.detachDeletedInstance, Ae = A.supportsMicrotasks, ie = A.scheduleMicrotask, de = A.supportsTestSelectors, O = A.findFiberRoot, AA = A.getBoundingRect, q = A.getTextContent, Z = A.isHiddenSubtree, $ = A.matchAccessibilityRole, BA = A.setFocusIfFocusable, GA = A.setupIntersectionObserver, bA = A.appendChild, DA = A.appendChildToContainer, SA = A.commitTextUpdate, EA = A.commitMount, mA = A.commitUpdate, YA = A.insertBefore, ZA = A.insertInContainerBefore, _A = A.removeChild, Se = A.removeChildFromContainer, cA = A.resetTextContent, xA = A.hideInstance, gA = A.hideTextInstance, RA = A.unhideInstance, UA = A.unhideTextInstance, TA = A.clearContainer, ge = A.cloneInstance, Me = A.createContainerChildSet, xe = A.appendChildToContainerChildSet, we = A.finalizeContainerChildren, Ee = A.replaceContainerChildren, he = A.cloneHiddenInstance, _e = A.cloneHiddenTextInstance, Pe = A.canHydrateInstance, Nt = A.canHydrateTextInstance, Jt = A.canHydrateSuspenseInstance, vi = A.isSuspenseInstancePending, je = A.isSuspenseInstanceFallback, Ri = A.registerSuspenseInstanceRetry, lA = A.getNextHydratableSibling, jA = A.getFirstHydratableChild, se = A.getFirstHydratableChildWithinContainer, PA = A.getFirstHydratableChildWithinSuspenseInstance, Be = A.hydrateInstance, At = A.hydrateTextInstance, rt = A.hydrateSuspenseInstance, it = A.getNextHydratableInstanceAfterSuspenseInstance, Et = A.commitHydratedContainer, Bt = A.commitHydratedSuspenseInstance, ft = A.clearSuspenseBoundary, tt = A.clearSuspenseBoundaryFromContainer, Ft = A.shouldDeleteUnhydratedTailInstances, ui = A.didNotMatchHydratedContainerTextInstance, Li = A.didNotMatchHydratedTextInstance, $i;
    function hi(Q) {
      if ($i === void 0)
        try {
          throw Error();
        } catch (M) {
          var l = M.stack.trim().match(/\n( *(at )?)/);
          $i = l && l[1] || "";
        }
      return `
` + $i + Q;
    }
    var pt = !1;
    function Gr(Q, l) {
      if (!Q || pt)
        return "";
      pt = !0;
      var M = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (l)
          if (l = function() {
            throw Error();
          }, Object.defineProperty(l.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(l, []);
            } catch (Re) {
              var U = Re;
            }
            Reflect.construct(Q, [], l);
          } else {
            try {
              l.call();
            } catch (Re) {
              U = Re;
            }
            Q.call(l.prototype);
          }
        else {
          try {
            throw Error();
          } catch (Re) {
            U = Re;
          }
          Q();
        }
      } catch (Re) {
        if (Re && U && typeof Re.stack == "string") {
          for (var K = Re.stack.split(`
`), z = U.stack.split(`
`), uA = K.length - 1, HA = z.length - 1; 1 <= uA && 0 <= HA && K[uA] !== z[HA]; )
            HA--;
          for (; 1 <= uA && 0 <= HA; uA--, HA--)
            if (K[uA] !== z[HA]) {
              if (uA !== 1 || HA !== 1)
                do
                  if (uA--, HA--, 0 > HA || K[uA] !== z[HA]) {
                    var ae = `
` + K[uA].replace(" at new ", " at ");
                    return Q.displayName && ae.includes("<anonymous>") && (ae = ae.replace("<anonymous>", Q.displayName)), ae;
                  }
                while (1 <= uA && 0 <= HA);
              break;
            }
        }
      } finally {
        pt = !1, Error.prepareStackTrace = M;
      }
      return (Q = Q ? Q.displayName || Q.name : "") ? hi(Q) : "";
    }
    var Ui = Object.prototype.hasOwnProperty, Rn = [], St = -1;
    function Nn(Q) {
      return { current: Q };
    }
    function Wt(Q) {
      0 > St || (Q.current = Rn[St], Rn[St] = null, St--);
    }
    function ot(Q, l) {
      St++, Rn[St] = Q.current, Q.current = l;
    }
    var pi = {}, zi = Nn(pi), Mt = Nn(!1), sg = pi;
    function nr(Q, l) {
      var M = Q.type.contextTypes;
      if (!M)
        return pi;
      var U = Q.stateNode;
      if (U && U.__reactInternalMemoizedUnmaskedChildContext === l)
        return U.__reactInternalMemoizedMaskedChildContext;
      var K = {}, z;
      for (z in M)
        K[z] = l[z];
      return U && (Q = Q.stateNode, Q.__reactInternalMemoizedUnmaskedChildContext = l, Q.__reactInternalMemoizedMaskedChildContext = K), K;
    }
    function An(Q) {
      return Q = Q.childContextTypes, Q != null;
    }
    function na() {
      Wt(Mt), Wt(zi);
    }
    function ZC(Q, l, M) {
      if (zi.current !== pi)
        throw Error(r(168));
      ot(zi, l), ot(Mt, M);
    }
    function DB(Q, l, M) {
      var U = Q.stateNode;
      if (l = l.childContextTypes, typeof U.getChildContext != "function")
        return M;
      U = U.getChildContext();
      for (var K in U)
        if (!(K in l))
          throw Error(r(108, k(Q) || "Unknown", K));
      return n({}, M, U);
    }
    function xo(Q) {
      return Q = (Q = Q.stateNode) && Q.__reactInternalMemoizedMergedChildContext || pi, sg = zi.current, ot(zi, Q), ot(Mt, Mt.current), !0;
    }
    function tI(Q, l, M) {
      var U = Q.stateNode;
      if (!U)
        throw Error(r(169));
      M ? (Q = DB(Q, l, sg), U.__reactInternalMemoizedMergedChildContext = Q, Wt(Mt), Wt(zi), ot(zi, Q)) : Wt(Mt), ot(Mt, M);
    }
    var fg = Math.clz32 ? Math.clz32 : iI, wB = Math.log, ds = Math.LN2;
    function iI(Q) {
      return Q >>>= 0, Q === 0 ? 32 : 31 - (wB(Q) / ds | 0) | 0;
    }
    var ro = 64, fs = 4194304;
    function oo(Q) {
      switch (Q & -Q) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return Q & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return Q & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return Q;
      }
    }
    function so(Q, l) {
      var M = Q.pendingLanes;
      if (M === 0)
        return 0;
      var U = 0, K = Q.suspendedLanes, z = Q.pingedLanes, uA = M & 268435455;
      if (uA !== 0) {
        var HA = uA & ~K;
        HA !== 0 ? U = oo(HA) : (z &= uA, z !== 0 && (U = oo(z)));
      } else
        uA = M & ~K, uA !== 0 ? U = oo(uA) : z !== 0 && (U = oo(z));
      if (U === 0)
        return 0;
      if (l !== 0 && l !== U && !(l & K) && (K = U & -U, z = l & -l, K >= z || K === 16 && (z & 4194240) !== 0))
        return l;
      if (U & 4 && (U |= M & 16), l = Q.entangledLanes, l !== 0)
        for (Q = Q.entanglements, l &= U; 0 < l; )
          M = 31 - fg(l), K = 1 << M, U |= Q[M], l &= ~K;
      return U;
    }
    function _g(Q, l) {
      switch (Q) {
        case 1:
        case 2:
        case 4:
          return l + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return l + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function ga(Q, l) {
      for (var M = Q.suspendedLanes, U = Q.pingedLanes, K = Q.expirationTimes, z = Q.pendingLanes; 0 < z; ) {
        var uA = 31 - fg(z), HA = 1 << uA, ae = K[uA];
        ae === -1 ? (!(HA & M) || HA & U) && (K[uA] = _g(HA, l)) : ae <= l && (Q.expiredLanes |= HA), z &= ~HA;
      }
    }
    function fn(Q) {
      return Q = Q.pendingLanes & -1073741825, Q !== 0 ? Q : Q & 1073741824 ? 1073741824 : 0;
    }
    function nI(Q) {
      for (var l = [], M = 0; 31 > M; M++)
        l.push(Q);
      return l;
    }
    function vr(Q, l, M) {
      Q.pendingLanes |= l, l !== 536870912 && (Q.suspendedLanes = 0, Q.pingedLanes = 0), Q = Q.eventTimes, l = 31 - fg(l), Q[l] = M;
    }
    function VE(Q, l) {
      var M = Q.pendingLanes & ~l;
      Q.pendingLanes = l, Q.suspendedLanes = 0, Q.pingedLanes = 0, Q.expiredLanes &= l, Q.mutableReadLanes &= l, Q.entangledLanes &= l, l = Q.entanglements;
      var U = Q.eventTimes;
      for (Q = Q.expirationTimes; 0 < M; ) {
        var K = 31 - fg(M), z = 1 << K;
        l[K] = 0, U[K] = -1, Q[K] = -1, M &= ~z;
      }
    }
    function yB(Q, l) {
      var M = Q.entangledLanes |= l;
      for (Q = Q.entanglements; M; ) {
        var U = 31 - fg(M), K = 1 << U;
        K & l | Q[U] & l && (Q[U] |= l), M &= ~K;
      }
    }
    var $t = 0;
    function XC(Q) {
      return Q &= -Q, 1 < Q ? 4 < Q ? Q & 268435455 ? 16 : 536870912 : 4 : 1;
    }
    var ao = i.unstable_scheduleCallback, Ur = i.unstable_cancelCallback, mB = i.unstable_shouldYield, $C = i.unstable_requestPaint, ki = i.unstable_now, ra = i.unstable_ImmediatePriority, jE = i.unstable_UserBlockingPriority, SB = i.unstable_NormalPriority, ZE = i.unstable_IdlePriority, Lo = null, gr = null;
    function XE(Q) {
      if (gr && typeof gr.onCommitFiberRoot == "function")
        try {
          gr.onCommitFiberRoot(Lo, Q, void 0, (Q.current.flags & 128) === 128);
        } catch {
        }
    }
    function $E(Q, l) {
      return Q === l && (Q !== 0 || 1 / Q === 1 / l) || Q !== Q && l !== l;
    }
    var rr = typeof Object.is == "function" ? Object.is : $E, Fn = null, oa = !1, MB = !1;
    function RB(Q) {
      Fn === null ? Fn = [Q] : Fn.push(Q);
    }
    function Al(Q) {
      oa = !0, RB(Q);
    }
    function Gn() {
      if (!MB && Fn !== null) {
        MB = !0;
        var Q = 0, l = $t;
        try {
          var M = Fn;
          for ($t = 1; Q < M.length; Q++) {
            var U = M[Q];
            do
              U = U(!0);
            while (U !== null);
          }
          Fn = null, oa = !1;
        } catch (K) {
          throw Fn !== null && (Fn = Fn.slice(Q + 1)), ao(ra, Gn), K;
        } finally {
          $t = l, MB = !1;
        }
      }
      return null;
    }
    var AQ = s.ReactCurrentBatchConfig;
    function gI(Q, l) {
      if (rr(Q, l))
        return !0;
      if (typeof Q != "object" || Q === null || typeof l != "object" || l === null)
        return !1;
      var M = Object.keys(Q), U = Object.keys(l);
      if (M.length !== U.length)
        return !1;
      for (U = 0; U < M.length; U++) {
        var K = M[U];
        if (!Ui.call(l, K) || !rr(Q[K], l[K]))
          return !1;
      }
      return !0;
    }
    function sa(Q) {
      switch (Q.tag) {
        case 5:
          return hi(Q.type);
        case 16:
          return hi("Lazy");
        case 13:
          return hi("Suspense");
        case 19:
          return hi("SuspenseList");
        case 0:
        case 2:
        case 15:
          return Q = Gr(Q.type, !1), Q;
        case 11:
          return Q = Gr(Q.type.render, !1), Q;
        case 1:
          return Q = Gr(Q.type, !0), Q;
        default:
          return "";
      }
    }
    function Jg(Q, l) {
      if (Q && Q.defaultProps) {
        l = n({}, l), Q = Q.defaultProps;
        for (var M in Q)
          l[M] === void 0 && (l[M] = Q[M]);
        return l;
      }
      return l;
    }
    var aa = Nn(null), Ia = null, kr = null, To = null;
    function NB() {
      To = kr = Ia = null;
    }
    function FB(Q, l, M) {
      kA ? (ot(aa, l._currentValue), l._currentValue = M) : (ot(aa, l._currentValue2), l._currentValue2 = M);
    }
    function rI(Q) {
      var l = aa.current;
      Wt(aa), kA ? Q._currentValue = l : Q._currentValue2 = l;
    }
    function Ba(Q, l, M) {
      for (; Q !== null; ) {
        var U = Q.alternate;
        if ((Q.childLanes & l) !== l ? (Q.childLanes |= l, U !== null && (U.childLanes |= l)) : U !== null && (U.childLanes & l) !== l && (U.childLanes |= l), Q === M)
          break;
        Q = Q.return;
      }
    }
    function qn(Q, l) {
      Ia = Q, To = kr = null, Q = Q.dependencies, Q !== null && Q.firstContext !== null && (Q.lanes & l && (ig = !0), Q.firstContext = null);
    }
    function pg(Q) {
      var l = kA ? Q._currentValue : Q._currentValue2;
      if (To !== Q)
        if (Q = { context: Q, memoizedValue: l, next: null }, kr === null) {
          if (Ia === null)
            throw Error(r(308));
          kr = Q, Ia.dependencies = { lanes: 0, firstContext: Q };
        } else
          kr = kr.next = Q;
      return l;
    }
    var Og = null, or = !1;
    function GB(Q) {
      Q.updateQueue = { baseState: Q.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function Ko(Q, l) {
      Q = Q.updateQueue, l.updateQueue === Q && (l.updateQueue = { baseState: Q.baseState, firstBaseUpdate: Q.firstBaseUpdate, lastBaseUpdate: Q.lastBaseUpdate, shared: Q.shared, effects: Q.effects });
    }
    function xr(Q, l) {
      return { eventTime: Q, lane: l, tag: 0, payload: null, callback: null, next: null };
    }
    function ag(Q, l) {
      var M = Q.updateQueue;
      M !== null && (M = M.shared, pn !== null && Q.mode & 1 && !(Tt & 2) ? (Q = M.interleaved, Q === null ? (l.next = l, Og === null ? Og = [M] : Og.push(M)) : (l.next = Q.next, Q.next = l), M.interleaved = l) : (Q = M.pending, Q === null ? l.next = l : (l.next = Q.next, Q.next = l), M.pending = l));
    }
    function oI(Q, l, M) {
      if (l = l.updateQueue, l !== null && (l = l.shared, (M & 4194240) !== 0)) {
        var U = l.lanes;
        U &= Q.pendingLanes, M |= U, l.lanes = M, yB(Q, M);
      }
    }
    function eQ(Q, l) {
      var M = Q.updateQueue, U = Q.alternate;
      if (U !== null && (U = U.updateQueue, M === U)) {
        var K = null, z = null;
        if (M = M.firstBaseUpdate, M !== null) {
          do {
            var uA = { eventTime: M.eventTime, lane: M.lane, tag: M.tag, payload: M.payload, callback: M.callback, next: null };
            z === null ? K = z = uA : z = z.next = uA, M = M.next;
          } while (M !== null);
          z === null ? K = z = l : z = z.next = l;
        } else
          K = z = l;
        M = { baseState: U.baseState, firstBaseUpdate: K, lastBaseUpdate: z, shared: U.shared, effects: U.effects }, Q.updateQueue = M;
        return;
      }
      Q = M.lastBaseUpdate, Q === null ? M.firstBaseUpdate = l : Q.next = l, M.lastBaseUpdate = l;
    }
    function sI(Q, l, M, U) {
      var K = Q.updateQueue;
      or = !1;
      var z = K.firstBaseUpdate, uA = K.lastBaseUpdate, HA = K.shared.pending;
      if (HA !== null) {
        K.shared.pending = null;
        var ae = HA, Re = ae.next;
        ae.next = null, uA === null ? z = Re : uA.next = Re, uA = ae;
        var Ue = Q.alternate;
        Ue !== null && (Ue = Ue.updateQueue, HA = Ue.lastBaseUpdate, HA !== uA && (HA === null ? Ue.firstBaseUpdate = Re : HA.next = Re, Ue.lastBaseUpdate = ae));
      }
      if (z !== null) {
        var Qt = K.baseState;
        uA = 0, Ue = Re = ae = null, HA = z;
        do {
          var gt = HA.lane, wi = HA.eventTime;
          if ((U & gt) === gt) {
            Ue !== null && (Ue = Ue.next = {
              eventTime: wi,
              lane: 0,
              tag: HA.tag,
              payload: HA.payload,
              callback: HA.callback,
              next: null
            });
            A: {
              var Xe = Q, zn = HA;
              switch (gt = l, wi = M, zn.tag) {
                case 1:
                  if (Xe = zn.payload, typeof Xe == "function") {
                    Qt = Xe.call(wi, Qt, gt);
                    break A;
                  }
                  Qt = Xe;
                  break A;
                case 3:
                  Xe.flags = Xe.flags & -65537 | 128;
                case 0:
                  if (Xe = zn.payload, gt = typeof Xe == "function" ? Xe.call(wi, Qt, gt) : Xe, gt == null)
                    break A;
                  Qt = n({}, Qt, gt);
                  break A;
                case 2:
                  or = !0;
              }
            }
            HA.callback !== null && HA.lane !== 0 && (Q.flags |= 64, gt = K.effects, gt === null ? K.effects = [HA] : gt.push(HA));
          } else
            wi = { eventTime: wi, lane: gt, tag: HA.tag, payload: HA.payload, callback: HA.callback, next: null }, Ue === null ? (Re = Ue = wi, ae = Qt) : Ue = Ue.next = wi, uA |= gt;
          if (HA = HA.next, HA === null) {
            if (HA = K.shared.pending, HA === null)
              break;
            gt = HA, HA = gt.next, gt.next = null, K.lastBaseUpdate = gt, K.shared.pending = null;
          }
        } while (1);
        if (Ue === null && (ae = Qt), K.baseState = ae, K.firstBaseUpdate = Re, K.lastBaseUpdate = Ue, l = K.shared.interleaved, l !== null) {
          K = l;
          do
            uA |= K.lane, K = K.next;
          while (K !== l);
        } else
          z === null && (K.shared.lanes = 0);
        Qo |= uA, Q.lanes = uA, Q.memoizedState = Qt;
      }
    }
    function tQ(Q, l, M) {
      if (Q = l.effects, l.effects = null, Q !== null)
        for (l = 0; l < Q.length; l++) {
          var U = Q[l], K = U.callback;
          if (K !== null) {
            if (U.callback = null, U = M, typeof K != "function")
              throw Error(r(191, K));
            K.call(U);
          }
        }
    }
    var iQ = new t.Component().refs;
    function aI(Q, l, M, U) {
      l = Q.memoizedState, M = M(U, l), M = M == null ? l : n({}, l, M), Q.memoizedState = M, Q.lanes === 0 && (Q.updateQueue.baseState = M);
    }
    var II = { isMounted: function(Q) {
      return (Q = Q._reactInternals) ? v(Q) === Q : !1;
    }, enqueueSetState: function(Q, l, M) {
      Q = Q._reactInternals;
      var U = ng(), K = bs(Q), z = xr(U, K);
      z.payload = l, M != null && (z.callback = M), ag(Q, z), l = Cr(Q, K, U), l !== null && oI(l, Q, K);
    }, enqueueReplaceState: function(Q, l, M) {
      Q = Q._reactInternals;
      var U = ng(), K = bs(Q), z = xr(U, K);
      z.tag = 1, z.payload = l, M != null && (z.callback = M), ag(Q, z), l = Cr(Q, K, U), l !== null && oI(l, Q, K);
    }, enqueueForceUpdate: function(Q, l) {
      Q = Q._reactInternals;
      var M = ng(), U = bs(Q), K = xr(
        M,
        U
      );
      K.tag = 2, l != null && (K.callback = l), ag(Q, K), l = Cr(Q, U, M), l !== null && oI(l, Q, U);
    } };
    function vB(Q, l, M, U, K, z, uA) {
      return Q = Q.stateNode, typeof Q.shouldComponentUpdate == "function" ? Q.shouldComponentUpdate(U, z, uA) : l.prototype && l.prototype.isPureReactComponent ? !gI(M, U) || !gI(K, z) : !0;
    }
    function nQ(Q, l, M) {
      var U = !1, K = pi, z = l.contextType;
      return typeof z == "object" && z !== null ? z = pg(z) : (K = An(l) ? sg : zi.current, U = l.contextTypes, z = (U = U != null) ? nr(Q, K) : pi), l = new l(M, z), Q.memoizedState = l.state !== null && l.state !== void 0 ? l.state : null, l.updater = II, Q.stateNode = l, l._reactInternals = Q, U && (Q = Q.stateNode, Q.__reactInternalMemoizedUnmaskedChildContext = K, Q.__reactInternalMemoizedMaskedChildContext = z), l;
    }
    function gQ(Q, l, M, U) {
      Q = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(M, U), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(M, U), l.state !== Q && II.enqueueReplaceState(l, l.state, null);
    }
    function UB(Q, l, M, U) {
      var K = Q.stateNode;
      K.props = M, K.state = Q.memoizedState, K.refs = iQ, GB(Q);
      var z = l.contextType;
      typeof z == "object" && z !== null ? K.context = pg(z) : (z = An(l) ? sg : zi.current, K.context = nr(Q, z)), K.state = Q.memoizedState, z = l.getDerivedStateFromProps, typeof z == "function" && (aI(Q, l, z, M), K.state = Q.memoizedState), typeof l.getDerivedStateFromProps == "function" || typeof K.getSnapshotBeforeUpdate == "function" || typeof K.UNSAFE_componentWillMount != "function" && typeof K.componentWillMount != "function" || (l = K.state, typeof K.componentWillMount == "function" && K.componentWillMount(), typeof K.UNSAFE_componentWillMount == "function" && K.UNSAFE_componentWillMount(), l !== K.state && II.enqueueReplaceState(K, K.state, null), sI(Q, M, K, U), K.state = Q.memoizedState), typeof K.componentDidMount == "function" && (Q.flags |= 4194308);
    }
    var ps = [], Ds = 0, BI = null, CI = 0, Dg = [], wg = 0, bo = null, Lr = 1, Tr = "";
    function Yo(Q, l) {
      ps[Ds++] = CI, ps[Ds++] = BI, BI = Q, CI = l;
    }
    function QI(Q, l, M) {
      Dg[wg++] = Lr, Dg[wg++] = Tr, Dg[wg++] = bo, bo = Q;
      var U = Lr;
      Q = Tr;
      var K = 32 - fg(U) - 1;
      U &= ~(1 << K), M += 1;
      var z = 32 - fg(l) + K;
      if (30 < z) {
        var uA = K - K % 5;
        z = (U & (1 << uA) - 1).toString(32), U >>= uA, K -= uA, Lr = 1 << 32 - fg(l) + K | M << K | U, Tr = z + Q;
      } else
        Lr = 1 << z | M << K | U, Tr = Q;
    }
    function kB(Q) {
      Q.return !== null && (Yo(Q, 1), QI(Q, 1, 0));
    }
    function Ho(Q) {
      for (; Q === BI; )
        BI = ps[--Ds], ps[Ds] = null, CI = ps[--Ds], ps[Ds] = null;
      for (; Q === bo; )
        bo = Dg[--wg], Dg[wg] = null, Tr = Dg[--wg], Dg[wg] = null, Lr = Dg[--wg], Dg[wg] = null;
    }
    var Ig = null, vn = null, Di = !1, ws = !1, yg = null;
    function xB(Q, l) {
      var M = gg(5, null, null, 0);
      M.elementType = "DELETED", M.stateNode = l, M.return = Q, l = Q.deletions, l === null ? (Q.deletions = [M], Q.flags |= 16) : l.push(M);
    }
    function LB(Q, l) {
      switch (Q.tag) {
        case 5:
          return l = Pe(l, Q.type, Q.pendingProps), l !== null ? (Q.stateNode = l, Ig = Q, vn = jA(l), !0) : !1;
        case 6:
          return l = Nt(l, Q.pendingProps), l !== null ? (Q.stateNode = l, Ig = Q, vn = null, !0) : !1;
        case 13:
          if (l = Jt(l), l !== null) {
            var M = bo !== null ? { id: Lr, overflow: Tr } : null;
            return Q.memoizedState = { dehydrated: l, treeContext: M, retryLane: 1073741824 }, M = gg(18, null, null, 0), M.stateNode = l, M.return = Q, Q.child = M, Ig = Q, vn = null, !0;
          }
          return !1;
        default:
          return !1;
      }
    }
    function EI(Q) {
      return (Q.mode & 1) !== 0 && (Q.flags & 128) === 0;
    }
    function lI(Q) {
      if (Di) {
        var l = vn;
        if (l) {
          var M = l;
          if (!LB(Q, l)) {
            if (EI(Q))
              throw Error(r(418));
            l = lA(M);
            var U = Ig;
            l && LB(Q, l) ? xB(U, M) : (Q.flags = Q.flags & -4097 | 2, Di = !1, Ig = Q);
          }
        } else {
          if (EI(Q))
            throw Error(r(418));
          Q.flags = Q.flags & -4097 | 2, Di = !1, Ig = Q;
        }
      }
    }
    function ys(Q) {
      for (Q = Q.return; Q !== null && Q.tag !== 5 && Q.tag !== 3 && Q.tag !== 13; )
        Q = Q.return;
      Ig = Q;
    }
    function Ca(Q) {
      if (!vA || Q !== Ig)
        return !1;
      if (!Di)
        return ys(Q), Di = !0, !1;
      if (Q.tag !== 3 && (Q.tag !== 5 || Ft(Q.type) && !MA(Q.type, Q.memoizedProps))) {
        var l = vn;
        if (l) {
          if (EI(Q)) {
            for (Q = vn; Q; )
              Q = lA(Q);
            throw Error(r(418));
          }
          for (; l; )
            xB(Q, l), l = lA(l);
        }
      }
      if (ys(Q), Q.tag === 13) {
        if (!vA)
          throw Error(r(316));
        if (Q = Q.memoizedState, Q = Q !== null ? Q.dehydrated : null, !Q)
          throw Error(r(317));
        vn = it(Q);
      } else
        vn = Ig ? lA(Q.stateNode) : null;
      return !0;
    }
    function _o() {
      vA && (vn = Ig = null, ws = Di = !1);
    }
    function ms(Q) {
      yg === null ? yg = [Q] : yg.push(Q);
    }
    function Jo(Q, l, M) {
      if (Q = M.ref, Q !== null && typeof Q != "function" && typeof Q != "object") {
        if (M._owner) {
          if (M = M._owner, M) {
            if (M.tag !== 1)
              throw Error(r(309));
            var U = M.stateNode;
          }
          if (!U)
            throw Error(r(147, Q));
          var K = U, z = "" + Q;
          return l !== null && l.ref !== null && typeof l.ref == "function" && l.ref._stringRef === z ? l.ref : (l = function(uA) {
            var HA = K.refs;
            HA === iQ && (HA = K.refs = {}), uA === null ? delete HA[z] : HA[z] = uA;
          }, l._stringRef = z, l);
        }
        if (typeof Q != "string")
          throw Error(r(284));
        if (!M._owner)
          throw Error(r(290, Q));
      }
      return Q;
    }
    function qg(Q, l) {
      throw Q = Object.prototype.toString.call(l), Error(r(31, Q === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : Q));
    }
    function cI(Q) {
      var l = Q._init;
      return l(Q._payload);
    }
    function Qa(Q) {
      function l($A, qA) {
        if (Q) {
          var re = $A.deletions;
          re === null ? ($A.deletions = [qA], $A.flags |= 16) : re.push(qA);
        }
      }
      function M($A, qA) {
        if (!Q)
          return null;
        for (; qA !== null; )
          l($A, qA), qA = qA.sibling;
        return null;
      }
      function U($A, qA) {
        for ($A = /* @__PURE__ */ new Map(); qA !== null; )
          qA.key !== null ? $A.set(qA.key, qA) : $A.set(qA.index, qA), qA = qA.sibling;
        return $A;
      }
      function K($A, qA) {
        return $A = Gg($A, qA), $A.index = 0, $A.sibling = null, $A;
      }
      function z($A, qA, re) {
        return $A.index = re, Q ? (re = $A.alternate, re !== null ? (re = re.index, re < qA ? ($A.flags |= 2, qA) : re) : ($A.flags |= 2, qA)) : ($A.flags |= 1048576, qA);
      }
      function uA($A) {
        return Q && $A.alternate === null && ($A.flags |= 2), $A;
      }
      function HA($A, qA, re, He) {
        return qA === null || qA.tag !== 6 ? (qA = dQ(re, $A.mode, He), qA.return = $A, qA) : (qA = K(qA, re), qA.return = $A, qA);
      }
      function ae($A, qA, re, He) {
        var Ze = re.type;
        return Ze === E ? Ue($A, qA, re.props.children, He, re.key) : qA !== null && (qA.elementType === Ze || typeof Ze == "object" && Ze !== null && Ze.$$typeof === y && cI(Ze) === qA.type) ? (He = K(qA, re.props), He.ref = Jo($A, qA, re), He.return = $A, He) : (He = Fa(re.type, re.key, re.props, null, $A.mode, He), He.ref = Jo($A, qA, re), He.return = $A, He);
      }
      function Re($A, qA, re, He) {
        return qA === null || qA.tag !== 4 || qA.stateNode.containerInfo !== re.containerInfo || qA.stateNode.implementation !== re.implementation ? (qA = VB(re, $A.mode, He), qA.return = $A, qA) : (qA = K(qA, re.children || []), qA.return = $A, qA);
      }
      function Ue($A, qA, re, He, Ze) {
        return qA === null || qA.tag !== 7 ? (qA = Hs(re, $A.mode, He, Ze), qA.return = $A, qA) : (qA = K(qA, re), qA.return = $A, qA);
      }
      function Qt($A, qA, re) {
        if (typeof qA == "string" && qA !== "" || typeof qA == "number")
          return qA = dQ("" + qA, $A.mode, re), qA.return = $A, qA;
        if (typeof qA == "object" && qA !== null) {
          switch (qA.$$typeof) {
            case B:
              return re = Fa(qA.type, qA.key, qA.props, null, $A.mode, re), re.ref = Jo($A, null, qA), re.return = $A, re;
            case I:
              return qA = VB(qA, $A.mode, re), qA.return = $A, qA;
            case y:
              var He = qA._init;
              return Qt($A, He(qA._payload), re);
          }
          if (iA(qA) || F(qA))
            return qA = Hs(qA, $A.mode, re, null), qA.return = $A, qA;
          qg($A, qA);
        }
        return null;
      }
      function gt($A, qA, re, He) {
        var Ze = qA !== null ? qA.key : null;
        if (typeof re == "string" && re !== "" || typeof re == "number")
          return Ze !== null ? null : HA($A, qA, "" + re, He);
        if (typeof re == "object" && re !== null) {
          switch (re.$$typeof) {
            case B:
              return re.key === Ze ? ae($A, qA, re, He) : null;
            case I:
              return re.key === Ze ? Re($A, qA, re, He) : null;
            case y:
              return Ze = re._init, gt(
                $A,
                qA,
                Ze(re._payload),
                He
              );
          }
          if (iA(re) || F(re))
            return Ze !== null ? null : Ue($A, qA, re, He, null);
          qg($A, re);
        }
        return null;
      }
      function wi($A, qA, re, He, Ze) {
        if (typeof He == "string" && He !== "" || typeof He == "number")
          return $A = $A.get(re) || null, HA(qA, $A, "" + He, Ze);
        if (typeof He == "object" && He !== null) {
          switch (He.$$typeof) {
            case B:
              return $A = $A.get(He.key === null ? re : He.key) || null, ae(qA, $A, He, Ze);
            case I:
              return $A = $A.get(He.key === null ? re : He.key) || null, Re(qA, $A, He, Ze);
            case y:
              var vt = He._init;
              return wi($A, qA, re, vt(He._payload), Ze);
          }
          if (iA(He) || F(He))
            return $A = $A.get(re) || null, Ue(qA, $A, He, Ze, null);
          qg(qA, He);
        }
        return null;
      }
      function Xe($A, qA, re, He) {
        for (var Ze = null, vt = null, at = qA, Kt = qA = 0, an = null; at !== null && Kt < re.length; Kt++) {
          at.index > Kt ? (an = at, at = null) : an = at.sibling;
          var ti = gt($A, at, re[Kt], He);
          if (ti === null) {
            at === null && (at = an);
            break;
          }
          Q && at && ti.alternate === null && l($A, at), qA = z(ti, qA, Kt), vt === null ? Ze = ti : vt.sibling = ti, vt = ti, at = an;
        }
        if (Kt === re.length)
          return M($A, at), Di && Yo($A, Kt), Ze;
        if (at === null) {
          for (; Kt < re.length; Kt++)
            at = Qt($A, re[Kt], He), at !== null && (qA = z(at, qA, Kt), vt === null ? Ze = at : vt.sibling = at, vt = at);
          return Di && Yo($A, Kt), Ze;
        }
        for (at = U($A, at); Kt < re.length; Kt++)
          an = wi(at, $A, Kt, re[Kt], He), an !== null && (Q && an.alternate !== null && at.delete(an.key === null ? Kt : an.key), qA = z(an, qA, Kt), vt === null ? Ze = an : vt.sibling = an, vt = an);
        return Q && at.forEach(function(_s) {
          return l($A, _s);
        }), Di && Yo($A, Kt), Ze;
      }
      function zn($A, qA, re, He) {
        var Ze = F(re);
        if (typeof Ze != "function")
          throw Error(r(150));
        if (re = Ze.call(re), re == null)
          throw Error(r(151));
        for (var vt = Ze = null, at = qA, Kt = qA = 0, an = null, ti = re.next(); at !== null && !ti.done; Kt++, ti = re.next()) {
          at.index > Kt ? (an = at, at = null) : an = at.sibling;
          var _s = gt($A, at, ti.value, He);
          if (_s === null) {
            at === null && (at = an);
            break;
          }
          Q && at && _s.alternate === null && l($A, at), qA = z(_s, qA, Kt), vt === null ? Ze = _s : vt.sibling = _s, vt = _s, at = an;
        }
        if (ti.done)
          return M(
            $A,
            at
          ), Di && Yo($A, Kt), Ze;
        if (at === null) {
          for (; !ti.done; Kt++, ti = re.next())
            ti = Qt($A, ti.value, He), ti !== null && (qA = z(ti, qA, Kt), vt === null ? Ze = ti : vt.sibling = ti, vt = ti);
          return Di && Yo($A, Kt), Ze;
        }
        for (at = U($A, at); !ti.done; Kt++, ti = re.next())
          ti = wi(at, $A, Kt, ti.value, He), ti !== null && (Q && ti.alternate !== null && at.delete(ti.key === null ? Kt : ti.key), qA = z(ti, qA, Kt), vt === null ? Ze = ti : vt.sibling = ti, vt = ti);
        return Q && at.forEach(function(fQ) {
          return l($A, fQ);
        }), Di && Yo($A, Kt), Ze;
      }
      function Bg($A, qA, re, He) {
        if (typeof re == "object" && re !== null && re.type === E && re.key === null && (re = re.props.children), typeof re == "object" && re !== null) {
          switch (re.$$typeof) {
            case B:
              A: {
                for (var Ze = re.key, vt = qA; vt !== null; ) {
                  if (vt.key === Ze) {
                    if (Ze = re.type, Ze === E) {
                      if (vt.tag === 7) {
                        M($A, vt.sibling), qA = K(vt, re.props.children), qA.return = $A, $A = qA;
                        break A;
                      }
                    } else if (vt.elementType === Ze || typeof Ze == "object" && Ze !== null && Ze.$$typeof === y && cI(Ze) === vt.type) {
                      M($A, vt.sibling), qA = K(vt, re.props), qA.ref = Jo($A, vt, re), qA.return = $A, $A = qA;
                      break A;
                    }
                    M($A, vt);
                    break;
                  } else
                    l($A, vt);
                  vt = vt.sibling;
                }
                re.type === E ? (qA = Hs(re.props.children, $A.mode, He, re.key), qA.return = $A, $A = qA) : (He = Fa(re.type, re.key, re.props, null, $A.mode, He), He.ref = Jo($A, qA, re), He.return = $A, $A = He);
              }
              return uA($A);
            case I:
              A: {
                for (vt = re.key; qA !== null; ) {
                  if (qA.key === vt)
                    if (qA.tag === 4 && qA.stateNode.containerInfo === re.containerInfo && qA.stateNode.implementation === re.implementation) {
                      M($A, qA.sibling), qA = K(qA, re.children || []), qA.return = $A, $A = qA;
                      break A;
                    } else {
                      M($A, qA);
                      break;
                    }
                  else
                    l($A, qA);
                  qA = qA.sibling;
                }
                qA = VB(re, $A.mode, He), qA.return = $A, $A = qA;
              }
              return uA($A);
            case y:
              return vt = re._init, Bg($A, qA, vt(re._payload), He);
          }
          if (iA(re))
            return Xe($A, qA, re, He);
          if (F(re))
            return zn($A, qA, re, He);
          qg($A, re);
        }
        return typeof re == "string" && re !== "" || typeof re == "number" ? (re = "" + re, qA !== null && qA.tag === 6 ? (M($A, qA.sibling), qA = K(qA, re), qA.return = $A, $A = qA) : (M($A, qA), qA = dQ(re, $A.mode, He), qA.return = $A, $A = qA), uA($A)) : M($A, qA);
      }
      return Bg;
    }
    var Ss = Qa(!0), uI = Qa(!1), Ea = {}, Ti = Nn(Ea), la = Nn(Ea), Kr = Nn(Ea);
    function en(Q) {
      if (Q === Ea)
        throw Error(r(174));
      return Q;
    }
    function Ms(Q, l) {
      ot(Kr, l), ot(la, Q), ot(Ti, Ea), Q = oA(l), Wt(Ti), ot(Ti, Q);
    }
    function Oo() {
      Wt(Ti), Wt(la), Wt(Kr);
    }
    function Rt(Q) {
      var l = en(Kr.current), M = en(Ti.current);
      l = P(M, Q.type, l), M !== l && (ot(la, Q), ot(Ti, l));
    }
    function Vi(Q) {
      la.current === Q && (Wt(Ti), Wt(la));
    }
    var di = Nn(0);
    function br(Q) {
      for (var l = Q; l !== null; ) {
        if (l.tag === 13) {
          var M = l.memoizedState;
          if (M !== null && (M = M.dehydrated, M === null || vi(M) || je(M)))
            return l;
        } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) {
          if (l.flags & 128)
            return l;
        } else if (l.child !== null) {
          l.child.return = l, l = l.child;
          continue;
        }
        if (l === Q)
          break;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === Q)
            return null;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
      return null;
    }
    var lt = [];
    function ht() {
      for (var Q = 0; Q < lt.length; Q++) {
        var l = lt[Q];
        kA ? l._workInProgressVersionPrimary = null : l._workInProgressVersionSecondary = null;
      }
      lt.length = 0;
    }
    var ji = s.ReactCurrentDispatcher, Ci = s.ReactCurrentBatchConfig, Io = 0, qt = null, mi = null, Ei = null, Rs = !1, sr = !1, Ns = 0, Fs = 0;
    function tn() {
      throw Error(r(321));
    }
    function mg(Q, l) {
      if (l === null)
        return !1;
      for (var M = 0; M < l.length && M < Q.length; M++)
        if (!rr(Q[M], l[M]))
          return !1;
      return !0;
    }
    function Gs(Q, l, M, U, K, z) {
      if (Io = z, qt = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, ji.current = Q === null || Q.memoizedState === null ? KA : WA, Q = M(U, K), sr) {
        z = 0;
        do {
          if (sr = !1, Ns = 0, 25 <= z)
            throw Error(r(301));
          z += 1, Ei = mi = null, l.updateQueue = null, ji.current = OA, Q = M(U, K);
        } while (sr);
      }
      if (ji.current = NA, l = mi !== null && mi.next !== null, Io = 0, Ei = mi = qt = null, Rs = !1, l)
        throw Error(r(300));
      return Q;
    }
    function ca() {
      var Q = Ns !== 0;
      return Ns = 0, Q;
    }
    function ar() {
      var Q = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return Ei === null ? qt.memoizedState = Ei = Q : Ei = Ei.next = Q, Ei;
    }
    function Pg() {
      if (mi === null) {
        var Q = qt.alternate;
        Q = Q !== null ? Q.memoizedState : null;
      } else
        Q = mi.next;
      var l = Ei === null ? qt.memoizedState : Ei.next;
      if (l !== null)
        Ei = l, mi = Q;
      else {
        if (Q === null)
          throw Error(r(310));
        mi = Q, Q = { memoizedState: mi.memoizedState, baseState: mi.baseState, baseQueue: mi.baseQueue, queue: mi.queue, next: null }, Ei === null ? qt.memoizedState = Ei = Q : Ei = Ei.next = Q;
      }
      return Ei;
    }
    function Ir(Q, l) {
      return typeof l == "function" ? l(Q) : l;
    }
    function ua(Q) {
      var l = Pg(), M = l.queue;
      if (M === null)
        throw Error(r(311));
      M.lastRenderedReducer = Q;
      var U = mi, K = U.baseQueue, z = M.pending;
      if (z !== null) {
        if (K !== null) {
          var uA = K.next;
          K.next = z.next, z.next = uA;
        }
        U.baseQueue = K = z, M.pending = null;
      }
      if (K !== null) {
        z = K.next, U = U.baseState;
        var HA = uA = null, ae = null, Re = z;
        do {
          var Ue = Re.lane;
          if ((Io & Ue) === Ue)
            ae !== null && (ae = ae.next = { lane: 0, action: Re.action, hasEagerState: Re.hasEagerState, eagerState: Re.eagerState, next: null }), U = Re.hasEagerState ? Re.eagerState : Q(U, Re.action);
          else {
            var Qt = {
              lane: Ue,
              action: Re.action,
              hasEagerState: Re.hasEagerState,
              eagerState: Re.eagerState,
              next: null
            };
            ae === null ? (HA = ae = Qt, uA = U) : ae = ae.next = Qt, qt.lanes |= Ue, Qo |= Ue;
          }
          Re = Re.next;
        } while (Re !== null && Re !== z);
        ae === null ? uA = U : ae.next = HA, rr(U, l.memoizedState) || (ig = !0), l.memoizedState = U, l.baseState = uA, l.baseQueue = ae, M.lastRenderedState = U;
      }
      if (Q = M.interleaved, Q !== null) {
        K = Q;
        do
          z = K.lane, qt.lanes |= z, Qo |= z, K = K.next;
        while (K !== Q);
      } else
        K === null && (M.lanes = 0);
      return [l.memoizedState, M.dispatch];
    }
    function hI(Q) {
      var l = Pg(), M = l.queue;
      if (M === null)
        throw Error(r(311));
      M.lastRenderedReducer = Q;
      var U = M.dispatch, K = M.pending, z = l.memoizedState;
      if (K !== null) {
        M.pending = null;
        var uA = K = K.next;
        do
          z = Q(z, uA.action), uA = uA.next;
        while (uA !== K);
        rr(z, l.memoizedState) || (ig = !0), l.memoizedState = z, l.baseQueue === null && (l.baseState = z), M.lastRenderedState = z;
      }
      return [z, U];
    }
    function qo() {
    }
    function TB(Q, l) {
      var M = qt, U = Pg(), K = l(), z = !rr(U.memoizedState, K);
      if (z && (U.memoizedState = K, ig = !0), U = U.queue, De(zt.bind(null, M, U, Q), [Q]), U.getSnapshot !== l || z || Ei !== null && Ei.memoizedState.tag & 1) {
        if (M.flags |= 2048, vs(9, si.bind(null, M, U, K, l), void 0, null), pn === null)
          throw Error(r(349));
        Io & 30 || Ct(M, l, K);
      }
      return K;
    }
    function Ct(Q, l, M) {
      Q.flags |= 16384, Q = { getSnapshot: l, value: M }, l = qt.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, qt.updateQueue = l, l.stores = [Q]) : (M = l.stores, M === null ? l.stores = [Q] : M.push(Q));
    }
    function si(Q, l, M, U) {
      l.value = M, l.getSnapshot = U, Ki(l) && Cr(Q, 1, -1);
    }
    function zt(Q, l, M) {
      return M(function() {
        Ki(l) && Cr(Q, 1, -1);
      });
    }
    function Ki(Q) {
      var l = Q.getSnapshot;
      Q = Q.value;
      try {
        var M = l();
        return !rr(Q, M);
      } catch {
        return !0;
      }
    }
    function Sg(Q) {
      var l = ar();
      return typeof Q == "function" && (Q = Q()), l.memoizedState = l.baseState = Q, Q = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ir, lastRenderedState: Q }, l.queue = Q, Q = Q.dispatch = pI.bind(null, qt, Q), [l.memoizedState, Q];
    }
    function vs(Q, l, M, U) {
      return Q = { tag: Q, create: l, destroy: M, deps: U, next: null }, l = qt.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, qt.updateQueue = l, l.lastEffect = Q.next = Q) : (M = l.lastEffect, M === null ? l.lastEffect = Q.next = Q : (U = M.next, M.next = Q, Q.next = U, l.lastEffect = Q)), Q;
    }
    function rQ() {
      return Pg().memoizedState;
    }
    function dI(Q, l, M, U) {
      var K = ar();
      qt.flags |= Q, K.memoizedState = vs(1 | l, M, void 0, U === void 0 ? null : U);
    }
    function fI(Q, l, M, U) {
      var K = Pg();
      U = U === void 0 ? null : U;
      var z = void 0;
      if (mi !== null) {
        var uA = mi.memoizedState;
        if (z = uA.destroy, U !== null && mg(U, uA.deps)) {
          K.memoizedState = vs(l, M, z, U);
          return;
        }
      }
      qt.flags |= Q, K.memoizedState = vs(1 | l, M, z, U);
    }
    function ha(Q, l) {
      return dI(8390656, 8, Q, l);
    }
    function De(Q, l) {
      return fI(2048, 8, Q, l);
    }
    function nn(Q, l) {
      return fI(4, 2, Q, l);
    }
    function Lt(Q, l) {
      return fI(4, 4, Q, l);
    }
    function Po(Q, l) {
      if (typeof l == "function")
        return Q = Q(), l(Q), function() {
          l(null);
        };
      if (l != null)
        return Q = Q(), l.current = Q, function() {
          l.current = null;
        };
    }
    function Yr(Q, l, M) {
      return M = M != null ? M.concat([Q]) : null, fI(4, 4, Po.bind(null, l, Q), M);
    }
    function Hr() {
    }
    function Br(Q, l) {
      var M = Pg();
      l = l === void 0 ? null : l;
      var U = M.memoizedState;
      return U !== null && l !== null && mg(l, U[1]) ? U[0] : (M.memoizedState = [Q, l], Q);
    }
    function Us(Q, l) {
      var M = Pg();
      l = l === void 0 ? null : l;
      var U = M.memoizedState;
      return U !== null && l !== null && mg(l, U[1]) ? U[0] : (Q = Q(), M.memoizedState = [Q, l], Q);
    }
    function ks(Q, l) {
      var M = $t;
      $t = M !== 0 && 4 > M ? M : 4, Q(!0);
      var U = Ci.transition;
      Ci.transition = {};
      try {
        Q(!1), l();
      } finally {
        $t = M, Ci.transition = U;
      }
    }
    function _r() {
      return Pg().memoizedState;
    }
    function KB(Q, l, M) {
      var U = bs(Q);
      M = { lane: U, action: M, hasEagerState: !1, eagerState: null, next: null }, T(Q) ? b(l, M) : (X(Q, l, M), M = ng(), Q = Cr(Q, U, M), Q !== null && CA(Q, l, U));
    }
    function pI(Q, l, M) {
      var U = bs(Q), K = { lane: U, action: M, hasEagerState: !1, eagerState: null, next: null };
      if (T(Q))
        b(l, K);
      else {
        X(Q, l, K);
        var z = Q.alternate;
        if (Q.lanes === 0 && (z === null || z.lanes === 0) && (z = l.lastRenderedReducer, z !== null))
          try {
            var uA = l.lastRenderedState, HA = z(uA, M);
            if (K.hasEagerState = !0, K.eagerState = HA, rr(HA, uA))
              return;
          } catch {
          } finally {
          }
        M = ng(), Q = Cr(Q, U, M), Q !== null && CA(Q, l, U);
      }
    }
    function T(Q) {
      var l = Q.alternate;
      return Q === qt || l !== null && l === qt;
    }
    function b(Q, l) {
      sr = Rs = !0;
      var M = Q.pending;
      M === null ? l.next = l : (l.next = M.next, M.next = l), Q.pending = l;
    }
    function X(Q, l, M) {
      pn !== null && Q.mode & 1 && !(Tt & 2) ? (Q = l.interleaved, Q === null ? (M.next = M, Og === null ? Og = [l] : Og.push(l)) : (M.next = Q.next, Q.next = M), l.interleaved = M) : (Q = l.pending, Q === null ? M.next = M : (M.next = Q.next, Q.next = M), l.pending = M);
    }
    function CA(Q, l, M) {
      if (M & 4194240) {
        var U = l.lanes;
        U &= Q.pendingLanes, M |= U, l.lanes = M, yB(Q, M);
      }
    }
    var NA = { readContext: pg, useCallback: tn, useContext: tn, useEffect: tn, useImperativeHandle: tn, useInsertionEffect: tn, useLayoutEffect: tn, useMemo: tn, useReducer: tn, useRef: tn, useState: tn, useDebugValue: tn, useDeferredValue: tn, useTransition: tn, useMutableSource: tn, useSyncExternalStore: tn, useId: tn, unstable_isNewReconciler: !1 }, KA = { readContext: pg, useCallback: function(Q, l) {
      return ar().memoizedState = [Q, l === void 0 ? null : l], Q;
    }, useContext: pg, useEffect: ha, useImperativeHandle: function(Q, l, M) {
      return M = M != null ? M.concat([Q]) : null, dI(
        4194308,
        4,
        Po.bind(null, l, Q),
        M
      );
    }, useLayoutEffect: function(Q, l) {
      return dI(4194308, 4, Q, l);
    }, useInsertionEffect: function(Q, l) {
      return dI(4, 2, Q, l);
    }, useMemo: function(Q, l) {
      var M = ar();
      return l = l === void 0 ? null : l, Q = Q(), M.memoizedState = [Q, l], Q;
    }, useReducer: function(Q, l, M) {
      var U = ar();
      return l = M !== void 0 ? M(l) : l, U.memoizedState = U.baseState = l, Q = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Q, lastRenderedState: l }, U.queue = Q, Q = Q.dispatch = KB.bind(null, qt, Q), [U.memoizedState, Q];
    }, useRef: function(Q) {
      var l = ar();
      return Q = { current: Q }, l.memoizedState = Q;
    }, useState: Sg, useDebugValue: Hr, useDeferredValue: function(Q) {
      var l = Sg(Q), M = l[0], U = l[1];
      return ha(function() {
        var K = Ci.transition;
        Ci.transition = {};
        try {
          U(Q);
        } finally {
          Ci.transition = K;
        }
      }, [Q]), M;
    }, useTransition: function() {
      var Q = Sg(!1), l = Q[0];
      return Q = ks.bind(null, Q[1]), ar().memoizedState = Q, [l, Q];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(Q, l, M) {
      var U = qt, K = ar();
      if (Di) {
        if (M === void 0)
          throw Error(r(407));
        M = M();
      } else {
        if (M = l(), pn === null)
          throw Error(r(349));
        Io & 30 || Ct(U, l, M);
      }
      K.memoizedState = M;
      var z = { value: M, getSnapshot: l };
      return K.queue = z, ha(zt.bind(null, U, z, Q), [Q]), U.flags |= 2048, vs(9, si.bind(null, U, z, M, l), void 0, null), M;
    }, useId: function() {
      var Q = ar(), l = pn.identifierPrefix;
      if (Di) {
        var M = Tr, U = Lr;
        M = (U & ~(1 << 32 - fg(U) - 1)).toString(32) + M, l = ":" + l + "R" + M, M = Ns++, 0 < M && (l += "H" + M.toString(32)), l += ":";
      } else
        M = Fs++, l = ":" + l + "r" + M.toString(32) + ":";
      return Q.memoizedState = l;
    }, unstable_isNewReconciler: !1 }, WA = {
      readContext: pg,
      useCallback: Br,
      useContext: pg,
      useEffect: De,
      useImperativeHandle: Yr,
      useInsertionEffect: nn,
      useLayoutEffect: Lt,
      useMemo: Us,
      useReducer: ua,
      useRef: rQ,
      useState: function() {
        return ua(Ir);
      },
      useDebugValue: Hr,
      useDeferredValue: function(Q) {
        var l = ua(Ir), M = l[0], U = l[1];
        return De(function() {
          var K = Ci.transition;
          Ci.transition = {};
          try {
            U(Q);
          } finally {
            Ci.transition = K;
          }
        }, [Q]), M;
      },
      useTransition: function() {
        var Q = ua(Ir)[0], l = Pg().memoizedState;
        return [Q, l];
      },
      useMutableSource: qo,
      useSyncExternalStore: TB,
      useId: _r,
      unstable_isNewReconciler: !1
    }, OA = {
      readContext: pg,
      useCallback: Br,
      useContext: pg,
      useEffect: De,
      useImperativeHandle: Yr,
      useInsertionEffect: nn,
      useLayoutEffect: Lt,
      useMemo: Us,
      useReducer: hI,
      useRef: rQ,
      useState: function() {
        return hI(Ir);
      },
      useDebugValue: Hr,
      useDeferredValue: function(Q) {
        var l = hI(Ir), M = l[0], U = l[1];
        return De(function() {
          var K = Ci.transition;
          Ci.transition = {};
          try {
            U(Q);
          } finally {
            Ci.transition = K;
          }
        }, [Q]), M;
      },
      useTransition: function() {
        var Q = hI(Ir)[0], l = Pg().memoizedState;
        return [Q, l];
      },
      useMutableSource: qo,
      useSyncExternalStore: TB,
      useId: _r,
      unstable_isNewReconciler: !1
    };
    function zA(Q, l) {
      try {
        var M = "", U = l;
        do
          M += sa(U), U = U.return;
        while (U);
        var K = M;
      } catch (z) {
        K = `
Error generating stack: ` + z.message + `
` + z.stack;
      }
      return { value: Q, source: l, stack: K };
    }
    function Ce(Q, l) {
      try {
        console.error(l.value);
      } catch (M) {
        setTimeout(function() {
          throw M;
        });
      }
    }
    var Ge = typeof WeakMap == "function" ? WeakMap : Map;
    function ve(Q, l, M) {
      M = xr(-1, M), M.tag = 3, M.payload = { element: null };
      var U = l.value;
      return M.callback = function() {
        _B || (_B = !0, lQ = U), Ce(Q, l);
      }, M;
    }
    function Le(Q, l, M) {
      M = xr(-1, M), M.tag = 3;
      var U = Q.type.getDerivedStateFromError;
      if (typeof U == "function") {
        var K = l.value;
        M.payload = function() {
          return U(K);
        }, M.callback = function() {
          Ce(Q, l);
        };
      }
      var z = Q.stateNode;
      return z !== null && typeof z.componentDidCatch == "function" && (M.callback = function() {
        Ce(Q, l), typeof U != "function" && (Ts === null ? Ts = /* @__PURE__ */ new Set([this]) : Ts.add(this));
        var uA = l.stack;
        this.componentDidCatch(l.value, { componentStack: uA !== null ? uA : "" });
      }), M;
    }
    function ct(Q, l, M) {
      var U = Q.pingCache;
      if (U === null) {
        U = Q.pingCache = new Ge();
        var K = /* @__PURE__ */ new Set();
        U.set(l, K);
      } else
        K = U.get(l), K === void 0 && (K = /* @__PURE__ */ new Set(), U.set(l, K));
      K.has(M) || (K.add(M), Q = Eo.bind(null, Q, l, M), l.then(Q, Q));
    }
    function st(Q) {
      do {
        var l;
        if ((l = Q.tag === 13) && (l = Q.memoizedState, l = l !== null ? l.dehydrated !== null : !0), l)
          return Q;
        Q = Q.return;
      } while (Q !== null);
      return null;
    }
    function Vt(Q, l, M, U, K) {
      return Q.mode & 1 ? (Q.flags |= 65536, Q.lanes = K, Q) : (Q === l ? Q.flags |= 65536 : (Q.flags |= 128, M.flags |= 131072, M.flags &= -52805, M.tag === 1 && (M.alternate === null ? M.tag = 17 : (l = xr(-1, 1), l.tag = 2, ag(M, l))), M.lanes |= 1), Q);
    }
    function Ai(Q) {
      Q.flags |= 4;
    }
    function gn(Q, l) {
      if (Q !== null && Q.child === l.child)
        return !0;
      if (l.flags & 16)
        return !1;
      for (Q = l.child; Q !== null; ) {
        if (Q.flags & 12854 || Q.subtreeFlags & 12854)
          return !1;
        Q = Q.sibling;
      }
      return !0;
    }
    var ye, et, bi, Yi;
    if (FA)
      ye = function(Q, l) {
        for (var M = l.child; M !== null; ) {
          if (M.tag === 5 || M.tag === 6)
            rA(Q, M.stateNode);
          else if (M.tag !== 4 && M.child !== null) {
            M.child.return = M, M = M.child;
            continue;
          }
          if (M === l)
            break;
          for (; M.sibling === null; ) {
            if (M.return === null || M.return === l)
              return;
            M = M.return;
          }
          M.sibling.return = M.return, M = M.sibling;
        }
      }, et = function() {
      }, bi = function(Q, l, M, U, K) {
        if (Q = Q.memoizedProps, Q !== U) {
          var z = l.stateNode, uA = en(Ti.current);
          M = aA(z, M, Q, U, K, uA), (l.updateQueue = M) && Ai(l);
        }
      }, Yi = function(Q, l, M, U) {
        M !== U && Ai(l);
      };
    else if (dA) {
      ye = function(Q, l, M, U) {
        for (var K = l.child; K !== null; ) {
          if (K.tag === 5) {
            var z = K.stateNode;
            M && U && (z = he(z, K.type, K.memoizedProps, K)), rA(Q, z);
          } else if (K.tag === 6)
            z = K.stateNode, M && U && (z = _e(z, K.memoizedProps, K)), rA(Q, z);
          else if (K.tag !== 4) {
            if (K.tag === 22 && K.memoizedState !== null)
              z = K.child, z !== null && (z.return = K), ye(Q, K, !0, !0);
            else if (K.child !== null) {
              K.child.return = K, K = K.child;
              continue;
            }
          }
          if (K === l)
            break;
          for (; K.sibling === null; ) {
            if (K.return === null || K.return === l)
              return;
            K = K.return;
          }
          K.sibling.return = K.return, K = K.sibling;
        }
      };
      var Mg = function(Q, l, M, U) {
        for (var K = l.child; K !== null; ) {
          if (K.tag === 5) {
            var z = K.stateNode;
            M && U && (z = he(z, K.type, K.memoizedProps, K)), xe(Q, z);
          } else if (K.tag === 6)
            z = K.stateNode, M && U && (z = _e(z, K.memoizedProps, K)), xe(Q, z);
          else if (K.tag !== 4) {
            if (K.tag === 22 && K.memoizedState !== null)
              z = K.child, z !== null && (z.return = K), Mg(Q, K, !0, !0);
            else if (K.child !== null) {
              K.child.return = K, K = K.child;
              continue;
            }
          }
          if (K === l)
            break;
          for (; K.sibling === null; ) {
            if (K.return === null || K.return === l)
              return;
            K = K.return;
          }
          K.sibling.return = K.return, K = K.sibling;
        }
      };
      et = function(Q, l) {
        var M = l.stateNode;
        if (!gn(Q, l)) {
          Q = M.containerInfo;
          var U = Me(Q);
          Mg(U, l, !1, !1), M.pendingChildren = U, Ai(l), we(Q, U);
        }
      }, bi = function(Q, l, M, U, K) {
        var z = Q.stateNode, uA = Q.memoizedProps;
        if ((Q = gn(Q, l)) && uA === U)
          l.stateNode = z;
        else {
          var HA = l.stateNode, ae = en(Ti.current), Re = null;
          uA !== U && (Re = aA(HA, M, uA, U, K, ae)), Q && Re === null ? l.stateNode = z : (z = ge(z, Re, M, uA, U, l, Q, HA), QA(z, M, U, K, ae) && Ai(l), l.stateNode = z, Q ? Ai(l) : ye(z, l, !1, !1));
        }
      }, Yi = function(Q, l, M, U) {
        M !== U ? (Q = en(Kr.current), M = en(Ti.current), l.stateNode = hA(U, Q, M, l), Ai(l)) : l.stateNode = Q.stateNode;
      };
    } else
      et = function() {
      }, bi = function() {
      }, Yi = function() {
      };
    function tg(Q, l) {
      if (!Di)
        switch (Q.tailMode) {
          case "hidden":
            l = Q.tail;
            for (var M = null; l !== null; )
              l.alternate !== null && (M = l), l = l.sibling;
            M === null ? Q.tail = null : M.sibling = null;
            break;
          case "collapsed":
            M = Q.tail;
            for (var U = null; M !== null; )
              M.alternate !== null && (U = M), M = M.sibling;
            U === null ? l || Q.tail === null ? Q.tail = null : Q.tail.sibling = null : U.sibling = null;
        }
    }
    function fi(Q) {
      var l = Q.alternate !== null && Q.alternate.child === Q.child, M = 0, U = 0;
      if (l)
        for (var K = Q.child; K !== null; )
          M |= K.lanes | K.childLanes, U |= K.subtreeFlags & 14680064, U |= K.flags & 14680064, K.return = Q, K = K.sibling;
      else
        for (K = Q.child; K !== null; )
          M |= K.lanes | K.childLanes, U |= K.subtreeFlags, U |= K.flags, K.return = Q, K = K.sibling;
      return Q.subtreeFlags |= U, Q.childLanes = M, l;
    }
    function Wf(Q, l, M) {
      var U = l.pendingProps;
      switch (Ho(l), l.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return fi(l), null;
        case 1:
          return An(l.type) && na(), fi(l), null;
        case 3:
          return U = l.stateNode, Oo(), Wt(Mt), Wt(zi), ht(), U.pendingContext && (U.context = U.pendingContext, U.pendingContext = null), (Q === null || Q.child === null) && (Ca(l) ? Ai(l) : Q === null || Q.memoizedState.isDehydrated && !(l.flags & 256) || (l.flags |= 1024, yg !== null && (qB(yg), yg = null))), et(Q, l), fi(l), null;
        case 5:
          Vi(l), M = en(Kr.current);
          var K = l.type;
          if (Q !== null && l.stateNode != null)
            bi(Q, l, K, U, M), Q.ref !== l.ref && (l.flags |= 512, l.flags |= 2097152);
          else {
            if (!U) {
              if (l.stateNode === null)
                throw Error(r(166));
              return fi(l), null;
            }
            if (Q = en(Ti.current), Ca(l)) {
              if (!vA)
                throw Error(r(175));
              Q = Be(l.stateNode, l.type, l.memoizedProps, M, Q, l, !ws), l.updateQueue = Q, Q !== null && Ai(l);
            } else {
              var z = Y(K, U, M, Q, l);
              ye(z, l, !1, !1), l.stateNode = z, QA(z, K, U, M, Q) && Ai(l);
            }
            l.ref !== null && (l.flags |= 512, l.flags |= 2097152);
          }
          return fi(l), null;
        case 6:
          if (Q && l.stateNode != null)
            Yi(Q, l, Q.memoizedProps, U);
          else {
            if (typeof U != "string" && l.stateNode === null)
              throw Error(r(166));
            if (Q = en(Kr.current), M = en(Ti.current), Ca(l)) {
              if (!vA)
                throw Error(r(176));
              if (Q = l.stateNode, U = l.memoizedProps, (M = At(Q, U, l, !ws)) && (K = Ig, K !== null))
                switch (z = (K.mode & 1) !== 0, K.tag) {
                  case 3:
                    ui(K.stateNode.containerInfo, Q, U, z);
                    break;
                  case 5:
                    Li(K.type, K.memoizedProps, K.stateNode, Q, U, z);
                }
              M && Ai(l);
            } else
              l.stateNode = hA(U, Q, M, l);
          }
          return fi(l), null;
        case 13:
          if (Wt(di), U = l.memoizedState, Di && vn !== null && l.mode & 1 && !(l.flags & 128)) {
            for (Q = vn; Q; )
              Q = lA(Q);
            return _o(), l.flags |= 98560, l;
          }
          if (U !== null && U.dehydrated !== null) {
            if (U = Ca(l), Q === null) {
              if (!U)
                throw Error(r(318));
              if (!vA)
                throw Error(r(344));
              if (Q = l.memoizedState, Q = Q !== null ? Q.dehydrated : null, !Q)
                throw Error(r(317));
              rt(Q, l);
            } else
              _o(), !(l.flags & 128) && (l.memoizedState = null), l.flags |= 4;
            return fi(l), null;
          }
          return yg !== null && (qB(yg), yg = null), l.flags & 128 ? (l.lanes = M, l) : (U = U !== null, M = !1, Q === null ? Ca(l) : M = Q.memoizedState !== null, U && !M && (l.child.flags |= 8192, l.mode & 1 && (Q === null || di.current & 1 ? kn === 0 && (kn = 3) : dl())), l.updateQueue !== null && (l.flags |= 4), fi(l), null);
        case 4:
          return Oo(), et(Q, l), Q === null && ne(l.stateNode.containerInfo), fi(l), null;
        case 10:
          return rI(l.type._context), fi(l), null;
        case 17:
          return An(l.type) && na(), fi(l), null;
        case 19:
          if (Wt(di), K = l.memoizedState, K === null)
            return fi(l), null;
          if (U = (l.flags & 128) !== 0, z = K.rendering, z === null)
            if (U)
              tg(K, !1);
            else {
              if (kn !== 0 || Q !== null && Q.flags & 128)
                for (Q = l.child; Q !== null; ) {
                  if (z = br(Q), z !== null) {
                    for (l.flags |= 128, tg(K, !1), Q = z.updateQueue, Q !== null && (l.updateQueue = Q, l.flags |= 4), l.subtreeFlags = 0, Q = M, U = l.child; U !== null; )
                      M = U, K = Q, M.flags &= 14680066, z = M.alternate, z === null ? (M.childLanes = 0, M.lanes = K, M.child = null, M.subtreeFlags = 0, M.memoizedProps = null, M.memoizedState = null, M.updateQueue = null, M.dependencies = null, M.stateNode = null) : (M.childLanes = z.childLanes, M.lanes = z.lanes, M.child = z.child, M.subtreeFlags = 0, M.deletions = null, M.memoizedProps = z.memoizedProps, M.memoizedState = z.memoizedState, M.updateQueue = z.updateQueue, M.type = z.type, K = z.dependencies, M.dependencies = K === null ? null : { lanes: K.lanes, firstContext: K.firstContext }), U = U.sibling;
                    return ot(di, di.current & 1 | 2), l.child;
                  }
                  Q = Q.sibling;
                }
              K.tail !== null && ki() > ll && (l.flags |= 128, U = !0, tg(K, !1), l.lanes = 4194304);
            }
          else {
            if (!U)
              if (Q = br(z), Q !== null) {
                if (l.flags |= 128, U = !0, Q = Q.updateQueue, Q !== null && (l.updateQueue = Q, l.flags |= 4), tg(K, !0), K.tail === null && K.tailMode === "hidden" && !z.alternate && !Di)
                  return fi(l), null;
              } else
                2 * ki() - K.renderingStartTime > ll && M !== 1073741824 && (l.flags |= 128, U = !0, tg(K, !1), l.lanes = 4194304);
            K.isBackwards ? (z.sibling = l.child, l.child = z) : (Q = K.last, Q !== null ? Q.sibling = z : l.child = z, K.last = z);
          }
          return K.tail !== null ? (l = K.tail, K.rendering = l, K.tail = l.sibling, K.renderingStartTime = ki(), l.sibling = null, Q = di.current, ot(di, U ? Q & 1 | 2 : Q & 1), l) : (fi(l), null);
        case 22:
        case 23:
          return Qr(), U = l.memoizedState !== null, Q !== null && Q.memoizedState !== null !== U && (l.flags |= 8192), U && l.mode & 1 ? zg & 1073741824 && (fi(l), FA && l.subtreeFlags & 6 && (l.flags |= 8192)) : fi(l), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(r(156, l.tag));
    }
    var Si = s.ReactCurrentOwner, ig = !1;
    function Yn(Q, l, M, U) {
      l.child = Q === null ? uI(l, null, M, U) : Ss(l, Q.child, M, U);
    }
    function DI(Q, l, M, U, K) {
      M = M.render;
      var z = l.ref;
      return qn(l, K), U = Gs(Q, l, M, U, z, K), M = ca(), Q !== null && !ig ? (l.updateQueue = Q.updateQueue, l.flags &= -2053, Q.lanes &= ~K, rn(Q, l, K)) : (Di && M && kB(l), l.flags |= 1, Yn(Q, l, U, K), l.child);
    }
    function bB(Q, l, M, U, K) {
      if (Q === null) {
        var z = M.type;
        return typeof z == "function" && !Na(z) && z.defaultProps === void 0 && M.compare === null && M.defaultProps === void 0 ? (l.tag = 15, l.type = z, yu(Q, l, z, U, K)) : (Q = Fa(M.type, null, U, l, l.mode, K), Q.ref = l.ref, Q.return = l, l.child = Q);
      }
      if (z = Q.child, !(Q.lanes & K)) {
        var uA = z.memoizedProps;
        if (M = M.compare, M = M !== null ? M : gI, M(uA, U) && Q.ref === l.ref)
          return rn(Q, l, K);
      }
      return l.flags |= 1, Q = Gg(z, U), Q.ref = l.ref, Q.return = l, l.child = Q;
    }
    function yu(Q, l, M, U, K) {
      if (Q !== null && gI(Q.memoizedProps, U) && Q.ref === l.ref)
        if (ig = !1, (Q.lanes & K) !== 0)
          Q.flags & 131072 && (ig = !0);
        else
          return l.lanes = Q.lanes, rn(Q, l, K);
      return el(Q, l, M, U, K);
    }
    function mu(Q, l, M) {
      var U = l.pendingProps, K = U.children, z = Q !== null ? Q.memoizedState : null;
      if (U.mode === "hidden")
        if (!(l.mode & 1))
          l.memoizedState = { baseLanes: 0, cachePool: null }, ot(NI, zg), zg |= M;
        else if (M & 1073741824)
          l.memoizedState = { baseLanes: 0, cachePool: null }, U = z !== null ? z.baseLanes : M, ot(NI, zg), zg |= U;
        else
          return Q = z !== null ? z.baseLanes | M : M, l.lanes = l.childLanes = 1073741824, l.memoizedState = { baseLanes: Q, cachePool: null }, l.updateQueue = null, ot(NI, zg), zg |= Q, null;
      else
        z !== null ? (U = z.baseLanes | M, l.memoizedState = null) : U = M, ot(NI, zg), zg |= U;
      return Yn(Q, l, K, M), l.child;
    }
    function Su(Q, l) {
      var M = l.ref;
      (Q === null && M !== null || Q !== null && Q.ref !== M) && (l.flags |= 512, l.flags |= 2097152);
    }
    function el(Q, l, M, U, K) {
      var z = An(M) ? sg : zi.current;
      return z = nr(l, z), qn(l, K), M = Gs(Q, l, M, U, z, K), U = ca(), Q !== null && !ig ? (l.updateQueue = Q.updateQueue, l.flags &= -2053, Q.lanes &= ~K, rn(Q, l, K)) : (Di && U && kB(l), l.flags |= 1, Yn(Q, l, M, K), l.child);
    }
    function oQ(Q, l, M, U, K) {
      if (An(M)) {
        var z = !0;
        xo(l);
      } else
        z = !1;
      if (qn(l, K), l.stateNode === null)
        Q !== null && (Q.alternate = null, l.alternate = null, l.flags |= 2), nQ(l, M, U), UB(l, M, U, K), U = !0;
      else if (Q === null) {
        var uA = l.stateNode, HA = l.memoizedProps;
        uA.props = HA;
        var ae = uA.context, Re = M.contextType;
        typeof Re == "object" && Re !== null ? Re = pg(Re) : (Re = An(M) ? sg : zi.current, Re = nr(l, Re));
        var Ue = M.getDerivedStateFromProps, Qt = typeof Ue == "function" || typeof uA.getSnapshotBeforeUpdate == "function";
        Qt || typeof uA.UNSAFE_componentWillReceiveProps != "function" && typeof uA.componentWillReceiveProps != "function" || (HA !== U || ae !== Re) && gQ(l, uA, U, Re), or = !1;
        var gt = l.memoizedState;
        uA.state = gt, sI(l, U, uA, K), ae = l.memoizedState, HA !== U || gt !== ae || Mt.current || or ? (typeof Ue == "function" && (aI(l, M, Ue, U), ae = l.memoizedState), (HA = or || vB(l, M, HA, U, gt, ae, Re)) ? (Qt || typeof uA.UNSAFE_componentWillMount != "function" && typeof uA.componentWillMount != "function" || (typeof uA.componentWillMount == "function" && uA.componentWillMount(), typeof uA.UNSAFE_componentWillMount == "function" && uA.UNSAFE_componentWillMount()), typeof uA.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof uA.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = U, l.memoizedState = ae), uA.props = U, uA.state = ae, uA.context = Re, U = HA) : (typeof uA.componentDidMount == "function" && (l.flags |= 4194308), U = !1);
      } else {
        uA = l.stateNode, Ko(Q, l), HA = l.memoizedProps, Re = l.type === l.elementType ? HA : Jg(l.type, HA), uA.props = Re, Qt = l.pendingProps, gt = uA.context, ae = M.contextType, typeof ae == "object" && ae !== null ? ae = pg(ae) : (ae = An(M) ? sg : zi.current, ae = nr(l, ae));
        var wi = M.getDerivedStateFromProps;
        (Ue = typeof wi == "function" || typeof uA.getSnapshotBeforeUpdate == "function") || typeof uA.UNSAFE_componentWillReceiveProps != "function" && typeof uA.componentWillReceiveProps != "function" || (HA !== Qt || gt !== ae) && gQ(l, uA, U, ae), or = !1, gt = l.memoizedState, uA.state = gt, sI(l, U, uA, K);
        var Xe = l.memoizedState;
        HA !== Qt || gt !== Xe || Mt.current || or ? (typeof wi == "function" && (aI(l, M, wi, U), Xe = l.memoizedState), (Re = or || vB(l, M, Re, U, gt, Xe, ae) || !1) ? (Ue || typeof uA.UNSAFE_componentWillUpdate != "function" && typeof uA.componentWillUpdate != "function" || (typeof uA.componentWillUpdate == "function" && uA.componentWillUpdate(
          U,
          Xe,
          ae
        ), typeof uA.UNSAFE_componentWillUpdate == "function" && uA.UNSAFE_componentWillUpdate(U, Xe, ae)), typeof uA.componentDidUpdate == "function" && (l.flags |= 4), typeof uA.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof uA.componentDidUpdate != "function" || HA === Q.memoizedProps && gt === Q.memoizedState || (l.flags |= 4), typeof uA.getSnapshotBeforeUpdate != "function" || HA === Q.memoizedProps && gt === Q.memoizedState || (l.flags |= 1024), l.memoizedProps = U, l.memoizedState = Xe), uA.props = U, uA.state = Xe, uA.context = ae, U = Re) : (typeof uA.componentDidUpdate != "function" || HA === Q.memoizedProps && gt === Q.memoizedState || (l.flags |= 4), typeof uA.getSnapshotBeforeUpdate != "function" || HA === Q.memoizedProps && gt === Q.memoizedState || (l.flags |= 1024), U = !1);
      }
      return tl(Q, l, M, U, z, K);
    }
    function tl(Q, l, M, U, K, z) {
      Su(Q, l);
      var uA = (l.flags & 128) !== 0;
      if (!U && !uA)
        return K && tI(l, M, !1), rn(Q, l, z);
      U = l.stateNode, Si.current = l;
      var HA = uA && typeof M.getDerivedStateFromError != "function" ? null : U.render();
      return l.flags |= 1, Q !== null && uA ? (l.child = Ss(l, Q.child, null, z), l.child = Ss(l, null, HA, z)) : Yn(Q, l, HA, z), l.memoizedState = U.state, K && tI(l, M, !0), l.child;
    }
    function sQ(Q) {
      var l = Q.stateNode;
      l.pendingContext ? ZC(Q, l.pendingContext, l.pendingContext !== l.context) : l.context && ZC(Q, l.context, !1), Ms(Q, l.containerInfo);
    }
    function il(Q, l, M, U, K) {
      return _o(), ms(K), l.flags |= 256, Yn(Q, l, M, U), l.child;
    }
    var aQ = { dehydrated: null, treeContext: null, retryLane: 0 };
    function da(Q) {
      return { baseLanes: Q, cachePool: null };
    }
    function Mu(Q, l, M) {
      var U = l.pendingProps, K = di.current, z = !1, uA = (l.flags & 128) !== 0, HA;
      if ((HA = uA) || (HA = Q !== null && Q.memoizedState === null ? !1 : (K & 2) !== 0), HA ? (z = !0, l.flags &= -129) : (Q === null || Q.memoizedState !== null) && (K |= 1), ot(di, K & 1), Q === null)
        return lI(l), Q = l.memoizedState, Q !== null && (Q = Q.dehydrated, Q !== null) ? (l.mode & 1 ? je(Q) ? l.lanes = 8 : l.lanes = 1073741824 : l.lanes = 1, null) : (K = U.children, Q = U.fallback, z ? (U = l.mode, z = l.child, K = { mode: "hidden", children: K }, !(U & 1) && z !== null ? (z.childLanes = 0, z.pendingProps = K) : z = zB(K, U, 0, null), Q = Hs(Q, U, M, null), z.return = l, Q.return = l, z.sibling = Q, l.child = z, l.child.memoizedState = da(M), l.memoizedState = aQ, Q) : IQ(l, K));
      if (K = Q.memoizedState, K !== null) {
        if (HA = K.dehydrated, HA !== null) {
          if (uA)
            return l.flags & 256 ? (l.flags &= -257, Bo(Q, l, M, Error(r(422)))) : l.memoizedState !== null ? (l.child = Q.child, l.flags |= 128, null) : (z = U.fallback, K = l.mode, U = zB({ mode: "visible", children: U.children }, K, 0, null), z = Hs(z, K, M, null), z.flags |= 2, U.return = l, z.return = l, U.sibling = z, l.child = U, l.mode & 1 && Ss(
              l,
              Q.child,
              null,
              M
            ), l.child.memoizedState = da(M), l.memoizedState = aQ, z);
          if (!(l.mode & 1))
            l = Bo(Q, l, M, null);
          else if (je(HA))
            l = Bo(Q, l, M, Error(r(419)));
          else if (U = (M & Q.childLanes) !== 0, ig || U) {
            if (U = pn, U !== null) {
              switch (M & -M) {
                case 4:
                  z = 2;
                  break;
                case 16:
                  z = 8;
                  break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                  z = 32;
                  break;
                case 536870912:
                  z = 268435456;
                  break;
                default:
                  z = 0;
              }
              U = z & (U.suspendedLanes | M) ? 0 : z, U !== 0 && U !== K.retryLane && (K.retryLane = U, Cr(Q, U, -1));
            }
            dl(), l = Bo(Q, l, M, Error(r(421)));
          } else
            vi(HA) ? (l.flags |= 128, l.child = Q.child, l = Zf.bind(null, Q), Ri(HA, l), l = null) : (M = K.treeContext, vA && (vn = PA(HA), Ig = l, Di = !0, yg = null, ws = !1, M !== null && (Dg[wg++] = Lr, Dg[wg++] = Tr, Dg[wg++] = bo, Lr = M.id, Tr = M.overflow, bo = l)), l = IQ(l, l.pendingProps.children), l.flags |= 4096);
          return l;
        }
        return z ? (U = Nu(Q, l, U.children, U.fallback, M), z = l.child, K = Q.child.memoizedState, z.memoizedState = K === null ? da(M) : { baseLanes: K.baseLanes | M, cachePool: null }, z.childLanes = Q.childLanes & ~M, l.memoizedState = aQ, U) : (M = Ru(Q, l, U.children, M), l.memoizedState = null, M);
      }
      return z ? (U = Nu(Q, l, U.children, U.fallback, M), z = l.child, K = Q.child.memoizedState, z.memoizedState = K === null ? da(M) : { baseLanes: K.baseLanes | M, cachePool: null }, z.childLanes = Q.childLanes & ~M, l.memoizedState = aQ, U) : (M = Ru(Q, l, U.children, M), l.memoizedState = null, M);
    }
    function IQ(Q, l) {
      return l = zB({ mode: "visible", children: l }, Q.mode, 0, null), l.return = Q, Q.child = l;
    }
    function Ru(Q, l, M, U) {
      var K = Q.child;
      return Q = K.sibling, M = Gg(K, { mode: "visible", children: M }), !(l.mode & 1) && (M.lanes = U), M.return = l, M.sibling = null, Q !== null && (U = l.deletions, U === null ? (l.deletions = [Q], l.flags |= 16) : U.push(Q)), l.child = M;
    }
    function Nu(Q, l, M, U, K) {
      var z = l.mode;
      Q = Q.child;
      var uA = Q.sibling, HA = { mode: "hidden", children: M };
      return !(z & 1) && l.child !== Q ? (M = l.child, M.childLanes = 0, M.pendingProps = HA, l.deletions = null) : (M = Gg(Q, HA), M.subtreeFlags = Q.subtreeFlags & 14680064), uA !== null ? U = Gg(uA, U) : (U = Hs(U, z, K, null), U.flags |= 2), U.return = l, M.return = l, M.sibling = U, l.child = M, U;
    }
    function Bo(Q, l, M, U) {
      return U !== null && ms(U), Ss(l, Q.child, null, M), Q = IQ(l, l.pendingProps.children), Q.flags |= 2, l.memoizedState = null, Q;
    }
    function wI(Q, l, M) {
      Q.lanes |= l;
      var U = Q.alternate;
      U !== null && (U.lanes |= l), Ba(Q.return, l, M);
    }
    function Wo(Q, l, M, U, K) {
      var z = Q.memoizedState;
      z === null ? Q.memoizedState = { isBackwards: l, rendering: null, renderingStartTime: 0, last: U, tail: M, tailMode: K } : (z.isBackwards = l, z.rendering = null, z.renderingStartTime = 0, z.last = U, z.tail = M, z.tailMode = K);
    }
    function BQ(Q, l, M) {
      var U = l.pendingProps, K = U.revealOrder, z = U.tail;
      if (Yn(Q, l, U.children, M), U = di.current, U & 2)
        U = U & 1 | 2, l.flags |= 128;
      else {
        if (Q !== null && Q.flags & 128)
          A:
            for (Q = l.child; Q !== null; ) {
              if (Q.tag === 13)
                Q.memoizedState !== null && wI(Q, M, l);
              else if (Q.tag === 19)
                wI(Q, M, l);
              else if (Q.child !== null) {
                Q.child.return = Q, Q = Q.child;
                continue;
              }
              if (Q === l)
                break A;
              for (; Q.sibling === null; ) {
                if (Q.return === null || Q.return === l)
                  break A;
                Q = Q.return;
              }
              Q.sibling.return = Q.return, Q = Q.sibling;
            }
        U &= 1;
      }
      if (ot(di, U), !(l.mode & 1))
        l.memoizedState = null;
      else
        switch (K) {
          case "forwards":
            for (M = l.child, K = null; M !== null; )
              Q = M.alternate, Q !== null && br(Q) === null && (K = M), M = M.sibling;
            M = K, M === null ? (K = l.child, l.child = null) : (K = M.sibling, M.sibling = null), Wo(l, !1, K, M, z);
            break;
          case "backwards":
            for (M = null, K = l.child, l.child = null; K !== null; ) {
              if (Q = K.alternate, Q !== null && br(Q) === null) {
                l.child = K;
                break;
              }
              Q = K.sibling, K.sibling = M, M = K, K = Q;
            }
            Wo(l, !0, M, null, z);
            break;
          case "together":
            Wo(l, !1, null, null, void 0);
            break;
          default:
            l.memoizedState = null;
        }
      return l.child;
    }
    function rn(Q, l, M) {
      if (Q !== null && (l.dependencies = Q.dependencies), Qo |= l.lanes, !(M & l.childLanes))
        return null;
      if (Q !== null && l.child !== Q.child)
        throw Error(r(153));
      if (l.child !== null) {
        for (Q = l.child, M = Gg(Q, Q.pendingProps), l.child = M, M.return = l; Q.sibling !== null; )
          Q = Q.sibling, M = M.sibling = Gg(Q, Q.pendingProps), M.return = l;
        M.sibling = null;
      }
      return l.child;
    }
    function yI(Q, l, M) {
      switch (l.tag) {
        case 3:
          sQ(l), _o();
          break;
        case 5:
          Rt(l);
          break;
        case 1:
          An(l.type) && xo(l);
          break;
        case 4:
          Ms(l, l.stateNode.containerInfo);
          break;
        case 10:
          FB(l, l.type._context, l.memoizedProps.value);
          break;
        case 13:
          var U = l.memoizedState;
          if (U !== null)
            return U.dehydrated !== null ? (ot(di, di.current & 1), l.flags |= 128, null) : M & l.child.childLanes ? Mu(Q, l, M) : (ot(di, di.current & 1), Q = rn(Q, l, M), Q !== null ? Q.sibling : null);
          ot(di, di.current & 1);
          break;
        case 19:
          if (U = (M & l.childLanes) !== 0, Q.flags & 128) {
            if (U)
              return BQ(
                Q,
                l,
                M
              );
            l.flags |= 128;
          }
          var K = l.memoizedState;
          if (K !== null && (K.rendering = null, K.tail = null, K.lastEffect = null), ot(di, di.current), U)
            break;
          return null;
        case 22:
        case 23:
          return l.lanes = 0, mu(Q, l, M);
      }
      return rn(Q, l, M);
    }
    function Gt(Q, l) {
      switch (Ho(l), l.tag) {
        case 1:
          return An(l.type) && na(), Q = l.flags, Q & 65536 ? (l.flags = Q & -65537 | 128, l) : null;
        case 3:
          return Oo(), Wt(Mt), Wt(zi), ht(), Q = l.flags, Q & 65536 && !(Q & 128) ? (l.flags = Q & -65537 | 128, l) : null;
        case 5:
          return Vi(l), null;
        case 13:
          if (Wt(di), Q = l.memoizedState, Q !== null && Q.dehydrated !== null) {
            if (l.alternate === null)
              throw Error(r(340));
            _o();
          }
          return Q = l.flags, Q & 65536 ? (l.flags = Q & -65537 | 128, l) : null;
        case 19:
          return Wt(di), null;
        case 4:
          return Oo(), null;
        case 10:
          return rI(l.type._context), null;
        case 22:
        case 23:
          return Qr(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var fa = !1, xs = !1, wm = typeof WeakSet == "function" ? WeakSet : Set, Je = null;
    function mI(Q, l) {
      var M = Q.ref;
      if (M !== null)
        if (typeof M == "function")
          try {
            M(null);
          } catch (U) {
            ai(Q, l, U);
          }
        else
          M.current = null;
    }
    function pa(Q, l, M) {
      try {
        M();
      } catch (U) {
        ai(Q, l, U);
      }
    }
    var Fu = !1;
    function Gu(Q, l) {
      for (J(Q.containerInfo), Je = l; Je !== null; )
        if (Q = Je, l = Q.child, (Q.subtreeFlags & 1028) !== 0 && l !== null)
          l.return = Q, Je = l;
        else
          for (; Je !== null; ) {
            Q = Je;
            try {
              var M = Q.alternate;
              if (Q.flags & 1024)
                switch (Q.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (M !== null) {
                      var U = M.memoizedProps, K = M.memoizedState, z = Q.stateNode, uA = z.getSnapshotBeforeUpdate(Q.elementType === Q.type ? U : Jg(Q.type, U), K);
                      z.__reactInternalSnapshotBeforeUpdate = uA;
                    }
                    break;
                  case 3:
                    FA && TA(Q.stateNode.containerInfo);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(r(163));
                }
            } catch (HA) {
              ai(Q, Q.return, HA);
            }
            if (l = Q.sibling, l !== null) {
              l.return = Q.return, Je = l;
              break;
            }
            Je = Q.return;
          }
      return M = Fu, Fu = !1, M;
    }
    function Da(Q, l, M) {
      var U = l.updateQueue;
      if (U = U !== null ? U.lastEffect : null, U !== null) {
        var K = U = U.next;
        do {
          if ((K.tag & Q) === Q) {
            var z = K.destroy;
            K.destroy = void 0, z !== void 0 && pa(l, M, z);
          }
          K = K.next;
        } while (K !== U);
      }
    }
    function wa(Q, l) {
      if (l = l.updateQueue, l = l !== null ? l.lastEffect : null, l !== null) {
        var M = l = l.next;
        do {
          if ((M.tag & Q) === Q) {
            var U = M.create;
            M.destroy = U();
          }
          M = M.next;
        } while (M !== l);
      }
    }
    function nl(Q) {
      var l = Q.ref;
      if (l !== null) {
        var M = Q.stateNode;
        switch (Q.tag) {
          case 5:
            Q = eA(M);
            break;
          default:
            Q = M;
        }
        typeof l == "function" ? l(Q) : l.current = Q;
      }
    }
    function gl(Q, l, M) {
      if (gr && typeof gr.onCommitFiberUnmount == "function")
        try {
          gr.onCommitFiberUnmount(Lo, l);
        } catch {
        }
      switch (l.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          if (Q = l.updateQueue, Q !== null && (Q = Q.lastEffect, Q !== null)) {
            var U = Q = Q.next;
            do {
              var K = U, z = K.destroy;
              K = K.tag, z !== void 0 && (K & 2 || K & 4) && pa(l, M, z), U = U.next;
            } while (U !== Q);
          }
          break;
        case 1:
          if (mI(l, M), Q = l.stateNode, typeof Q.componentWillUnmount == "function")
            try {
              Q.props = l.memoizedProps, Q.state = l.memoizedState, Q.componentWillUnmount();
            } catch (uA) {
              ai(
                l,
                M,
                uA
              );
            }
          break;
        case 5:
          mI(l, M);
          break;
        case 4:
          FA ? Un(Q, l, M) : dA && dA && (l = l.stateNode.containerInfo, M = Me(l), Ee(l, M));
      }
    }
    function rl(Q, l, M) {
      for (var U = l; ; )
        if (gl(Q, U, M), U.child === null || FA && U.tag === 4) {
          if (U === l)
            break;
          for (; U.sibling === null; ) {
            if (U.return === null || U.return === l)
              return;
            U = U.return;
          }
          U.sibling.return = U.return, U = U.sibling;
        } else
          U.child.return = U, U = U.child;
    }
    function Jr(Q) {
      var l = Q.alternate;
      l !== null && (Q.alternate = null, Jr(l)), Q.child = null, Q.deletions = null, Q.sibling = null, Q.tag === 5 && (l = Q.stateNode, l !== null && pe(l)), Q.stateNode = null, Q.return = null, Q.dependencies = null, Q.memoizedProps = null, Q.memoizedState = null, Q.pendingProps = null, Q.stateNode = null, Q.updateQueue = null;
    }
    function SI(Q) {
      return Q.tag === 5 || Q.tag === 3 || Q.tag === 4;
    }
    function MI(Q) {
      A:
        for (; ; ) {
          for (; Q.sibling === null; ) {
            if (Q.return === null || SI(Q.return))
              return null;
            Q = Q.return;
          }
          for (Q.sibling.return = Q.return, Q = Q.sibling; Q.tag !== 5 && Q.tag !== 6 && Q.tag !== 18; ) {
            if (Q.flags & 2 || Q.child === null || Q.tag === 4)
              continue A;
            Q.child.return = Q, Q = Q.child;
          }
          if (!(Q.flags & 2))
            return Q.stateNode;
        }
    }
    function CQ(Q) {
      if (FA) {
        A: {
          for (var l = Q.return; l !== null; ) {
            if (SI(l))
              break A;
            l = l.return;
          }
          throw Error(r(160));
        }
        var M = l;
        switch (M.tag) {
          case 5:
            l = M.stateNode, M.flags & 32 && (cA(l), M.flags &= -33), M = MI(Q), Wg(Q, M, l);
            break;
          case 3:
          case 4:
            l = M.stateNode.containerInfo, M = MI(Q), ya(Q, M, l);
            break;
          default:
            throw Error(r(161));
        }
      }
    }
    function ya(Q, l, M) {
      var U = Q.tag;
      if (U === 5 || U === 6)
        Q = Q.stateNode, l ? ZA(M, Q, l) : DA(M, Q);
      else if (U !== 4 && (Q = Q.child, Q !== null))
        for (ya(Q, l, M), Q = Q.sibling; Q !== null; )
          ya(Q, l, M), Q = Q.sibling;
    }
    function Wg(Q, l, M) {
      var U = Q.tag;
      if (U === 5 || U === 6)
        Q = Q.stateNode, l ? YA(M, Q, l) : bA(M, Q);
      else if (U !== 4 && (Q = Q.child, Q !== null))
        for (Wg(Q, l, M), Q = Q.sibling; Q !== null; )
          Wg(Q, l, M), Q = Q.sibling;
    }
    function Un(Q, l, M) {
      for (var U = l, K = !1, z, uA; ; ) {
        if (!K) {
          K = U.return;
          A:
            for (; ; ) {
              if (K === null)
                throw Error(r(160));
              switch (z = K.stateNode, K.tag) {
                case 5:
                  uA = !1;
                  break A;
                case 3:
                  z = z.containerInfo, uA = !0;
                  break A;
                case 4:
                  z = z.containerInfo, uA = !0;
                  break A;
              }
              K = K.return;
            }
          K = !0;
        }
        if (U.tag === 5 || U.tag === 6)
          rl(Q, U, M), uA ? Se(z, U.stateNode) : _A(z, U.stateNode);
        else if (U.tag === 18)
          uA ? tt(z, U.stateNode) : ft(z, U.stateNode);
        else if (U.tag === 4) {
          if (U.child !== null) {
            z = U.stateNode.containerInfo, uA = !0, U.child.return = U, U = U.child;
            continue;
          }
        } else if (gl(Q, U, M), U.child !== null) {
          U.child.return = U, U = U.child;
          continue;
        }
        if (U === l)
          break;
        for (; U.sibling === null; ) {
          if (U.return === null || U.return === l)
            return;
          U = U.return, U.tag === 4 && (K = !1);
        }
        U.sibling.return = U.return, U = U.sibling;
      }
    }
    function ol(Q, l) {
      if (FA) {
        switch (l.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            Da(3, l, l.return), wa(3, l), Da(5, l, l.return);
            return;
          case 1:
            return;
          case 5:
            var M = l.stateNode;
            if (M != null) {
              var U = l.memoizedProps;
              Q = Q !== null ? Q.memoizedProps : U;
              var K = l.type, z = l.updateQueue;
              l.updateQueue = null, z !== null && mA(M, z, K, Q, U, l);
            }
            return;
          case 6:
            if (l.stateNode === null)
              throw Error(r(162));
            M = l.memoizedProps, SA(l.stateNode, Q !== null ? Q.memoizedProps : M, M);
            return;
          case 3:
            vA && Q !== null && Q.memoizedState.isDehydrated && Et(l.stateNode.containerInfo);
            return;
          case 12:
            return;
          case 13:
            QQ(l);
            return;
          case 19:
            QQ(l);
            return;
          case 17:
            return;
        }
        throw Error(r(163));
      }
      switch (l.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Da(3, l, l.return), wa(3, l), Da(5, l, l.return);
          return;
        case 12:
          return;
        case 13:
          QQ(l);
          return;
        case 19:
          QQ(l);
          return;
        case 3:
          vA && Q !== null && Q.memoizedState.isDehydrated && Et(l.stateNode.containerInfo);
          break;
        case 22:
        case 23:
          return;
      }
      A:
        if (dA) {
          switch (l.tag) {
            case 1:
            case 5:
            case 6:
              break A;
            case 3:
            case 4:
              l = l.stateNode, Ee(l.containerInfo, l.pendingChildren);
              break A;
          }
          throw Error(r(163));
        }
    }
    function QQ(Q) {
      var l = Q.updateQueue;
      if (l !== null) {
        Q.updateQueue = null;
        var M = Q.stateNode;
        M === null && (M = Q.stateNode = new wm()), l.forEach(function(U) {
          var K = Ra.bind(null, Q, U);
          M.has(U) || (M.add(U), U.then(K, K));
        });
      }
    }
    function zf(Q, l) {
      for (Je = l; Je !== null; ) {
        l = Je;
        var M = l.deletions;
        if (M !== null)
          for (var U = 0; U < M.length; U++) {
            var K = M[U];
            try {
              var z = Q;
              FA ? Un(z, K, l) : rl(z, K, l);
              var uA = K.alternate;
              uA !== null && (uA.return = null), K.return = null;
            } catch (Ze) {
              ai(K, l, Ze);
            }
          }
        if (M = l.child, l.subtreeFlags & 12854 && M !== null)
          M.return = l, Je = M;
        else
          for (; Je !== null; ) {
            l = Je;
            try {
              var HA = l.flags;
              if (HA & 32 && FA && cA(l.stateNode), HA & 512) {
                var ae = l.alternate;
                if (ae !== null) {
                  var Re = ae.ref;
                  Re !== null && (typeof Re == "function" ? Re(null) : Re.current = null);
                }
              }
              if (HA & 8192)
                switch (l.tag) {
                  case 13:
                    if (l.memoizedState !== null) {
                      var Ue = l.alternate;
                      (Ue === null || Ue.memoizedState === null) && (El = ki());
                    }
                    break;
                  case 22:
                    var Qt = l.memoizedState !== null, gt = l.alternate, wi = gt !== null && gt.memoizedState !== null;
                    if (M = l, FA) {
                      A:
                        if (U = M, K = Qt, z = null, FA)
                          for (var Xe = U; ; ) {
                            if (Xe.tag === 5) {
                              if (z === null) {
                                z = Xe;
                                var zn = Xe.stateNode;
                                K ? xA(zn) : RA(Xe.stateNode, Xe.memoizedProps);
                              }
                            } else if (Xe.tag === 6) {
                              if (z === null) {
                                var Bg = Xe.stateNode;
                                K ? gA(Bg) : UA(Bg, Xe.memoizedProps);
                              }
                            } else if ((Xe.tag !== 22 && Xe.tag !== 23 || Xe.memoizedState === null || Xe === U) && Xe.child !== null) {
                              Xe.child.return = Xe, Xe = Xe.child;
                              continue;
                            }
                            if (Xe === U)
                              break;
                            for (; Xe.sibling === null; ) {
                              if (Xe.return === null || Xe.return === U)
                                break A;
                              z === Xe && (z = null), Xe = Xe.return;
                            }
                            z === Xe && (z = null), Xe.sibling.return = Xe.return, Xe = Xe.sibling;
                          }
                    }
                    if (Qt && !wi && M.mode & 1) {
                      Je = M;
                      for (var $A = M.child; $A !== null; ) {
                        for (M = Je = $A; Je !== null; ) {
                          U = Je;
                          var qA = U.child;
                          switch (U.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                              Da(4, U, U.return);
                              break;
                            case 1:
                              mI(U, U.return);
                              var re = U.stateNode;
                              if (typeof re.componentWillUnmount == "function") {
                                var He = U.return;
                                try {
                                  re.props = U.memoizedProps, re.state = U.memoizedState, re.componentWillUnmount();
                                } catch (Ze) {
                                  ai(
                                    U,
                                    He,
                                    Ze
                                  );
                                }
                              }
                              break;
                            case 5:
                              mI(U, U.return);
                              break;
                            case 22:
                              if (U.memoizedState !== null) {
                                Uu(M);
                                continue;
                              }
                          }
                          qA !== null ? (qA.return = U, Je = qA) : Uu(M);
                        }
                        $A = $A.sibling;
                      }
                    }
                }
              switch (HA & 4102) {
                case 2:
                  CQ(l), l.flags &= -3;
                  break;
                case 6:
                  CQ(l), l.flags &= -3, ol(l.alternate, l);
                  break;
                case 4096:
                  l.flags &= -4097;
                  break;
                case 4100:
                  l.flags &= -4097, ol(l.alternate, l);
                  break;
                case 4:
                  ol(l.alternate, l);
              }
            } catch (Ze) {
              ai(l, l.return, Ze);
            }
            if (M = l.sibling, M !== null) {
              M.return = l.return, Je = M;
              break;
            }
            Je = l.return;
          }
      }
    }
    function vu(Q, l, M) {
      Je = Q, sl(Q);
    }
    function sl(Q, l, M) {
      for (var U = (Q.mode & 1) !== 0; Je !== null; ) {
        var K = Je, z = K.child;
        if (K.tag === 22 && U) {
          var uA = K.memoizedState !== null || fa;
          if (!uA) {
            var HA = K.alternate, ae = HA !== null && HA.memoizedState !== null || xs;
            HA = fa;
            var Re = xs;
            if (fa = uA, (xs = ae) && !Re)
              for (Je = K; Je !== null; )
                uA = Je, ae = uA.child, uA.tag === 22 && uA.memoizedState !== null ? ku(K) : ae !== null ? (ae.return = uA, Je = ae) : ku(K);
            for (; z !== null; )
              Je = z, sl(z), z = z.sibling;
            Je = K, fa = HA, xs = Re;
          }
          al(Q);
        } else
          K.subtreeFlags & 8772 && z !== null ? (z.return = K, Je = z) : al(Q);
      }
    }
    function al(Q) {
      for (; Je !== null; ) {
        var l = Je;
        if (l.flags & 8772) {
          var M = l.alternate;
          try {
            if (l.flags & 8772)
              switch (l.tag) {
                case 0:
                case 11:
                case 15:
                  xs || wa(5, l);
                  break;
                case 1:
                  var U = l.stateNode;
                  if (l.flags & 4 && !xs)
                    if (M === null)
                      U.componentDidMount();
                    else {
                      var K = l.elementType === l.type ? M.memoizedProps : Jg(l.type, M.memoizedProps);
                      U.componentDidUpdate(K, M.memoizedState, U.__reactInternalSnapshotBeforeUpdate);
                    }
                  var z = l.updateQueue;
                  z !== null && tQ(l, z, U);
                  break;
                case 3:
                  var uA = l.updateQueue;
                  if (uA !== null) {
                    if (M = null, l.child !== null)
                      switch (l.child.tag) {
                        case 5:
                          M = eA(l.child.stateNode);
                          break;
                        case 1:
                          M = l.child.stateNode;
                      }
                    tQ(l, uA, M);
                  }
                  break;
                case 5:
                  var HA = l.stateNode;
                  M === null && l.flags & 4 && EA(HA, l.type, l.memoizedProps, l);
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (vA && l.memoizedState === null) {
                    var ae = l.alternate;
                    if (ae !== null) {
                      var Re = ae.memoizedState;
                      if (Re !== null) {
                        var Ue = Re.dehydrated;
                        Ue !== null && Bt(Ue);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                  break;
                default:
                  throw Error(r(163));
              }
            xs || l.flags & 512 && nl(l);
          } catch (Qt) {
            ai(l, l.return, Qt);
          }
        }
        if (l === Q) {
          Je = null;
          break;
        }
        if (M = l.sibling, M !== null) {
          M.return = l.return, Je = M;
          break;
        }
        Je = l.return;
      }
    }
    function Uu(Q) {
      for (; Je !== null; ) {
        var l = Je;
        if (l === Q) {
          Je = null;
          break;
        }
        var M = l.sibling;
        if (M !== null) {
          M.return = l.return, Je = M;
          break;
        }
        Je = l.return;
      }
    }
    function ku(Q) {
      for (; Je !== null; ) {
        var l = Je;
        try {
          switch (l.tag) {
            case 0:
            case 11:
            case 15:
              var M = l.return;
              try {
                wa(4, l);
              } catch (ae) {
                ai(l, M, ae);
              }
              break;
            case 1:
              var U = l.stateNode;
              if (typeof U.componentDidMount == "function") {
                var K = l.return;
                try {
                  U.componentDidMount();
                } catch (ae) {
                  ai(l, K, ae);
                }
              }
              var z = l.return;
              try {
                nl(l);
              } catch (ae) {
                ai(l, z, ae);
              }
              break;
            case 5:
              var uA = l.return;
              try {
                nl(l);
              } catch (ae) {
                ai(l, uA, ae);
              }
          }
        } catch (ae) {
          ai(l, l.return, ae);
        }
        if (l === Q) {
          Je = null;
          break;
        }
        var HA = l.sibling;
        if (HA !== null) {
          HA.return = l.return, Je = HA;
          break;
        }
        Je = l.return;
      }
    }
    var EQ = 0, on = 1, ma = 2, YB = 3, zo = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var RI = Symbol.for;
      EQ = RI("selector.component"), on = RI("selector.has_pseudo_class"), ma = RI("selector.role"), YB = RI("selector.test_id"), zo = RI("selector.text");
    }
    function Il(Q) {
      var l = JA(Q);
      if (l != null) {
        if (typeof l.memoizedProps["data-testname"] != "string")
          throw Error(r(364));
        return l;
      }
      if (Q = O(Q), Q === null)
        throw Error(r(362));
      return Q.stateNode.current;
    }
    function Bl(Q, l) {
      switch (l.$$typeof) {
        case EQ:
          if (Q.type === l.value)
            return !0;
          break;
        case on:
          A: {
            l = l.value, Q = [Q, 0];
            for (var M = 0; M < Q.length; ) {
              var U = Q[M++], K = Q[M++], z = l[K];
              if (U.tag !== 5 || !Z(U)) {
                for (; z != null && Bl(U, z); )
                  K++, z = l[K];
                if (K === l.length) {
                  l = !0;
                  break A;
                } else
                  for (U = U.child; U !== null; )
                    Q.push(U, K), U = U.sibling;
              }
            }
            l = !1;
          }
          return l;
        case ma:
          if (Q.tag === 5 && $(Q.stateNode, l.value))
            return !0;
          break;
        case zo:
          if ((Q.tag === 5 || Q.tag === 6) && (Q = q(Q), Q !== null && 0 <= Q.indexOf(l.value)))
            return !0;
          break;
        case YB:
          if (Q.tag === 5 && (Q = Q.memoizedProps["data-testname"], typeof Q == "string" && Q.toLowerCase() === l.value.toLowerCase()))
            return !0;
          break;
        default:
          throw Error(r(365));
      }
      return !1;
    }
    function Ls(Q) {
      switch (Q.$$typeof) {
        case EQ:
          return "<" + (G(Q.value) || "Unknown") + ">";
        case on:
          return ":has(" + (Ls(Q) || "") + ")";
        case ma:
          return '[role="' + Q.value + '"]';
        case zo:
          return '"' + Q.value + '"';
        case YB:
          return '[data-testname="' + Q.value + '"]';
        default:
          throw Error(r(365));
      }
    }
    function Pn(Q, l) {
      var M = [];
      Q = [Q, 0];
      for (var U = 0; U < Q.length; ) {
        var K = Q[U++], z = Q[U++], uA = l[z];
        if (K.tag !== 5 || !Z(K)) {
          for (; uA != null && Bl(K, uA); )
            z++, uA = l[z];
          if (z === l.length)
            M.push(K);
          else
            for (K = K.child; K !== null; )
              Q.push(K, z), K = K.sibling;
        }
      }
      return M;
    }
    function Ye(Q, l) {
      if (!de)
        throw Error(r(363));
      Q = Il(Q), Q = Pn(Q, l), l = [], Q = Array.from(Q);
      for (var M = 0; M < Q.length; ) {
        var U = Q[M++];
        if (U.tag === 5)
          Z(U) || l.push(U.stateNode);
        else
          for (U = U.child; U !== null; )
            Q.push(U), U = U.sibling;
      }
      return l;
    }
    var Co = Math.ceil, Rg = s.ReactCurrentDispatcher, Cl = s.ReactCurrentOwner, sn = s.ReactCurrentBatchConfig, Tt = 0, pn = null, Dn = null, ei = 0, zg = 0, NI = Nn(0), kn = 0, FI = null, Qo = 0, Vo = 0, Ql = 0, HB = null, Ng = null, El = 0, ll = 1 / 0;
    function GI() {
      ll = ki() + 500;
    }
    var _B = !1, lQ = null, Ts = null, cQ = !1, Ks = null, uQ = 0, JB = 0, cl = null, OB = -1, hQ = 0;
    function ng() {
      return Tt & 6 ? ki() : OB !== -1 ? OB : OB = ki();
    }
    function bs(Q) {
      return Q.mode & 1 ? Tt & 2 && ei !== 0 ? ei & -ei : AQ.transition !== null ? (hQ === 0 && (Q = ro, ro <<= 1, !(ro & 4194240) && (ro = 64), hQ = Q), hQ) : (Q = $t, Q !== 0 ? Q : ee()) : 1;
    }
    function Cr(Q, l, M) {
      if (50 < JB)
        throw JB = 0, cl = null, Error(r(185));
      var U = vI(Q, l);
      return U === null ? null : (vr(U, l, M), (!(Tt & 2) || U !== pn) && (U === pn && (!(Tt & 2) && (Vo |= l), kn === 4 && jo(U, ei)), Fg(U, M), l === 1 && Tt === 0 && !(Q.mode & 1) && (GI(), oa && Gn())), U);
    }
    function vI(Q, l) {
      Q.lanes |= l;
      var M = Q.alternate;
      for (M !== null && (M.lanes |= l), M = Q, Q = Q.return; Q !== null; )
        Q.childLanes |= l, M = Q.alternate, M !== null && (M.childLanes |= l), M = Q, Q = Q.return;
      return M.tag === 3 ? M.stateNode : null;
    }
    function Fg(Q, l) {
      var M = Q.callbackNode;
      ga(Q, l);
      var U = so(Q, Q === pn ? ei : 0);
      if (U === 0)
        M !== null && Ur(M), Q.callbackNode = null, Q.callbackPriority = 0;
      else if (l = U & -U, Q.callbackPriority !== l) {
        if (M != null && Ur(M), l === 1)
          Q.tag === 0 ? Al(xu.bind(null, Q)) : RB(xu.bind(null, Q)), Ae ? ie(function() {
            Tt === 0 && Gn();
          }) : ao(ra, Gn), M = null;
        else {
          switch (XC(U)) {
            case 1:
              M = ra;
              break;
            case 4:
              M = jE;
              break;
            case 16:
              M = SB;
              break;
            case 536870912:
              M = ZE;
              break;
            default:
              M = SB;
          }
          M = kI(M, Vg.bind(null, Q));
        }
        Q.callbackPriority = l, Q.callbackNode = M;
      }
    }
    function Vg(Q, l) {
      if (OB = -1, hQ = 0, Tt & 6)
        throw Error(r(327));
      var M = Q.callbackNode;
      if (Ma() && Q.callbackNode !== M)
        return null;
      var U = so(Q, Q === pn ? ei : 0);
      if (U === 0)
        return null;
      if (U & 30 || U & Q.expiredLanes || l)
        l = Sa(Q, U);
      else {
        l = U;
        var K = Tt;
        Tt |= 2;
        var z = Tu();
        (pn !== Q || ei !== l) && (GI(), Ys(Q, l));
        do
          try {
            Ku();
            break;
          } catch (HA) {
            Lu(Q, HA);
          }
        while (1);
        NB(), Rg.current = z, Tt = K, Dn !== null ? l = 0 : (pn = null, ei = 0, l = kn);
      }
      if (l !== 0) {
        if (l === 2 && (K = fn(Q), K !== 0 && (U = K, l = Or(Q, K))), l === 1)
          throw M = FI, Ys(Q, 0), jo(Q, U), Fg(Q, ki()), M;
        if (l === 6)
          jo(Q, U);
        else {
          if (K = Q.current.alternate, !(U & 30) && !ul(K) && (l = Sa(Q, U), l === 2 && (z = fn(Q), z !== 0 && (U = z, l = Or(Q, z))), l === 1))
            throw M = FI, Ys(Q, 0), jo(Q, U), Fg(Q, ki()), M;
          switch (Q.finishedWork = K, Q.finishedLanes = U, l) {
            case 0:
            case 1:
              throw Error(r(345));
            case 2:
              qr(Q, Ng);
              break;
            case 3:
              if (jo(Q, U), (U & 130023424) === U && (l = El + 500 - ki(), 10 < l)) {
                if (so(Q, 0) !== 0)
                  break;
                if (K = Q.suspendedLanes, (K & U) !== U) {
                  ng(), Q.pingedLanes |= Q.suspendedLanes & K;
                  break;
                }
                Q.timeoutHandle = fA(qr.bind(null, Q, Ng), l);
                break;
              }
              qr(Q, Ng);
              break;
            case 4:
              if (jo(Q, U), (U & 4194240) === U)
                break;
              for (l = Q.eventTimes, K = -1; 0 < U; ) {
                var uA = 31 - fg(U);
                z = 1 << uA, uA = l[uA], uA > K && (K = uA), U &= ~z;
              }
              if (U = K, U = ki() - U, U = (120 > U ? 120 : 480 > U ? 480 : 1080 > U ? 1080 : 1920 > U ? 1920 : 3e3 > U ? 3e3 : 4320 > U ? 4320 : 1960 * Co(U / 1960)) - U, 10 < U) {
                Q.timeoutHandle = fA(qr.bind(null, Q, Ng), U);
                break;
              }
              qr(Q, Ng);
              break;
            case 5:
              qr(Q, Ng);
              break;
            default:
              throw Error(r(329));
          }
        }
      }
      return Fg(Q, ki()), Q.callbackNode === M ? Vg.bind(null, Q) : null;
    }
    function Or(Q, l) {
      var M = HB;
      return Q.current.memoizedState.isDehydrated && (Ys(Q, l).flags |= 256), Q = Sa(Q, l), Q !== 2 && (l = Ng, Ng = M, l !== null && qB(l)), Q;
    }
    function qB(Q) {
      Ng === null ? Ng = Q : Ng.push.apply(Ng, Q);
    }
    function ul(Q) {
      for (var l = Q; ; ) {
        if (l.flags & 16384) {
          var M = l.updateQueue;
          if (M !== null && (M = M.stores, M !== null))
            for (var U = 0; U < M.length; U++) {
              var K = M[U], z = K.getSnapshot;
              K = K.value;
              try {
                if (!rr(z(), K))
                  return !1;
              } catch {
                return !1;
              }
            }
        }
        if (M = l.child, l.subtreeFlags & 16384 && M !== null)
          M.return = l, l = M;
        else {
          if (l === Q)
            break;
          for (; l.sibling === null; ) {
            if (l.return === null || l.return === Q)
              return !0;
            l = l.return;
          }
          l.sibling.return = l.return, l = l.sibling;
        }
      }
      return !0;
    }
    function jo(Q, l) {
      for (l &= ~Ql, l &= ~Vo, Q.suspendedLanes |= l, Q.pingedLanes &= ~l, Q = Q.expirationTimes; 0 < l; ) {
        var M = 31 - fg(l), U = 1 << M;
        Q[M] = -1, l &= ~U;
      }
    }
    function xu(Q) {
      if (Tt & 6)
        throw Error(r(327));
      Ma();
      var l = so(Q, 0);
      if (!(l & 1))
        return Fg(Q, ki()), null;
      var M = Sa(Q, l);
      if (Q.tag !== 0 && M === 2) {
        var U = fn(Q);
        U !== 0 && (l = U, M = Or(Q, U));
      }
      if (M === 1)
        throw M = FI, Ys(Q, 0), jo(Q, l), Fg(Q, ki()), M;
      if (M === 6)
        throw Error(r(345));
      return Q.finishedWork = Q.current.alternate, Q.finishedLanes = l, qr(Q, Ng), Fg(Q, ki()), null;
    }
    function hl(Q) {
      Ks !== null && Ks.tag === 0 && !(Tt & 6) && Ma();
      var l = Tt;
      Tt |= 1;
      var M = sn.transition, U = $t;
      try {
        if (sn.transition = null, $t = 1, Q)
          return Q();
      } finally {
        $t = U, sn.transition = M, Tt = l, !(Tt & 6) && Gn();
      }
    }
    function Qr() {
      zg = NI.current, Wt(NI);
    }
    function Ys(Q, l) {
      Q.finishedWork = null, Q.finishedLanes = 0;
      var M = Q.timeoutHandle;
      if (M !== yA && (Q.timeoutHandle = yA, wA(M)), Dn !== null)
        for (M = Dn.return; M !== null; ) {
          var U = M;
          switch (Ho(U), U.tag) {
            case 1:
              U = U.type.childContextTypes, U != null && na();
              break;
            case 3:
              Oo(), Wt(Mt), Wt(zi), ht();
              break;
            case 5:
              Vi(U);
              break;
            case 4:
              Oo();
              break;
            case 13:
              Wt(di);
              break;
            case 19:
              Wt(di);
              break;
            case 10:
              rI(U.type._context);
              break;
            case 22:
            case 23:
              Qr();
          }
          M = M.return;
        }
      if (pn = Q, Dn = Q = Gg(Q.current, null), ei = zg = l, kn = 0, FI = null, Ql = Vo = Qo = 0, Ng = HB = null, Og !== null) {
        for (l = 0; l < Og.length; l++)
          if (M = Og[l], U = M.interleaved, U !== null) {
            M.interleaved = null;
            var K = U.next, z = M.pending;
            if (z !== null) {
              var uA = z.next;
              z.next = K, U.next = uA;
            }
            M.pending = U;
          }
        Og = null;
      }
      return Q;
    }
    function Lu(Q, l) {
      do {
        var M = Dn;
        try {
          if (NB(), ji.current = NA, Rs) {
            for (var U = qt.memoizedState; U !== null; ) {
              var K = U.queue;
              K !== null && (K.pending = null), U = U.next;
            }
            Rs = !1;
          }
          if (Io = 0, Ei = mi = qt = null, sr = !1, Ns = 0, Cl.current = null, M === null || M.return === null) {
            kn = 1, FI = l, Dn = null;
            break;
          }
          A: {
            var z = Q, uA = M.return, HA = M, ae = l;
            if (l = ei, HA.flags |= 32768, ae !== null && typeof ae == "object" && typeof ae.then == "function") {
              var Re = ae, Ue = HA, Qt = Ue.tag;
              if (!(Ue.mode & 1) && (Qt === 0 || Qt === 11 || Qt === 15)) {
                var gt = Ue.alternate;
                gt ? (Ue.updateQueue = gt.updateQueue, Ue.memoizedState = gt.memoizedState, Ue.lanes = gt.lanes) : (Ue.updateQueue = null, Ue.memoizedState = null);
              }
              var wi = st(uA);
              if (wi !== null) {
                wi.flags &= -257, Vt(wi, uA, HA, z, l), wi.mode & 1 && ct(z, Re, l), l = wi, ae = Re;
                var Xe = l.updateQueue;
                if (Xe === null) {
                  var zn = /* @__PURE__ */ new Set();
                  zn.add(ae), l.updateQueue = zn;
                } else
                  Xe.add(ae);
                break A;
              } else {
                if (!(l & 1)) {
                  ct(z, Re, l), dl();
                  break A;
                }
                ae = Error(r(426));
              }
            } else if (Di && HA.mode & 1) {
              var Bg = st(uA);
              if (Bg !== null) {
                !(Bg.flags & 65536) && (Bg.flags |= 256), Vt(Bg, uA, HA, z, l), ms(ae);
                break A;
              }
            }
            z = ae, kn !== 4 && (kn = 2), HB === null ? HB = [z] : HB.push(z), ae = zA(ae, HA), HA = uA;
            do {
              switch (HA.tag) {
                case 3:
                  HA.flags |= 65536, l &= -l, HA.lanes |= l;
                  var $A = ve(HA, ae, l);
                  eQ(HA, $A);
                  break A;
                case 1:
                  z = ae;
                  var qA = HA.type, re = HA.stateNode;
                  if (!(HA.flags & 128) && (typeof qA.getDerivedStateFromError == "function" || re !== null && typeof re.componentDidCatch == "function" && (Ts === null || !Ts.has(re)))) {
                    HA.flags |= 65536, l &= -l, HA.lanes |= l;
                    var He = Le(HA, z, l);
                    eQ(HA, He);
                    break A;
                  }
              }
              HA = HA.return;
            } while (HA !== null);
          }
          jg(M);
        } catch (Ze) {
          l = Ze, Dn === M && M !== null && (Dn = M = M.return);
          continue;
        }
        break;
      } while (1);
    }
    function Tu() {
      var Q = Rg.current;
      return Rg.current = NA, Q === null ? NA : Q;
    }
    function dl() {
      (kn === 0 || kn === 3 || kn === 2) && (kn = 4), pn === null || !(Qo & 268435455) && !(Vo & 268435455) || jo(pn, ei);
    }
    function Sa(Q, l) {
      var M = Tt;
      Tt |= 2;
      var U = Tu();
      pn === Q && ei === l || Ys(Q, l);
      do
        try {
          Vf();
          break;
        } catch (K) {
          Lu(Q, K);
        }
      while (1);
      if (NB(), Tt = M, Rg.current = U, Dn !== null)
        throw Error(r(261));
      return pn = null, ei = 0, kn;
    }
    function Vf() {
      for (; Dn !== null; )
        fl(Dn);
    }
    function Ku() {
      for (; Dn !== null && !mB(); )
        fl(Dn);
    }
    function fl(Q) {
      var l = UI(Q.alternate, Q, zg);
      Q.memoizedProps = Q.pendingProps, l === null ? jg(Q) : Dn = l, Cl.current = null;
    }
    function jg(Q) {
      var l = Q;
      do {
        var M = l.alternate;
        if (Q = l.return, l.flags & 32768) {
          if (M = Gt(M, l), M !== null) {
            M.flags &= 32767, Dn = M;
            return;
          }
          if (Q !== null)
            Q.flags |= 32768, Q.subtreeFlags = 0, Q.deletions = null;
          else {
            kn = 6, Dn = null;
            return;
          }
        } else if (M = Wf(M, l, zg), M !== null) {
          Dn = M;
          return;
        }
        if (l = l.sibling, l !== null) {
          Dn = l;
          return;
        }
        Dn = l = Q;
      } while (l !== null);
      kn === 0 && (kn = 5);
    }
    function qr(Q, l) {
      var M = $t, U = sn.transition;
      try {
        sn.transition = null, $t = 1, jf(Q, l, M);
      } finally {
        sn.transition = U, $t = M;
      }
      return null;
    }
    function jf(Q, l, M) {
      do
        Ma();
      while (Ks !== null);
      if (Tt & 6)
        throw Error(r(327));
      var U = Q.finishedWork, K = Q.finishedLanes;
      if (U === null)
        return null;
      if (Q.finishedWork = null, Q.finishedLanes = 0, U === Q.current)
        throw Error(r(177));
      Q.callbackNode = null, Q.callbackPriority = 0;
      var z = U.lanes | U.childLanes;
      if (VE(Q, z), Q === pn && (Dn = pn = null, ei = 0), !(U.subtreeFlags & 2064) && !(U.flags & 2064) || cQ || (cQ = !0, kI(SB, function() {
        return Ma(), null;
      })), z = (U.flags & 15990) !== 0, U.subtreeFlags & 15990 || z) {
        z = sn.transition, sn.transition = null;
        var uA = $t;
        $t = 1;
        var HA = Tt;
        Tt |= 4, Cl.current = null, Gu(Q, U), zf(Q, U), tA(Q.containerInfo), Q.current = U, vu(U), $C(), Tt = HA, $t = uA, sn.transition = z;
      } else
        Q.current = U;
      if (cQ && (cQ = !1, Ks = Q, uQ = K), z = Q.pendingLanes, z === 0 && (Ts = null), XE(U.stateNode), Fg(Q, ki()), l !== null)
        for (M = Q.onRecoverableError, U = 0; U < l.length; U++)
          M(l[U]);
      if (_B)
        throw _B = !1, Q = lQ, lQ = null, Q;
      return uQ & 1 && Q.tag !== 0 && Ma(), z = Q.pendingLanes, z & 1 ? Q === cl ? JB++ : (JB = 0, cl = Q) : JB = 0, Gn(), null;
    }
    function Ma() {
      if (Ks !== null) {
        var Q = XC(uQ), l = sn.transition, M = $t;
        try {
          if (sn.transition = null, $t = 16 > Q ? 16 : Q, Ks === null)
            var U = !1;
          else {
            if (Q = Ks, Ks = null, uQ = 0, Tt & 6)
              throw Error(r(331));
            var K = Tt;
            for (Tt |= 4, Je = Q.current; Je !== null; ) {
              var z = Je, uA = z.child;
              if (Je.flags & 16) {
                var HA = z.deletions;
                if (HA !== null) {
                  for (var ae = 0; ae < HA.length; ae++) {
                    var Re = HA[ae];
                    for (Je = Re; Je !== null; ) {
                      var Ue = Je;
                      switch (Ue.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Da(8, Ue, z);
                      }
                      var Qt = Ue.child;
                      if (Qt !== null)
                        Qt.return = Ue, Je = Qt;
                      else
                        for (; Je !== null; ) {
                          Ue = Je;
                          var gt = Ue.sibling, wi = Ue.return;
                          if (Jr(Ue), Ue === Re) {
                            Je = null;
                            break;
                          }
                          if (gt !== null) {
                            gt.return = wi, Je = gt;
                            break;
                          }
                          Je = wi;
                        }
                    }
                  }
                  var Xe = z.alternate;
                  if (Xe !== null) {
                    var zn = Xe.child;
                    if (zn !== null) {
                      Xe.child = null;
                      do {
                        var Bg = zn.sibling;
                        zn.sibling = null, zn = Bg;
                      } while (zn !== null);
                    }
                  }
                  Je = z;
                }
              }
              if (z.subtreeFlags & 2064 && uA !== null)
                uA.return = z, Je = uA;
              else
                A:
                  for (; Je !== null; ) {
                    if (z = Je, z.flags & 2048)
                      switch (z.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Da(9, z, z.return);
                      }
                    var $A = z.sibling;
                    if ($A !== null) {
                      $A.return = z.return, Je = $A;
                      break A;
                    }
                    Je = z.return;
                  }
            }
            var qA = Q.current;
            for (Je = qA; Je !== null; ) {
              uA = Je;
              var re = uA.child;
              if (uA.subtreeFlags & 2064 && re !== null)
                re.return = uA, Je = re;
              else
                A:
                  for (uA = qA; Je !== null; ) {
                    if (HA = Je, HA.flags & 2048)
                      try {
                        switch (HA.tag) {
                          case 0:
                          case 11:
                          case 15:
                            wa(9, HA);
                        }
                      } catch (Ze) {
                        ai(HA, HA.return, Ze);
                      }
                    if (HA === uA) {
                      Je = null;
                      break A;
                    }
                    var He = HA.sibling;
                    if (He !== null) {
                      He.return = HA.return, Je = He;
                      break A;
                    }
                    Je = HA.return;
                  }
            }
            if (Tt = K, Gn(), gr && typeof gr.onPostCommitFiberRoot == "function")
              try {
                gr.onPostCommitFiberRoot(Lo, Q);
              } catch {
              }
            U = !0;
          }
          return U;
        } finally {
          $t = M, sn.transition = l;
        }
      }
      return !1;
    }
    function Wn(Q, l, M) {
      l = zA(M, l), l = ve(Q, l, 1), ag(Q, l), l = ng(), Q = vI(Q, 1), Q !== null && (vr(Q, 1, l), Fg(Q, l));
    }
    function ai(Q, l, M) {
      if (Q.tag === 3)
        Wn(Q, Q, M);
      else
        for (; l !== null; ) {
          if (l.tag === 3) {
            Wn(l, Q, M);
            break;
          } else if (l.tag === 1) {
            var U = l.stateNode;
            if (typeof l.type.getDerivedStateFromError == "function" || typeof U.componentDidCatch == "function" && (Ts === null || !Ts.has(U))) {
              Q = zA(M, Q), Q = Le(l, Q, 1), ag(l, Q), Q = ng(), l = vI(l, 1), l !== null && (vr(l, 1, Q), Fg(l, Q));
              break;
            }
          }
          l = l.return;
        }
    }
    function Eo(Q, l, M) {
      var U = Q.pingCache;
      U !== null && U.delete(l), l = ng(), Q.pingedLanes |= Q.suspendedLanes & M, pn === Q && (ei & M) === M && (kn === 4 || kn === 3 && (ei & 130023424) === ei && 500 > ki() - El ? Ys(Q, 0) : Ql |= M), Fg(Q, l);
    }
    function Er(Q, l) {
      l === 0 && (Q.mode & 1 ? (l = fs, fs <<= 1, !(fs & 130023424) && (fs = 4194304)) : l = 1);
      var M = ng();
      Q = vI(Q, l), Q !== null && (vr(Q, l, M), Fg(Q, M));
    }
    function Zf(Q) {
      var l = Q.memoizedState, M = 0;
      l !== null && (M = l.retryLane), Er(Q, M);
    }
    function Ra(Q, l) {
      var M = 0;
      switch (Q.tag) {
        case 13:
          var U = Q.stateNode, K = Q.memoizedState;
          K !== null && (M = K.retryLane);
          break;
        case 19:
          U = Q.stateNode;
          break;
        default:
          throw Error(r(314));
      }
      U !== null && U.delete(l), Er(Q, M);
    }
    var UI;
    UI = function(Q, l, M) {
      if (Q !== null)
        if (Q.memoizedProps !== l.pendingProps || Mt.current)
          ig = !0;
        else {
          if (!(Q.lanes & M) && !(l.flags & 128))
            return ig = !1, yI(Q, l, M);
          ig = !!(Q.flags & 131072);
        }
      else
        ig = !1, Di && l.flags & 1048576 && QI(l, CI, l.index);
      switch (l.lanes = 0, l.tag) {
        case 2:
          var U = l.type;
          Q !== null && (Q.alternate = null, l.alternate = null, l.flags |= 2), Q = l.pendingProps;
          var K = nr(l, zi.current);
          qn(l, M), K = Gs(null, l, U, Q, K, M);
          var z = ca();
          return l.flags |= 1, typeof K == "object" && K !== null && typeof K.render == "function" && K.$$typeof === void 0 ? (l.tag = 1, l.memoizedState = null, l.updateQueue = null, An(U) ? (z = !0, xo(l)) : z = !1, l.memoizedState = K.state !== null && K.state !== void 0 ? K.state : null, GB(l), K.updater = II, l.stateNode = K, K._reactInternals = l, UB(l, U, Q, M), l = tl(null, l, U, !0, z, M)) : (l.tag = 0, Di && z && kB(l), Yn(null, l, K, M), l = l.child), l;
        case 16:
          U = l.elementType;
          A: {
            switch (Q !== null && (Q.alternate = null, l.alternate = null, l.flags |= 2), Q = l.pendingProps, K = U._init, U = K(U._payload), l.type = U, K = l.tag = WB(U), Q = Jg(U, Q), K) {
              case 0:
                l = el(null, l, U, Q, M);
                break A;
              case 1:
                l = oQ(
                  null,
                  l,
                  U,
                  Q,
                  M
                );
                break A;
              case 11:
                l = DI(null, l, U, Q, M);
                break A;
              case 14:
                l = bB(null, l, U, Jg(U.type, Q), M);
                break A;
            }
            throw Error(r(306, U, ""));
          }
          return l;
        case 0:
          return U = l.type, K = l.pendingProps, K = l.elementType === U ? K : Jg(U, K), el(Q, l, U, K, M);
        case 1:
          return U = l.type, K = l.pendingProps, K = l.elementType === U ? K : Jg(U, K), oQ(Q, l, U, K, M);
        case 3:
          A: {
            if (sQ(l), Q === null)
              throw Error(r(387));
            U = l.pendingProps, z = l.memoizedState, K = z.element, Ko(Q, l), sI(l, U, null, M);
            var uA = l.memoizedState;
            if (U = uA.element, vA && z.isDehydrated)
              if (z = {
                element: U,
                isDehydrated: !1,
                cache: uA.cache,
                transitions: uA.transitions
              }, l.updateQueue.baseState = z, l.memoizedState = z, l.flags & 256) {
                K = Error(r(423)), l = il(Q, l, U, M, K);
                break A;
              } else if (U !== K) {
                K = Error(r(424)), l = il(Q, l, U, M, K);
                break A;
              } else
                for (vA && (vn = se(l.stateNode.containerInfo), Ig = l, Di = !0, yg = null, ws = !1), M = uI(l, null, U, M), l.child = M; M; )
                  M.flags = M.flags & -3 | 4096, M = M.sibling;
            else {
              if (_o(), U === K) {
                l = rn(Q, l, M);
                break A;
              }
              Yn(Q, l, U, M);
            }
            l = l.child;
          }
          return l;
        case 5:
          return Rt(l), Q === null && lI(l), U = l.type, K = l.pendingProps, z = Q !== null ? Q.memoizedProps : null, uA = K.children, MA(U, K) ? uA = null : z !== null && MA(U, z) && (l.flags |= 32), Su(Q, l), Yn(Q, l, uA, M), l.child;
        case 6:
          return Q === null && lI(l), null;
        case 13:
          return Mu(Q, l, M);
        case 4:
          return Ms(l, l.stateNode.containerInfo), U = l.pendingProps, Q === null ? l.child = Ss(l, null, U, M) : Yn(Q, l, U, M), l.child;
        case 11:
          return U = l.type, K = l.pendingProps, K = l.elementType === U ? K : Jg(U, K), DI(Q, l, U, K, M);
        case 7:
          return Yn(Q, l, l.pendingProps, M), l.child;
        case 8:
          return Yn(Q, l, l.pendingProps.children, M), l.child;
        case 12:
          return Yn(Q, l, l.pendingProps.children, M), l.child;
        case 10:
          A: {
            if (U = l.type._context, K = l.pendingProps, z = l.memoizedProps, uA = K.value, FB(l, U, uA), z !== null)
              if (rr(z.value, uA)) {
                if (z.children === K.children && !Mt.current) {
                  l = rn(Q, l, M);
                  break A;
                }
              } else
                for (z = l.child, z !== null && (z.return = l); z !== null; ) {
                  var HA = z.dependencies;
                  if (HA !== null) {
                    uA = z.child;
                    for (var ae = HA.firstContext; ae !== null; ) {
                      if (ae.context === U) {
                        if (z.tag === 1) {
                          ae = xr(-1, M & -M), ae.tag = 2;
                          var Re = z.updateQueue;
                          if (Re !== null) {
                            Re = Re.shared;
                            var Ue = Re.pending;
                            Ue === null ? ae.next = ae : (ae.next = Ue.next, Ue.next = ae), Re.pending = ae;
                          }
                        }
                        z.lanes |= M, ae = z.alternate, ae !== null && (ae.lanes |= M), Ba(z.return, M, l), HA.lanes |= M;
                        break;
                      }
                      ae = ae.next;
                    }
                  } else if (z.tag === 10)
                    uA = z.type === l.type ? null : z.child;
                  else if (z.tag === 18) {
                    if (uA = z.return, uA === null)
                      throw Error(r(341));
                    uA.lanes |= M, HA = uA.alternate, HA !== null && (HA.lanes |= M), Ba(uA, M, l), uA = z.sibling;
                  } else
                    uA = z.child;
                  if (uA !== null)
                    uA.return = z;
                  else
                    for (uA = z; uA !== null; ) {
                      if (uA === l) {
                        uA = null;
                        break;
                      }
                      if (z = uA.sibling, z !== null) {
                        z.return = uA.return, uA = z;
                        break;
                      }
                      uA = uA.return;
                    }
                  z = uA;
                }
            Yn(Q, l, K.children, M), l = l.child;
          }
          return l;
        case 9:
          return K = l.type, U = l.pendingProps.children, qn(l, M), K = pg(K), U = U(K), l.flags |= 1, Yn(Q, l, U, M), l.child;
        case 14:
          return U = l.type, K = Jg(U, l.pendingProps), K = Jg(U.type, K), bB(Q, l, U, K, M);
        case 15:
          return yu(Q, l, l.type, l.pendingProps, M);
        case 17:
          return U = l.type, K = l.pendingProps, K = l.elementType === U ? K : Jg(U, K), Q !== null && (Q.alternate = null, l.alternate = null, l.flags |= 2), l.tag = 1, An(U) ? (Q = !0, xo(l)) : Q = !1, qn(l, M), nQ(l, U, K), UB(l, U, K, M), tl(null, l, U, !0, Q, M);
        case 19:
          return BQ(Q, l, M);
        case 22:
          return mu(Q, l, M);
      }
      throw Error(r(156, l.tag));
    };
    function kI(Q, l) {
      return ao(Q, l);
    }
    function PB(Q, l, M, U) {
      this.tag = Q, this.key = M, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = U, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function gg(Q, l, M, U) {
      return new PB(Q, l, M, U);
    }
    function Na(Q) {
      return Q = Q.prototype, !(!Q || !Q.isReactComponent);
    }
    function WB(Q) {
      if (typeof Q == "function")
        return Na(Q) ? 1 : 0;
      if (Q != null) {
        if (Q = Q.$$typeof, Q === p)
          return 11;
        if (Q === S)
          return 14;
      }
      return 2;
    }
    function Gg(Q, l) {
      var M = Q.alternate;
      return M === null ? (M = gg(Q.tag, l, Q.key, Q.mode), M.elementType = Q.elementType, M.type = Q.type, M.stateNode = Q.stateNode, M.alternate = Q, Q.alternate = M) : (M.pendingProps = l, M.type = Q.type, M.flags = 0, M.subtreeFlags = 0, M.deletions = null), M.flags = Q.flags & 14680064, M.childLanes = Q.childLanes, M.lanes = Q.lanes, M.child = Q.child, M.memoizedProps = Q.memoizedProps, M.memoizedState = Q.memoizedState, M.updateQueue = Q.updateQueue, l = Q.dependencies, M.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }, M.sibling = Q.sibling, M.index = Q.index, M.ref = Q.ref, M;
    }
    function Fa(Q, l, M, U, K, z) {
      var uA = 2;
      if (U = Q, typeof Q == "function")
        Na(Q) && (uA = 1);
      else if (typeof Q == "string")
        uA = 5;
      else
        A:
          switch (Q) {
            case E:
              return Hs(M.children, K, z, l);
            case C:
              uA = 8, K |= 8;
              break;
            case c:
              return Q = gg(12, M, l, K | 2), Q.elementType = c, Q.lanes = z, Q;
            case D:
              return Q = gg(13, M, l, K), Q.elementType = D, Q.lanes = z, Q;
            case f:
              return Q = gg(19, M, l, K), Q.elementType = f, Q.lanes = z, Q;
            case m:
              return zB(M, K, z, l);
            default:
              if (typeof Q == "object" && Q !== null)
                switch (Q.$$typeof) {
                  case u:
                    uA = 10;
                    break A;
                  case d:
                    uA = 9;
                    break A;
                  case p:
                    uA = 11;
                    break A;
                  case S:
                    uA = 14;
                    break A;
                  case y:
                    uA = 16, U = null;
                    break A;
                }
              throw Error(r(130, Q == null ? Q : typeof Q, ""));
          }
      return l = gg(uA, M, l, K), l.elementType = Q, l.type = U, l.lanes = z, l;
    }
    function Hs(Q, l, M, U) {
      return Q = gg(7, Q, U, l), Q.lanes = M, Q;
    }
    function zB(Q, l, M, U) {
      return Q = gg(22, Q, U, l), Q.elementType = m, Q.lanes = M, Q.stateNode = {}, Q;
    }
    function dQ(Q, l, M) {
      return Q = gg(6, Q, null, l), Q.lanes = M, Q;
    }
    function VB(Q, l, M) {
      return l = gg(4, Q.children !== null ? Q.children : [], Q.key, l), l.lanes = M, l.stateNode = { containerInfo: Q.containerInfo, pendingChildren: null, implementation: Q.implementation }, l;
    }
    function Xf(Q, l, M, U, K) {
      this.tag = l, this.containerInfo = Q, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = yA, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = nI(0), this.expirationTimes = nI(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = nI(0), this.identifierPrefix = U, this.onRecoverableError = K, vA && (this.mutableSourceEagerHydrationData = null);
    }
    function bu(Q, l, M, U, K, z, uA, HA, ae) {
      return Q = new Xf(Q, l, M, HA, ae), l === 1 ? (l = 1, z === !0 && (l |= 8)) : l = 0, z = gg(3, null, null, l), Q.current = z, z.stateNode = Q, z.memoizedState = { element: U, isDehydrated: M, cache: null, transitions: null }, GB(z), Q;
    }
    function lr(Q) {
      if (!Q)
        return pi;
      Q = Q._reactInternals;
      A: {
        if (v(Q) !== Q || Q.tag !== 1)
          throw Error(r(170));
        var l = Q;
        do {
          switch (l.tag) {
            case 3:
              l = l.stateNode.context;
              break A;
            case 1:
              if (An(l.type)) {
                l = l.stateNode.__reactInternalMemoizedMergedChildContext;
                break A;
              }
          }
          l = l.return;
        } while (l !== null);
        throw Error(r(171));
      }
      if (Q.tag === 1) {
        var M = Q.type;
        if (An(M))
          return DB(Q, M, l);
      }
      return l;
    }
    function jB(Q) {
      var l = Q._reactInternals;
      if (l === void 0)
        throw typeof Q.render == "function" ? Error(r(188)) : (Q = Object.keys(Q).join(","), Error(r(268, Q)));
      return Q = _(l), Q === null ? null : Q.stateNode;
    }
    function xI(Q, l) {
      if (Q = Q.memoizedState, Q !== null && Q.dehydrated !== null) {
        var M = Q.retryLane;
        Q.retryLane = M !== 0 && M < l ? M : l;
      }
    }
    function LI(Q, l) {
      xI(Q, l), (Q = Q.alternate) && xI(Q, l);
    }
    function TI(Q) {
      return Q = _(Q), Q === null ? null : Q.stateNode;
    }
    function pl() {
      return null;
    }
    return e.attemptContinuousHydration = function(Q) {
      if (Q.tag === 13) {
        var l = ng();
        Cr(Q, 134217728, l), LI(Q, 134217728);
      }
    }, e.attemptHydrationAtCurrentPriority = function(Q) {
      if (Q.tag === 13) {
        var l = ng(), M = bs(Q);
        Cr(Q, M, l), LI(Q, M);
      }
    }, e.attemptSynchronousHydration = function(Q) {
      switch (Q.tag) {
        case 3:
          var l = Q.stateNode;
          if (l.current.memoizedState.isDehydrated) {
            var M = oo(l.pendingLanes);
            M !== 0 && (yB(l, M | 1), Fg(l, ki()), !(Tt & 6) && (GI(), Gn()));
          }
          break;
        case 13:
          var U = ng();
          hl(function() {
            return Cr(Q, 1, U);
          }), LI(Q, 1);
      }
    }, e.batchedUpdates = function(Q, l) {
      var M = Tt;
      Tt |= 1;
      try {
        return Q(l);
      } finally {
        Tt = M, Tt === 0 && (GI(), oa && Gn());
      }
    }, e.createComponentSelector = function(Q) {
      return { $$typeof: EQ, value: Q };
    }, e.createContainer = function(Q, l, M, U, K, z, uA) {
      return bu(Q, l, !1, null, M, U, K, z, uA);
    }, e.createHasPseudoClassSelector = function(Q) {
      return { $$typeof: on, value: Q };
    }, e.createHydrationContainer = function(Q, l, M, U, K, z, uA, HA, ae) {
      return Q = bu(M, U, !0, Q, K, z, uA, HA, ae), Q.context = lr(null), M = Q.current, U = ng(), K = bs(M), z = xr(U, K), z.callback = l ?? null, ag(M, z), Q.current.lanes = K, vr(Q, K, U), Fg(Q, U), Q;
    }, e.createPortal = function(Q, l, M) {
      var U = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return { $$typeof: I, key: U == null ? null : "" + U, children: Q, containerInfo: l, implementation: M };
    }, e.createRoleSelector = function(Q) {
      return { $$typeof: ma, value: Q };
    }, e.createTestNameSelector = function(Q) {
      return { $$typeof: YB, value: Q };
    }, e.createTextSelector = function(Q) {
      return { $$typeof: zo, value: Q };
    }, e.deferredUpdates = function(Q) {
      var l = $t, M = sn.transition;
      try {
        return sn.transition = null, $t = 16, Q();
      } finally {
        $t = l, sn.transition = M;
      }
    }, e.discreteUpdates = function(Q, l, M, U, K) {
      var z = $t, uA = sn.transition;
      try {
        return sn.transition = null, $t = 1, Q(l, M, U, K);
      } finally {
        $t = z, sn.transition = uA, Tt === 0 && GI();
      }
    }, e.findAllNodes = Ye, e.findBoundingRects = function(Q, l) {
      if (!de)
        throw Error(r(363));
      l = Ye(Q, l), Q = [];
      for (var M = 0; M < l.length; M++)
        Q.push(AA(l[M]));
      for (l = Q.length - 1; 0 < l; l--) {
        M = Q[l];
        for (var U = M.x, K = U + M.width, z = M.y, uA = z + M.height, HA = l - 1; 0 <= HA; HA--)
          if (l !== HA) {
            var ae = Q[HA], Re = ae.x, Ue = Re + ae.width, Qt = ae.y, gt = Qt + ae.height;
            if (U >= Re && z >= Qt && K <= Ue && uA <= gt) {
              Q.splice(l, 1);
              break;
            } else if (U !== Re || M.width !== ae.width || gt < z || Qt > uA) {
              if (!(z !== Qt || M.height !== ae.height || Ue < U || Re > K)) {
                Re > U && (ae.width += Re - U, ae.x = U), Ue < K && (ae.width = K - Re), Q.splice(l, 1);
                break;
              }
            } else {
              Qt > z && (ae.height += Qt - z, ae.y = z), gt < uA && (ae.height = uA - Qt), Q.splice(l, 1);
              break;
            }
          }
      }
      return Q;
    }, e.findHostInstance = jB, e.findHostInstanceWithNoPortals = function(Q) {
      return Q = H(Q), Q = Q !== null ? V(Q) : null, Q === null ? null : Q.stateNode;
    }, e.findHostInstanceWithWarning = function(Q) {
      return jB(Q);
    }, e.flushControlled = function(Q) {
      var l = Tt;
      Tt |= 1;
      var M = sn.transition, U = $t;
      try {
        sn.transition = null, $t = 1, Q();
      } finally {
        $t = U, sn.transition = M, Tt = l, Tt === 0 && (GI(), Gn());
      }
    }, e.flushPassiveEffects = Ma, e.flushSync = hl, e.focusWithin = function(Q, l) {
      if (!de)
        throw Error(r(363));
      for (Q = Il(Q), l = Pn(Q, l), l = Array.from(l), Q = 0; Q < l.length; ) {
        var M = l[Q++];
        if (!Z(M)) {
          if (M.tag === 5 && BA(M.stateNode))
            return !0;
          for (M = M.child; M !== null; )
            l.push(M), M = M.sibling;
        }
      }
      return !1;
    }, e.getCurrentUpdatePriority = function() {
      return $t;
    }, e.getFindAllNodesFailureDescription = function(Q, l) {
      if (!de)
        throw Error(r(363));
      var M = 0, U = [];
      Q = [Il(Q), 0];
      for (var K = 0; K < Q.length; ) {
        var z = Q[K++], uA = Q[K++], HA = l[uA];
        if ((z.tag !== 5 || !Z(z)) && (Bl(z, HA) && (U.push(Ls(HA)), uA++, uA > M && (M = uA)), uA < l.length))
          for (z = z.child; z !== null; )
            Q.push(z, uA), z = z.sibling;
      }
      if (M < l.length) {
        for (Q = []; M < l.length; M++)
          Q.push(Ls(l[M]));
        return `findAllNodes was able to match part of the selector:
  ` + (U.join(" > ") + `

No matching component was found for:
  `) + Q.join(" > ");
      }
      return null;
    }, e.getPublicRootInstance = function(Q) {
      if (Q = Q.current, !Q.child)
        return null;
      switch (Q.child.tag) {
        case 5:
          return eA(Q.child.stateNode);
        default:
          return Q.child.stateNode;
      }
    }, e.injectIntoDevTools = function(Q) {
      if (Q = { bundleType: Q.bundleType, version: Q.version, rendererPackageName: Q.rendererPackageName, rendererConfig: Q.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: s.ReactCurrentDispatcher, findHostInstanceByFiber: TI, findFiberByHostInstance: Q.findFiberByHostInstance || pl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        Q = !1;
      else {
        var l = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (l.isDisabled || !l.supportsFiber)
          Q = !0;
        else {
          try {
            Lo = l.inject(Q), gr = l;
          } catch {
          }
          Q = !!l.checkDCE;
        }
      }
      return Q;
    }, e.isAlreadyRendering = function() {
      return !1;
    }, e.observeVisibleRects = function(Q, l, M, U) {
      if (!de)
        throw Error(r(363));
      Q = Ye(Q, l);
      var K = GA(Q, M, U).disconnect;
      return { disconnect: function() {
        K();
      } };
    }, e.registerMutableSourceForHydration = function(Q, l) {
      var M = l._getVersion;
      M = M(l._source), Q.mutableSourceEagerHydrationData == null ? Q.mutableSourceEagerHydrationData = [l, M] : Q.mutableSourceEagerHydrationData.push(l, M);
    }, e.runWithPriority = function(Q, l) {
      var M = $t;
      try {
        return $t = Q, l();
      } finally {
        $t = M;
      }
    }, e.shouldError = function() {
      return null;
    }, e.shouldSuspend = function() {
      return !1;
    }, e.updateContainer = function(Q, l, M, U) {
      var K = l.current, z = ng(), uA = bs(K);
      return M = lr(M), l.context === null ? l.context = M : l.pendingContext = M, l = xr(z, uA), l.payload = { element: Q }, U = U === void 0 ? null : U, U !== null && (l.callback = U), ag(K, l), Q = Cr(K, uA, z), Q !== null && oI(Q, K, uA), uA;
    }, e;
  }), G0;
}
var Qf = {}, l3 = {
  get exports() {
    return Qf;
  },
  set exports(g) {
    Qf = g;
  }
};
/**
 * @license React
 * react-reconciler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XN;
function c3() {
  return XN || (XN = 1, process.env.NODE_ENV !== "production" && (l3.exports = function(A) {
    var e = {}, t = qi, i = MU(), n = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, r = !1;
    function s(o) {
      r = o;
    }
    function B(o) {
      if (!r) {
        for (var a = arguments.length, h = new Array(a > 1 ? a - 1 : 0), w = 1; w < a; w++)
          h[w - 1] = arguments[w];
        E("warn", o, h);
      }
    }
    function I(o) {
      if (!r) {
        for (var a = arguments.length, h = new Array(a > 1 ? a - 1 : 0), w = 1; w < a; w++)
          h[w - 1] = arguments[w];
        E("error", o, h);
      }
    }
    function E(o, a, h) {
      {
        var w = n.ReactDebugCurrentFrame, R = w.getStackAddendum();
        R !== "" && (a += "%s", h = h.concat([R]));
        var L = h.map(function(W) {
          return String(W);
        });
        L.unshift("Warning: " + a), Function.prototype.apply.call(console[o], console, L);
      }
    }
    var C = Object.assign;
    function c(o) {
      return o._reactInternals;
    }
    function u(o, a) {
      o._reactInternals = a;
    }
    var d = !1, p = !1, D = !1, f = !1, S = !1, y = !1, m = !0, N = !0, F = !0, G = 0, k = 1, v = 2, x = 3, H = 4, _ = 5, j = 6, V = 7, iA = 8, eA = 9, oA = 10, P = 11, J = 12, tA = 13, Y = 14, rA = 15, QA = 16, aA = 17, MA = 18, hA = 19, fA = 21, wA = 22, yA = 23, kA = 24, FA = 25, dA = Symbol.for("react.element"), vA = Symbol.for("react.portal"), JA = Symbol.for("react.fragment"), ne = Symbol.for("react.strict_mode"), ee = Symbol.for("react.profiler"), pe = Symbol.for("react.provider"), Ae = Symbol.for("react.context"), ie = Symbol.for("react.forward_ref"), de = Symbol.for("react.suspense"), O = Symbol.for("react.suspense_list"), AA = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), Z = Symbol.for("react.scope"), $ = Symbol.for("react.debug_trace_mode"), BA = Symbol.for("react.offscreen"), GA = Symbol.for("react.legacy_hidden"), bA = Symbol.for("react.cache"), DA = Symbol.for("react.tracing_marker"), SA = Symbol.iterator, EA = "@@iterator";
    function mA(o) {
      if (o === null || typeof o != "object")
        return null;
      var a = SA && o[SA] || o[EA];
      return typeof a == "function" ? a : null;
    }
    function YA(o, a, h) {
      var w = o.displayName;
      if (w)
        return w;
      var R = a.displayName || a.name || "";
      return R !== "" ? h + "(" + R + ")" : h;
    }
    function ZA(o) {
      return o.displayName || "Context";
    }
    function _A(o) {
      if (o == null)
        return null;
      if (typeof o.tag == "number" && I("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof o == "function")
        return o.displayName || o.name || null;
      if (typeof o == "string")
        return o;
      switch (o) {
        case JA:
          return "Fragment";
        case vA:
          return "Portal";
        case ee:
          return "Profiler";
        case ne:
          return "StrictMode";
        case de:
          return "Suspense";
        case O:
          return "SuspenseList";
      }
      if (typeof o == "object")
        switch (o.$$typeof) {
          case Ae:
            var a = o;
            return ZA(a) + ".Consumer";
          case pe:
            var h = o;
            return ZA(h._context) + ".Provider";
          case ie:
            return YA(o, o.render, "ForwardRef");
          case AA:
            var w = o.displayName || null;
            return w !== null ? w : _A(o.type) || "Memo";
          case q: {
            var R = o, L = R._payload, W = R._init;
            try {
              return _A(W(L));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Se(o, a, h) {
      var w = a.displayName || a.name || "";
      return o.displayName || (w !== "" ? h + "(" + w + ")" : h);
    }
    function cA(o) {
      return o.displayName || "Context";
    }
    function xA(o) {
      var a = o.tag, h = o.type;
      switch (a) {
        case kA:
          return "Cache";
        case eA:
          var w = h;
          return cA(w) + ".Consumer";
        case oA:
          var R = h;
          return cA(R._context) + ".Provider";
        case MA:
          return "DehydratedFragment";
        case P:
          return Se(h, h.render, "ForwardRef");
        case V:
          return "Fragment";
        case _:
          return h;
        case H:
          return "Portal";
        case x:
          return "Root";
        case j:
          return "Text";
        case QA:
          return _A(h);
        case iA:
          return h === ne ? "StrictMode" : "Mode";
        case wA:
          return "Offscreen";
        case J:
          return "Profiler";
        case fA:
          return "Scope";
        case tA:
          return "Suspense";
        case hA:
          return "SuspenseList";
        case FA:
          return "TracingMarker";
        case k:
        case G:
        case aA:
        case v:
        case Y:
        case rA:
          if (typeof h == "function")
            return h.displayName || h.name || null;
          if (typeof h == "string")
            return h;
          break;
      }
      return null;
    }
    var gA = (
      /*                      */
      0
    ), RA = (
      /*                */
      1
    ), UA = (
      /*                    */
      2
    ), TA = (
      /*                       */
      4
    ), ge = (
      /*           */
      UA | TA
    ), Me = (
      /*                */
      16
    ), xe = (
      /*                 */
      32
    ), we = (
      /*                     */
      64
    ), Ee = (
      /*                   */
      128
    ), he = (
      /*            */
      256
    ), _e = (
      /*                          */
      512
    ), Pe = (
      /*                     */
      1024
    ), Nt = (
      /*                      */
      2048
    ), Jt = (
      /*                    */
      4096
    ), vi = (
      /*           */
      Jt | TA
    ), je = (
      /*                   */
      8192
    ), Ri = (
      /*             */
      16384
    ), lA = Nt | TA | we | _e | Pe | Ri, jA = (
      /*               */
      32767
    ), se = (
      /*                   */
      32768
    ), PA = (
      /*                */
      65536
    ), Be = (
      /* */
      131072
    ), At = (
      /*                       */
      1048576
    ), rt = (
      /*                    */
      2097152
    ), it = (
      /*                 */
      4194304
    ), Et = (
      /*                */
      8388608
    ), Bt = (
      /*               */
      16777216
    ), ft = (
      /*              */
      33554432
    ), tt = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      TA | Pe | 0
    ), Ft = UA | TA | Me | xe | _e | Jt | je, ui = TA | we | _e | je, Li = Nt | Me, $i = it | Et | rt, hi = n.ReactCurrentOwner;
    function pt(o) {
      var a = o, h = o;
      if (o.alternate)
        for (; a.return; )
          a = a.return;
      else {
        var w = a;
        do
          a = w, (a.flags & (UA | Jt)) !== gA && (h = a.return), w = a.return;
        while (w);
      }
      return a.tag === x ? h : null;
    }
    function Gr(o) {
      return pt(o) === o;
    }
    function Ui(o) {
      {
        var a = hi.current;
        if (a !== null && a.tag === k) {
          var h = a, w = h.stateNode;
          w._warnedAboutRefsInRender || I("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", xA(h) || "A component"), w._warnedAboutRefsInRender = !0;
        }
      }
      var R = c(o);
      return R ? pt(R) === R : !1;
    }
    function Rn(o) {
      if (pt(o) !== o)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function St(o) {
      var a = o.alternate;
      if (!a) {
        var h = pt(o);
        if (h === null)
          throw new Error("Unable to find node on an unmounted component.");
        return h !== o ? null : o;
      }
      for (var w = o, R = a; ; ) {
        var L = w.return;
        if (L === null)
          break;
        var W = L.alternate;
        if (W === null) {
          var nA = L.return;
          if (nA !== null) {
            w = R = nA;
            continue;
          }
          break;
        }
        if (L.child === W.child) {
          for (var sA = L.child; sA; ) {
            if (sA === w)
              return Rn(L), o;
            if (sA === R)
              return Rn(L), a;
            sA = sA.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (w.return !== R.return)
          w = L, R = W;
        else {
          for (var pA = !1, LA = L.child; LA; ) {
            if (LA === w) {
              pA = !0, w = L, R = W;
              break;
            }
            if (LA === R) {
              pA = !0, R = L, w = W;
              break;
            }
            LA = LA.sibling;
          }
          if (!pA) {
            for (LA = W.child; LA; ) {
              if (LA === w) {
                pA = !0, w = W, R = L;
                break;
              }
              if (LA === R) {
                pA = !0, R = W, w = L;
                break;
              }
              LA = LA.sibling;
            }
            if (!pA)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (w.alternate !== R)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (w.tag !== x)
        throw new Error("Unable to find node on an unmounted component.");
      return w.stateNode.current === w ? o : a;
    }
    function Nn(o) {
      var a = St(o);
      return a !== null ? Wt(a) : null;
    }
    function Wt(o) {
      if (o.tag === _ || o.tag === j)
        return o;
      for (var a = o.child; a !== null; ) {
        var h = Wt(a);
        if (h !== null)
          return h;
        a = a.sibling;
      }
      return null;
    }
    function ot(o) {
      var a = St(o);
      return a !== null ? pi(a) : null;
    }
    function pi(o) {
      if (o.tag === _ || o.tag === j)
        return o;
      for (var a = o.child; a !== null; ) {
        if (a.tag !== H) {
          var h = pi(a);
          if (h !== null)
            return h;
        }
        a = a.sibling;
      }
      return null;
    }
    var zi = Array.isArray;
    function Mt(o) {
      return zi(o);
    }
    var sg = A.getPublicInstance, nr = A.getRootHostContext, An = A.getChildHostContext, na = A.prepareForCommit, ZC = A.resetAfterCommit, DB = A.createInstance, xo = A.appendInitialChild, tI = A.finalizeInitialChildren, fg = A.prepareUpdate, wB = A.shouldSetTextContent, ds = A.createTextInstance, iI = A.scheduleTimeout, ro = A.cancelTimeout, fs = A.noTimeout;
    A.now;
    var oo = A.isPrimaryRenderer, so = A.warnsIfNotActing, _g = A.supportsMutation, ga = A.supportsPersistence, fn = A.supportsHydration, nI = A.getInstanceFromNode;
    A.beforeActiveInstanceBlur, A.afterActiveInstanceBlur;
    var vr = A.preparePortalMount;
    A.preparePortalMount, A.getInstanceFromScope;
    var VE = A.getCurrentEventPriority, yB = A.detachDeletedInstance, $t = A.supportsMicrotasks, XC = A.scheduleMicrotask, ao = A.supportsTestSelectors, Ur = A.findFiberRoot, mB = A.getBoundingRect, $C = A.getTextContent, ki = A.isHiddenSubtree, ra = A.matchAccessibilityRole, jE = A.setFocusIfFocusable, SB = A.setupIntersectionObserver, ZE = A.appendChild, Lo = A.appendChildToContainer, gr = A.commitTextUpdate, XE = A.commitMount, $E = A.commitUpdate, rr = A.insertBefore, Fn = A.insertInContainerBefore, oa = A.removeChild, MB = A.removeChildFromContainer, RB = A.resetTextContent, Al = A.hideInstance, Gn = A.hideTextInstance, AQ = A.unhideInstance, gI = A.unhideTextInstance, sa = A.clearContainer, Jg = A.cloneInstance, aa = A.createContainerChildSet, Ia = A.appendChildToContainerChildSet, kr = A.finalizeContainerChildren, To = A.replaceContainerChildren;
    A.getOffscreenContainerType;
    var NB = A.getOffscreenContainerProps, FB = A.cloneHiddenInstance, rI = A.cloneHiddenTextInstance, Ba = A.canHydrateInstance, qn = A.canHydrateTextInstance, pg = A.canHydrateSuspenseInstance, Og = A.isSuspenseInstancePending, or = A.isSuspenseInstanceFallback, GB = A.registerSuspenseInstanceRetry, Ko = A.getNextHydratableSibling, xr = A.getFirstHydratableChild, ag = A.getFirstHydratableChildWithinContainer, oI = A.getFirstHydratableChildWithinSuspenseInstance, eQ = A.hydrateInstance, sI = A.hydrateTextInstance, tQ = A.hydrateSuspenseInstance, iQ = A.getNextHydratableInstanceAfterSuspenseInstance, aI = A.commitHydratedContainer, II = A.commitHydratedSuspenseInstance, vB = A.clearSuspenseBoundary, nQ = A.clearSuspenseBoundaryFromContainer, gQ = A.shouldDeleteUnhydratedTailInstances, UB = A.didNotMatchHydratedContainerTextInstance, ps = A.didNotMatchHydratedTextInstance, Ds = A.didNotHydrateInstanceWithinContainer, BI = A.didNotHydrateInstanceWithinSuspenseInstance, CI = A.didNotHydrateInstance, Dg = A.didNotFindHydratableInstanceWithinContainer, wg = A.didNotFindHydratableTextInstanceWithinContainer, bo = A.didNotFindHydratableSuspenseInstanceWithinContainer, Lr = A.didNotFindHydratableInstanceWithinSuspenseInstance, Tr = A.didNotFindHydratableTextInstanceWithinSuspenseInstance, Yo = A.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance, QI = A.didNotFindHydratableInstance, kB = A.didNotFindHydratableTextInstance, Ho = A.didNotFindHydratableSuspenseInstance, Ig = A.errorHydratingContainer, vn = 0, Di, ws, yg, xB, LB, EI, lI;
    function ys() {
    }
    ys.__reactDisabledLog = !0;
    function Ca() {
      {
        if (vn === 0) {
          Di = console.log, ws = console.info, yg = console.warn, xB = console.error, LB = console.group, EI = console.groupCollapsed, lI = console.groupEnd;
          var o = {
            configurable: !0,
            enumerable: !0,
            value: ys,
            writable: !0
          };
          Object.defineProperties(console, {
            info: o,
            log: o,
            warn: o,
            error: o,
            group: o,
            groupCollapsed: o,
            groupEnd: o
          });
        }
        vn++;
      }
    }
    function _o() {
      {
        if (vn--, vn === 0) {
          var o = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: C({}, o, {
              value: Di
            }),
            info: C({}, o, {
              value: ws
            }),
            warn: C({}, o, {
              value: yg
            }),
            error: C({}, o, {
              value: xB
            }),
            group: C({}, o, {
              value: LB
            }),
            groupCollapsed: C({}, o, {
              value: EI
            }),
            groupEnd: C({}, o, {
              value: lI
            })
          });
        }
        vn < 0 && I("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ms = n.ReactCurrentDispatcher, Jo;
    function qg(o, a, h) {
      {
        if (Jo === void 0)
          try {
            throw Error();
          } catch (R) {
            var w = R.stack.trim().match(/\n( *(at )?)/);
            Jo = w && w[1] || "";
          }
        return `
` + Jo + o;
      }
    }
    var cI = !1, Qa;
    {
      var Ss = typeof WeakMap == "function" ? WeakMap : Map;
      Qa = new Ss();
    }
    function uI(o, a) {
      if (!o || cI)
        return "";
      {
        var h = Qa.get(o);
        if (h !== void 0)
          return h;
      }
      var w;
      cI = !0;
      var R = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var L;
      L = ms.current, ms.current = null, Ca();
      try {
        if (a) {
          var W = function() {
            throw Error();
          };
          if (Object.defineProperty(W.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(W, []);
            } catch (me) {
              w = me;
            }
            Reflect.construct(o, [], W);
          } else {
            try {
              W.call();
            } catch (me) {
              w = me;
            }
            o.call(W.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (me) {
            w = me;
          }
          o();
        }
      } catch (me) {
        if (me && w && typeof me.stack == "string") {
          for (var nA = me.stack.split(`
`), sA = w.stack.split(`
`), pA = nA.length - 1, LA = sA.length - 1; pA >= 1 && LA >= 0 && nA[pA] !== sA[LA]; )
            LA--;
          for (; pA >= 1 && LA >= 0; pA--, LA--)
            if (nA[pA] !== sA[LA]) {
              if (pA !== 1 || LA !== 1)
                do
                  if (pA--, LA--, LA < 0 || nA[pA] !== sA[LA]) {
                    var VA = `
` + nA[pA].replace(" at new ", " at ");
                    return o.displayName && VA.includes("<anonymous>") && (VA = VA.replace("<anonymous>", o.displayName)), typeof o == "function" && Qa.set(o, VA), VA;
                  }
                while (pA >= 1 && LA >= 0);
              break;
            }
        }
      } finally {
        cI = !1, ms.current = L, _o(), Error.prepareStackTrace = R;
      }
      var oe = o ? o.displayName || o.name : "", Qe = oe ? qg(oe) : "";
      return typeof o == "function" && Qa.set(o, Qe), Qe;
    }
    function Ea(o, a, h) {
      return uI(o, !0);
    }
    function Ti(o, a, h) {
      return uI(o, !1);
    }
    function la(o) {
      var a = o.prototype;
      return !!(a && a.isReactComponent);
    }
    function Kr(o, a, h) {
      if (o == null)
        return "";
      if (typeof o == "function")
        return uI(o, la(o));
      if (typeof o == "string")
        return qg(o);
      switch (o) {
        case de:
          return qg("Suspense");
        case O:
          return qg("SuspenseList");
      }
      if (typeof o == "object")
        switch (o.$$typeof) {
          case ie:
            return Ti(o.render);
          case AA:
            return Kr(o.type, a, h);
          case q: {
            var w = o, R = w._payload, L = w._init;
            try {
              return Kr(L(R), a, h);
            } catch {
            }
          }
        }
      return "";
    }
    var en = Object.prototype.hasOwnProperty, Ms = {}, Oo = n.ReactDebugCurrentFrame;
    function Rt(o) {
      if (o) {
        var a = o._owner, h = Kr(o.type, o._source, a ? a.type : null);
        Oo.setExtraStackFrame(h);
      } else
        Oo.setExtraStackFrame(null);
    }
    function Vi(o, a, h, w, R) {
      {
        var L = Function.call.bind(en);
        for (var W in o)
          if (L(o, W)) {
            var nA = void 0;
            try {
              if (typeof o[W] != "function") {
                var sA = Error((w || "React class") + ": " + h + " type `" + W + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[W] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw sA.name = "Invariant Violation", sA;
              }
              nA = o[W](a, W, w, h, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (pA) {
              nA = pA;
            }
            nA && !(nA instanceof Error) && (Rt(R), I("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", w || "React class", h, W, typeof nA), Rt(null)), nA instanceof Error && !(nA.message in Ms) && (Ms[nA.message] = !0, Rt(R), I("Failed %s type: %s", h, nA.message), Rt(null));
          }
      }
    }
    var di = [], br;
    br = [];
    var lt = -1;
    function ht(o) {
      return {
        current: o
      };
    }
    function ji(o, a) {
      if (lt < 0) {
        I("Unexpected pop.");
        return;
      }
      a !== br[lt] && I("Unexpected Fiber popped."), o.current = di[lt], di[lt] = null, br[lt] = null, lt--;
    }
    function Ci(o, a, h) {
      lt++, di[lt] = o.current, br[lt] = h, o.current = a;
    }
    var Io;
    Io = {};
    var qt = {};
    Object.freeze(qt);
    var mi = ht(qt), Ei = ht(!1), Rs = qt;
    function sr(o, a, h) {
      return h && mg(a) ? Rs : mi.current;
    }
    function Ns(o, a, h) {
      {
        var w = o.stateNode;
        w.__reactInternalMemoizedUnmaskedChildContext = a, w.__reactInternalMemoizedMaskedChildContext = h;
      }
    }
    function Fs(o, a) {
      {
        var h = o.type, w = h.contextTypes;
        if (!w)
          return qt;
        var R = o.stateNode;
        if (R && R.__reactInternalMemoizedUnmaskedChildContext === a)
          return R.__reactInternalMemoizedMaskedChildContext;
        var L = {};
        for (var W in w)
          L[W] = a[W];
        {
          var nA = xA(o) || "Unknown";
          Vi(w, L, "context", nA);
        }
        return R && Ns(o, a, L), L;
      }
    }
    function tn() {
      return Ei.current;
    }
    function mg(o) {
      {
        var a = o.childContextTypes;
        return a != null;
      }
    }
    function Gs(o) {
      ji(Ei, o), ji(mi, o);
    }
    function ca(o) {
      ji(Ei, o), ji(mi, o);
    }
    function ar(o, a, h) {
      {
        if (mi.current !== qt)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Ci(mi, a, o), Ci(Ei, h, o);
      }
    }
    function Pg(o, a, h) {
      {
        var w = o.stateNode, R = a.childContextTypes;
        if (typeof w.getChildContext != "function") {
          {
            var L = xA(o) || "Unknown";
            Io[L] || (Io[L] = !0, I("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", L, L));
          }
          return h;
        }
        var W = w.getChildContext();
        for (var nA in W)
          if (!(nA in R))
            throw new Error((xA(o) || "Unknown") + '.getChildContext(): key "' + nA + '" is not defined in childContextTypes.');
        {
          var sA = xA(o) || "Unknown";
          Vi(R, W, "child context", sA);
        }
        return C({}, h, W);
      }
    }
    function Ir(o) {
      {
        var a = o.stateNode, h = a && a.__reactInternalMemoizedMergedChildContext || qt;
        return Rs = mi.current, Ci(mi, h, o), Ci(Ei, Ei.current, o), !0;
      }
    }
    function ua(o, a, h) {
      {
        var w = o.stateNode;
        if (!w)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (h) {
          var R = Pg(o, a, Rs);
          w.__reactInternalMemoizedMergedChildContext = R, ji(Ei, o), ji(mi, o), Ci(mi, R, o), Ci(Ei, h, o);
        } else
          ji(Ei, o), Ci(Ei, h, o);
      }
    }
    function hI(o) {
      {
        if (!Gr(o) || o.tag !== k)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var a = o;
        do {
          switch (a.tag) {
            case x:
              return a.stateNode.context;
            case k: {
              var h = a.type;
              if (mg(h))
                return a.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          a = a.return;
        } while (a !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var qo = 0, TB = 1, Ct = (
      /*                         */
      0
    ), si = (
      /*                 */
      1
    ), zt = (
      /*                    */
      2
    ), Ki = (
      /*               */
      8
    ), Sg = (
      /*              */
      16
    ), vs = Math.clz32 ? Math.clz32 : fI, rQ = Math.log, dI = Math.LN2;
    function fI(o) {
      var a = o >>> 0;
      return a === 0 ? 32 : 31 - (rQ(a) / dI | 0) | 0;
    }
    var ha = 31, De = (
      /*                        */
      0
    ), nn = (
      /*                          */
      0
    ), Lt = (
      /*                        */
      1
    ), Po = (
      /*    */
      2
    ), Yr = (
      /*            */
      4
    ), Hr = (
      /*            */
      8
    ), Br = (
      /*                    */
      16
    ), Us = (
      /*                */
      32
    ), ks = (
      /*                       */
      4194240
    ), _r = (
      /*                        */
      64
    ), KB = (
      /*                        */
      128
    ), pI = (
      /*                        */
      256
    ), T = (
      /*                        */
      512
    ), b = (
      /*                        */
      1024
    ), X = (
      /*                        */
      2048
    ), CA = (
      /*                        */
      4096
    ), NA = (
      /*                        */
      8192
    ), KA = (
      /*                        */
      16384
    ), WA = (
      /*                       */
      32768
    ), OA = (
      /*                       */
      65536
    ), zA = (
      /*                       */
      131072
    ), Ce = (
      /*                       */
      262144
    ), Ge = (
      /*                       */
      524288
    ), ve = (
      /*                       */
      1048576
    ), Le = (
      /*                       */
      2097152
    ), ct = (
      /*                            */
      130023424
    ), st = (
      /*                             */
      4194304
    ), Vt = (
      /*                             */
      8388608
    ), Ai = (
      /*                             */
      16777216
    ), gn = (
      /*                             */
      33554432
    ), ye = (
      /*                             */
      67108864
    ), et = st, bi = (
      /*          */
      134217728
    ), Yi = (
      /*                                 */
      268435455
    ), Mg = (
      /*               */
      268435456
    ), tg = (
      /*                       */
      536870912
    ), fi = (
      /*                   */
      1073741824
    );
    function Wf(o) {
      {
        if (o & Lt)
          return "Sync";
        if (o & Po)
          return "InputContinuousHydration";
        if (o & Yr)
          return "InputContinuous";
        if (o & Hr)
          return "DefaultHydration";
        if (o & Br)
          return "Default";
        if (o & Us)
          return "TransitionHydration";
        if (o & ks)
          return "Transition";
        if (o & ct)
          return "Retry";
        if (o & bi)
          return "SelectiveHydration";
        if (o & Mg)
          return "IdleHydration";
        if (o & tg)
          return "Idle";
        if (o & fi)
          return "Offscreen";
      }
    }
    var Si = -1, ig = _r, Yn = st;
    function DI(o) {
      switch (Bo(o)) {
        case Lt:
          return Lt;
        case Po:
          return Po;
        case Yr:
          return Yr;
        case Hr:
          return Hr;
        case Br:
          return Br;
        case Us:
          return Us;
        case _r:
        case KB:
        case pI:
        case T:
        case b:
        case X:
        case CA:
        case NA:
        case KA:
        case WA:
        case OA:
        case zA:
        case Ce:
        case Ge:
        case ve:
        case Le:
          return o & ks;
        case st:
        case Vt:
        case Ai:
        case gn:
        case ye:
          return o & ct;
        case bi:
          return bi;
        case Mg:
          return Mg;
        case tg:
          return tg;
        case fi:
          return fi;
        default:
          return I("Should have found matching lanes. This is a bug in React."), o;
      }
    }
    function bB(o, a) {
      var h = o.pendingLanes;
      if (h === De)
        return De;
      var w = De, R = o.suspendedLanes, L = o.pingedLanes, W = h & Yi;
      if (W !== De) {
        var nA = W & ~R;
        if (nA !== De)
          w = DI(nA);
        else {
          var sA = W & L;
          sA !== De && (w = DI(sA));
        }
      } else {
        var pA = h & ~R;
        pA !== De ? w = DI(pA) : L !== De && (w = DI(L));
      }
      if (w === De)
        return De;
      if (a !== De && a !== w && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (a & R) === De) {
        var LA = Bo(w), VA = Bo(a);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          LA >= VA || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          LA === Br && (VA & ks) !== De
        )
          return a;
      }
      (w & Yr) !== De && (w |= h & Br);
      var oe = o.entangledLanes;
      if (oe !== De)
        for (var Qe = o.entanglements, me = w & oe; me > 0; ) {
          var Ne = Wo(me), nt = 1 << Ne;
          w |= Qe[Ne], me &= ~nt;
        }
      return w;
    }
    function yu(o, a) {
      for (var h = o.eventTimes, w = Si; a > 0; ) {
        var R = Wo(a), L = 1 << R, W = h[R];
        W > w && (w = W), a &= ~L;
      }
      return w;
    }
    function mu(o, a) {
      switch (o) {
        case Lt:
        case Po:
        case Yr:
          return a + 250;
        case Hr:
        case Br:
        case Us:
        case _r:
        case KB:
        case pI:
        case T:
        case b:
        case X:
        case CA:
        case NA:
        case KA:
        case WA:
        case OA:
        case zA:
        case Ce:
        case Ge:
        case ve:
        case Le:
          return a + 5e3;
        case st:
        case Vt:
        case Ai:
        case gn:
        case ye:
          return Si;
        case bi:
        case Mg:
        case tg:
        case fi:
          return Si;
        default:
          return I("Should have found matching lanes. This is a bug in React."), Si;
      }
    }
    function Su(o, a) {
      for (var h = o.pendingLanes, w = o.suspendedLanes, R = o.pingedLanes, L = o.expirationTimes, W = h; W > 0; ) {
        var nA = Wo(W), sA = 1 << nA, pA = L[nA];
        pA === Si ? ((sA & w) === De || (sA & R) !== De) && (L[nA] = mu(sA, a)) : pA <= a && (o.expiredLanes |= sA), W &= ~sA;
      }
    }
    function el(o) {
      return DI(o.pendingLanes);
    }
    function oQ(o) {
      var a = o.pendingLanes & ~fi;
      return a !== De ? a : a & fi ? fi : De;
    }
    function tl(o) {
      return (o & Lt) !== De;
    }
    function sQ(o) {
      return (o & Yi) !== De;
    }
    function il(o) {
      return (o & ct) === o;
    }
    function aQ(o) {
      return (o & ks) === o;
    }
    function da(o, a) {
      var h = Po | Yr | Hr | Br;
      return (a & h) !== De;
    }
    function Mu(o, a) {
      return (a & o.expiredLanes) !== De;
    }
    function IQ(o) {
      return (o & ks) !== 0;
    }
    function Ru() {
      var o = ig;
      return ig <<= 1, ig & ks || (ig = _r), o;
    }
    function Nu() {
      var o = Yn;
      return Yn <<= 1, Yn & ct || (Yn = st), o;
    }
    function Bo(o) {
      return o & -o;
    }
    function wI(o) {
      return Bo(o);
    }
    function Wo(o) {
      return 31 - vs(o);
    }
    function BQ(o) {
      return Wo(o);
    }
    function rn(o, a) {
      return (o & a) !== De;
    }
    function yI(o, a) {
      return (o & a) === a;
    }
    function Gt(o, a) {
      return o | a;
    }
    function fa(o, a) {
      return o & ~a;
    }
    function xs(o, a) {
      return o & a;
    }
    function wm(o) {
      return o;
    }
    function Je(o, a) {
      return o !== nn && o < a ? o : a;
    }
    function mI(o) {
      for (var a = [], h = 0; h < ha; h++)
        a.push(o);
      return a;
    }
    function pa(o, a, h) {
      o.pendingLanes |= a, a !== tg && (o.suspendedLanes = De, o.pingedLanes = De);
      var w = o.eventTimes, R = BQ(a);
      w[R] = h;
    }
    function Fu(o, a) {
      o.suspendedLanes |= a, o.pingedLanes &= ~a;
      for (var h = o.expirationTimes, w = a; w > 0; ) {
        var R = Wo(w), L = 1 << R;
        h[R] = Si, w &= ~L;
      }
    }
    function Gu(o, a, h) {
      o.pingedLanes |= o.suspendedLanes & a;
    }
    function Da(o, a) {
      var h = o.pendingLanes & ~a;
      o.pendingLanes = a, o.suspendedLanes = 0, o.pingedLanes = 0, o.expiredLanes &= a, o.mutableReadLanes &= a, o.entangledLanes &= a;
      for (var w = o.entanglements, R = o.eventTimes, L = o.expirationTimes, W = h; W > 0; ) {
        var nA = Wo(W), sA = 1 << nA;
        w[nA] = De, R[nA] = Si, L[nA] = Si, W &= ~sA;
      }
    }
    function wa(o, a) {
      for (var h = o.entangledLanes |= a, w = o.entanglements, R = h; R; ) {
        var L = Wo(R), W = 1 << L;
        // Is this one of the newly entangled lanes?
        W & a | // Is this lane transitively entangled with the newly entangled lanes?
        w[L] & a && (w[L] |= a), R &= ~W;
      }
    }
    function nl(o, a) {
      var h = Bo(a), w;
      switch (h) {
        case Yr:
          w = Po;
          break;
        case Br:
          w = Hr;
          break;
        case _r:
        case KB:
        case pI:
        case T:
        case b:
        case X:
        case CA:
        case NA:
        case KA:
        case WA:
        case OA:
        case zA:
        case Ce:
        case Ge:
        case ve:
        case Le:
        case st:
        case Vt:
        case Ai:
        case gn:
        case ye:
          w = Us;
          break;
        case tg:
          w = Mg;
          break;
        default:
          w = nn;
          break;
      }
      return (w & (o.suspendedLanes | a)) !== nn ? nn : w;
    }
    function gl(o, a, h) {
      if (Rg)
        for (var w = o.pendingUpdatersLaneMap; h > 0; ) {
          var R = BQ(h), L = 1 << R, W = w[R];
          W.add(a), h &= ~L;
        }
    }
    function rl(o, a) {
      if (Rg)
        for (var h = o.pendingUpdatersLaneMap, w = o.memoizedUpdaters; a > 0; ) {
          var R = BQ(a), L = 1 << R, W = h[R];
          W.size > 0 && (W.forEach(function(nA) {
            var sA = nA.alternate;
            (sA === null || !w.has(sA)) && w.add(nA);
          }), W.clear()), a &= ~L;
        }
    }
    var Jr = Lt, SI = Yr, MI = Br, CQ = tg, ya = nn;
    function Wg() {
      return ya;
    }
    function Un(o) {
      ya = o;
    }
    function ol(o, a) {
      var h = ya;
      try {
        return ya = o, a();
      } finally {
        ya = h;
      }
    }
    function QQ(o, a) {
      return o !== 0 && o < a ? o : a;
    }
    function zf(o, a) {
      return o === 0 || o > a ? o : a;
    }
    function vu(o, a) {
      return o !== 0 && o < a;
    }
    function sl(o) {
      var a = Bo(o);
      return vu(Jr, a) ? vu(SI, a) ? sQ(a) ? MI : CQ : SI : Jr;
    }
    var al = i.unstable_scheduleCallback, Uu = i.unstable_cancelCallback, ku = i.unstable_shouldYield, EQ = i.unstable_requestPaint, on = i.unstable_now, ma = i.unstable_ImmediatePriority, YB = i.unstable_UserBlockingPriority, zo = i.unstable_NormalPriority, RI = i.unstable_IdlePriority, Il = i.unstable_yieldValue, Bl = i.unstable_setDisableYieldValue, Ls = null, Pn = null, Ye = null, Co = !1, Rg = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Cl(o) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var a = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (a.isDisabled)
        return !0;
      if (!a.supportsFiber)
        return I("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        m && (o = C({}, o, {
          getLaneLabelMap: NI,
          injectProfilingHooks: zg
        })), Ls = a.inject(o), Pn = a;
      } catch (h) {
        I("React instrumentation encountered an error: %s.", h);
      }
      return !!a.checkDCE;
    }
    function sn(o, a) {
      if (Pn && typeof Pn.onScheduleFiberRoot == "function")
        try {
          Pn.onScheduleFiberRoot(Ls, o, a);
        } catch (h) {
          Co || (Co = !0, I("React instrumentation encountered an error: %s", h));
        }
    }
    function Tt(o, a) {
      if (Pn && typeof Pn.onCommitFiberRoot == "function")
        try {
          var h = (o.current.flags & Ee) === Ee;
          if (N) {
            var w;
            switch (a) {
              case Jr:
                w = ma;
                break;
              case SI:
                w = YB;
                break;
              case MI:
                w = zo;
                break;
              case CQ:
                w = RI;
                break;
              default:
                w = zo;
                break;
            }
            Pn.onCommitFiberRoot(Ls, o, w, h);
          }
        } catch (R) {
          Co || (Co = !0, I("React instrumentation encountered an error: %s", R));
        }
    }
    function pn(o) {
      if (Pn && typeof Pn.onPostCommitFiberRoot == "function")
        try {
          Pn.onPostCommitFiberRoot(Ls, o);
        } catch (a) {
          Co || (Co = !0, I("React instrumentation encountered an error: %s", a));
        }
    }
    function Dn(o) {
      if (Pn && typeof Pn.onCommitFiberUnmount == "function")
        try {
          Pn.onCommitFiberUnmount(Ls, o);
        } catch (a) {
          Co || (Co = !0, I("React instrumentation encountered an error: %s", a));
        }
    }
    function ei(o) {
      if (typeof Il == "function" && (Bl(o), s(o)), Pn && typeof Pn.setStrictMode == "function")
        try {
          Pn.setStrictMode(Ls, o);
        } catch (a) {
          Co || (Co = !0, I("React instrumentation encountered an error: %s", a));
        }
    }
    function zg(o) {
      Ye = o;
    }
    function NI() {
      {
        for (var o = /* @__PURE__ */ new Map(), a = 1, h = 0; h < ha; h++) {
          var w = Wf(a);
          o.set(a, w), a *= 2;
        }
        return o;
      }
    }
    function kn(o) {
      Ye !== null && typeof Ye.markCommitStarted == "function" && Ye.markCommitStarted(o);
    }
    function FI() {
      Ye !== null && typeof Ye.markCommitStopped == "function" && Ye.markCommitStopped();
    }
    function Qo(o) {
      Ye !== null && typeof Ye.markComponentRenderStarted == "function" && Ye.markComponentRenderStarted(o);
    }
    function Vo() {
      Ye !== null && typeof Ye.markComponentRenderStopped == "function" && Ye.markComponentRenderStopped();
    }
    function Ql(o) {
      Ye !== null && typeof Ye.markComponentPassiveEffectMountStarted == "function" && Ye.markComponentPassiveEffectMountStarted(o);
    }
    function HB() {
      Ye !== null && typeof Ye.markComponentPassiveEffectMountStopped == "function" && Ye.markComponentPassiveEffectMountStopped();
    }
    function Ng(o) {
      Ye !== null && typeof Ye.markComponentPassiveEffectUnmountStarted == "function" && Ye.markComponentPassiveEffectUnmountStarted(o);
    }
    function El() {
      Ye !== null && typeof Ye.markComponentPassiveEffectUnmountStopped == "function" && Ye.markComponentPassiveEffectUnmountStopped();
    }
    function ll(o) {
      Ye !== null && typeof Ye.markComponentLayoutEffectMountStarted == "function" && Ye.markComponentLayoutEffectMountStarted(o);
    }
    function GI() {
      Ye !== null && typeof Ye.markComponentLayoutEffectMountStopped == "function" && Ye.markComponentLayoutEffectMountStopped();
    }
    function _B(o) {
      Ye !== null && typeof Ye.markComponentLayoutEffectUnmountStarted == "function" && Ye.markComponentLayoutEffectUnmountStarted(o);
    }
    function lQ() {
      Ye !== null && typeof Ye.markComponentLayoutEffectUnmountStopped == "function" && Ye.markComponentLayoutEffectUnmountStopped();
    }
    function Ts(o, a, h) {
      Ye !== null && typeof Ye.markComponentErrored == "function" && Ye.markComponentErrored(o, a, h);
    }
    function cQ(o, a, h) {
      Ye !== null && typeof Ye.markComponentSuspended == "function" && Ye.markComponentSuspended(o, a, h);
    }
    function Ks(o) {
      Ye !== null && typeof Ye.markLayoutEffectsStarted == "function" && Ye.markLayoutEffectsStarted(o);
    }
    function uQ() {
      Ye !== null && typeof Ye.markLayoutEffectsStopped == "function" && Ye.markLayoutEffectsStopped();
    }
    function JB(o) {
      Ye !== null && typeof Ye.markPassiveEffectsStarted == "function" && Ye.markPassiveEffectsStarted(o);
    }
    function cl() {
      Ye !== null && typeof Ye.markPassiveEffectsStopped == "function" && Ye.markPassiveEffectsStopped();
    }
    function OB(o) {
      Ye !== null && typeof Ye.markRenderStarted == "function" && Ye.markRenderStarted(o);
    }
    function hQ() {
      Ye !== null && typeof Ye.markRenderYielded == "function" && Ye.markRenderYielded();
    }
    function ng() {
      Ye !== null && typeof Ye.markRenderStopped == "function" && Ye.markRenderStopped();
    }
    function bs(o) {
      Ye !== null && typeof Ye.markRenderScheduled == "function" && Ye.markRenderScheduled(o);
    }
    function Cr(o, a) {
      Ye !== null && typeof Ye.markForceUpdateScheduled == "function" && Ye.markForceUpdateScheduled(o, a);
    }
    function vI(o, a) {
      Ye !== null && typeof Ye.markStateUpdateScheduled == "function" && Ye.markStateUpdateScheduled(o, a);
    }
    function Fg(o, a) {
      return o === a && (o !== 0 || 1 / o === 1 / a) || o !== o && a !== a;
    }
    var Vg = typeof Object.is == "function" ? Object.is : Fg, Or = null, qB = !1, ul = !1;
    function jo(o) {
      Or === null ? Or = [o] : Or.push(o);
    }
    function xu(o) {
      qB = !0, jo(o);
    }
    function hl() {
      qB && Qr();
    }
    function Qr() {
      if (!ul && Or !== null) {
        ul = !0;
        var o = 0, a = Wg();
        try {
          var h = !0, w = Or;
          for (Un(Jr); o < w.length; o++) {
            var R = w[o];
            do
              R = R(h);
            while (R !== null);
          }
          Or = null, qB = !1;
        } catch (L) {
          throw Or !== null && (Or = Or.slice(o + 1)), al(ma, Qr), L;
        } finally {
          Un(a), ul = !1;
        }
      }
      return null;
    }
    function Ys(o) {
      var a = o.current.memoizedState;
      return a.isDehydrated;
    }
    var Lu = n.ReactCurrentBatchConfig, Tu = null;
    function dl() {
      return Lu.transition;
    }
    function Sa(o, a) {
      if (Vg(o, a))
        return !0;
      if (typeof o != "object" || o === null || typeof a != "object" || a === null)
        return !1;
      var h = Object.keys(o), w = Object.keys(a);
      if (h.length !== w.length)
        return !1;
      for (var R = 0; R < h.length; R++) {
        var L = h[R];
        if (!en.call(a, L) || !Vg(o[L], a[L]))
          return !1;
      }
      return !0;
    }
    function Vf(o) {
      switch (o._debugOwner && o._debugOwner.type, o._debugSource, o.tag) {
        case _:
          return qg(o.type);
        case QA:
          return qg("Lazy");
        case tA:
          return qg("Suspense");
        case hA:
          return qg("SuspenseList");
        case G:
        case v:
        case rA:
          return Ti(o.type);
        case P:
          return Ti(o.type.render);
        case k:
          return Ea(o.type);
        default:
          return "";
      }
    }
    function Ku(o) {
      try {
        var a = "", h = o;
        do
          a += Vf(h), h = h.return;
        while (h);
        return a;
      } catch (w) {
        return `
Error generating stack: ` + w.message + `
` + w.stack;
      }
    }
    var fl = n.ReactDebugCurrentFrame, jg = null, qr = !1;
    function jf() {
      {
        if (jg === null)
          return null;
        var o = jg._debugOwner;
        if (o !== null && typeof o < "u")
          return xA(o);
      }
      return null;
    }
    function Ma() {
      return jg === null ? "" : Ku(jg);
    }
    function Wn() {
      fl.getCurrentStack = null, jg = null, qr = !1;
    }
    function ai(o) {
      fl.getCurrentStack = Ma, jg = o, qr = !1;
    }
    function Eo(o) {
      qr = o;
    }
    var Er = {
      recordUnsafeLifecycleWarnings: function(o, a) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(o, a) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var Zf = function(o) {
        for (var a = null, h = o; h !== null; )
          h.mode & Ki && (a = h), h = h.return;
        return a;
      }, Ra = function(o) {
        var a = [];
        return o.forEach(function(h) {
          a.push(h);
        }), a.sort().join(", ");
      }, UI = [], kI = [], PB = [], gg = [], Na = [], WB = [], Gg = /* @__PURE__ */ new Set();
      Er.recordUnsafeLifecycleWarnings = function(o, a) {
        Gg.has(o.type) || (typeof a.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        a.componentWillMount.__suppressDeprecationWarning !== !0 && UI.push(o), o.mode & Ki && typeof a.UNSAFE_componentWillMount == "function" && kI.push(o), typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && PB.push(o), o.mode & Ki && typeof a.UNSAFE_componentWillReceiveProps == "function" && gg.push(o), typeof a.componentWillUpdate == "function" && a.componentWillUpdate.__suppressDeprecationWarning !== !0 && Na.push(o), o.mode & Ki && typeof a.UNSAFE_componentWillUpdate == "function" && WB.push(o));
      }, Er.flushPendingUnsafeLifecycleWarnings = function() {
        var o = /* @__PURE__ */ new Set();
        UI.length > 0 && (UI.forEach(function(oe) {
          o.add(xA(oe) || "Component"), Gg.add(oe.type);
        }), UI = []);
        var a = /* @__PURE__ */ new Set();
        kI.length > 0 && (kI.forEach(function(oe) {
          a.add(xA(oe) || "Component"), Gg.add(oe.type);
        }), kI = []);
        var h = /* @__PURE__ */ new Set();
        PB.length > 0 && (PB.forEach(function(oe) {
          h.add(xA(oe) || "Component"), Gg.add(oe.type);
        }), PB = []);
        var w = /* @__PURE__ */ new Set();
        gg.length > 0 && (gg.forEach(function(oe) {
          w.add(xA(oe) || "Component"), Gg.add(oe.type);
        }), gg = []);
        var R = /* @__PURE__ */ new Set();
        Na.length > 0 && (Na.forEach(function(oe) {
          R.add(xA(oe) || "Component"), Gg.add(oe.type);
        }), Na = []);
        var L = /* @__PURE__ */ new Set();
        if (WB.length > 0 && (WB.forEach(function(oe) {
          L.add(xA(oe) || "Component"), Gg.add(oe.type);
        }), WB = []), a.size > 0) {
          var W = Ra(a);
          I(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, W);
        }
        if (w.size > 0) {
          var nA = Ra(w);
          I(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, nA);
        }
        if (L.size > 0) {
          var sA = Ra(L);
          I(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, sA);
        }
        if (o.size > 0) {
          var pA = Ra(o);
          B(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, pA);
        }
        if (h.size > 0) {
          var LA = Ra(h);
          B(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, LA);
        }
        if (R.size > 0) {
          var VA = Ra(R);
          B(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, VA);
        }
      };
      var Fa = /* @__PURE__ */ new Map(), Hs = /* @__PURE__ */ new Set();
      Er.recordLegacyContextWarning = function(o, a) {
        var h = Zf(o);
        if (h === null) {
          I("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!Hs.has(o.type)) {
          var w = Fa.get(h);
          (o.type.contextTypes != null || o.type.childContextTypes != null || a !== null && typeof a.getChildContext == "function") && (w === void 0 && (w = [], Fa.set(h, w)), w.push(o));
        }
      }, Er.flushLegacyContextWarning = function() {
        Fa.forEach(function(o, a) {
          if (o.length !== 0) {
            var h = o[0], w = /* @__PURE__ */ new Set();
            o.forEach(function(L) {
              w.add(xA(L) || "Component"), Hs.add(L.type);
            });
            var R = Ra(w);
            try {
              ai(h), I(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, R);
            } finally {
              Wn();
            }
          }
        });
      }, Er.discardPendingWarnings = function() {
        UI = [], kI = [], PB = [], gg = [], Na = [], WB = [], Fa = /* @__PURE__ */ new Map();
      };
    }
    function zB(o) {
      {
        var a = typeof Symbol == "function" && Symbol.toStringTag, h = a && o[Symbol.toStringTag] || o.constructor.name || "Object";
        return h;
      }
    }
    function dQ(o) {
      try {
        return VB(o), !1;
      } catch {
        return !0;
      }
    }
    function VB(o) {
      return "" + o;
    }
    function Xf(o) {
      if (dQ(o))
        return I("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", zB(o)), VB(o);
    }
    function bu(o, a) {
      if (dQ(o))
        return I("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", a, zB(o)), VB(o);
    }
    function lr(o, a) {
      if (o && o.defaultProps) {
        var h = C({}, a), w = o.defaultProps;
        for (var R in w)
          h[R] === void 0 && (h[R] = w[R]);
        return h;
      }
      return a;
    }
    var jB = ht(null), xI;
    xI = {};
    var LI = null, TI = null, pl = null, Q = !1;
    function l() {
      LI = null, TI = null, pl = null, Q = !1;
    }
    function M() {
      Q = !0;
    }
    function U() {
      Q = !1;
    }
    function K(o, a, h) {
      oo ? (Ci(jB, a._currentValue, o), a._currentValue = h, a._currentRenderer !== void 0 && a._currentRenderer !== null && a._currentRenderer !== xI && I("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), a._currentRenderer = xI) : (Ci(jB, a._currentValue2, o), a._currentValue2 = h, a._currentRenderer2 !== void 0 && a._currentRenderer2 !== null && a._currentRenderer2 !== xI && I("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), a._currentRenderer2 = xI);
    }
    function z(o, a) {
      var h = jB.current;
      ji(jB, a), oo ? o._currentValue = h : o._currentValue2 = h;
    }
    function uA(o, a, h) {
      for (var w = o; w !== null; ) {
        var R = w.alternate;
        if (yI(w.childLanes, a) ? R !== null && !yI(R.childLanes, a) && (R.childLanes = Gt(R.childLanes, a)) : (w.childLanes = Gt(w.childLanes, a), R !== null && (R.childLanes = Gt(R.childLanes, a))), w === h)
          break;
        w = w.return;
      }
      w !== h && I("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function HA(o, a, h) {
      ae(o, a, h);
    }
    function ae(o, a, h) {
      var w = o.child;
      for (w !== null && (w.return = o); w !== null; ) {
        var R = void 0, L = w.dependencies;
        if (L !== null) {
          R = w.child;
          for (var W = L.firstContext; W !== null; ) {
            if (W.context === a) {
              if (w.tag === k) {
                var nA = wI(h), sA = at(Si, nA);
                sA.tag = Bg;
                var pA = w.updateQueue;
                if (pA !== null) {
                  var LA = pA.shared, VA = LA.pending;
                  VA === null ? sA.next = sA : (sA.next = VA.next, VA.next = sA), LA.pending = sA;
                }
              }
              w.lanes = Gt(w.lanes, h);
              var oe = w.alternate;
              oe !== null && (oe.lanes = Gt(oe.lanes, h)), uA(w.return, h, o), L.lanes = Gt(L.lanes, h);
              break;
            }
            W = W.next;
          }
        } else if (w.tag === oA)
          R = w.type === o.type ? null : w.child;
        else if (w.tag === MA) {
          var Qe = w.return;
          if (Qe === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Qe.lanes = Gt(Qe.lanes, h);
          var me = Qe.alternate;
          me !== null && (me.lanes = Gt(me.lanes, h)), uA(Qe, h, o), R = w.sibling;
        } else
          R = w.child;
        if (R !== null)
          R.return = w;
        else
          for (R = w; R !== null; ) {
            if (R === o) {
              R = null;
              break;
            }
            var Ne = R.sibling;
            if (Ne !== null) {
              Ne.return = R.return, R = Ne;
              break;
            }
            R = R.return;
          }
        w = R;
      }
    }
    function Re(o, a) {
      LI = o, TI = null, pl = null;
      var h = o.dependencies;
      if (h !== null) {
        var w = h.firstContext;
        w !== null && (rn(h.lanes, a) && Dh(), h.firstContext = null);
      }
    }
    function Ue(o) {
      Q && I("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var a = oo ? o._currentValue : o._currentValue2;
      if (pl !== o) {
        var h = {
          context: o,
          memoizedValue: a,
          next: null
        };
        if (TI === null) {
          if (LI === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          TI = h, LI.dependencies = {
            lanes: De,
            firstContext: h
          };
        } else
          TI = TI.next = h;
      }
      return a;
    }
    var Qt = null;
    function gt(o) {
      Qt === null ? Qt = [o] : Qt.push(o);
    }
    function wi() {
      if (Qt !== null) {
        for (var o = 0; o < Qt.length; o++) {
          var a = Qt[o], h = a.interleaved;
          if (h !== null) {
            a.interleaved = null;
            var w = h.next, R = a.pending;
            if (R !== null) {
              var L = R.next;
              R.next = w, h.next = L;
            }
            a.pending = h;
          }
        }
        Qt = null;
      }
    }
    var Xe = 0, zn = 1, Bg = 2, $A = 3, qA = !1, re, He;
    re = !1, He = null;
    function Ze(o) {
      var a = {
        baseState: o.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: De
        },
        effects: null
      };
      o.updateQueue = a;
    }
    function vt(o, a) {
      var h = a.updateQueue, w = o.updateQueue;
      if (h === w) {
        var R = {
          baseState: w.baseState,
          firstBaseUpdate: w.firstBaseUpdate,
          lastBaseUpdate: w.lastBaseUpdate,
          shared: w.shared,
          effects: w.effects
        };
        a.updateQueue = R;
      }
    }
    function at(o, a) {
      var h = {
        eventTime: o,
        lane: a,
        tag: Xe,
        payload: null,
        callback: null,
        next: null
      };
      return h;
    }
    function Kt(o, a, h) {
      var w = o.updateQueue;
      if (w !== null) {
        var R = w.shared;
        if (yM(o)) {
          var L = R.interleaved;
          L === null ? (a.next = a, gt(R)) : (a.next = L.next, L.next = a), R.interleaved = a;
        } else {
          var W = R.pending;
          W === null ? a.next = a : (a.next = W.next, W.next = a), R.pending = a;
        }
        He === R && !re && (I("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), re = !0);
      }
    }
    function an(o, a, h) {
      var w = a.updateQueue;
      if (w !== null) {
        var R = w.shared;
        if (IQ(h)) {
          var L = R.lanes;
          L = xs(L, o.pendingLanes);
          var W = Gt(L, h);
          R.lanes = W, wa(o, W);
        }
      }
    }
    function ti(o, a) {
      var h = o.updateQueue, w = o.alternate;
      if (w !== null) {
        var R = w.updateQueue;
        if (h === R) {
          var L = null, W = null, nA = h.firstBaseUpdate;
          if (nA !== null) {
            var sA = nA;
            do {
              var pA = {
                eventTime: sA.eventTime,
                lane: sA.lane,
                tag: sA.tag,
                payload: sA.payload,
                callback: sA.callback,
                next: null
              };
              W === null ? L = W = pA : (W.next = pA, W = pA), sA = sA.next;
            } while (sA !== null);
            W === null ? L = W = a : (W.next = a, W = a);
          } else
            L = W = a;
          h = {
            baseState: R.baseState,
            firstBaseUpdate: L,
            lastBaseUpdate: W,
            shared: R.shared,
            effects: R.effects
          }, o.updateQueue = h;
          return;
        }
      }
      var LA = h.lastBaseUpdate;
      LA === null ? h.firstBaseUpdate = a : LA.next = a, h.lastBaseUpdate = a;
    }
    function _s(o, a, h, w, R, L) {
      switch (h.tag) {
        case zn: {
          var W = h.payload;
          if (typeof W == "function") {
            M();
            var nA = W.call(L, w, R);
            {
              if (o.mode & Ki) {
                ei(!0);
                try {
                  W.call(L, w, R);
                } finally {
                  ei(!1);
                }
              }
              U();
            }
            return nA;
          }
          return W;
        }
        case $A:
          o.flags = o.flags & ~PA | Ee;
        case Xe: {
          var sA = h.payload, pA;
          if (typeof sA == "function") {
            M(), pA = sA.call(L, w, R);
            {
              if (o.mode & Ki) {
                ei(!0);
                try {
                  sA.call(L, w, R);
                } finally {
                  ei(!1);
                }
              }
              U();
            }
          } else
            pA = sA;
          return pA == null ? w : C({}, w, pA);
        }
        case Bg:
          return qA = !0, w;
      }
      return w;
    }
    function fQ(o, a, h, w) {
      var R = o.updateQueue;
      qA = !1, He = R.shared;
      var L = R.firstBaseUpdate, W = R.lastBaseUpdate, nA = R.shared.pending;
      if (nA !== null) {
        R.shared.pending = null;
        var sA = nA, pA = sA.next;
        sA.next = null, W === null ? L = pA : W.next = pA, W = sA;
        var LA = o.alternate;
        if (LA !== null) {
          var VA = LA.updateQueue, oe = VA.lastBaseUpdate;
          oe !== W && (oe === null ? VA.firstBaseUpdate = pA : oe.next = pA, VA.lastBaseUpdate = sA);
        }
      }
      if (L !== null) {
        var Qe = R.baseState, me = De, Ne = null, nt = null, Ut = null, It = L;
        do {
          var Hi = It.lane, _i = It.eventTime;
          if (yI(w, Hi)) {
            if (Ut !== null) {
              var le = {
                eventTime: _i,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: nn,
                tag: It.tag,
                payload: It.payload,
                callback: It.callback,
                next: null
              };
              Ut = Ut.next = le;
            }
            Qe = _s(o, R, It, Qe, a, h);
            var XA = It.callback;
            if (XA !== null && // If the update was already committed, we should not queue its
            // callback again.
            It.lane !== nn) {
              o.flags |= we;
              var Fe = R.effects;
              Fe === null ? R.effects = [It] : Fe.push(It);
            }
          } else {
            var te = {
              eventTime: _i,
              lane: Hi,
              tag: It.tag,
              payload: It.payload,
              callback: It.callback,
              next: null
            };
            Ut === null ? (nt = Ut = te, Ne = Qe) : Ut = Ut.next = te, me = Gt(me, Hi);
          }
          if (It = It.next, It === null) {
            if (nA = R.shared.pending, nA === null)
              break;
            var $e = nA, ze = $e.next;
            $e.next = null, It = ze, R.lastBaseUpdate = $e, R.shared.pending = null;
          }
        } while (!0);
        Ut === null && (Ne = Qe), R.baseState = Ne, R.firstBaseUpdate = nt, R.lastBaseUpdate = Ut;
        var jt = R.shared.interleaved;
        if (jt !== null) {
          var li = jt;
          do
            me = Gt(me, li.lane), li = li.next;
          while (li !== jt);
        } else
          L === null && (R.shared.lanes = De);
        qh(me), o.lanes = me, o.memoizedState = Qe;
      }
      He = null;
    }
    function _k(o, a) {
      if (typeof o != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + o));
      o.call(a);
    }
    function ym() {
      qA = !1;
    }
    function Yu() {
      return qA;
    }
    function mm(o, a, h) {
      var w = a.effects;
      if (a.effects = null, w !== null)
        for (var R = 0; R < w.length; R++) {
          var L = w[R], W = L.callback;
          W !== null && (L.callback = null, _k(W, h));
        }
    }
    var $f = {}, Sm = new t.Component().refs, Ap, ep, tp, ip, np, Mm, Hu, gp, rp, op;
    {
      Ap = /* @__PURE__ */ new Set(), ep = /* @__PURE__ */ new Set(), tp = /* @__PURE__ */ new Set(), ip = /* @__PURE__ */ new Set(), gp = /* @__PURE__ */ new Set(), np = /* @__PURE__ */ new Set(), rp = /* @__PURE__ */ new Set(), op = /* @__PURE__ */ new Set();
      var Rm = /* @__PURE__ */ new Set();
      Hu = function(o, a) {
        if (!(o === null || typeof o == "function")) {
          var h = a + "_" + o;
          Rm.has(h) || (Rm.add(h), I("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", a, o));
        }
      }, Mm = function(o, a) {
        if (a === void 0) {
          var h = _A(o) || "Component";
          np.has(h) || (np.add(h), I("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", h));
        }
      }, Object.defineProperty($f, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze($f);
    }
    function sp(o, a, h, w) {
      var R = o.memoizedState, L = h(w, R);
      {
        if (o.mode & Ki) {
          ei(!0);
          try {
            L = h(w, R);
          } finally {
            ei(!1);
          }
        }
        Mm(a, L);
      }
      var W = L == null ? R : C({}, R, L);
      if (o.memoizedState = W, o.lanes === De) {
        var nA = o.updateQueue;
        nA.baseState = W;
      }
    }
    var ap = {
      isMounted: Ui,
      enqueueSetState: function(o, a, h) {
        var w = c(o), R = Xg(), L = qI(w), W = at(R, L);
        W.payload = a, h != null && (Hu(h, "setState"), W.callback = h), Kt(w, W);
        var nA = Xn(w, L, R);
        nA !== null && an(nA, w, L), vI(w, L);
      },
      enqueueReplaceState: function(o, a, h) {
        var w = c(o), R = Xg(), L = qI(w), W = at(R, L);
        W.tag = zn, W.payload = a, h != null && (Hu(h, "replaceState"), W.callback = h), Kt(w, W);
        var nA = Xn(w, L, R);
        nA !== null && an(nA, w, L), vI(w, L);
      },
      enqueueForceUpdate: function(o, a) {
        var h = c(o), w = Xg(), R = qI(h), L = at(w, R);
        L.tag = Bg, a != null && (Hu(a, "forceUpdate"), L.callback = a), Kt(h, L);
        var W = Xn(h, R, w);
        W !== null && an(W, h, R), Cr(h, R);
      }
    };
    function Nm(o, a, h, w, R, L, W) {
      var nA = o.stateNode;
      if (typeof nA.shouldComponentUpdate == "function") {
        var sA = nA.shouldComponentUpdate(w, L, W);
        {
          if (o.mode & Ki) {
            ei(!0);
            try {
              sA = nA.shouldComponentUpdate(w, L, W);
            } finally {
              ei(!1);
            }
          }
          sA === void 0 && I("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", _A(a) || "Component");
        }
        return sA;
      }
      return a.prototype && a.prototype.isPureReactComponent ? !Sa(h, w) || !Sa(R, L) : !0;
    }
    function Jk(o, a, h) {
      var w = o.stateNode;
      {
        var R = _A(a) || "Component", L = w.render;
        L || (a.prototype && typeof a.prototype.render == "function" ? I("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", R) : I("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", R)), w.getInitialState && !w.getInitialState.isReactClassApproved && !w.state && I("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", R), w.getDefaultProps && !w.getDefaultProps.isReactClassApproved && I("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", R), w.propTypes && I("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", R), w.contextType && I("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", R), w.contextTypes && I("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", R), a.contextType && a.contextTypes && !rp.has(a) && (rp.add(a), I("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", R)), typeof w.componentShouldUpdate == "function" && I("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", R), a.prototype && a.prototype.isPureReactComponent && typeof w.shouldComponentUpdate < "u" && I("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", _A(a) || "A pure component"), typeof w.componentDidUnmount == "function" && I("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", R), typeof w.componentDidReceiveProps == "function" && I("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", R), typeof w.componentWillRecieveProps == "function" && I("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", R), typeof w.UNSAFE_componentWillRecieveProps == "function" && I("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", R);
        var W = w.props !== h;
        w.props !== void 0 && W && I("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", R, R), w.defaultProps && I("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", R, R), typeof w.getSnapshotBeforeUpdate == "function" && typeof w.componentDidUpdate != "function" && !tp.has(a) && (tp.add(a), I("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", _A(a))), typeof w.getDerivedStateFromProps == "function" && I("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", R), typeof w.getDerivedStateFromError == "function" && I("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", R), typeof a.getSnapshotBeforeUpdate == "function" && I("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", R);
        var nA = w.state;
        nA && (typeof nA != "object" || Mt(nA)) && I("%s.state: must be set to an object or null", R), typeof w.getChildContext == "function" && typeof a.childContextTypes != "object" && I("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", R);
      }
    }
    function Fm(o, a) {
      a.updater = ap, o.stateNode = a, u(a, o), a._reactInternalInstance = $f;
    }
    function Gm(o, a, h) {
      var w = !1, R = qt, L = qt, W = a.contextType;
      if ("contextType" in a) {
        var nA = (
          // Allow null for conditional declaration
          W === null || W !== void 0 && W.$$typeof === Ae && W._context === void 0
        );
        if (!nA && !op.has(a)) {
          op.add(a);
          var sA = "";
          W === void 0 ? sA = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof W != "object" ? sA = " However, it is set to a " + typeof W + "." : W.$$typeof === pe ? sA = " Did you accidentally pass the Context.Provider instead?" : W._context !== void 0 ? sA = " Did you accidentally pass the Context.Consumer instead?" : sA = " However, it is set to an object with keys {" + Object.keys(W).join(", ") + "}.", I("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", _A(a) || "Component", sA);
        }
      }
      if (typeof W == "object" && W !== null)
        L = Ue(W);
      else {
        R = sr(o, a, !0);
        var pA = a.contextTypes;
        w = pA != null, L = w ? Fs(o, R) : qt;
      }
      var LA = new a(h, L);
      if (o.mode & Ki) {
        ei(!0);
        try {
          LA = new a(h, L);
        } finally {
          ei(!1);
        }
      }
      var VA = o.memoizedState = LA.state !== null && LA.state !== void 0 ? LA.state : null;
      Fm(o, LA);
      {
        if (typeof a.getDerivedStateFromProps == "function" && VA === null) {
          var oe = _A(a) || "Component";
          ep.has(oe) || (ep.add(oe), I("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", oe, LA.state === null ? "null" : "undefined", oe));
        }
        if (typeof a.getDerivedStateFromProps == "function" || typeof LA.getSnapshotBeforeUpdate == "function") {
          var Qe = null, me = null, Ne = null;
          if (typeof LA.componentWillMount == "function" && LA.componentWillMount.__suppressDeprecationWarning !== !0 ? Qe = "componentWillMount" : typeof LA.UNSAFE_componentWillMount == "function" && (Qe = "UNSAFE_componentWillMount"), typeof LA.componentWillReceiveProps == "function" && LA.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? me = "componentWillReceiveProps" : typeof LA.UNSAFE_componentWillReceiveProps == "function" && (me = "UNSAFE_componentWillReceiveProps"), typeof LA.componentWillUpdate == "function" && LA.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Ne = "componentWillUpdate" : typeof LA.UNSAFE_componentWillUpdate == "function" && (Ne = "UNSAFE_componentWillUpdate"), Qe !== null || me !== null || Ne !== null) {
            var nt = _A(a) || "Component", Ut = typeof a.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            ip.has(nt) || (ip.add(nt), I(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, nt, Ut, Qe !== null ? `
  ` + Qe : "", me !== null ? `
  ` + me : "", Ne !== null ? `
  ` + Ne : ""));
          }
        }
      }
      return w && Ns(o, R, L), LA;
    }
    function Ok(o, a) {
      var h = a.state;
      typeof a.componentWillMount == "function" && a.componentWillMount(), typeof a.UNSAFE_componentWillMount == "function" && a.UNSAFE_componentWillMount(), h !== a.state && (I("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", xA(o) || "Component"), ap.enqueueReplaceState(a, a.state, null));
    }
    function vm(o, a, h, w) {
      var R = a.state;
      if (typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps(h, w), typeof a.UNSAFE_componentWillReceiveProps == "function" && a.UNSAFE_componentWillReceiveProps(h, w), a.state !== R) {
        {
          var L = xA(o) || "Component";
          Ap.has(L) || (Ap.add(L), I("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", L));
        }
        ap.enqueueReplaceState(a, a.state, null);
      }
    }
    function Ip(o, a, h, w) {
      Jk(o, a, h);
      var R = o.stateNode;
      R.props = h, R.state = o.memoizedState, R.refs = Sm, Ze(o);
      var L = a.contextType;
      if (typeof L == "object" && L !== null)
        R.context = Ue(L);
      else {
        var W = sr(o, a, !0);
        R.context = Fs(o, W);
      }
      {
        if (R.state === h) {
          var nA = _A(a) || "Component";
          gp.has(nA) || (gp.add(nA), I("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", nA));
        }
        o.mode & Ki && Er.recordLegacyContextWarning(o, R), Er.recordUnsafeLifecycleWarnings(o, R);
      }
      R.state = o.memoizedState;
      var sA = a.getDerivedStateFromProps;
      if (typeof sA == "function" && (sp(o, a, sA, h), R.state = o.memoizedState), typeof a.getDerivedStateFromProps != "function" && typeof R.getSnapshotBeforeUpdate != "function" && (typeof R.UNSAFE_componentWillMount == "function" || typeof R.componentWillMount == "function") && (Ok(o, R), fQ(o, h, R, w), R.state = o.memoizedState), typeof R.componentDidMount == "function") {
        var pA = TA;
        pA |= it, (o.mode & Sg) !== Ct && (pA |= Bt), o.flags |= pA;
      }
    }
    function qk(o, a, h, w) {
      var R = o.stateNode, L = o.memoizedProps;
      R.props = L;
      var W = R.context, nA = a.contextType, sA = qt;
      if (typeof nA == "object" && nA !== null)
        sA = Ue(nA);
      else {
        var pA = sr(o, a, !0);
        sA = Fs(o, pA);
      }
      var LA = a.getDerivedStateFromProps, VA = typeof LA == "function" || typeof R.getSnapshotBeforeUpdate == "function";
      !VA && (typeof R.UNSAFE_componentWillReceiveProps == "function" || typeof R.componentWillReceiveProps == "function") && (L !== h || W !== sA) && vm(o, R, h, sA), ym();
      var oe = o.memoizedState, Qe = R.state = oe;
      if (fQ(o, h, R, w), Qe = o.memoizedState, L === h && oe === Qe && !tn() && !Yu()) {
        if (typeof R.componentDidMount == "function") {
          var me = TA;
          me |= it, (o.mode & Sg) !== Ct && (me |= Bt), o.flags |= me;
        }
        return !1;
      }
      typeof LA == "function" && (sp(o, a, LA, h), Qe = o.memoizedState);
      var Ne = Yu() || Nm(o, a, L, h, oe, Qe, sA);
      if (Ne) {
        if (!VA && (typeof R.UNSAFE_componentWillMount == "function" || typeof R.componentWillMount == "function") && (typeof R.componentWillMount == "function" && R.componentWillMount(), typeof R.UNSAFE_componentWillMount == "function" && R.UNSAFE_componentWillMount()), typeof R.componentDidMount == "function") {
          var nt = TA;
          nt |= it, (o.mode & Sg) !== Ct && (nt |= Bt), o.flags |= nt;
        }
      } else {
        if (typeof R.componentDidMount == "function") {
          var Ut = TA;
          Ut |= it, (o.mode & Sg) !== Ct && (Ut |= Bt), o.flags |= Ut;
        }
        o.memoizedProps = h, o.memoizedState = Qe;
      }
      return R.props = h, R.state = Qe, R.context = sA, Ne;
    }
    function Pk(o, a, h, w, R) {
      var L = a.stateNode;
      vt(o, a);
      var W = a.memoizedProps, nA = a.type === a.elementType ? W : lr(a.type, W);
      L.props = nA;
      var sA = a.pendingProps, pA = L.context, LA = h.contextType, VA = qt;
      if (typeof LA == "object" && LA !== null)
        VA = Ue(LA);
      else {
        var oe = sr(a, h, !0);
        VA = Fs(a, oe);
      }
      var Qe = h.getDerivedStateFromProps, me = typeof Qe == "function" || typeof L.getSnapshotBeforeUpdate == "function";
      !me && (typeof L.UNSAFE_componentWillReceiveProps == "function" || typeof L.componentWillReceiveProps == "function") && (W !== sA || pA !== VA) && vm(a, L, w, VA), ym();
      var Ne = a.memoizedState, nt = L.state = Ne;
      if (fQ(a, w, L, R), nt = a.memoizedState, W === sA && Ne === nt && !tn() && !Yu() && !D)
        return typeof L.componentDidUpdate == "function" && (W !== o.memoizedProps || Ne !== o.memoizedState) && (a.flags |= TA), typeof L.getSnapshotBeforeUpdate == "function" && (W !== o.memoizedProps || Ne !== o.memoizedState) && (a.flags |= Pe), !1;
      typeof Qe == "function" && (sp(a, h, Qe, w), nt = a.memoizedState);
      var Ut = Yu() || Nm(a, h, nA, w, Ne, nt, VA) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      D;
      return Ut ? (!me && (typeof L.UNSAFE_componentWillUpdate == "function" || typeof L.componentWillUpdate == "function") && (typeof L.componentWillUpdate == "function" && L.componentWillUpdate(w, nt, VA), typeof L.UNSAFE_componentWillUpdate == "function" && L.UNSAFE_componentWillUpdate(w, nt, VA)), typeof L.componentDidUpdate == "function" && (a.flags |= TA), typeof L.getSnapshotBeforeUpdate == "function" && (a.flags |= Pe)) : (typeof L.componentDidUpdate == "function" && (W !== o.memoizedProps || Ne !== o.memoizedState) && (a.flags |= TA), typeof L.getSnapshotBeforeUpdate == "function" && (W !== o.memoizedProps || Ne !== o.memoizedState) && (a.flags |= Pe), a.memoizedProps = w, a.memoizedState = nt), L.props = w, L.state = nt, L.context = VA, Ut;
    }
    var pQ = [], DQ = 0, _u = null, Ju = 0, lo = [], co = 0, ZB = null, Ga = 1, va = "";
    function Wk(o) {
      return $B(), (o.flags & At) !== gA;
    }
    function zk(o) {
      return $B(), Ju;
    }
    function Vk() {
      var o = va, a = Ga, h = a & ~jk(a);
      return h.toString(32) + o;
    }
    function XB(o, a) {
      $B(), pQ[DQ++] = Ju, pQ[DQ++] = _u, _u = o, Ju = a;
    }
    function Um(o, a, h) {
      $B(), lo[co++] = Ga, lo[co++] = va, lo[co++] = ZB, ZB = o;
      var w = Ga, R = va, L = Ou(w) - 1, W = w & ~(1 << L), nA = h + 1, sA = Ou(a) + L;
      if (sA > 30) {
        var pA = L - L % 5, LA = (1 << pA) - 1, VA = (W & LA).toString(32), oe = W >> pA, Qe = L - pA, me = Ou(a) + Qe, Ne = nA << Qe, nt = Ne | oe, Ut = VA + R;
        Ga = 1 << me | nt, va = Ut;
      } else {
        var It = nA << L, Hi = It | W, _i = R;
        Ga = 1 << sA | Hi, va = _i;
      }
    }
    function Bp(o) {
      $B();
      var a = o.return;
      if (a !== null) {
        var h = 1, w = 0;
        XB(o, h), Um(o, h, w);
      }
    }
    function Ou(o) {
      return 32 - vs(o);
    }
    function jk(o) {
      return 1 << Ou(o) - 1;
    }
    function Cp(o) {
      for (; o === _u; )
        _u = pQ[--DQ], pQ[DQ] = null, Ju = pQ[--DQ], pQ[DQ] = null;
      for (; o === ZB; )
        ZB = lo[--co], lo[co] = null, va = lo[--co], lo[co] = null, Ga = lo[--co], lo[co] = null;
    }
    function Zk() {
      return $B(), ZB !== null ? {
        id: Ga,
        overflow: va
      } : null;
    }
    function Xk(o, a) {
      $B(), lo[co++] = Ga, lo[co++] = va, lo[co++] = ZB, Ga = a.id, va = a.overflow, ZB = o;
    }
    function $B() {
      vg() || I("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Cg = null, uo = null, Zo = !1, AC = !1, KI = null;
    function $k() {
      Zo && I("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function Ax() {
      AC = !0;
    }
    function ex(o) {
      if (!fn)
        return !1;
      var a = o.stateNode.containerInfo;
      return uo = ag(a), Cg = o, Zo = !0, KI = null, AC = !1, !0;
    }
    function tx(o, a, h) {
      return fn ? (uo = oI(a), Cg = o, Zo = !0, KI = null, AC = !1, h !== null && Xk(o, h), !0) : !1;
    }
    function km(o, a) {
      switch (o.tag) {
        case x:
          Ds(o.stateNode.containerInfo, a);
          break;
        case _:
          CI(o.type, o.memoizedProps, o.stateNode, a);
          break;
        case tA:
          var h = o.memoizedState;
          h.dehydrated !== null && BI(h.dehydrated, a);
          break;
      }
    }
    function xm(o, a) {
      km(o, a);
      var h = iK();
      h.stateNode = a, h.return = o;
      var w = o.deletions;
      w === null ? (o.deletions = [h], o.flags |= Me) : w.push(h);
    }
    function Qp(o, a) {
      {
        if (AC)
          return;
        switch (o.tag) {
          case x: {
            var h = o.stateNode.containerInfo;
            switch (a.tag) {
              case _:
                var w = a.type, R = a.pendingProps;
                Dg(h, w, R);
                break;
              case j:
                var L = a.pendingProps;
                wg(h, L);
                break;
              case tA:
                bo(h);
                break;
            }
            break;
          }
          case _: {
            var W = o.type, nA = o.memoizedProps, sA = o.stateNode;
            switch (a.tag) {
              case _:
                var pA = a.type, LA = a.pendingProps;
                QI(W, nA, sA, pA, LA);
                break;
              case j:
                var VA = a.pendingProps;
                kB(W, nA, sA, VA);
                break;
              case tA:
                Ho(W, nA, sA);
                break;
            }
            break;
          }
          case tA: {
            var oe = o.memoizedState, Qe = oe.dehydrated;
            if (Qe !== null)
              switch (a.tag) {
                case _:
                  var me = a.type, Ne = a.pendingProps;
                  Lr(Qe, me, Ne);
                  break;
                case j:
                  var nt = a.pendingProps;
                  Tr(Qe, nt);
                  break;
                case tA:
                  Yo(Qe);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function Lm(o, a) {
      a.flags = a.flags & ~Jt | UA, Qp(o, a);
    }
    function Tm(o, a) {
      switch (o.tag) {
        case _: {
          var h = o.type, w = o.pendingProps, R = Ba(a, h, w);
          return R !== null ? (o.stateNode = R, Cg = o, uo = xr(R), !0) : !1;
        }
        case j: {
          var L = o.pendingProps, W = qn(a, L);
          return W !== null ? (o.stateNode = W, Cg = o, uo = null, !0) : !1;
        }
        case tA: {
          {
            var nA = pg(a);
            if (nA !== null) {
              var sA = {
                dehydrated: nA,
                treeContext: Zk(),
                retryLane: fi
              };
              o.memoizedState = sA;
              var pA = nK(nA);
              return pA.return = o, o.child = pA, Cg = o, uo = null, !0;
            }
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function Ep(o) {
      return (o.mode & si) !== Ct && (o.flags & Ee) === gA;
    }
    function lp(o) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function cp(o) {
      if (Zo) {
        var a = uo;
        if (!a) {
          Ep(o) && (Qp(Cg, o), lp()), Lm(Cg, o), Zo = !1, Cg = o;
          return;
        }
        var h = a;
        if (!Tm(o, a)) {
          Ep(o) && (Qp(Cg, o), lp()), a = Ko(h);
          var w = Cg;
          if (!a || !Tm(o, a)) {
            Lm(Cg, o), Zo = !1, Cg = o;
            return;
          }
          xm(w, h);
        }
      }
    }
    function ix(o, a, h) {
      if (!fn)
        throw new Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var w = o.stateNode, R = !AC, L = eQ(w, o.type, o.memoizedProps, a, h, o, R);
      return o.updateQueue = L, L !== null;
    }
    function nx(o) {
      if (!fn)
        throw new Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var a = o.stateNode, h = o.memoizedProps, w = !AC, R = sI(a, h, o, w);
      if (R) {
        var L = Cg;
        if (L !== null) {
          var W = (L.mode & si) !== Ct;
          switch (L.tag) {
            case x: {
              var nA = L.stateNode.containerInfo;
              UB(
                nA,
                a,
                h,
                // TODO: Delete this argument when we remove the legacy root API.
                W
              );
              break;
            }
            case _: {
              var sA = L.type, pA = L.memoizedProps, LA = L.stateNode;
              ps(
                sA,
                pA,
                LA,
                a,
                h,
                // TODO: Delete this argument when we remove the legacy root API.
                W
              );
              break;
            }
          }
        }
      }
      return R;
    }
    function gx(o) {
      if (!fn)
        throw new Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var a = o.memoizedState, h = a !== null ? a.dehydrated : null;
      if (!h)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      tQ(h, o);
    }
    function rx(o) {
      if (!fn)
        throw new Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var a = o.memoizedState, h = a !== null ? a.dehydrated : null;
      if (!h)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return iQ(h);
    }
    function Km(o) {
      for (var a = o.return; a !== null && a.tag !== _ && a.tag !== x && a.tag !== tA; )
        a = a.return;
      Cg = a;
    }
    function Dl(o) {
      if (!fn || o !== Cg)
        return !1;
      if (!Zo)
        return Km(o), Zo = !0, !1;
      if (o.tag !== x && (o.tag !== _ || gQ(o.type) && !wB(o.type, o.memoizedProps))) {
        var a = uo;
        if (a)
          if (Ep(o))
            bm(o), lp();
          else
            for (; a; )
              xm(o, a), a = Ko(a);
      }
      return Km(o), o.tag === tA ? uo = rx(o) : uo = Cg ? Ko(o.stateNode) : null, !0;
    }
    function ox() {
      return Zo && uo !== null;
    }
    function bm(o) {
      for (var a = uo; a; )
        km(o, a), a = Ko(a);
    }
    function wQ() {
      fn && (Cg = null, uo = null, Zo = !1, AC = !1);
    }
    function Ym() {
      KI !== null && (SM(KI), KI = null);
    }
    function vg() {
      return Zo;
    }
    function up(o) {
      KI === null ? KI = [o] : KI.push(o);
    }
    var hp, dp, fp, pp, Dp, Hm = function(o, a) {
    };
    hp = !1, dp = !1, fp = {}, pp = {}, Dp = {}, Hm = function(o, a) {
      if (!(o === null || typeof o != "object") && !(!o._store || o._store.validated || o.key != null)) {
        if (typeof o._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        o._store.validated = !0;
        var h = xA(a) || "Component";
        pp[h] || (pp[h] = !0, I('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function wl(o, a, h) {
      var w = h.ref;
      if (w !== null && typeof w != "function" && typeof w != "object") {
        if ((o.mode & Ki || y) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(h._owner && h._self && h._owner.stateNode !== h._self)) {
          var R = xA(o) || "Component";
          fp[R] || (I('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', w), fp[R] = !0);
        }
        if (h._owner) {
          var L = h._owner, W;
          if (L) {
            var nA = L;
            if (nA.tag !== k)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            W = nA.stateNode;
          }
          if (!W)
            throw new Error("Missing owner for string ref " + w + ". This error is likely caused by a bug in React. Please file an issue.");
          var sA = W;
          bu(w, "ref");
          var pA = "" + w;
          if (a !== null && a.ref !== null && typeof a.ref == "function" && a.ref._stringRef === pA)
            return a.ref;
          var LA = function(VA) {
            var oe = sA.refs;
            oe === Sm && (oe = sA.refs = {}), VA === null ? delete oe[pA] : oe[pA] = VA;
          };
          return LA._stringRef = pA, LA;
        } else {
          if (typeof w != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!h._owner)
            throw new Error("Element ref was specified as a string (" + w + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return w;
    }
    function qu(o, a) {
      var h = Object.prototype.toString.call(a);
      throw new Error("Objects are not valid as a React child (found: " + (h === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : h) + "). If you meant to render a collection of children, use an array instead.");
    }
    function Pu(o) {
      {
        var a = xA(o) || "Component";
        if (Dp[a])
          return;
        Dp[a] = !0, I("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function _m(o) {
      var a = o._payload, h = o._init;
      return h(a);
    }
    function Jm(o) {
      function a(te, le) {
        if (o) {
          var XA = te.deletions;
          XA === null ? (te.deletions = [le], te.flags |= Me) : XA.push(le);
        }
      }
      function h(te, le) {
        if (!o)
          return null;
        for (var XA = le; XA !== null; )
          a(te, XA), XA = XA.sibling;
        return null;
      }
      function w(te, le) {
        for (var XA = /* @__PURE__ */ new Map(), Fe = le; Fe !== null; )
          Fe.key !== null ? XA.set(Fe.key, Fe) : XA.set(Fe.index, Fe), Fe = Fe.sibling;
        return XA;
      }
      function R(te, le) {
        var XA = oC(te, le);
        return XA.index = 0, XA.sibling = null, XA;
      }
      function L(te, le, XA) {
        if (te.index = XA, !o)
          return te.flags |= At, le;
        var Fe = te.alternate;
        if (Fe !== null) {
          var $e = Fe.index;
          return $e < le ? (te.flags |= UA, le) : $e;
        } else
          return te.flags |= UA, le;
      }
      function W(te) {
        return o && te.alternate === null && (te.flags |= UA), te;
      }
      function nA(te, le, XA, Fe) {
        if (le === null || le.tag !== j) {
          var $e = qD(XA, te.mode, Fe);
          return $e.return = te, $e;
        } else {
          var ze = R(le, XA);
          return ze.return = te, ze;
        }
      }
      function sA(te, le, XA, Fe) {
        var $e = XA.type;
        if ($e === JA)
          return LA(te, le, XA.props.children, Fe, XA.key);
        if (le !== null && (le.elementType === $e || // Keep this check inline so it only runs on the false path:
        HM(le, XA) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof $e == "object" && $e !== null && $e.$$typeof === q && _m($e) === le.type)) {
          var ze = R(le, XA.props);
          return ze.ref = wl(te, le, XA), ze.return = te, ze._debugSource = XA._source, ze._debugOwner = XA._owner, ze;
        }
        var jt = OD(XA, te.mode, Fe);
        return jt.ref = wl(te, le, XA), jt.return = te, jt;
      }
      function pA(te, le, XA, Fe) {
        if (le === null || le.tag !== H || le.stateNode.containerInfo !== XA.containerInfo || le.stateNode.implementation !== XA.implementation) {
          var $e = PD(XA, te.mode, Fe);
          return $e.return = te, $e;
        } else {
          var ze = R(le, XA.children || []);
          return ze.return = te, ze;
        }
      }
      function LA(te, le, XA, Fe, $e) {
        if (le === null || le.tag !== V) {
          var ze = WI(XA, te.mode, Fe, $e);
          return ze.return = te, ze;
        } else {
          var jt = R(le, XA);
          return jt.return = te, jt;
        }
      }
      function VA(te, le, XA) {
        if (typeof le == "string" && le !== "" || typeof le == "number") {
          var Fe = qD("" + le, te.mode, XA);
          return Fe.return = te, Fe;
        }
        if (typeof le == "object" && le !== null) {
          switch (le.$$typeof) {
            case dA: {
              var $e = OD(le, te.mode, XA);
              return $e.ref = wl(te, null, le), $e.return = te, $e;
            }
            case vA: {
              var ze = PD(le, te.mode, XA);
              return ze.return = te, ze;
            }
            case q: {
              var jt = le._payload, li = le._init;
              return VA(te, li(jt), XA);
            }
          }
          if (Mt(le) || mA(le)) {
            var Ni = WI(le, te.mode, XA, null);
            return Ni.return = te, Ni;
          }
          qu(te, le);
        }
        return typeof le == "function" && Pu(te), null;
      }
      function oe(te, le, XA, Fe) {
        var $e = le !== null ? le.key : null;
        if (typeof XA == "string" && XA !== "" || typeof XA == "number")
          return $e !== null ? null : nA(te, le, "" + XA, Fe);
        if (typeof XA == "object" && XA !== null) {
          switch (XA.$$typeof) {
            case dA:
              return XA.key === $e ? sA(te, le, XA, Fe) : null;
            case vA:
              return XA.key === $e ? pA(te, le, XA, Fe) : null;
            case q: {
              var ze = XA._payload, jt = XA._init;
              return oe(te, le, jt(ze), Fe);
            }
          }
          if (Mt(XA) || mA(XA))
            return $e !== null ? null : LA(te, le, XA, Fe, null);
          qu(te, XA);
        }
        return typeof XA == "function" && Pu(te), null;
      }
      function Qe(te, le, XA, Fe, $e) {
        if (typeof Fe == "string" && Fe !== "" || typeof Fe == "number") {
          var ze = te.get(XA) || null;
          return nA(le, ze, "" + Fe, $e);
        }
        if (typeof Fe == "object" && Fe !== null) {
          switch (Fe.$$typeof) {
            case dA: {
              var jt = te.get(Fe.key === null ? XA : Fe.key) || null;
              return sA(le, jt, Fe, $e);
            }
            case vA: {
              var li = te.get(Fe.key === null ? XA : Fe.key) || null;
              return pA(le, li, Fe, $e);
            }
            case q: {
              var Ni = Fe._payload, ci = Fe._init;
              return Qe(te, le, XA, ci(Ni), $e);
            }
          }
          if (Mt(Fe) || mA(Fe)) {
            var Qn = te.get(XA) || null;
            return LA(le, Qn, Fe, $e, null);
          }
          qu(le, Fe);
        }
        return typeof Fe == "function" && Pu(le), null;
      }
      function me(te, le, XA) {
        {
          if (typeof te != "object" || te === null)
            return le;
          switch (te.$$typeof) {
            case dA:
            case vA:
              Hm(te, XA);
              var Fe = te.key;
              if (typeof Fe != "string")
                break;
              if (le === null) {
                le = /* @__PURE__ */ new Set(), le.add(Fe);
                break;
              }
              if (!le.has(Fe)) {
                le.add(Fe);
                break;
              }
              I("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", Fe);
              break;
            case q: {
              var $e = te._payload, ze = te._init;
              me(ze($e), le, XA);
              break;
            }
          }
        }
        return le;
      }
      function Ne(te, le, XA, Fe) {
        for (var $e = null, ze = 0; ze < XA.length; ze++) {
          var jt = XA[ze];
          $e = me(jt, $e, te);
        }
        for (var li = null, Ni = null, ci = le, Qn = 0, Ii = 0, Ot = null; ci !== null && Ii < XA.length; Ii++) {
          ci.index > Ii ? (Ot = ci, ci = null) : Ot = ci.sibling;
          var Ln = oe(te, ci, XA[Ii], Fe);
          if (Ln === null) {
            ci === null && (ci = Ot);
            break;
          }
          o && ci && Ln.alternate === null && a(te, ci), Qn = L(Ln, Qn, Ii), Ni === null ? li = Ln : Ni.sibling = Ln, Ni = Ln, ci = Ot;
        }
        if (Ii === XA.length) {
          if (h(te, ci), vg()) {
            var En = Ii;
            XB(te, En);
          }
          return li;
        }
        if (ci === null) {
          for (; Ii < XA.length; Ii++) {
            var yo = VA(te, XA[Ii], Fe);
            yo !== null && (Qn = L(yo, Qn, Ii), Ni === null ? li = yo : Ni.sibling = yo, Ni = yo);
          }
          if (vg()) {
            var ug = Ii;
            XB(te, ug);
          }
          return li;
        }
        for (var Wr = w(te, ci); Ii < XA.length; Ii++) {
          var zr = Qe(Wr, te, Ii, XA[Ii], Fe);
          zr !== null && (o && zr.alternate !== null && Wr.delete(zr.key === null ? Ii : zr.key), Qn = L(zr, Qn, Ii), Ni === null ? li = zr : Ni.sibling = zr, Ni = zr);
        }
        if (o && Wr.forEach(function(bQ) {
          return a(te, bQ);
        }), vg()) {
          var Vs = Ii;
          XB(te, Vs);
        }
        return li;
      }
      function nt(te, le, XA, Fe) {
        var $e = mA(XA);
        if (typeof $e != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          XA[Symbol.toStringTag] === "Generator" && (dp || I("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), dp = !0), XA.entries === $e && (hp || I("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), hp = !0);
          var ze = $e.call(XA);
          if (ze)
            for (var jt = null, li = ze.next(); !li.done; li = ze.next()) {
              var Ni = li.value;
              jt = me(Ni, jt, te);
            }
        }
        var ci = $e.call(XA);
        if (ci == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Qn = null, Ii = null, Ot = le, Ln = 0, En = 0, yo = null, ug = ci.next(); Ot !== null && !ug.done; En++, ug = ci.next()) {
          Ot.index > En ? (yo = Ot, Ot = null) : yo = Ot.sibling;
          var Wr = oe(te, Ot, ug.value, Fe);
          if (Wr === null) {
            Ot === null && (Ot = yo);
            break;
          }
          o && Ot && Wr.alternate === null && a(te, Ot), Ln = L(Wr, Ln, En), Ii === null ? Qn = Wr : Ii.sibling = Wr, Ii = Wr, Ot = yo;
        }
        if (ug.done) {
          if (h(te, Ot), vg()) {
            var zr = En;
            XB(te, zr);
          }
          return Qn;
        }
        if (Ot === null) {
          for (; !ug.done; En++, ug = ci.next()) {
            var Vs = VA(te, ug.value, Fe);
            Vs !== null && (Ln = L(Vs, Ln, En), Ii === null ? Qn = Vs : Ii.sibling = Vs, Ii = Vs);
          }
          if (vg()) {
            var bQ = En;
            XB(te, bQ);
          }
          return Qn;
        }
        for (var YQ = w(te, Ot); !ug.done; En++, ug = ci.next()) {
          var Vr = Qe(YQ, te, En, ug.value, Fe);
          Vr !== null && (o && Vr.alternate !== null && YQ.delete(Vr.key === null ? En : Vr.key), Ln = L(Vr, Ln, En), Ii === null ? Qn = Vr : Ii.sibling = Vr, Ii = Vr);
        }
        if (o && YQ.forEach(function(ZD) {
          return a(te, ZD);
        }), vg()) {
          var sC = En;
          XB(te, sC);
        }
        return Qn;
      }
      function Ut(te, le, XA, Fe) {
        if (le !== null && le.tag === j) {
          h(te, le.sibling);
          var $e = R(le, XA);
          return $e.return = te, $e;
        }
        h(te, le);
        var ze = qD(XA, te.mode, Fe);
        return ze.return = te, ze;
      }
      function It(te, le, XA, Fe) {
        for (var $e = XA.key, ze = le; ze !== null; ) {
          if (ze.key === $e) {
            var jt = XA.type;
            if (jt === JA) {
              if (ze.tag === V) {
                h(te, ze.sibling);
                var li = R(ze, XA.props.children);
                return li.return = te, li._debugSource = XA._source, li._debugOwner = XA._owner, li;
              }
            } else if (ze.elementType === jt || // Keep this check inline so it only runs on the false path:
            HM(ze, XA) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof jt == "object" && jt !== null && jt.$$typeof === q && _m(jt) === ze.type) {
              h(te, ze.sibling);
              var Ni = R(ze, XA.props);
              return Ni.ref = wl(te, ze, XA), Ni.return = te, Ni._debugSource = XA._source, Ni._debugOwner = XA._owner, Ni;
            }
            h(te, ze);
            break;
          } else
            a(te, ze);
          ze = ze.sibling;
        }
        if (XA.type === JA) {
          var ci = WI(XA.props.children, te.mode, Fe, XA.key);
          return ci.return = te, ci;
        } else {
          var Qn = OD(XA, te.mode, Fe);
          return Qn.ref = wl(te, le, XA), Qn.return = te, Qn;
        }
      }
      function Hi(te, le, XA, Fe) {
        for (var $e = XA.key, ze = le; ze !== null; ) {
          if (ze.key === $e)
            if (ze.tag === H && ze.stateNode.containerInfo === XA.containerInfo && ze.stateNode.implementation === XA.implementation) {
              h(te, ze.sibling);
              var jt = R(ze, XA.children || []);
              return jt.return = te, jt;
            } else {
              h(te, ze);
              break;
            }
          else
            a(te, ze);
          ze = ze.sibling;
        }
        var li = PD(XA, te.mode, Fe);
        return li.return = te, li;
      }
      function _i(te, le, XA, Fe) {
        var $e = typeof XA == "object" && XA !== null && XA.type === JA && XA.key === null;
        if ($e && (XA = XA.props.children), typeof XA == "object" && XA !== null) {
          switch (XA.$$typeof) {
            case dA:
              return W(It(te, le, XA, Fe));
            case vA:
              return W(Hi(te, le, XA, Fe));
            case q: {
              var ze = XA._payload, jt = XA._init;
              return _i(te, le, jt(ze), Fe);
            }
          }
          if (Mt(XA))
            return Ne(te, le, XA, Fe);
          if (mA(XA))
            return nt(te, le, XA, Fe);
          qu(te, XA);
        }
        return typeof XA == "string" && XA !== "" || typeof XA == "number" ? W(Ut(te, le, "" + XA, Fe)) : (typeof XA == "function" && Pu(te), h(te, le));
      }
      return _i;
    }
    var yQ = Jm(!0), Om = Jm(!1);
    function sx(o, a) {
      if (o !== null && a.child !== o.child)
        throw new Error("Resuming work not yet implemented.");
      if (a.child !== null) {
        var h = a.child, w = oC(h, h.pendingProps);
        for (a.child = w, w.return = a; h.sibling !== null; )
          h = h.sibling, w = w.sibling = oC(h, h.pendingProps), w.return = a;
        w.sibling = null;
      }
    }
    function ax(o, a) {
      for (var h = o.child; h !== null; )
        XT(h, a), h = h.sibling;
    }
    var yl = {}, bI = ht(yl), ml = ht(yl), Wu = ht(yl);
    function zu(o) {
      if (o === yl)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return o;
    }
    function wp() {
      var o = zu(Wu.current);
      return o;
    }
    function yp(o, a) {
      Ci(Wu, a, o), Ci(ml, o, o), Ci(bI, yl, o);
      var h = nr(a);
      ji(bI, o), Ci(bI, h, o);
    }
    function mQ(o) {
      ji(bI, o), ji(ml, o), ji(Wu, o);
    }
    function Sl() {
      var o = zu(bI.current);
      return o;
    }
    function qm(o) {
      var a = zu(Wu.current), h = zu(bI.current), w = An(h, o.type, a);
      h !== w && (Ci(ml, o, o), Ci(bI, w, o));
    }
    function mp(o) {
      ml.current === o && (ji(bI, o), ji(ml, o));
    }
    var Ix = 0, Pm = 1, Wm = 1, Ml = 2, Xo = ht(Ix);
    function Sp(o, a) {
      return (o & a) !== 0;
    }
    function SQ(o) {
      return o & Pm;
    }
    function Mp(o, a) {
      return o & Pm | a;
    }
    function Bx(o, a) {
      return o | a;
    }
    function YI(o, a) {
      Ci(Xo, a, o);
    }
    function MQ(o) {
      ji(Xo, o);
    }
    function Cx(o, a) {
      var h = o.memoizedState;
      return h !== null ? h.dehydrated !== null : (o.memoizedProps, !0);
    }
    function Vu(o) {
      for (var a = o; a !== null; ) {
        if (a.tag === tA) {
          var h = a.memoizedState;
          if (h !== null) {
            var w = h.dehydrated;
            if (w === null || Og(w) || or(w))
              return a;
          }
        } else if (a.tag === hA && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        a.memoizedProps.revealOrder !== void 0) {
          var R = (a.flags & Ee) !== gA;
          if (R)
            return a;
        } else if (a.child !== null) {
          a.child.return = a, a = a.child;
          continue;
        }
        if (a === o)
          return null;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === o)
            return null;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
      return null;
    }
    var Js = (
      /*   */
      0
    ), In = (
      /* */
      1
    ), HI = (
      /*  */
      2
    ), xn = (
      /*    */
      4
    ), Qg = (
      /*   */
      8
    ), Rp = [];
    function Np() {
      for (var o = 0; o < Rp.length; o++) {
        var a = Rp[o];
        oo ? a._workInProgressVersionPrimary = null : a._workInProgressVersionSecondary = null;
      }
      Rp.length = 0;
    }
    function Qx(o, a) {
      var h = a._getVersion, w = h(a._source);
      o.mutableSourceEagerHydrationData == null ? o.mutableSourceEagerHydrationData = [a, w] : o.mutableSourceEagerHydrationData.push(a, w);
    }
    var We = n.ReactCurrentDispatcher, cr = n.ReactCurrentBatchConfig, Fp, RQ;
    Fp = /* @__PURE__ */ new Set();
    var NQ = De, Mi = null, Ug = null, Vn = null, ju = !1, Rl = !1, Nl = 0, Ex = 0, lx = 25, ce = null, ho = null, _I = -1, Gp = !1;
    function Qi() {
      {
        var o = ce;
        ho === null ? ho = [o] : ho.push(o);
      }
    }
    function Ke() {
      {
        var o = ce;
        ho !== null && (_I++, ho[_I] !== o && cx(o));
      }
    }
    function FQ(o) {
      o != null && !Mt(o) && I("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", ce, typeof o);
    }
    function cx(o) {
      {
        var a = xA(Mi);
        if (!Fp.has(a) && (Fp.add(a), ho !== null)) {
          for (var h = "", w = 30, R = 0; R <= _I; R++) {
            for (var L = ho[R], W = R === _I ? o : L, nA = R + 1 + ". " + L; nA.length < w; )
              nA += " ";
            nA += W + `
`, h += nA;
          }
          I(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, a, h);
        }
      }
    }
    function kg() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function vp(o, a) {
      if (Gp)
        return !1;
      if (a === null)
        return I("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", ce), !1;
      o.length !== a.length && I(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, ce, "[" + a.join(", ") + "]", "[" + o.join(", ") + "]");
      for (var h = 0; h < a.length && h < o.length; h++)
        if (!Vg(o[h], a[h]))
          return !1;
      return !0;
    }
    function GQ(o, a, h, w, R, L) {
      NQ = L, Mi = a, ho = o !== null ? o._debugHookTypes : null, _I = -1, Gp = o !== null && o.type !== a.type, a.memoizedState = null, a.updateQueue = null, a.lanes = De, o !== null && o.memoizedState !== null ? We.current = lS : ho !== null ? We.current = ES : We.current = QS;
      var W = h(w, R);
      if (Rl) {
        var nA = 0;
        do {
          if (Rl = !1, Nl = 0, nA >= lx)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          nA += 1, Gp = !1, Ug = null, Vn = null, a.updateQueue = null, _I = -1, We.current = cS, W = h(w, R);
        } while (Rl);
      }
      We.current = ah, a._debugHookTypes = ho;
      var sA = Ug !== null && Ug.next !== null;
      if (NQ = De, Mi = null, Ug = null, Vn = null, ce = null, ho = null, _I = -1, o !== null && (o.flags & $i) !== (a.flags & $i) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (o.mode & si) !== Ct && I("Internal React error: Expected static flag was missing. Please notify the React team."), ju = !1, sA)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return W;
    }
    function vQ() {
      var o = Nl !== 0;
      return Nl = 0, o;
    }
    function zm(o, a, h) {
      a.updateQueue = o.updateQueue, (a.mode & Sg) !== Ct ? a.flags &= ~(ft | Bt | Nt | TA) : a.flags &= ~(Nt | TA), o.lanes = fa(o.lanes, h);
    }
    function Vm() {
      if (We.current = ah, ju) {
        for (var o = Mi.memoizedState; o !== null; ) {
          var a = o.queue;
          a !== null && (a.pending = null), o = o.next;
        }
        ju = !1;
      }
      NQ = De, Mi = null, Ug = null, Vn = null, ho = null, _I = -1, ce = null, oS = !1, Rl = !1, Nl = 0;
    }
    function Ua() {
      var o = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Vn === null ? Mi.memoizedState = Vn = o : Vn = Vn.next = o, Vn;
    }
    function Os() {
      var o;
      if (Ug === null) {
        var a = Mi.alternate;
        a !== null ? o = a.memoizedState : o = null;
      } else
        o = Ug.next;
      var h;
      if (Vn === null ? h = Mi.memoizedState : h = Vn.next, h !== null)
        Vn = h, h = Vn.next, Ug = o;
      else {
        if (o === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Ug = o;
        var w = {
          memoizedState: Ug.memoizedState,
          baseState: Ug.baseState,
          baseQueue: Ug.baseQueue,
          queue: Ug.queue,
          next: null
        };
        Vn === null ? Mi.memoizedState = Vn = w : Vn = Vn.next = w;
      }
      return Vn;
    }
    function jm() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function Up(o, a) {
      return typeof a == "function" ? a(o) : a;
    }
    function kp(o, a, h) {
      var w = Ua(), R;
      h !== void 0 ? R = h(a) : R = a, w.memoizedState = w.baseState = R;
      var L = {
        pending: null,
        interleaved: null,
        lanes: De,
        dispatch: null,
        lastRenderedReducer: o,
        lastRenderedState: R
      };
      w.queue = L;
      var W = L.dispatch = fx.bind(null, Mi, L);
      return [w.memoizedState, W];
    }
    function xp(o, a, h) {
      var w = Os(), R = w.queue;
      if (R === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      R.lastRenderedReducer = o;
      var L = Ug, W = L.baseQueue, nA = R.pending;
      if (nA !== null) {
        if (W !== null) {
          var sA = W.next, pA = nA.next;
          W.next = pA, nA.next = sA;
        }
        L.baseQueue !== W && I("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), L.baseQueue = W = nA, R.pending = null;
      }
      if (W !== null) {
        var LA = W.next, VA = L.baseState, oe = null, Qe = null, me = null, Ne = LA;
        do {
          var nt = Ne.lane;
          if (yI(NQ, nt)) {
            if (me !== null) {
              var It = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: nn,
                action: Ne.action,
                hasEagerState: Ne.hasEagerState,
                eagerState: Ne.eagerState,
                next: null
              };
              me = me.next = It;
            }
            if (Ne.hasEagerState)
              VA = Ne.eagerState;
            else {
              var Hi = Ne.action;
              VA = o(VA, Hi);
            }
          } else {
            var Ut = {
              lane: nt,
              action: Ne.action,
              hasEagerState: Ne.hasEagerState,
              eagerState: Ne.eagerState,
              next: null
            };
            me === null ? (Qe = me = Ut, oe = VA) : me = me.next = Ut, Mi.lanes = Gt(Mi.lanes, nt), qh(nt);
          }
          Ne = Ne.next;
        } while (Ne !== null && Ne !== LA);
        me === null ? oe = VA : me.next = Qe, Vg(VA, w.memoizedState) || Dh(), w.memoizedState = VA, w.baseState = oe, w.baseQueue = me, R.lastRenderedState = VA;
      }
      var _i = R.interleaved;
      if (_i !== null) {
        var te = _i;
        do {
          var le = te.lane;
          Mi.lanes = Gt(Mi.lanes, le), qh(le), te = te.next;
        } while (te !== _i);
      } else
        W === null && (R.lanes = De);
      var XA = R.dispatch;
      return [w.memoizedState, XA];
    }
    function Lp(o, a, h) {
      var w = Os(), R = w.queue;
      if (R === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      R.lastRenderedReducer = o;
      var L = R.dispatch, W = R.pending, nA = w.memoizedState;
      if (W !== null) {
        R.pending = null;
        var sA = W.next, pA = sA;
        do {
          var LA = pA.action;
          nA = o(nA, LA), pA = pA.next;
        } while (pA !== sA);
        Vg(nA, w.memoizedState) || Dh(), w.memoizedState = nA, w.baseQueue === null && (w.baseState = nA), R.lastRenderedState = nA;
      }
      return [nA, L];
    }
    function i5(o, a, h) {
    }
    function n5(o, a, h) {
    }
    function Tp(o, a, h) {
      var w = Mi, R = Ua(), L, W = vg();
      if (W) {
        if (h === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        L = h(), RQ || L !== h() && (I("The result of getServerSnapshot should be cached to avoid an infinite loop"), RQ = !0);
      } else {
        if (L = a(), !RQ) {
          var nA = a();
          Vg(L, nA) || (I("The result of getSnapshot should be cached to avoid an infinite loop"), RQ = !0);
        }
        var sA = Hh();
        if (sA === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        da(sA, NQ) || Zm(w, a, L);
      }
      R.memoizedState = L;
      var pA = {
        value: L,
        getSnapshot: a
      };
      return R.queue = pA, Ul($m.bind(null, w, pA, o), [o]), w.flags |= Nt, Gl(In | Qg, Xm.bind(null, w, pA, L, a), void 0, null), L;
    }
    function Zu(o, a, h) {
      var w = Mi, R = Os(), L = a();
      if (!RQ) {
        var W = a();
        Vg(L, W) || (I("The result of getSnapshot should be cached to avoid an infinite loop"), RQ = !0);
      }
      var nA = R.memoizedState, sA = !Vg(nA, L);
      sA && (R.memoizedState = L, Dh());
      var pA = R.queue;
      if (eC($m.bind(null, w, pA, o), [o]), pA.getSnapshot !== a || sA || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Vn !== null && Vn.memoizedState.tag & In) {
        w.flags |= Nt, Gl(In | Qg, Xm.bind(null, w, pA, L, a), void 0, null);
        var LA = Hh();
        if (LA === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        da(LA, NQ) || Zm(w, a, L);
      }
      return L;
    }
    function Zm(o, a, h) {
      o.flags |= Ri;
      var w = {
        getSnapshot: a,
        value: h
      }, R = Mi.updateQueue;
      if (R === null)
        R = jm(), Mi.updateQueue = R, R.stores = [w];
      else {
        var L = R.stores;
        L === null ? R.stores = [w] : L.push(w);
      }
    }
    function Xm(o, a, h, w) {
      a.value = h, a.getSnapshot = w, AS(a) && eS(o);
    }
    function $m(o, a, h) {
      var w = function() {
        AS(a) && eS(o);
      };
      return h(w);
    }
    function AS(o) {
      var a = o.getSnapshot, h = o.value;
      try {
        var w = a();
        return !Vg(h, w);
      } catch {
        return !0;
      }
    }
    function eS(o) {
      Xn(o, Lt, Si);
    }
    function Fl(o) {
      var a = Ua();
      typeof o == "function" && (o = o()), a.memoizedState = a.baseState = o;
      var h = {
        pending: null,
        interleaved: null,
        lanes: De,
        dispatch: null,
        lastRenderedReducer: Up,
        lastRenderedState: o
      };
      a.queue = h;
      var w = h.dispatch = px.bind(null, Mi, h);
      return [a.memoizedState, w];
    }
    function Xu(o) {
      return xp(Up);
    }
    function $u(o) {
      return Lp(Up);
    }
    function Gl(o, a, h, w) {
      var R = {
        tag: o,
        create: a,
        destroy: h,
        deps: w,
        // Circular
        next: null
      }, L = Mi.updateQueue;
      if (L === null)
        L = jm(), Mi.updateQueue = L, L.lastEffect = R.next = R;
      else {
        var W = L.lastEffect;
        if (W === null)
          L.lastEffect = R.next = R;
        else {
          var nA = W.next;
          W.next = R, R.next = nA, L.lastEffect = R;
        }
      }
      return R;
    }
    function Kp(o) {
      var a = Ua();
      {
        var h = {
          current: o
        };
        return a.memoizedState = h, h;
      }
    }
    function Ah(o) {
      var a = Os();
      return a.memoizedState;
    }
    function vl(o, a, h, w) {
      var R = Ua(), L = w === void 0 ? null : w;
      Mi.flags |= o, R.memoizedState = Gl(In | a, h, void 0, L);
    }
    function eh(o, a, h, w) {
      var R = Os(), L = w === void 0 ? null : w, W = void 0;
      if (Ug !== null) {
        var nA = Ug.memoizedState;
        if (W = nA.destroy, L !== null) {
          var sA = nA.deps;
          if (vp(L, sA)) {
            R.memoizedState = Gl(a, h, W, L);
            return;
          }
        }
      }
      Mi.flags |= o, R.memoizedState = Gl(In | a, h, W, L);
    }
    function Ul(o, a) {
      return (Mi.mode & Sg) !== Ct ? vl(ft | Nt | Et, Qg, o, a) : vl(Nt | Et, Qg, o, a);
    }
    function eC(o, a) {
      return eh(Nt, Qg, o, a);
    }
    function bp(o, a) {
      return vl(TA, HI, o, a);
    }
    function th(o, a) {
      return eh(TA, HI, o, a);
    }
    function Yp(o, a) {
      var h = TA;
      return h |= it, (Mi.mode & Sg) !== Ct && (h |= Bt), vl(h, xn, o, a);
    }
    function ih(o, a) {
      return eh(TA, xn, o, a);
    }
    function tS(o, a) {
      if (typeof a == "function") {
        var h = a, w = o();
        return h(w), function() {
          h(null);
        };
      } else if (a != null) {
        var R = a;
        R.hasOwnProperty("current") || I("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(R).join(", ") + "}");
        var L = o();
        return R.current = L, function() {
          R.current = null;
        };
      }
    }
    function Hp(o, a, h) {
      typeof a != "function" && I("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", a !== null ? typeof a : "null");
      var w = h != null ? h.concat([o]) : null, R = TA;
      return R |= it, (Mi.mode & Sg) !== Ct && (R |= Bt), vl(R, xn, tS.bind(null, a, o), w);
    }
    function nh(o, a, h) {
      typeof a != "function" && I("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", a !== null ? typeof a : "null");
      var w = h != null ? h.concat([o]) : null;
      return eh(TA, xn, tS.bind(null, a, o), w);
    }
    function ux(o, a) {
    }
    var gh = ux;
    function _p(o, a) {
      var h = Ua(), w = a === void 0 ? null : a;
      return h.memoizedState = [o, w], o;
    }
    function rh(o, a) {
      var h = Os(), w = a === void 0 ? null : a, R = h.memoizedState;
      if (R !== null && w !== null) {
        var L = R[1];
        if (vp(w, L))
          return R[0];
      }
      return h.memoizedState = [o, w], o;
    }
    function Jp(o, a) {
      var h = Ua(), w = a === void 0 ? null : a, R = o();
      return h.memoizedState = [R, w], R;
    }
    function oh(o, a) {
      var h = Os(), w = a === void 0 ? null : a, R = h.memoizedState;
      if (R !== null && w !== null) {
        var L = R[1];
        if (vp(w, L))
          return R[0];
      }
      var W = o();
      return h.memoizedState = [W, w], W;
    }
    function Op(o) {
      var a = Fl(o), h = a[0], w = a[1];
      return Ul(function() {
        var R = cr.transition;
        cr.transition = {};
        try {
          w(o);
        } finally {
          cr.transition = R;
        }
      }, [o]), h;
    }
    function iS(o) {
      var a = Xu(), h = a[0], w = a[1];
      return eC(function() {
        var R = cr.transition;
        cr.transition = {};
        try {
          w(o);
        } finally {
          cr.transition = R;
        }
      }, [o]), h;
    }
    function nS(o) {
      var a = $u(), h = a[0], w = a[1];
      return eC(function() {
        var R = cr.transition;
        cr.transition = {};
        try {
          w(o);
        } finally {
          cr.transition = R;
        }
      }, [o]), h;
    }
    function hx(o, a, h) {
      var w = Wg();
      Un(QQ(w, SI)), o(!0);
      var R = cr.transition;
      cr.transition = {};
      var L = cr.transition;
      cr.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        o(!1), a();
      } finally {
        if (Un(w), cr.transition = R, R === null && L._updatedFibers) {
          var W = L._updatedFibers.size;
          W > 10 && B("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), L._updatedFibers.clear();
        }
      }
    }
    function qp() {
      var o = Fl(!1), a = o[0], h = o[1], w = hx.bind(null, h), R = Ua();
      return R.memoizedState = w, [a, w];
    }
    function gS() {
      var o = Xu(), a = o[0], h = Os(), w = h.memoizedState;
      return [a, w];
    }
    function rS() {
      var o = $u(), a = o[0], h = Os(), w = h.memoizedState;
      return [a, w];
    }
    var oS = !1;
    function dx() {
      return oS;
    }
    function Pp() {
      var o = Ua(), a = Hh(), h = a.identifierPrefix, w;
      if (vg()) {
        var R = Vk();
        w = ":" + h + "R" + R;
        var L = Nl++;
        L > 0 && (w += "H" + L.toString(32)), w += ":";
      } else {
        var W = Ex++;
        w = ":" + h + "r" + W.toString(32) + ":";
      }
      return o.memoizedState = w, w;
    }
    function sh() {
      var o = Os(), a = o.memoizedState;
      return a;
    }
    function fx(o, a, h) {
      typeof arguments[3] == "function" && I("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var w = qI(o), R = {
        lane: w,
        action: h,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (sS(o))
        aS(a, R);
      else {
        IS(o, a, R);
        var L = Xg(), W = Xn(o, w, L);
        W !== null && BS(W, a, w);
      }
      CS(o, w);
    }
    function px(o, a, h) {
      typeof arguments[3] == "function" && I("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var w = qI(o), R = {
        lane: w,
        action: h,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (sS(o))
        aS(a, R);
      else {
        IS(o, a, R);
        var L = o.alternate;
        if (o.lanes === De && (L === null || L.lanes === De)) {
          var W = a.lastRenderedReducer;
          if (W !== null) {
            var nA;
            nA = We.current, We.current = $o;
            try {
              var sA = a.lastRenderedState, pA = W(sA, h);
              if (R.hasEagerState = !0, R.eagerState = pA, Vg(pA, sA))
                return;
            } catch {
            } finally {
              We.current = nA;
            }
          }
        }
        var LA = Xg(), VA = Xn(o, w, LA);
        VA !== null && BS(VA, a, w);
      }
      CS(o, w);
    }
    function sS(o) {
      var a = o.alternate;
      return o === Mi || a !== null && a === Mi;
    }
    function aS(o, a) {
      Rl = ju = !0;
      var h = o.pending;
      h === null ? a.next = a : (a.next = h.next, h.next = a), o.pending = a;
    }
    function IS(o, a, h, w) {
      if (yM(o)) {
        var R = a.interleaved;
        R === null ? (h.next = h, gt(a)) : (h.next = R.next, R.next = h), a.interleaved = h;
      } else {
        var L = a.pending;
        L === null ? h.next = h : (h.next = L.next, L.next = h), a.pending = h;
      }
    }
    function BS(o, a, h) {
      if (IQ(h)) {
        var w = a.lanes;
        w = xs(w, o.pendingLanes);
        var R = Gt(w, h);
        a.lanes = R, wa(o, R);
      }
    }
    function CS(o, a, h) {
      vI(o, a);
    }
    var ah = {
      readContext: Ue,
      useCallback: kg,
      useContext: kg,
      useEffect: kg,
      useImperativeHandle: kg,
      useInsertionEffect: kg,
      useLayoutEffect: kg,
      useMemo: kg,
      useReducer: kg,
      useRef: kg,
      useState: kg,
      useDebugValue: kg,
      useDeferredValue: kg,
      useTransition: kg,
      useMutableSource: kg,
      useSyncExternalStore: kg,
      useId: kg,
      unstable_isNewReconciler: p
    }, QS = null, ES = null, lS = null, cS = null, qs = null, $o = null, Ih = null;
    {
      var Wp = function() {
        I("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, dt = function() {
        I("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      QS = {
        readContext: function(o) {
          return Ue(o);
        },
        useCallback: function(o, a) {
          return ce = "useCallback", Qi(), FQ(a), _p(o, a);
        },
        useContext: function(o) {
          return ce = "useContext", Qi(), Ue(o);
        },
        useEffect: function(o, a) {
          return ce = "useEffect", Qi(), FQ(a), Ul(o, a);
        },
        useImperativeHandle: function(o, a, h) {
          return ce = "useImperativeHandle", Qi(), FQ(h), Hp(o, a, h);
        },
        useInsertionEffect: function(o, a) {
          return ce = "useInsertionEffect", Qi(), FQ(a), bp(o, a);
        },
        useLayoutEffect: function(o, a) {
          return ce = "useLayoutEffect", Qi(), FQ(a), Yp(o, a);
        },
        useMemo: function(o, a) {
          ce = "useMemo", Qi(), FQ(a);
          var h = We.current;
          We.current = qs;
          try {
            return Jp(o, a);
          } finally {
            We.current = h;
          }
        },
        useReducer: function(o, a, h) {
          ce = "useReducer", Qi();
          var w = We.current;
          We.current = qs;
          try {
            return kp(o, a, h);
          } finally {
            We.current = w;
          }
        },
        useRef: function(o) {
          return ce = "useRef", Qi(), Kp(o);
        },
        useState: function(o) {
          ce = "useState", Qi();
          var a = We.current;
          We.current = qs;
          try {
            return Fl(o);
          } finally {
            We.current = a;
          }
        },
        useDebugValue: function(o, a) {
          return ce = "useDebugValue", Qi(), void 0;
        },
        useDeferredValue: function(o) {
          return ce = "useDeferredValue", Qi(), Op(o);
        },
        useTransition: function() {
          return ce = "useTransition", Qi(), qp();
        },
        useMutableSource: function(o, a, h) {
          return ce = "useMutableSource", Qi(), void 0;
        },
        useSyncExternalStore: function(o, a, h) {
          return ce = "useSyncExternalStore", Qi(), Tp(o, a, h);
        },
        useId: function() {
          return ce = "useId", Qi(), Pp();
        },
        unstable_isNewReconciler: p
      }, ES = {
        readContext: function(o) {
          return Ue(o);
        },
        useCallback: function(o, a) {
          return ce = "useCallback", Ke(), _p(o, a);
        },
        useContext: function(o) {
          return ce = "useContext", Ke(), Ue(o);
        },
        useEffect: function(o, a) {
          return ce = "useEffect", Ke(), Ul(o, a);
        },
        useImperativeHandle: function(o, a, h) {
          return ce = "useImperativeHandle", Ke(), Hp(o, a, h);
        },
        useInsertionEffect: function(o, a) {
          return ce = "useInsertionEffect", Ke(), bp(o, a);
        },
        useLayoutEffect: function(o, a) {
          return ce = "useLayoutEffect", Ke(), Yp(o, a);
        },
        useMemo: function(o, a) {
          ce = "useMemo", Ke();
          var h = We.current;
          We.current = qs;
          try {
            return Jp(o, a);
          } finally {
            We.current = h;
          }
        },
        useReducer: function(o, a, h) {
          ce = "useReducer", Ke();
          var w = We.current;
          We.current = qs;
          try {
            return kp(o, a, h);
          } finally {
            We.current = w;
          }
        },
        useRef: function(o) {
          return ce = "useRef", Ke(), Kp(o);
        },
        useState: function(o) {
          ce = "useState", Ke();
          var a = We.current;
          We.current = qs;
          try {
            return Fl(o);
          } finally {
            We.current = a;
          }
        },
        useDebugValue: function(o, a) {
          return ce = "useDebugValue", Ke(), void 0;
        },
        useDeferredValue: function(o) {
          return ce = "useDeferredValue", Ke(), Op(o);
        },
        useTransition: function() {
          return ce = "useTransition", Ke(), qp();
        },
        useMutableSource: function(o, a, h) {
          return ce = "useMutableSource", Ke(), void 0;
        },
        useSyncExternalStore: function(o, a, h) {
          return ce = "useSyncExternalStore", Ke(), Tp(o, a, h);
        },
        useId: function() {
          return ce = "useId", Ke(), Pp();
        },
        unstable_isNewReconciler: p
      }, lS = {
        readContext: function(o) {
          return Ue(o);
        },
        useCallback: function(o, a) {
          return ce = "useCallback", Ke(), rh(o, a);
        },
        useContext: function(o) {
          return ce = "useContext", Ke(), Ue(o);
        },
        useEffect: function(o, a) {
          return ce = "useEffect", Ke(), eC(o, a);
        },
        useImperativeHandle: function(o, a, h) {
          return ce = "useImperativeHandle", Ke(), nh(o, a, h);
        },
        useInsertionEffect: function(o, a) {
          return ce = "useInsertionEffect", Ke(), th(o, a);
        },
        useLayoutEffect: function(o, a) {
          return ce = "useLayoutEffect", Ke(), ih(o, a);
        },
        useMemo: function(o, a) {
          ce = "useMemo", Ke();
          var h = We.current;
          We.current = $o;
          try {
            return oh(o, a);
          } finally {
            We.current = h;
          }
        },
        useReducer: function(o, a, h) {
          ce = "useReducer", Ke();
          var w = We.current;
          We.current = $o;
          try {
            return xp(o, a, h);
          } finally {
            We.current = w;
          }
        },
        useRef: function(o) {
          return ce = "useRef", Ke(), Ah();
        },
        useState: function(o) {
          ce = "useState", Ke();
          var a = We.current;
          We.current = $o;
          try {
            return Xu(o);
          } finally {
            We.current = a;
          }
        },
        useDebugValue: function(o, a) {
          return ce = "useDebugValue", Ke(), gh();
        },
        useDeferredValue: function(o) {
          return ce = "useDeferredValue", Ke(), iS(o);
        },
        useTransition: function() {
          return ce = "useTransition", Ke(), gS();
        },
        useMutableSource: function(o, a, h) {
          return ce = "useMutableSource", Ke(), void 0;
        },
        useSyncExternalStore: function(o, a, h) {
          return ce = "useSyncExternalStore", Ke(), Zu(o, a);
        },
        useId: function() {
          return ce = "useId", Ke(), sh();
        },
        unstable_isNewReconciler: p
      }, cS = {
        readContext: function(o) {
          return Ue(o);
        },
        useCallback: function(o, a) {
          return ce = "useCallback", Ke(), rh(o, a);
        },
        useContext: function(o) {
          return ce = "useContext", Ke(), Ue(o);
        },
        useEffect: function(o, a) {
          return ce = "useEffect", Ke(), eC(o, a);
        },
        useImperativeHandle: function(o, a, h) {
          return ce = "useImperativeHandle", Ke(), nh(o, a, h);
        },
        useInsertionEffect: function(o, a) {
          return ce = "useInsertionEffect", Ke(), th(o, a);
        },
        useLayoutEffect: function(o, a) {
          return ce = "useLayoutEffect", Ke(), ih(o, a);
        },
        useMemo: function(o, a) {
          ce = "useMemo", Ke();
          var h = We.current;
          We.current = Ih;
          try {
            return oh(o, a);
          } finally {
            We.current = h;
          }
        },
        useReducer: function(o, a, h) {
          ce = "useReducer", Ke();
          var w = We.current;
          We.current = Ih;
          try {
            return Lp(o, a, h);
          } finally {
            We.current = w;
          }
        },
        useRef: function(o) {
          return ce = "useRef", Ke(), Ah();
        },
        useState: function(o) {
          ce = "useState", Ke();
          var a = We.current;
          We.current = Ih;
          try {
            return $u(o);
          } finally {
            We.current = a;
          }
        },
        useDebugValue: function(o, a) {
          return ce = "useDebugValue", Ke(), gh();
        },
        useDeferredValue: function(o) {
          return ce = "useDeferredValue", Ke(), nS(o);
        },
        useTransition: function() {
          return ce = "useTransition", Ke(), rS();
        },
        useMutableSource: function(o, a, h) {
          return ce = "useMutableSource", Ke(), void 0;
        },
        useSyncExternalStore: function(o, a, h) {
          return ce = "useSyncExternalStore", Ke(), Zu(o, a);
        },
        useId: function() {
          return ce = "useId", Ke(), sh();
        },
        unstable_isNewReconciler: p
      }, qs = {
        readContext: function(o) {
          return Wp(), Ue(o);
        },
        useCallback: function(o, a) {
          return ce = "useCallback", dt(), Qi(), _p(o, a);
        },
        useContext: function(o) {
          return ce = "useContext", dt(), Qi(), Ue(o);
        },
        useEffect: function(o, a) {
          return ce = "useEffect", dt(), Qi(), Ul(o, a);
        },
        useImperativeHandle: function(o, a, h) {
          return ce = "useImperativeHandle", dt(), Qi(), Hp(o, a, h);
        },
        useInsertionEffect: function(o, a) {
          return ce = "useInsertionEffect", dt(), Qi(), bp(o, a);
        },
        useLayoutEffect: function(o, a) {
          return ce = "useLayoutEffect", dt(), Qi(), Yp(o, a);
        },
        useMemo: function(o, a) {
          ce = "useMemo", dt(), Qi();
          var h = We.current;
          We.current = qs;
          try {
            return Jp(o, a);
          } finally {
            We.current = h;
          }
        },
        useReducer: function(o, a, h) {
          ce = "useReducer", dt(), Qi();
          var w = We.current;
          We.current = qs;
          try {
            return kp(o, a, h);
          } finally {
            We.current = w;
          }
        },
        useRef: function(o) {
          return ce = "useRef", dt(), Qi(), Kp(o);
        },
        useState: function(o) {
          ce = "useState", dt(), Qi();
          var a = We.current;
          We.current = qs;
          try {
            return Fl(o);
          } finally {
            We.current = a;
          }
        },
        useDebugValue: function(o, a) {
          return ce = "useDebugValue", dt(), Qi(), void 0;
        },
        useDeferredValue: function(o) {
          return ce = "useDeferredValue", dt(), Qi(), Op(o);
        },
        useTransition: function() {
          return ce = "useTransition", dt(), Qi(), qp();
        },
        useMutableSource: function(o, a, h) {
          return ce = "useMutableSource", dt(), Qi(), void 0;
        },
        useSyncExternalStore: function(o, a, h) {
          return ce = "useSyncExternalStore", dt(), Qi(), Tp(o, a, h);
        },
        useId: function() {
          return ce = "useId", dt(), Qi(), Pp();
        },
        unstable_isNewReconciler: p
      }, $o = {
        readContext: function(o) {
          return Wp(), Ue(o);
        },
        useCallback: function(o, a) {
          return ce = "useCallback", dt(), Ke(), rh(o, a);
        },
        useContext: function(o) {
          return ce = "useContext", dt(), Ke(), Ue(o);
        },
        useEffect: function(o, a) {
          return ce = "useEffect", dt(), Ke(), eC(o, a);
        },
        useImperativeHandle: function(o, a, h) {
          return ce = "useImperativeHandle", dt(), Ke(), nh(o, a, h);
        },
        useInsertionEffect: function(o, a) {
          return ce = "useInsertionEffect", dt(), Ke(), th(o, a);
        },
        useLayoutEffect: function(o, a) {
          return ce = "useLayoutEffect", dt(), Ke(), ih(o, a);
        },
        useMemo: function(o, a) {
          ce = "useMemo", dt(), Ke();
          var h = We.current;
          We.current = $o;
          try {
            return oh(o, a);
          } finally {
            We.current = h;
          }
        },
        useReducer: function(o, a, h) {
          ce = "useReducer", dt(), Ke();
          var w = We.current;
          We.current = $o;
          try {
            return xp(o, a, h);
          } finally {
            We.current = w;
          }
        },
        useRef: function(o) {
          return ce = "useRef", dt(), Ke(), Ah();
        },
        useState: function(o) {
          ce = "useState", dt(), Ke();
          var a = We.current;
          We.current = $o;
          try {
            return Xu(o);
          } finally {
            We.current = a;
          }
        },
        useDebugValue: function(o, a) {
          return ce = "useDebugValue", dt(), Ke(), gh();
        },
        useDeferredValue: function(o) {
          return ce = "useDeferredValue", dt(), Ke(), iS(o);
        },
        useTransition: function() {
          return ce = "useTransition", dt(), Ke(), gS();
        },
        useMutableSource: function(o, a, h) {
          return ce = "useMutableSource", dt(), Ke(), void 0;
        },
        useSyncExternalStore: function(o, a, h) {
          return ce = "useSyncExternalStore", dt(), Ke(), Zu(o, a);
        },
        useId: function() {
          return ce = "useId", dt(), Ke(), sh();
        },
        unstable_isNewReconciler: p
      }, Ih = {
        readContext: function(o) {
          return Wp(), Ue(o);
        },
        useCallback: function(o, a) {
          return ce = "useCallback", dt(), Ke(), rh(o, a);
        },
        useContext: function(o) {
          return ce = "useContext", dt(), Ke(), Ue(o);
        },
        useEffect: function(o, a) {
          return ce = "useEffect", dt(), Ke(), eC(o, a);
        },
        useImperativeHandle: function(o, a, h) {
          return ce = "useImperativeHandle", dt(), Ke(), nh(o, a, h);
        },
        useInsertionEffect: function(o, a) {
          return ce = "useInsertionEffect", dt(), Ke(), th(o, a);
        },
        useLayoutEffect: function(o, a) {
          return ce = "useLayoutEffect", dt(), Ke(), ih(o, a);
        },
        useMemo: function(o, a) {
          ce = "useMemo", dt(), Ke();
          var h = We.current;
          We.current = $o;
          try {
            return oh(o, a);
          } finally {
            We.current = h;
          }
        },
        useReducer: function(o, a, h) {
          ce = "useReducer", dt(), Ke();
          var w = We.current;
          We.current = $o;
          try {
            return Lp(o, a, h);
          } finally {
            We.current = w;
          }
        },
        useRef: function(o) {
          return ce = "useRef", dt(), Ke(), Ah();
        },
        useState: function(o) {
          ce = "useState", dt(), Ke();
          var a = We.current;
          We.current = $o;
          try {
            return $u(o);
          } finally {
            We.current = a;
          }
        },
        useDebugValue: function(o, a) {
          return ce = "useDebugValue", dt(), Ke(), gh();
        },
        useDeferredValue: function(o) {
          return ce = "useDeferredValue", dt(), Ke(), nS(o);
        },
        useTransition: function() {
          return ce = "useTransition", dt(), Ke(), rS();
        },
        useMutableSource: function(o, a, h) {
          return ce = "useMutableSource", dt(), Ke(), void 0;
        },
        useSyncExternalStore: function(o, a, h) {
          return ce = "useSyncExternalStore", dt(), Ke(), Zu(o, a);
        },
        useId: function() {
          return ce = "useId", dt(), Ke(), sh();
        },
        unstable_isNewReconciler: p
      };
    }
    var JI = i.unstable_now, uS = 0, Bh = -1, kl = -1, Ch = -1, zp = !1, Qh = !1;
    function hS() {
      return zp;
    }
    function Dx() {
      Qh = !0;
    }
    function wx() {
      zp = !1, Qh = !1;
    }
    function yx() {
      zp = Qh, Qh = !1;
    }
    function dS() {
      return uS;
    }
    function fS() {
      uS = JI();
    }
    function Vp(o) {
      kl = JI(), o.actualStartTime < 0 && (o.actualStartTime = JI());
    }
    function pS(o) {
      kl = -1;
    }
    function Eh(o, a) {
      if (kl >= 0) {
        var h = JI() - kl;
        o.actualDuration += h, a && (o.selfBaseDuration = h), kl = -1;
      }
    }
    function fo(o) {
      if (Bh >= 0) {
        var a = JI() - Bh;
        Bh = -1;
        for (var h = o.return; h !== null; ) {
          switch (h.tag) {
            case x:
              var w = h.stateNode;
              w.effectDuration += a;
              return;
            case J:
              var R = h.stateNode;
              R.effectDuration += a;
              return;
          }
          h = h.return;
        }
      }
    }
    function jp(o) {
      if (Ch >= 0) {
        var a = JI() - Ch;
        Ch = -1;
        for (var h = o.return; h !== null; ) {
          switch (h.tag) {
            case x:
              var w = h.stateNode;
              w !== null && (w.passiveEffectDuration += a);
              return;
            case J:
              var R = h.stateNode;
              R !== null && (R.passiveEffectDuration += a);
              return;
          }
          h = h.return;
        }
      }
    }
    function po() {
      Bh = JI();
    }
    function Zp() {
      Ch = JI();
    }
    function Xp(o) {
      for (var a = o.child; a; )
        o.actualDuration += a.actualDuration, a = a.sibling;
    }
    function lh(o, a) {
      return {
        value: o,
        source: a,
        stack: Ku(a)
      };
    }
    function mx(o, a) {
      return !0;
    }
    function $p(o, a) {
      try {
        var h = mx(o, a);
        if (h === !1)
          return;
        var w = a.value, R = a.source, L = a.stack, W = L !== null ? L : "";
        if (w != null && w._suppressLogging) {
          if (o.tag === k)
            return;
          console.error(w);
        }
        var nA = R ? xA(R) : null, sA = nA ? "The above error occurred in the <" + nA + "> component:" : "The above error occurred in one of your React components:", pA;
        if (o.tag === x)
          pA = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var LA = xA(o) || "Anonymous";
          pA = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + LA + ".");
        }
        var VA = sA + `
` + W + `

` + ("" + pA);
        console.error(VA);
      } catch (oe) {
        setTimeout(function() {
          throw oe;
        });
      }
    }
    var Sx = typeof WeakMap == "function" ? WeakMap : Map;
    function DS(o, a, h) {
      var w = at(Si, h);
      w.tag = $A, w.payload = {
        element: null
      };
      var R = a.value;
      return w.callback = function() {
        vT(R), $p(o, a);
      }, w;
    }
    function AD(o, a, h) {
      var w = at(Si, h);
      w.tag = $A;
      var R = o.type.getDerivedStateFromError;
      if (typeof R == "function") {
        var L = a.value;
        w.payload = function() {
          return R(L);
        }, w.callback = function() {
          _M(o), $p(o, a);
        };
      }
      var W = o.stateNode;
      return W !== null && typeof W.componentDidCatch == "function" && (w.callback = function() {
        _M(o), $p(o, a), typeof R != "function" && FT(this);
        var sA = a.value, pA = a.stack;
        this.componentDidCatch(sA, {
          componentStack: pA !== null ? pA : ""
        }), typeof R != "function" && (rn(o.lanes, Lt) || I("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", xA(o) || "Unknown"));
      }), w;
    }
    function wS(o, a, h) {
      var w = o.pingCache, R;
      if (w === null ? (w = o.pingCache = new Sx(), R = /* @__PURE__ */ new Set(), w.set(a, R)) : (R = w.get(a), R === void 0 && (R = /* @__PURE__ */ new Set(), w.set(a, R))), !R.has(h)) {
        R.add(h);
        var L = UT.bind(null, o, a, h);
        Rg && jl(o, h), a.then(L, L);
      }
    }
    function Mx(o, a, h, w) {
      var R = o.updateQueue;
      if (R === null) {
        var L = /* @__PURE__ */ new Set();
        L.add(h), o.updateQueue = L;
      } else
        R.add(h);
    }
    function Rx(o, a) {
      var h = o.tag;
      if ((o.mode & si) === Ct && (h === G || h === P || h === rA)) {
        var w = o.alternate;
        w ? (o.updateQueue = w.updateQueue, o.memoizedState = w.memoizedState, o.lanes = w.lanes) : (o.updateQueue = null, o.memoizedState = null);
      }
    }
    function yS(o) {
      var a = o;
      do {
        if (a.tag === tA && Cx(a))
          return a;
        a = a.return;
      } while (a !== null);
      return null;
    }
    function mS(o, a, h, w, R) {
      if ((o.mode & si) === Ct) {
        if (o === a)
          o.flags |= PA;
        else {
          if (o.flags |= Ee, h.flags |= Be, h.flags &= ~(lA | se), ga && d) {
            var L = o.alternate;
            if (L === null) {
              var W = o.child, nA = W.child;
              if (nA !== null) {
                var sA = nA.memoizedProps.children, pA = NB("hidden", sA);
                nA.pendingProps = pA, nA.memoizedProps = pA;
              }
            }
          }
          if (h.tag === k) {
            var LA = h.alternate;
            if (LA === null)
              h.tag = aA;
            else {
              var VA = at(Si, Lt);
              VA.tag = Bg, Kt(h, VA);
            }
          }
          h.lanes = Gt(h.lanes, Lt);
        }
        return o;
      }
      return o.flags |= PA, o.lanes = R, o;
    }
    function Nx(o, a, h, w, R) {
      if (h.flags |= se, Rg && jl(o, R), w !== null && typeof w == "object" && typeof w.then == "function") {
        var L = w;
        Rx(h);
        var W = yS(a);
        if (W !== null) {
          W.flags &= ~he, mS(W, a, h, o, R), W.mode & si && wS(o, L, R), Mx(W, o, L);
          return;
        } else {
          if (!tl(R)) {
            wS(o, L, R), UD();
            return;
          }
          var nA = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          w = nA;
        }
      } else if (vg() && h.mode & si) {
        Ax();
        var sA = yS(a);
        if (sA !== null) {
          (sA.flags & PA) === gA && (sA.flags |= he), mS(sA, a, h, o, R), up(w);
          return;
        }
      }
      DT(w), w = lh(w, h);
      var pA = a;
      do {
        switch (pA.tag) {
          case x: {
            var LA = w;
            pA.flags |= PA;
            var VA = wI(R);
            pA.lanes = Gt(pA.lanes, VA);
            var oe = DS(pA, LA, VA);
            ti(pA, oe);
            return;
          }
          case k:
            var Qe = w, me = pA.type, Ne = pA.stateNode;
            if ((pA.flags & Ee) === gA && (typeof me.getDerivedStateFromError == "function" || Ne !== null && typeof Ne.componentDidCatch == "function" && !UM(Ne))) {
              pA.flags |= PA;
              var nt = wI(R);
              pA.lanes = Gt(pA.lanes, nt);
              var Ut = AD(pA, Qe, nt);
              ti(pA, Ut);
              return;
            }
            break;
        }
        pA = pA.return;
      } while (pA !== null);
    }
    function Fx() {
      return null;
    }
    function Ps(o) {
      o.flags |= TA;
    }
    function SS(o) {
      o.flags |= _e, o.flags |= rt;
    }
    function MS(o, a) {
      var h = o !== null && o.child === a.child;
      if (h)
        return !0;
      if ((a.flags & Me) !== gA)
        return !1;
      for (var w = a.child; w !== null; ) {
        if ((w.flags & Ft) !== gA || (w.subtreeFlags & Ft) !== gA)
          return !1;
        w = w.sibling;
      }
      return !0;
    }
    var xl, Ll, ch, uh;
    if (_g)
      xl = function(o, a, h, w) {
        for (var R = a.child; R !== null; ) {
          if (R.tag === _ || R.tag === j)
            xo(o, R.stateNode);
          else if (R.tag !== H) {
            if (R.child !== null) {
              R.child.return = R, R = R.child;
              continue;
            }
          }
          if (R === a)
            return;
          for (; R.sibling === null; ) {
            if (R.return === null || R.return === a)
              return;
            R = R.return;
          }
          R.sibling.return = R.return, R = R.sibling;
        }
      }, Ll = function(o, a) {
      }, ch = function(o, a, h, w, R) {
        var L = o.memoizedProps;
        if (L !== w) {
          var W = a.stateNode, nA = Sl(), sA = fg(W, h, L, w, R, nA);
          a.updateQueue = sA, sA && Ps(a);
        }
      }, uh = function(o, a, h, w) {
        h !== w && Ps(a);
      };
    else if (ga) {
      xl = function(o, a, h, w) {
        for (var R = a.child; R !== null; ) {
          if (R.tag === _) {
            var L = R.stateNode;
            if (h && w) {
              var W = R.memoizedProps, nA = R.type;
              L = FB(L, nA, W, R);
            }
            xo(o, L);
          } else if (R.tag === j) {
            var sA = R.stateNode;
            if (h && w) {
              var pA = R.memoizedProps;
              sA = rI(sA, pA, R);
            }
            xo(o, sA);
          } else if (R.tag !== H) {
            if (R.tag === wA && R.memoizedState !== null) {
              var LA = R.child;
              LA !== null && (LA.return = R), xl(o, R, !0, !0);
            } else if (R.child !== null) {
              R.child.return = R, R = R.child;
              continue;
            }
          }
          if (R = R, R === a)
            return;
          for (; R.sibling === null; ) {
            if (R.return === null || R.return === a)
              return;
            R = R.return;
          }
          R.sibling.return = R.return, R = R.sibling;
        }
      };
      var RS = function(o, a, h, w) {
        for (var R = a.child; R !== null; ) {
          if (R.tag === _) {
            var L = R.stateNode;
            if (h && w) {
              var W = R.memoizedProps, nA = R.type;
              L = FB(L, nA, W, R);
            }
            Ia(o, L);
          } else if (R.tag === j) {
            var sA = R.stateNode;
            if (h && w) {
              var pA = R.memoizedProps;
              sA = rI(sA, pA, R);
            }
            Ia(o, sA);
          } else if (R.tag !== H) {
            if (R.tag === wA && R.memoizedState !== null) {
              var LA = R.child;
              LA !== null && (LA.return = R), RS(o, R, !0, !0);
            } else if (R.child !== null) {
              R.child.return = R, R = R.child;
              continue;
            }
          }
          if (R = R, R === a)
            return;
          for (; R.sibling === null; ) {
            if (R.return === null || R.return === a)
              return;
            R = R.return;
          }
          R.sibling.return = R.return, R = R.sibling;
        }
      };
      Ll = function(o, a) {
        var h = a.stateNode, w = MS(o, a);
        if (!w) {
          var R = h.containerInfo, L = aa(R);
          RS(L, a, !1, !1), h.pendingChildren = L, Ps(a), kr(R, L);
        }
      }, ch = function(o, a, h, w, R) {
        var L = o.stateNode, W = o.memoizedProps, nA = MS(o, a);
        if (nA && W === w) {
          a.stateNode = L;
          return;
        }
        var sA = a.stateNode, pA = Sl(), LA = null;
        if (W !== w && (LA = fg(sA, h, W, w, R, pA)), nA && LA === null) {
          a.stateNode = L;
          return;
        }
        var VA = Jg(L, LA, h, W, w, a, nA, sA);
        tI(VA, h, w, R, pA) && Ps(a), a.stateNode = VA, nA ? Ps(a) : xl(VA, a, !1, !1);
      }, uh = function(o, a, h, w) {
        if (h !== w) {
          var R = wp(), L = Sl();
          a.stateNode = ds(w, R, L, a), Ps(a);
        } else
          a.stateNode = o.stateNode;
      };
    } else
      Ll = function(o, a) {
      }, ch = function(o, a, h, w, R) {
      }, uh = function(o, a, h, w) {
      };
    function Tl(o, a) {
      if (!vg())
        switch (o.tailMode) {
          case "hidden": {
            for (var h = o.tail, w = null; h !== null; )
              h.alternate !== null && (w = h), h = h.sibling;
            w === null ? o.tail = null : w.sibling = null;
            break;
          }
          case "collapsed": {
            for (var R = o.tail, L = null; R !== null; )
              R.alternate !== null && (L = R), R = R.sibling;
            L === null ? !a && o.tail !== null ? o.tail.sibling = null : o.tail = null : L.sibling = null;
            break;
          }
        }
    }
    function Eg(o) {
      var a = o.alternate !== null && o.alternate.child === o.child, h = De, w = gA;
      if (a) {
        if ((o.mode & zt) !== Ct) {
          for (var sA = o.selfBaseDuration, pA = o.child; pA !== null; )
            h = Gt(h, Gt(pA.lanes, pA.childLanes)), w |= pA.subtreeFlags & $i, w |= pA.flags & $i, sA += pA.treeBaseDuration, pA = pA.sibling;
          o.treeBaseDuration = sA;
        } else
          for (var LA = o.child; LA !== null; )
            h = Gt(h, Gt(LA.lanes, LA.childLanes)), w |= LA.subtreeFlags & $i, w |= LA.flags & $i, LA.return = o, LA = LA.sibling;
        o.subtreeFlags |= w;
      } else {
        if ((o.mode & zt) !== Ct) {
          for (var R = o.actualDuration, L = o.selfBaseDuration, W = o.child; W !== null; )
            h = Gt(h, Gt(W.lanes, W.childLanes)), w |= W.subtreeFlags, w |= W.flags, R += W.actualDuration, L += W.treeBaseDuration, W = W.sibling;
          o.actualDuration = R, o.treeBaseDuration = L;
        } else
          for (var nA = o.child; nA !== null; )
            h = Gt(h, Gt(nA.lanes, nA.childLanes)), w |= nA.subtreeFlags, w |= nA.flags, nA.return = o, nA = nA.sibling;
        o.subtreeFlags |= w;
      }
      return o.childLanes = h, a;
    }
    function NS(o, a, h) {
      var w = a.pendingProps;
      switch (Cp(a), a.tag) {
        case v:
        case QA:
        case rA:
        case G:
        case P:
        case V:
        case iA:
        case J:
        case eA:
        case Y:
          return Eg(a), null;
        case k: {
          var R = a.type;
          return mg(R) && Gs(a), Eg(a), null;
        }
        case x: {
          var L = a.stateNode;
          if (mQ(a), ca(a), Np(), L.pendingContext && (L.context = L.pendingContext, L.pendingContext = null), o === null || o.child === null) {
            var W = Dl(a);
            if (W)
              Ps(a);
            else if (o !== null) {
              var nA = o.memoizedState;
              // Check if this is a client root
              (!nA.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (a.flags & he) !== gA) && (a.flags |= Pe, Ym());
            }
          }
          return Ll(o, a), Eg(a), null;
        }
        case _: {
          mp(a);
          var sA = wp(), pA = a.type;
          if (o !== null && a.stateNode != null)
            ch(o, a, pA, w, sA), o.ref !== a.ref && SS(a);
          else {
            if (!w) {
              if (a.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Eg(a), null;
            }
            var LA = Sl(), VA = Dl(a);
            if (VA)
              ix(a, sA, LA) && Ps(a);
            else {
              var oe = DB(pA, w, sA, LA, a);
              xl(oe, a, !1, !1), a.stateNode = oe, tI(oe, pA, w, sA, LA) && Ps(a);
            }
            a.ref !== null && SS(a);
          }
          return Eg(a), null;
        }
        case j: {
          var Qe = w;
          if (o && a.stateNode != null) {
            var me = o.memoizedProps;
            uh(o, a, me, Qe);
          } else {
            if (typeof Qe != "string" && a.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Ne = wp(), nt = Sl(), Ut = Dl(a);
            Ut ? nx(a) && Ps(a) : a.stateNode = ds(Qe, Ne, nt, a);
          }
          return Eg(a), null;
        }
        case tA: {
          MQ(a);
          var It = a.memoizedState;
          {
            if (ox() && (a.mode & si) !== Ct && (a.flags & Ee) === gA)
              return bm(a), wQ(), a.flags |= he | se | PA, a;
            if (It !== null && It.dehydrated !== null) {
              var Hi = Dl(a);
              if (o === null) {
                if (!Hi)
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                if (gx(a), Eg(a), (a.mode & zt) !== Ct) {
                  var _i = It !== null;
                  if (_i) {
                    var te = a.child;
                    te !== null && (a.treeBaseDuration -= te.treeBaseDuration);
                  }
                }
                return null;
              } else {
                if (wQ(), (a.flags & Ee) === gA && (a.memoizedState = null), a.flags |= TA, Eg(a), (a.mode & zt) !== Ct) {
                  var le = It !== null;
                  if (le) {
                    var XA = a.child;
                    XA !== null && (a.treeBaseDuration -= XA.treeBaseDuration);
                  }
                }
                return null;
              }
            }
            Ym();
          }
          if ((a.flags & Ee) !== gA)
            return a.lanes = h, (a.mode & zt) !== Ct && Xp(a), a;
          var Fe = It !== null, $e = !1;
          if (o === null)
            Dl(a);
          else {
            var ze = o.memoizedState;
            $e = ze !== null;
          }
          if (Fe && !$e) {
            var jt = a.child;
            if (jt.flags |= je, (a.mode & si) !== Ct) {
              var li = o === null && (a.memoizedProps.unstable_avoidThisFallback !== !0 || !S);
              li || Sp(Xo.current, Wm) ? pT() : UD();
            }
          }
          var Ni = a.updateQueue;
          if (Ni !== null && (a.flags |= TA), Eg(a), (a.mode & zt) !== Ct && Fe) {
            var ci = a.child;
            ci !== null && (a.treeBaseDuration -= ci.treeBaseDuration);
          }
          return null;
        }
        case H:
          return mQ(a), Ll(o, a), o === null && vr(a.stateNode.containerInfo), Eg(a), null;
        case oA:
          var Qn = a.type._context;
          return z(Qn, a), Eg(a), null;
        case aA: {
          var Ii = a.type;
          return mg(Ii) && Gs(a), Eg(a), null;
        }
        case hA: {
          MQ(a);
          var Ot = a.memoizedState;
          if (Ot === null)
            return Eg(a), null;
          var Ln = (a.flags & Ee) !== gA, En = Ot.rendering;
          if (En === null)
            if (Ln)
              Tl(Ot, !1);
            else {
              var yo = wT() && (o === null || (o.flags & Ee) === gA);
              if (!yo)
                for (var ug = a.child; ug !== null; ) {
                  var Wr = Vu(ug);
                  if (Wr !== null) {
                    Ln = !0, a.flags |= Ee, Tl(Ot, !1);
                    var zr = Wr.updateQueue;
                    return zr !== null && (a.updateQueue = zr, a.flags |= TA), a.subtreeFlags = gA, ax(a, h), YI(a, Mp(Xo.current, Ml)), a.child;
                  }
                  ug = ug.sibling;
                }
              Ot.tail !== null && on() > wM() && (a.flags |= Ee, Ln = !0, Tl(Ot, !1), a.lanes = et);
            }
          else {
            if (!Ln) {
              var Vs = Vu(En);
              if (Vs !== null) {
                a.flags |= Ee, Ln = !0;
                var bQ = Vs.updateQueue;
                if (bQ !== null && (a.updateQueue = bQ, a.flags |= TA), Tl(Ot, !0), Ot.tail === null && Ot.tailMode === "hidden" && !En.alternate && !vg())
                  return Eg(a), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                on() * 2 - Ot.renderingStartTime > wM() && h !== fi && (a.flags |= Ee, Ln = !0, Tl(Ot, !1), a.lanes = et);
            }
            if (Ot.isBackwards)
              En.sibling = a.child, a.child = En;
            else {
              var YQ = Ot.last;
              YQ !== null ? YQ.sibling = En : a.child = En, Ot.last = En;
            }
          }
          if (Ot.tail !== null) {
            var Vr = Ot.tail;
            Ot.rendering = Vr, Ot.tail = Vr.sibling, Ot.renderingStartTime = on(), Vr.sibling = null;
            var sC = Xo.current;
            return Ln ? sC = Mp(sC, Ml) : sC = SQ(sC), YI(a, sC), Vr;
          }
          return Eg(a), null;
        }
        case fA:
          break;
        case wA:
        case yA: {
          vD(a);
          var ZD = a.memoizedState, lR = ZD !== null;
          if (o !== null) {
            var pK = o.memoizedState, DK = pK !== null;
            DK !== lR && // LegacyHidden doesn't do any hiding  it only pre-renders.
            !f && (a.flags |= je);
          }
          return !lR || (a.mode & si) === Ct ? Eg(a) : rn(Ws, fi) && (Eg(a), _g && a.subtreeFlags & (UA | TA) && (a.flags |= je)), null;
        }
        case kA:
          return null;
        case FA:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + a.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    var Kl = n.ReactCurrentOwner, As = !1, eD, bl, tD, iD, nD, tC, gD, hh;
    eD = {}, bl = {}, tD = {}, iD = {}, nD = {}, tC = !1, gD = {}, hh = {};
    function Zg(o, a, h, w) {
      o === null ? a.child = Om(a, null, h, w) : a.child = yQ(a, o.child, h, w);
    }
    function Gx(o, a, h, w) {
      a.child = yQ(a, o.child, null, w), a.child = yQ(a, null, h, w);
    }
    function FS(o, a, h, w, R) {
      if (a.type !== a.elementType) {
        var L = h.propTypes;
        L && Vi(
          L,
          w,
          // Resolved props
          "prop",
          _A(h)
        );
      }
      var W = h.render, nA = a.ref, sA, pA;
      Re(a, R), Qo(a);
      {
        if (Kl.current = a, Eo(!0), sA = GQ(o, a, W, w, nA, R), pA = vQ(), a.mode & Ki) {
          ei(!0);
          try {
            sA = GQ(o, a, W, w, nA, R), pA = vQ();
          } finally {
            ei(!1);
          }
        }
        Eo(!1);
      }
      return Vo(), o !== null && !As ? (zm(o, a, R), ka(o, a, R)) : (vg() && pA && Bp(a), a.flags |= RA, Zg(o, a, sA, R), a.child);
    }
    function GS(o, a, h, w, R) {
      if (o === null) {
        var L = h.type;
        if (jT(L) && h.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        h.defaultProps === void 0) {
          var W = L;
          return W = KQ(L), a.tag = rA, a.type = W, sD(a, L), vS(o, a, W, w, R);
        }
        {
          var nA = L.propTypes;
          nA && Vi(
            nA,
            w,
            // Resolved props
            "prop",
            _A(L)
          );
        }
        var sA = JD(h.type, null, w, a, a.mode, R);
        return sA.ref = a.ref, sA.return = a, a.child = sA, sA;
      }
      {
        var pA = h.type, LA = pA.propTypes;
        LA && Vi(
          LA,
          w,
          // Resolved props
          "prop",
          _A(pA)
        );
      }
      var VA = o.child, oe = CD(o, R);
      if (!oe) {
        var Qe = VA.memoizedProps, me = h.compare;
        if (me = me !== null ? me : Sa, me(Qe, w) && o.ref === a.ref)
          return ka(o, a, R);
      }
      a.flags |= RA;
      var Ne = oC(VA, w);
      return Ne.ref = a.ref, Ne.return = a, a.child = Ne, Ne;
    }
    function vS(o, a, h, w, R) {
      if (a.type !== a.elementType) {
        var L = a.elementType;
        if (L.$$typeof === q) {
          var W = L, nA = W._payload, sA = W._init;
          try {
            L = sA(nA);
          } catch {
            L = null;
          }
          var pA = L && L.propTypes;
          pA && Vi(
            pA,
            w,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            _A(L)
          );
        }
      }
      if (o !== null) {
        var LA = o.memoizedProps;
        if (Sa(LA, w) && o.ref === a.ref && // Prevent bailout if the implementation changed due to hot reload.
        a.type === o.type)
          if (As = !1, CD(o, R))
            (o.flags & Be) !== gA && (As = !0);
          else
            return a.lanes = o.lanes, ka(o, a, R);
      }
      return rD(o, a, h, w, R);
    }
    function US(o, a, h) {
      var w = a.pendingProps, R = w.children, L = o !== null ? o.memoizedState : null;
      if (w.mode === "hidden" || f)
        if ((a.mode & si) === Ct) {
          var W = {
            baseLanes: De,
            cachePool: null
          };
          a.memoizedState = W, Oh(a, h);
        } else if (rn(h, fi)) {
          var VA = {
            baseLanes: De,
            cachePool: null
          };
          a.memoizedState = VA;
          var oe = L !== null ? L.baseLanes : h;
          Oh(a, oe);
        } else {
          var nA = null, sA;
          if (L !== null) {
            var pA = L.baseLanes;
            sA = Gt(pA, h);
          } else
            sA = h;
          a.lanes = a.childLanes = fi;
          var LA = {
            baseLanes: sA,
            cachePool: nA
          };
          return a.memoizedState = LA, a.updateQueue = null, Oh(a, sA), null;
        }
      else {
        var Qe;
        L !== null ? (Qe = Gt(L.baseLanes, h), a.memoizedState = null) : Qe = h, Oh(a, Qe);
      }
      return Zg(o, a, R, h), a.child;
    }
    function vx(o, a, h) {
      var w = a.pendingProps;
      return Zg(o, a, w, h), a.child;
    }
    function Ux(o, a, h) {
      var w = a.pendingProps.children;
      return Zg(o, a, w, h), a.child;
    }
    function kx(o, a, h) {
      {
        a.flags |= TA;
        {
          var w = a.stateNode;
          w.effectDuration = 0, w.passiveEffectDuration = 0;
        }
      }
      var R = a.pendingProps, L = R.children;
      return Zg(o, a, L, h), a.child;
    }
    function kS(o, a) {
      var h = a.ref;
      (o === null && h !== null || o !== null && o.ref !== h) && (a.flags |= _e, a.flags |= rt);
    }
    function rD(o, a, h, w, R) {
      if (a.type !== a.elementType) {
        var L = h.propTypes;
        L && Vi(
          L,
          w,
          // Resolved props
          "prop",
          _A(h)
        );
      }
      var W;
      {
        var nA = sr(a, h, !0);
        W = Fs(a, nA);
      }
      var sA, pA;
      Re(a, R), Qo(a);
      {
        if (Kl.current = a, Eo(!0), sA = GQ(o, a, h, w, W, R), pA = vQ(), a.mode & Ki) {
          ei(!0);
          try {
            sA = GQ(o, a, h, w, W, R), pA = vQ();
          } finally {
            ei(!1);
          }
        }
        Eo(!1);
      }
      return Vo(), o !== null && !As ? (zm(o, a, R), ka(o, a, R)) : (vg() && pA && Bp(a), a.flags |= RA, Zg(o, a, sA, R), a.child);
    }
    function xS(o, a, h, w, R) {
      {
        switch (ZM(a)) {
          case !1: {
            var L = a.stateNode, W = a.type, nA = new W(a.memoizedProps, L.context), sA = nA.state;
            L.updater.enqueueSetState(L, sA, null);
            break;
          }
          case !0: {
            a.flags |= Ee, a.flags |= PA;
            var pA = new Error("Simulated error coming from DevTools"), LA = wI(R);
            a.lanes = Gt(a.lanes, LA);
            var VA = AD(a, lh(pA, a), LA);
            ti(a, VA);
            break;
          }
        }
        if (a.type !== a.elementType) {
          var oe = h.propTypes;
          oe && Vi(
            oe,
            w,
            // Resolved props
            "prop",
            _A(h)
          );
        }
      }
      var Qe;
      mg(h) ? (Qe = !0, Ir(a)) : Qe = !1, Re(a, R);
      var me = a.stateNode, Ne;
      me === null ? (o !== null && (o.alternate = null, a.alternate = null, a.flags |= UA), Gm(a, h, w), Ip(a, h, w, R), Ne = !0) : o === null ? Ne = qk(a, h, w, R) : Ne = Pk(o, a, h, w, R);
      var nt = oD(o, a, h, Ne, Qe, R);
      {
        var Ut = a.stateNode;
        Ne && Ut.props !== w && (tC || I("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", xA(a) || "a component"), tC = !0);
      }
      return nt;
    }
    function oD(o, a, h, w, R, L) {
      kS(o, a);
      var W = (a.flags & Ee) !== gA;
      if (!w && !W)
        return R && ua(a, h, !1), ka(o, a, L);
      var nA = a.stateNode;
      Kl.current = a;
      var sA;
      if (W && typeof h.getDerivedStateFromError != "function")
        sA = null, pS();
      else {
        Qo(a);
        {
          if (Eo(!0), sA = nA.render(), a.mode & Ki) {
            ei(!0);
            try {
              nA.render();
            } finally {
              ei(!1);
            }
          }
          Eo(!1);
        }
        Vo();
      }
      return a.flags |= RA, o !== null && W ? Gx(o, a, sA, L) : Zg(o, a, sA, L), a.memoizedState = nA.state, R && ua(a, h, !0), a.child;
    }
    function LS(o) {
      var a = o.stateNode;
      a.pendingContext ? ar(o, a.pendingContext, a.pendingContext !== a.context) : a.context && ar(o, a.context, !1), yp(o, a.containerInfo);
    }
    function xx(o, a, h) {
      if (LS(a), o === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var w = a.pendingProps, R = a.memoizedState, L = R.element;
      vt(o, a), fQ(a, w, null, h);
      var W = a.memoizedState;
      a.stateNode;
      var nA = W.element;
      if (fn && R.isDehydrated) {
        var sA = {
          element: nA,
          isDehydrated: !1,
          cache: W.cache,
          transitions: W.transitions
        }, pA = a.updateQueue;
        if (pA.baseState = sA, a.memoizedState = sA, a.flags & he) {
          var LA = new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.");
          return TS(o, a, nA, h, LA);
        } else if (nA !== L) {
          var VA = new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.");
          return TS(o, a, nA, h, VA);
        } else {
          ex(a);
          var oe = Om(a, null, nA, h);
          a.child = oe;
          for (var Qe = oe; Qe; )
            Qe.flags = Qe.flags & ~UA | Jt, Qe = Qe.sibling;
        }
      } else {
        if (wQ(), nA === L)
          return ka(o, a, h);
        Zg(o, a, nA, h);
      }
      return a.child;
    }
    function TS(o, a, h, w, R) {
      return wQ(), up(R), a.flags |= he, Zg(o, a, h, w), a.child;
    }
    function Lx(o, a, h) {
      qm(a), o === null && cp(a);
      var w = a.type, R = a.pendingProps, L = o !== null ? o.memoizedProps : null, W = R.children, nA = wB(w, R);
      return nA ? W = null : L !== null && wB(w, L) && (a.flags |= xe), kS(o, a), Zg(o, a, W, h), a.child;
    }
    function Tx(o, a) {
      return o === null && cp(a), null;
    }
    function Kx(o, a, h, w) {
      o !== null && (o.alternate = null, a.alternate = null, a.flags |= UA);
      var R = a.pendingProps, L = h, W = L._payload, nA = L._init, sA = nA(W);
      a.type = sA;
      var pA = a.tag = ZT(sA), LA = lr(sA, R), VA;
      switch (pA) {
        case G:
          return sD(a, sA), a.type = sA = KQ(sA), VA = rD(null, a, sA, LA, w), VA;
        case k:
          return a.type = sA = TD(sA), VA = xS(null, a, sA, LA, w), VA;
        case P:
          return a.type = sA = KD(sA), VA = FS(null, a, sA, LA, w), VA;
        case Y: {
          if (a.type !== a.elementType) {
            var oe = sA.propTypes;
            oe && Vi(
              oe,
              LA,
              // Resolved for outer only
              "prop",
              _A(sA)
            );
          }
          return VA = GS(
            null,
            a,
            sA,
            lr(sA.type, LA),
            // The inner type can have defaults too
            w
          ), VA;
        }
      }
      var Qe = "";
      throw sA !== null && typeof sA == "object" && sA.$$typeof === q && (Qe = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + sA + ". " + ("Lazy element type must resolve to a class or function." + Qe));
    }
    function bx(o, a, h, w, R) {
      o !== null && (o.alternate = null, a.alternate = null, a.flags |= UA), a.tag = k;
      var L;
      return mg(h) ? (L = !0, Ir(a)) : L = !1, Re(a, R), Gm(a, h, w), Ip(a, h, w, R), oD(null, a, h, !0, L, R);
    }
    function Yx(o, a, h, w) {
      o !== null && (o.alternate = null, a.alternate = null, a.flags |= UA);
      var R = a.pendingProps, L;
      {
        var W = sr(a, h, !1);
        L = Fs(a, W);
      }
      Re(a, w);
      var nA, sA;
      Qo(a);
      {
        if (h.prototype && typeof h.prototype.render == "function") {
          var pA = _A(h) || "Unknown";
          eD[pA] || (I("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", pA, pA), eD[pA] = !0);
        }
        a.mode & Ki && Er.recordLegacyContextWarning(a, null), Eo(!0), Kl.current = a, nA = GQ(null, a, h, R, L, w), sA = vQ(), Eo(!1);
      }
      if (Vo(), a.flags |= RA, typeof nA == "object" && nA !== null && typeof nA.render == "function" && nA.$$typeof === void 0) {
        var LA = _A(h) || "Unknown";
        bl[LA] || (I("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", LA, LA, LA), bl[LA] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof nA == "object" && nA !== null && typeof nA.render == "function" && nA.$$typeof === void 0
      ) {
        {
          var VA = _A(h) || "Unknown";
          bl[VA] || (I("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", VA, VA, VA), bl[VA] = !0);
        }
        a.tag = k, a.memoizedState = null, a.updateQueue = null;
        var oe = !1;
        return mg(h) ? (oe = !0, Ir(a)) : oe = !1, a.memoizedState = nA.state !== null && nA.state !== void 0 ? nA.state : null, Ze(a), Fm(a, nA), Ip(a, h, R, w), oD(null, a, h, !0, oe, w);
      } else {
        if (a.tag = G, a.mode & Ki) {
          ei(!0);
          try {
            nA = GQ(null, a, h, R, L, w), sA = vQ();
          } finally {
            ei(!1);
          }
        }
        return vg() && sA && Bp(a), Zg(null, a, nA, w), sD(a, h), a.child;
      }
    }
    function sD(o, a) {
      {
        if (a && a.childContextTypes && I("%s(...): childContextTypes cannot be defined on a function component.", a.displayName || a.name || "Component"), o.ref !== null) {
          var h = "", w = jf();
          w && (h += `

Check the render method of \`` + w + "`.");
          var R = w || "", L = o._debugSource;
          L && (R = L.fileName + ":" + L.lineNumber), nD[R] || (nD[R] = !0, I("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", h));
        }
        if (typeof a.getDerivedStateFromProps == "function") {
          var W = _A(a) || "Unknown";
          iD[W] || (I("%s: Function components do not support getDerivedStateFromProps.", W), iD[W] = !0);
        }
        if (typeof a.contextType == "object" && a.contextType !== null) {
          var nA = _A(a) || "Unknown";
          tD[nA] || (I("%s: Function components do not support contextType.", nA), tD[nA] = !0);
        }
      }
    }
    var dh = {
      dehydrated: null,
      treeContext: null,
      retryLane: nn
    };
    function fh(o) {
      return {
        baseLanes: o,
        cachePool: Fx()
      };
    }
    function KS(o, a) {
      var h = null;
      return {
        baseLanes: Gt(o.baseLanes, a),
        cachePool: h
      };
    }
    function Hx(o, a, h, w) {
      if (a !== null) {
        var R = a.memoizedState;
        if (R === null)
          return !1;
      }
      return Sp(o, Ml);
    }
    function bS(o, a) {
      return fa(o.childLanes, a);
    }
    function YS(o, a, h) {
      var w = a.pendingProps;
      $M(a) && (a.flags |= Ee);
      var R = Xo.current, L = !1, W = (a.flags & Ee) !== gA;
      if (W || Hx(R, o) ? (L = !0, a.flags &= ~Ee) : (o === null || o.memoizedState !== null) && (R = Bx(R, Wm)), R = SQ(R), YI(a, R), o === null) {
        cp(a);
        {
          var nA = a.memoizedState;
          if (nA !== null) {
            var sA = nA.dehydrated;
            if (sA !== null)
              return Ox(a, sA);
          }
        }
        var pA = w.children, LA = w.fallback;
        if (L) {
          var VA = _x(a, pA, LA, h), oe = a.child;
          return oe.memoizedState = fh(h), a.memoizedState = dh, VA;
        } else
          return aD(a, pA);
      } else {
        var Qe = o.memoizedState;
        if (Qe !== null) {
          {
            var me = Qe.dehydrated;
            if (me !== null)
              if (W) {
                if (a.flags & he)
                  return a.flags &= ~he, ph(o, a, h, new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                if (a.memoizedState !== null)
                  return a.child = o.child, a.flags |= Ee, null;
                var Ne = w.children, nt = w.fallback, Ut = Jx(o, a, Ne, nt, h), It = a.child;
                return It.memoizedState = fh(h), a.memoizedState = dh, Ut;
              } else
                return qx(o, a, me, Qe, h);
          }
          if (L) {
            var Hi = w.fallback, _i = w.children, te = JS(o, a, _i, Hi, h), le = a.child, XA = o.child.memoizedState;
            return le.memoizedState = XA === null ? fh(h) : KS(XA, h), le.childLanes = bS(o, h), a.memoizedState = dh, te;
          } else {
            var Fe = w.children, $e = _S(o, a, Fe, h);
            return a.memoizedState = null, $e;
          }
        } else if (L) {
          var ze = w.fallback, jt = w.children, li = JS(o, a, jt, ze, h), Ni = a.child, ci = o.child.memoizedState;
          return Ni.memoizedState = ci === null ? fh(h) : KS(ci, h), Ni.childLanes = bS(o, h), a.memoizedState = dh, li;
        } else {
          var Qn = w.children, Ii = _S(o, a, Qn, h);
          return a.memoizedState = null, Ii;
        }
      }
    }
    function aD(o, a, h) {
      var w = o.mode, R = {
        mode: "visible",
        children: a
      }, L = ID(R, w);
      return L.return = o, o.child = L, L;
    }
    function _x(o, a, h, w) {
      var R = o.mode, L = o.child, W = {
        mode: "hidden",
        children: a
      }, nA, sA;
      return (R & si) === Ct && L !== null ? (nA = L, nA.childLanes = De, nA.pendingProps = W, o.mode & zt && (nA.actualDuration = 0, nA.actualStartTime = -1, nA.selfBaseDuration = 0, nA.treeBaseDuration = 0), sA = WI(h, R, w, null)) : (nA = ID(W, R), sA = WI(h, R, w, null)), nA.return = o, sA.return = o, nA.sibling = sA, o.child = nA, sA;
    }
    function ID(o, a, h) {
      return OM(o, a, De, null);
    }
    function HS(o, a) {
      return oC(o, a);
    }
    function _S(o, a, h, w) {
      var R = o.child, L = R.sibling, W = HS(R, {
        mode: "visible",
        children: h
      });
      if ((a.mode & si) === Ct && (W.lanes = w), W.return = a, W.sibling = null, L !== null) {
        var nA = a.deletions;
        nA === null ? (a.deletions = [L], a.flags |= Me) : nA.push(L);
      }
      return a.child = W, W;
    }
    function JS(o, a, h, w, R) {
      var L = a.mode, W = o.child, nA = W.sibling, sA = {
        mode: "hidden",
        children: h
      }, pA;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (L & si) === Ct && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        a.child !== W
      ) {
        var LA = a.child;
        pA = LA, pA.childLanes = De, pA.pendingProps = sA, a.mode & zt && (pA.actualDuration = 0, pA.actualStartTime = -1, pA.selfBaseDuration = W.selfBaseDuration, pA.treeBaseDuration = W.treeBaseDuration), a.deletions = null;
      } else
        pA = HS(W, sA), pA.subtreeFlags = W.subtreeFlags & $i;
      var VA;
      return nA !== null ? VA = oC(nA, w) : (VA = WI(w, L, R, null), VA.flags |= UA), VA.return = a, pA.return = a, pA.sibling = VA, a.child = pA, VA;
    }
    function ph(o, a, h, w) {
      w !== null && up(w), yQ(a, o.child, null, h);
      var R = a.pendingProps, L = R.children, W = aD(a, L);
      return W.flags |= UA, a.memoizedState = null, W;
    }
    function Jx(o, a, h, w, R) {
      var L = a.mode, W = {
        mode: "visible",
        children: h
      }, nA = ID(W, L), sA = WI(w, L, R, null);
      return sA.flags |= UA, nA.return = a, sA.return = a, nA.sibling = sA, a.child = nA, (a.mode & si) !== Ct && yQ(a, o.child, null, R), sA;
    }
    function Ox(o, a, h) {
      return (o.mode & si) === Ct ? (I("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), o.lanes = Lt) : or(a) ? o.lanes = Hr : o.lanes = fi, null;
    }
    function qx(o, a, h, w, R) {
      if ($k(), (a.mode & si) === Ct)
        return ph(
          o,
          a,
          R,
          // TODO: When we delete legacy mode, we should make this error argument
          // required  every concurrent mode path that causes hydration to
          // de-opt to client rendering should have an error message.
          null
        );
      if (or(h))
        return ph(
          o,
          a,
          R,
          // TODO: The server should serialize the error message so we can log it
          // here on the client. Or, in production, a hash/id that corresponds to
          // the error.
          new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.")
        );
      var L = rn(R, o.childLanes);
      if (As || L) {
        var W = Hh();
        if (W !== null) {
          var nA = nl(W, R);
          if (nA !== nn && nA !== w.retryLane) {
            w.retryLane = nA;
            var sA = Si;
            Xn(o, nA, sA);
          }
        }
        return UD(), ph(o, a, R, new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
      } else if (Og(h)) {
        a.flags |= Ee, a.child = o.child;
        var pA = kT.bind(null, o);
        return GB(h, pA), null;
      } else {
        tx(a, h, w.treeContext);
        var LA = a.pendingProps, VA = LA.children, oe = aD(a, VA);
        return oe.flags |= Jt, oe;
      }
    }
    function OS(o, a, h) {
      o.lanes = Gt(o.lanes, a);
      var w = o.alternate;
      w !== null && (w.lanes = Gt(w.lanes, a)), uA(o.return, a, h);
    }
    function Px(o, a, h) {
      for (var w = a; w !== null; ) {
        if (w.tag === tA) {
          var R = w.memoizedState;
          R !== null && OS(w, h, o);
        } else if (w.tag === hA)
          OS(w, h, o);
        else if (w.child !== null) {
          w.child.return = w, w = w.child;
          continue;
        }
        if (w === o)
          return;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === o)
            return;
          w = w.return;
        }
        w.sibling.return = w.return, w = w.sibling;
      }
    }
    function Wx(o) {
      for (var a = o, h = null; a !== null; ) {
        var w = a.alternate;
        w !== null && Vu(w) === null && (h = a), a = a.sibling;
      }
      return h;
    }
    function zx(o) {
      if (o !== void 0 && o !== "forwards" && o !== "backwards" && o !== "together" && !gD[o])
        if (gD[o] = !0, typeof o == "string")
          switch (o.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              I('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', o, o.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              I('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', o, o.toLowerCase());
              break;
            }
            default:
              I('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', o);
              break;
          }
        else
          I('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', o);
    }
    function Vx(o, a) {
      o !== void 0 && !hh[o] && (o !== "collapsed" && o !== "hidden" ? (hh[o] = !0, I('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', o)) : a !== "forwards" && a !== "backwards" && (hh[o] = !0, I('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', o)));
    }
    function qS(o, a) {
      {
        var h = Mt(o), w = !h && typeof mA(o) == "function";
        if (h || w) {
          var R = h ? "array" : "iterable";
          return I("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", R, a, R), !1;
        }
      }
      return !0;
    }
    function jx(o, a) {
      if ((a === "forwards" || a === "backwards") && o !== void 0 && o !== null && o !== !1)
        if (Mt(o)) {
          for (var h = 0; h < o.length; h++)
            if (!qS(o[h], h))
              return;
        } else {
          var w = mA(o);
          if (typeof w == "function") {
            var R = w.call(o);
            if (R)
              for (var L = R.next(), W = 0; !L.done; L = R.next()) {
                if (!qS(L.value, W))
                  return;
                W++;
              }
          } else
            I('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', a);
        }
    }
    function BD(o, a, h, w, R) {
      var L = o.memoizedState;
      L === null ? o.memoizedState = {
        isBackwards: a,
        rendering: null,
        renderingStartTime: 0,
        last: w,
        tail: h,
        tailMode: R
      } : (L.isBackwards = a, L.rendering = null, L.renderingStartTime = 0, L.last = w, L.tail = h, L.tailMode = R);
    }
    function PS(o, a, h) {
      var w = a.pendingProps, R = w.revealOrder, L = w.tail, W = w.children;
      zx(R), Vx(L, R), jx(W, R), Zg(o, a, W, h);
      var nA = Xo.current, sA = Sp(nA, Ml);
      if (sA)
        nA = Mp(nA, Ml), a.flags |= Ee;
      else {
        var pA = o !== null && (o.flags & Ee) !== gA;
        pA && Px(a, a.child, h), nA = SQ(nA);
      }
      if (YI(a, nA), (a.mode & si) === Ct)
        a.memoizedState = null;
      else
        switch (R) {
          case "forwards": {
            var LA = Wx(a.child), VA;
            LA === null ? (VA = a.child, a.child = null) : (VA = LA.sibling, LA.sibling = null), BD(
              a,
              !1,
              // isBackwards
              VA,
              LA,
              L
            );
            break;
          }
          case "backwards": {
            var oe = null, Qe = a.child;
            for (a.child = null; Qe !== null; ) {
              var me = Qe.alternate;
              if (me !== null && Vu(me) === null) {
                a.child = Qe;
                break;
              }
              var Ne = Qe.sibling;
              Qe.sibling = oe, oe = Qe, Qe = Ne;
            }
            BD(
              a,
              !0,
              // isBackwards
              oe,
              null,
              // last
              L
            );
            break;
          }
          case "together": {
            BD(
              a,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            a.memoizedState = null;
        }
      return a.child;
    }
    function Zx(o, a, h) {
      yp(a, a.stateNode.containerInfo);
      var w = a.pendingProps;
      return o === null ? a.child = yQ(a, null, w, h) : Zg(o, a, w, h), a.child;
    }
    var WS = !1;
    function Xx(o, a, h) {
      var w = a.type, R = w._context, L = a.pendingProps, W = a.memoizedProps, nA = L.value;
      {
        "value" in L || WS || (WS = !0, I("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var sA = a.type.propTypes;
        sA && Vi(sA, L, "prop", "Context.Provider");
      }
      if (K(a, R, nA), W !== null) {
        var pA = W.value;
        if (Vg(pA, nA)) {
          if (W.children === L.children && !tn())
            return ka(o, a, h);
        } else
          HA(a, R, h);
      }
      var LA = L.children;
      return Zg(o, a, LA, h), a.child;
    }
    var zS = !1;
    function $x(o, a, h) {
      var w = a.type;
      w._context === void 0 ? w !== w.Consumer && (zS || (zS = !0, I("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : w = w._context;
      var R = a.pendingProps, L = R.children;
      typeof L != "function" && I("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Re(a, h);
      var W = Ue(w);
      Qo(a);
      var nA;
      return Kl.current = a, Eo(!0), nA = L(W), Eo(!1), Vo(), a.flags |= RA, Zg(o, a, nA, h), a.child;
    }
    function Dh() {
      As = !0;
    }
    function ka(o, a, h) {
      return o !== null && (a.dependencies = o.dependencies), pS(), qh(a.lanes), rn(h, a.childLanes) ? (sx(o, a), a.child) : null;
    }
    function AL(o, a, h) {
      {
        var w = a.return;
        if (w === null)
          throw new Error("Cannot swap the root fiber.");
        if (o.alternate = null, a.alternate = null, h.index = a.index, h.sibling = a.sibling, h.return = a.return, h.ref = a.ref, a === w.child)
          w.child = h;
        else {
          var R = w.child;
          if (R === null)
            throw new Error("Expected parent to have a child.");
          for (; R.sibling !== a; )
            if (R = R.sibling, R === null)
              throw new Error("Expected to find the previous sibling.");
          R.sibling = h;
        }
        var L = w.deletions;
        return L === null ? (w.deletions = [o], w.flags |= Me) : L.push(o), h.flags |= UA, h;
      }
    }
    function CD(o, a) {
      var h = o.lanes;
      return !!rn(h, a);
    }
    function eL(o, a, h) {
      switch (a.tag) {
        case x:
          LS(a), a.stateNode, wQ();
          break;
        case _:
          qm(a);
          break;
        case k: {
          var w = a.type;
          mg(w) && Ir(a);
          break;
        }
        case H:
          yp(a, a.stateNode.containerInfo);
          break;
        case oA: {
          var R = a.memoizedProps.value, L = a.type._context;
          K(a, L, R);
          break;
        }
        case J:
          {
            var W = rn(h, a.childLanes);
            W && (a.flags |= TA);
            {
              var nA = a.stateNode;
              nA.effectDuration = 0, nA.passiveEffectDuration = 0;
            }
          }
          break;
        case tA: {
          var sA = a.memoizedState;
          if (sA !== null) {
            if (sA.dehydrated !== null)
              return YI(a, SQ(Xo.current)), a.flags |= Ee, null;
            var pA = a.child, LA = pA.childLanes;
            if (rn(h, LA))
              return YS(o, a, h);
            YI(a, SQ(Xo.current));
            var VA = ka(o, a, h);
            return VA !== null ? VA.sibling : null;
          } else
            YI(a, SQ(Xo.current));
          break;
        }
        case hA: {
          var oe = (o.flags & Ee) !== gA, Qe = rn(h, a.childLanes);
          if (oe) {
            if (Qe)
              return PS(o, a, h);
            a.flags |= Ee;
          }
          var me = a.memoizedState;
          if (me !== null && (me.rendering = null, me.tail = null, me.lastEffect = null), YI(a, Xo.current), Qe)
            break;
          return null;
        }
        case wA:
        case yA:
          return a.lanes = De, US(o, a, h);
      }
      return ka(o, a, h);
    }
    function VS(o, a, h) {
      if (a._debugNeedsRemount && o !== null)
        return AL(o, a, JD(a.type, a.key, a.pendingProps, a._debugOwner || null, a.mode, a.lanes));
      if (o !== null) {
        var w = o.memoizedProps, R = a.pendingProps;
        if (w !== R || tn() || // Force a re-render if the implementation changed due to hot reload:
        a.type !== o.type)
          As = !0;
        else {
          var L = CD(o, h);
          if (!L && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (a.flags & Ee) === gA)
            return As = !1, eL(o, a, h);
          (o.flags & Be) !== gA ? As = !0 : As = !1;
        }
      } else if (As = !1, vg() && Wk(a)) {
        var W = a.index, nA = zk();
        Um(a, nA, W);
      }
      switch (a.lanes = De, a.tag) {
        case v:
          return Yx(o, a, a.type, h);
        case QA: {
          var sA = a.elementType;
          return Kx(o, a, sA, h);
        }
        case G: {
          var pA = a.type, LA = a.pendingProps, VA = a.elementType === pA ? LA : lr(pA, LA);
          return rD(o, a, pA, VA, h);
        }
        case k: {
          var oe = a.type, Qe = a.pendingProps, me = a.elementType === oe ? Qe : lr(oe, Qe);
          return xS(o, a, oe, me, h);
        }
        case x:
          return xx(o, a, h);
        case _:
          return Lx(o, a, h);
        case j:
          return Tx(o, a);
        case tA:
          return YS(o, a, h);
        case H:
          return Zx(o, a, h);
        case P: {
          var Ne = a.type, nt = a.pendingProps, Ut = a.elementType === Ne ? nt : lr(Ne, nt);
          return FS(o, a, Ne, Ut, h);
        }
        case V:
          return vx(o, a, h);
        case iA:
          return Ux(o, a, h);
        case J:
          return kx(o, a, h);
        case oA:
          return Xx(o, a, h);
        case eA:
          return $x(o, a, h);
        case Y: {
          var It = a.type, Hi = a.pendingProps, _i = lr(It, Hi);
          if (a.type !== a.elementType) {
            var te = It.propTypes;
            te && Vi(
              te,
              _i,
              // Resolved for outer only
              "prop",
              _A(It)
            );
          }
          return _i = lr(It.type, _i), GS(o, a, It, _i, h);
        }
        case rA:
          return vS(o, a, a.type, a.pendingProps, h);
        case aA: {
          var le = a.type, XA = a.pendingProps, Fe = a.elementType === le ? XA : lr(le, XA);
          return bx(o, a, le, Fe, h);
        }
        case hA:
          return PS(o, a, h);
        case fA:
          break;
        case wA:
          return US(o, a, h);
      }
      throw new Error("Unknown unit of work tag (" + a.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function tL(o, a, h) {
      switch (Cp(a), a.tag) {
        case k: {
          var w = a.type;
          mg(w) && Gs(a);
          var R = a.flags;
          return R & PA ? (a.flags = R & ~PA | Ee, (a.mode & zt) !== Ct && Xp(a), a) : null;
        }
        case x: {
          mQ(a), ca(a), Np();
          var L = a.flags;
          return (L & PA) !== gA && (L & Ee) === gA ? (a.flags = L & ~PA | Ee, a) : null;
        }
        case _:
          return mp(a), null;
        case tA: {
          MQ(a);
          {
            var W = a.memoizedState;
            if (W !== null && W.dehydrated !== null) {
              if (a.alternate === null)
                throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
              wQ();
            }
          }
          var nA = a.flags;
          return nA & PA ? (a.flags = nA & ~PA | Ee, (a.mode & zt) !== Ct && Xp(a), a) : null;
        }
        case hA:
          return MQ(a), null;
        case H:
          return mQ(a), null;
        case oA:
          var sA = a.type._context;
          return z(sA, a), null;
        case wA:
        case yA:
          return vD(a), null;
        case kA:
          return null;
        default:
          return null;
      }
    }
    function jS(o, a, h) {
      switch (Cp(a), a.tag) {
        case k: {
          var w = a.type.childContextTypes;
          w != null && Gs(a);
          break;
        }
        case x: {
          mQ(a), ca(a), Np();
          break;
        }
        case _: {
          mp(a);
          break;
        }
        case H:
          mQ(a);
          break;
        case tA:
          MQ(a);
          break;
        case hA:
          MQ(a);
          break;
        case oA:
          var R = a.type._context;
          z(R, a);
          break;
        case wA:
        case yA:
          vD(a);
          break;
      }
    }
    function ZS(o, a, h, w, R, L, W, nA, sA) {
      var pA = Array.prototype.slice.call(arguments, 3);
      try {
        a.apply(h, pA);
      } catch (LA) {
        this.onError(LA);
      }
    }
    var XS = ZS;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var QD = document.createElement("react");
      XS = function(a, h, w, R, L, W, nA, sA, pA) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var LA = document.createEvent("Event"), VA = !1, oe = !0, Qe = window.event, me = Object.getOwnPropertyDescriptor(window, "event");
        function Ne() {
          QD.removeEventListener(le, Ut, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Qe);
        }
        var nt = Array.prototype.slice.call(arguments, 3);
        function Ut() {
          VA = !0, Ne(), h.apply(w, nt), oe = !1;
        }
        var It, Hi = !1, _i = !1;
        function te(XA) {
          if (It = XA.error, Hi = !0, It === null && XA.colno === 0 && XA.lineno === 0 && (_i = !0), XA.defaultPrevented && It != null && typeof It == "object")
            try {
              It._suppressLogging = !0;
            } catch {
            }
        }
        var le = "react-" + (a || "invokeguardedcallback");
        if (window.addEventListener("error", te), QD.addEventListener(le, Ut, !1), LA.initEvent(le, !1, !1), QD.dispatchEvent(LA), me && Object.defineProperty(window, "event", me), VA && oe && (Hi ? _i && (It = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : It = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(It)), window.removeEventListener("error", te), !VA)
          return Ne(), ZS.apply(this, arguments);
      };
    }
    var iL = XS, Yl = !1, wh = null, nL = {
      onError: function(o) {
        Yl = !0, wh = o;
      }
    };
    function $S(o, a, h, w, R, L, W, nA, sA) {
      Yl = !1, wh = null, iL.apply(nL, arguments);
    }
    function gL() {
      return Yl;
    }
    function AM() {
      if (Yl) {
        var o = wh;
        return Yl = !1, wh = null, o;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    var eM = null;
    eM = /* @__PURE__ */ new Set();
    var yh = !1, OI = !1, rL = typeof WeakSet == "function" ? WeakSet : Set, qe = null, UQ = null, kQ = null;
    function lg(o) {
      $S(null, function() {
        throw o;
      }), AM();
    }
    var oL = function(o, a) {
      if (a.props = o.memoizedProps, a.state = o.memoizedState, o.mode & zt)
        try {
          po(), a.componentWillUnmount();
        } finally {
          fo(o);
        }
      else
        a.componentWillUnmount();
    };
    function tM(o, a) {
      try {
        xa(xn, o);
      } catch (h) {
        lg(h), cg(o, a, h);
      }
    }
    function ED(o, a, h) {
      try {
        oL(o, h);
      } catch (w) {
        lg(w), cg(o, a, w);
      }
    }
    function sL(o, a, h) {
      try {
        h.componentDidMount();
      } catch (w) {
        lg(w), cg(o, a, w);
      }
    }
    function iM(o, a) {
      try {
        gM(o);
      } catch (h) {
        lg(h), cg(o, a, h);
      }
    }
    function mh(o, a) {
      var h = o.ref;
      if (h !== null)
        if (typeof h == "function") {
          var w;
          try {
            if (N && F && o.mode & zt)
              try {
                po(), w = h(null);
              } finally {
                fo(o);
              }
            else
              w = h(null);
          } catch (R) {
            lg(R), cg(o, a, R);
          }
          typeof w == "function" && I("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", xA(o));
        } else
          h.current = null;
    }
    function Sh(o, a, h) {
      try {
        h();
      } catch (w) {
        lg(w), cg(o, a, w);
      }
    }
    var nM = !1;
    function aL(o, a) {
      na(o.containerInfo), qe = a, IL();
      var h = nM;
      return nM = !1, h;
    }
    function IL() {
      for (; qe !== null; ) {
        var o = qe, a = o.child;
        (o.subtreeFlags & tt) !== gA && a !== null ? (Do(a, o), qe = a) : BL();
      }
    }
    function BL() {
      for (; qe !== null; ) {
        var o = qe;
        ai(o);
        try {
          CL(o);
        } catch (h) {
          lg(h), cg(o, o.return, h);
        }
        Wn();
        var a = o.sibling;
        if (a !== null) {
          Do(a, o.return), qe = a;
          return;
        }
        qe = o.return;
      }
    }
    function CL(o) {
      var a = o.alternate, h = o.flags;
      if ((h & Pe) !== gA) {
        switch (ai(o), o.tag) {
          case G:
          case P:
          case rA:
            break;
          case k: {
            if (a !== null) {
              var w = a.memoizedProps, R = a.memoizedState, L = o.stateNode;
              o.type === o.elementType && !tC && (L.props !== o.memoizedProps && I("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xA(o) || "instance"), L.state !== o.memoizedState && I("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xA(o) || "instance"));
              var W = L.getSnapshotBeforeUpdate(o.elementType === o.type ? w : lr(o.type, w), R);
              {
                var nA = eM;
                W === void 0 && !nA.has(o.type) && (nA.add(o.type), I("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", xA(o)));
              }
              L.__reactInternalSnapshotBeforeUpdate = W;
            }
            break;
          }
          case x: {
            if (_g) {
              var sA = o.stateNode;
              sa(sA.containerInfo);
            }
            break;
          }
          case _:
          case j:
          case H:
          case aA:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Wn();
      }
    }
    function ur(o, a, h) {
      var w = a.updateQueue, R = w !== null ? w.lastEffect : null;
      if (R !== null) {
        var L = R.next, W = L;
        do {
          if ((W.tag & o) === o) {
            var nA = W.destroy;
            W.destroy = void 0, nA !== void 0 && ((o & Qg) !== Js ? Ng(a) : (o & xn) !== Js && _B(a), Sh(a, h, nA), (o & Qg) !== Js ? El() : (o & xn) !== Js && lQ());
          }
          W = W.next;
        } while (W !== L);
      }
    }
    function xa(o, a) {
      var h = a.updateQueue, w = h !== null ? h.lastEffect : null;
      if (w !== null) {
        var R = w.next, L = R;
        do {
          if ((L.tag & o) === o) {
            (o & Qg) !== Js ? Ql(a) : (o & xn) !== Js && ll(a);
            var W = L.create;
            L.destroy = W(), (o & Qg) !== Js ? HB() : (o & xn) !== Js && GI();
            {
              var nA = L.destroy;
              if (nA !== void 0 && typeof nA != "function") {
                var sA = void 0;
                (L.tag & xn) !== gA ? sA = "useLayoutEffect" : (L.tag & HI) !== gA ? sA = "useInsertionEffect" : sA = "useEffect";
                var pA = void 0;
                nA === null ? pA = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof nA.then == "function" ? pA = `

It looks like you wrote ` + sA + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + sA + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : pA = " You returned: " + nA, I("%s must not return anything besides a function, which is used for clean-up.%s", sA, pA);
              }
            }
          }
          L = L.next;
        } while (L !== R);
      }
    }
    function QL(o, a) {
      if ((a.flags & TA) !== gA)
        switch (a.tag) {
          case J: {
            var h = a.stateNode.passiveEffectDuration, w = a.memoizedProps, R = w.id, L = w.onPostCommit, W = dS(), nA = a.alternate === null ? "mount" : "update";
            hS() && (nA = "nested-update"), typeof L == "function" && L(R, nA, h, W);
            var sA = a.return;
            A:
              for (; sA !== null; ) {
                switch (sA.tag) {
                  case x:
                    var pA = sA.stateNode;
                    pA.passiveEffectDuration += h;
                    break A;
                  case J:
                    var LA = sA.stateNode;
                    LA.passiveEffectDuration += h;
                    break A;
                }
                sA = sA.return;
              }
            break;
          }
        }
    }
    function EL(o, a, h, w) {
      if ((h.flags & ui) !== gA)
        switch (h.tag) {
          case G:
          case P:
          case rA: {
            if (!OI)
              if (h.mode & zt)
                try {
                  po(), xa(xn | In, h);
                } finally {
                  fo(h);
                }
              else
                xa(xn | In, h);
            break;
          }
          case k: {
            var R = h.stateNode;
            if (h.flags & TA && !OI)
              if (a === null)
                if (h.type === h.elementType && !tC && (R.props !== h.memoizedProps && I("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xA(h) || "instance"), R.state !== h.memoizedState && I("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xA(h) || "instance")), h.mode & zt)
                  try {
                    po(), R.componentDidMount();
                  } finally {
                    fo(h);
                  }
                else
                  R.componentDidMount();
              else {
                var L = h.elementType === h.type ? a.memoizedProps : lr(h.type, a.memoizedProps), W = a.memoizedState;
                if (h.type === h.elementType && !tC && (R.props !== h.memoizedProps && I("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xA(h) || "instance"), R.state !== h.memoizedState && I("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xA(h) || "instance")), h.mode & zt)
                  try {
                    po(), R.componentDidUpdate(L, W, R.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    fo(h);
                  }
                else
                  R.componentDidUpdate(L, W, R.__reactInternalSnapshotBeforeUpdate);
              }
            var nA = h.updateQueue;
            nA !== null && (h.type === h.elementType && !tC && (R.props !== h.memoizedProps && I("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xA(h) || "instance"), R.state !== h.memoizedState && I("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xA(h) || "instance")), mm(h, nA, R));
            break;
          }
          case x: {
            var sA = h.updateQueue;
            if (sA !== null) {
              var pA = null;
              if (h.child !== null)
                switch (h.child.tag) {
                  case _:
                    pA = sg(h.child.stateNode);
                    break;
                  case k:
                    pA = h.child.stateNode;
                    break;
                }
              mm(h, sA, pA);
            }
            break;
          }
          case _: {
            var LA = h.stateNode;
            if (a === null && h.flags & TA) {
              var VA = h.type, oe = h.memoizedProps;
              XE(LA, VA, oe, h);
            }
            break;
          }
          case j:
            break;
          case H:
            break;
          case J: {
            {
              var Qe = h.memoizedProps, me = Qe.onCommit, Ne = Qe.onRender, nt = h.stateNode.effectDuration, Ut = dS(), It = a === null ? "mount" : "update";
              hS() && (It = "nested-update"), typeof Ne == "function" && Ne(h.memoizedProps.id, It, h.actualDuration, h.treeBaseDuration, h.actualStartTime, Ut);
              {
                typeof me == "function" && me(h.memoizedProps.id, It, nt, Ut), RT(h);
                var Hi = h.return;
                A:
                  for (; Hi !== null; ) {
                    switch (Hi.tag) {
                      case x:
                        var _i = Hi.stateNode;
                        _i.effectDuration += nt;
                        break A;
                      case J:
                        var te = Hi.stateNode;
                        te.effectDuration += nt;
                        break A;
                    }
                    Hi = Hi.return;
                  }
              }
            }
            break;
          }
          case tA: {
            wL(o, h);
            break;
          }
          case hA:
          case aA:
          case fA:
          case wA:
          case yA:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      OI || h.flags & _e && gM(h);
    }
    function lL(o) {
      switch (o.tag) {
        case G:
        case P:
        case rA: {
          if (o.mode & zt)
            try {
              po(), tM(o, o.return);
            } finally {
              fo(o);
            }
          else
            tM(o, o.return);
          break;
        }
        case k: {
          var a = o.stateNode;
          typeof a.componentDidMount == "function" && sL(o, o.return, a), iM(o, o.return);
          break;
        }
        case _: {
          iM(o, o.return);
          break;
        }
      }
    }
    function cL(o, a) {
      var h = null;
      if (_g)
        for (var w = o; ; ) {
          if (w.tag === _) {
            if (h === null) {
              h = w;
              var R = w.stateNode;
              a ? Al(R) : AQ(w.stateNode, w.memoizedProps);
            }
          } else if (w.tag === j) {
            if (h === null) {
              var L = w.stateNode;
              a ? Gn(L) : gI(L, w.memoizedProps);
            }
          } else if (!((w.tag === wA || w.tag === yA) && w.memoizedState !== null && w !== o)) {
            if (w.child !== null) {
              w.child.return = w, w = w.child;
              continue;
            }
          }
          if (w === o)
            return;
          for (; w.sibling === null; ) {
            if (w.return === null || w.return === o)
              return;
            h === w && (h = null), w = w.return;
          }
          h === w && (h = null), w.sibling.return = w.return, w = w.sibling;
        }
    }
    function gM(o) {
      var a = o.ref;
      if (a !== null) {
        var h = o.stateNode, w;
        switch (o.tag) {
          case _:
            w = sg(h);
            break;
          default:
            w = h;
        }
        if (typeof a == "function") {
          var R;
          if (o.mode & zt)
            try {
              po(), R = a(w);
            } finally {
              fo(o);
            }
          else
            R = a(w);
          typeof R == "function" && I("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", xA(o));
        } else
          a.hasOwnProperty("current") || I("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", xA(o)), a.current = w;
      }
    }
    function uL(o) {
      var a = o.ref;
      if (a !== null)
        if (typeof a == "function")
          if (o.mode & zt)
            try {
              po(), a(null);
            } finally {
              fo(o);
            }
          else
            a(null);
        else
          a.current = null;
    }
    function rM(o, a, h) {
      switch (Dn(a), a.tag) {
        case G:
        case P:
        case Y:
        case rA: {
          var w = a.updateQueue;
          if (w !== null) {
            var R = w.lastEffect;
            if (R !== null) {
              var L = R.next, W = L;
              do {
                var nA = W, sA = nA.destroy, pA = nA.tag;
                sA !== void 0 && ((pA & HI) !== Js ? Sh(a, h, sA) : (pA & xn) !== Js && (_B(a), a.mode & zt ? (po(), Sh(a, h, sA), fo(a)) : Sh(a, h, sA), lQ())), W = W.next;
              } while (W !== L);
            }
          }
          return;
        }
        case k: {
          mh(a, h);
          var LA = a.stateNode;
          typeof LA.componentWillUnmount == "function" && ED(a, h, LA);
          return;
        }
        case _: {
          mh(a, h);
          return;
        }
        case H: {
          _g ? CM(o, a, h) : ga && dL(a);
          return;
        }
        case MA:
          return;
        case fA:
          return;
      }
    }
    function oM(o, a, h) {
      for (var w = a; ; ) {
        if (rM(o, w, h), w.child !== null && // If we use mutation we drill down into portals using commitUnmount above.
        // If we don't use mutation we drill down into portals here instead.
        (!_g || w.tag !== H)) {
          w.child.return = w, w = w.child;
          continue;
        }
        if (w === a)
          return;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === a)
            return;
          w = w.return;
        }
        w.sibling.return = w.return, w = w.sibling;
      }
    }
    function hL(o) {
      var a = o.alternate;
      a !== null && (a.return = null), o.return = null;
    }
    function sM(o) {
      var a = o.alternate;
      a !== null && (o.alternate = null, sM(a));
      {
        if (o.child = null, o.deletions = null, o.sibling = null, o.tag === _) {
          var h = o.stateNode;
          h !== null && yB(h);
        }
        o.stateNode = null, o._debugOwner = null, o.return = null, o.dependencies = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.stateNode = null, o.updateQueue = null;
      }
    }
    function dL(o) {
      if (ga) {
        var a = o.stateNode, h = a.containerInfo, w = aa(h);
        To(h, w);
      }
    }
    function fL(o) {
      if (ga) {
        switch (o.tag) {
          case k:
          case _:
          case j:
            return;
          case x:
          case H: {
            var a = o.stateNode, h = a.containerInfo, w = a.pendingChildren;
            To(h, w);
            return;
          }
        }
        throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function pL(o) {
      for (var a = o.return; a !== null; ) {
        if (aM(a))
          return a;
        a = a.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function aM(o) {
      return o.tag === _ || o.tag === x || o.tag === H;
    }
    function IM(o) {
      var a = o;
      A:
        for (; ; ) {
          for (; a.sibling === null; ) {
            if (a.return === null || aM(a.return))
              return null;
            a = a.return;
          }
          for (a.sibling.return = a.return, a = a.sibling; a.tag !== _ && a.tag !== j && a.tag !== MA; ) {
            if (a.flags & UA || a.child === null || a.tag === H)
              continue A;
            a.child.return = a, a = a.child;
          }
          if (!(a.flags & UA))
            return a.stateNode;
        }
    }
    function BM(o) {
      if (_g) {
        var a = pL(o);
        switch (a.tag) {
          case _: {
            var h = a.stateNode;
            a.flags & xe && (RB(h), a.flags &= ~xe);
            var w = IM(o);
            cD(o, w, h);
            break;
          }
          case x:
          case H: {
            var R = a.stateNode.containerInfo, L = IM(o);
            lD(o, L, R);
            break;
          }
          default:
            throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
    }
    function lD(o, a, h) {
      var w = o.tag, R = w === _ || w === j;
      if (R) {
        var L = o.stateNode;
        a ? Fn(h, L, a) : Lo(h, L);
      } else if (w !== H) {
        var W = o.child;
        if (W !== null) {
          lD(W, a, h);
          for (var nA = W.sibling; nA !== null; )
            lD(nA, a, h), nA = nA.sibling;
        }
      }
    }
    function cD(o, a, h) {
      var w = o.tag, R = w === _ || w === j;
      if (R) {
        var L = o.stateNode;
        a ? rr(h, L, a) : ZE(h, L);
      } else if (w !== H) {
        var W = o.child;
        if (W !== null) {
          cD(W, a, h);
          for (var nA = W.sibling; nA !== null; )
            cD(nA, a, h), nA = nA.sibling;
        }
      }
    }
    function CM(o, a, h) {
      for (var w = a, R = !1, L, W; ; ) {
        if (!R) {
          var nA = w.return;
          A:
            for (; ; ) {
              if (nA === null)
                throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              var sA = nA.stateNode;
              switch (nA.tag) {
                case _:
                  L = sA, W = !1;
                  break A;
                case x:
                  L = sA.containerInfo, W = !0;
                  break A;
                case H:
                  L = sA.containerInfo, W = !0;
                  break A;
              }
              nA = nA.return;
            }
          R = !0;
        }
        if (w.tag === _ || w.tag === j)
          oM(o, w, h), W ? MB(L, w.stateNode) : oa(L, w.stateNode);
        else if (w.tag === MA)
          W ? nQ(L, w.stateNode) : vB(L, w.stateNode);
        else if (w.tag === H) {
          if (w.child !== null) {
            L = w.stateNode.containerInfo, W = !0, w.child.return = w, w = w.child;
            continue;
          }
        } else if (rM(o, w, h), w.child !== null) {
          w.child.return = w, w = w.child;
          continue;
        }
        if (w === a)
          return;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === a)
            return;
          w = w.return, w.tag === H && (R = !1);
        }
        w.sibling.return = w.return, w = w.sibling;
      }
    }
    function DL(o, a, h) {
      _g ? CM(o, a, h) : oM(o, a, h), hL(a);
    }
    function uD(o, a) {
      if (!_g) {
        switch (a.tag) {
          case G:
          case P:
          case Y:
          case rA: {
            if (ur(HI | In, a, a.return), xa(HI | In, a), a.mode & zt)
              try {
                po(), ur(xn | In, a, a.return);
              } finally {
                fo(a);
              }
            else
              ur(xn | In, a, a.return);
            return;
          }
          case J:
            return;
          case tA: {
            QM(a), Mh(a);
            return;
          }
          case hA: {
            Mh(a);
            return;
          }
          case x: {
            if (fn && o !== null) {
              var h = o.memoizedState;
              if (h.isDehydrated) {
                var w = a.stateNode;
                aI(w.containerInfo);
              }
            }
            break;
          }
          case wA:
          case yA:
            return;
        }
        fL(a);
        return;
      }
      switch (a.tag) {
        case G:
        case P:
        case Y:
        case rA: {
          if (ur(HI | In, a, a.return), xa(HI | In, a), a.mode & zt)
            try {
              po(), ur(xn | In, a, a.return);
            } finally {
              fo(a);
            }
          else
            ur(xn | In, a, a.return);
          return;
        }
        case k:
          return;
        case _: {
          var R = a.stateNode;
          if (R != null) {
            var L = a.memoizedProps, W = o !== null ? o.memoizedProps : L, nA = a.type, sA = a.updateQueue;
            a.updateQueue = null, sA !== null && $E(R, sA, nA, W, L, a);
          }
          return;
        }
        case j: {
          if (a.stateNode === null)
            throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
          var pA = a.stateNode, LA = a.memoizedProps, VA = o !== null ? o.memoizedProps : LA;
          gr(pA, VA, LA);
          return;
        }
        case x: {
          if (fn && o !== null) {
            var oe = o.memoizedState;
            if (oe.isDehydrated) {
              var Qe = a.stateNode;
              aI(Qe.containerInfo);
            }
          }
          return;
        }
        case J:
          return;
        case tA: {
          QM(a), Mh(a);
          return;
        }
        case hA: {
          Mh(a);
          return;
        }
        case aA:
          return;
      }
      throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function QM(o) {
      o.memoizedState;
    }
    function wL(o, a) {
      if (fn) {
        var h = a.memoizedState;
        if (h === null) {
          var w = a.alternate;
          if (w !== null) {
            var R = w.memoizedState;
            if (R !== null) {
              var L = R.dehydrated;
              L !== null && II(L);
            }
          }
        }
      }
    }
    function Mh(o) {
      var a = o.updateQueue;
      if (a !== null) {
        o.updateQueue = null;
        var h = o.stateNode;
        h === null && (h = o.stateNode = new rL()), a.forEach(function(w) {
          var R = xT.bind(null, o, w);
          if (!h.has(w)) {
            if (h.add(w), Rg)
              if (UQ !== null && kQ !== null)
                jl(kQ, UQ);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            w.then(R, R);
          }
        });
      }
    }
    function yL(o) {
      _g && RB(o.stateNode);
    }
    function mL(o, a, h) {
      UQ = h, kQ = o, qe = a, SL(o, h), UQ = null, kQ = null;
    }
    function SL(o, a) {
      for (; qe !== null; ) {
        var h = qe, w = h.deletions;
        if (w !== null)
          for (var R = 0; R < w.length; R++) {
            var L = w[R];
            try {
              DL(o, L, h);
            } catch (nA) {
              lg(nA), cg(L, h, nA);
            }
          }
        var W = h.child;
        (h.subtreeFlags & Ft) !== gA && W !== null ? (Do(W, h), qe = W) : ML(o, a);
      }
    }
    function ML(o, a) {
      for (; qe !== null; ) {
        var h = qe;
        ai(h);
        try {
          RL(h, o, a);
        } catch (R) {
          lg(R), cg(h, h.return, R);
        }
        Wn();
        var w = h.sibling;
        if (w !== null) {
          Do(w, h.return), qe = w;
          return;
        }
        qe = h.return;
      }
    }
    function RL(o, a, h) {
      var w = o.flags;
      if (w & xe && yL(o), w & _e) {
        var R = o.alternate;
        R !== null && uL(R);
      }
      if (w & je)
        switch (o.tag) {
          case tA: {
            var L = o.memoizedState, W = L !== null;
            if (W) {
              var nA = o.alternate, sA = nA !== null && nA.memoizedState !== null;
              sA || fT();
            }
            break;
          }
          case wA: {
            var pA = o.memoizedState, LA = pA !== null, VA = o.alternate, oe = VA !== null && VA.memoizedState !== null, Qe = o;
            _g && cL(Qe, LA);
            {
              if (LA && !oe && (Qe.mode & si) !== Ct) {
                qe = Qe;
                for (var me = Qe.child; me !== null; )
                  qe = me, FL(me), me = me.sibling;
              }
              break;
            }
          }
        }
      var Ne = w & (UA | TA | Jt);
      switch (Ne) {
        case UA: {
          BM(o), o.flags &= ~UA;
          break;
        }
        case ge: {
          BM(o), o.flags &= ~UA;
          var nt = o.alternate;
          uD(nt, o);
          break;
        }
        case Jt: {
          o.flags &= ~Jt;
          break;
        }
        case vi: {
          o.flags &= ~Jt;
          var Ut = o.alternate;
          uD(Ut, o);
          break;
        }
        case TA: {
          var It = o.alternate;
          uD(It, o);
          break;
        }
      }
    }
    function NL(o, a, h) {
      UQ = h, kQ = a, qe = o, EM(o, a, h), UQ = null, kQ = null;
    }
    function EM(o, a, h) {
      for (var w = (o.mode & si) !== Ct; qe !== null; ) {
        var R = qe, L = R.child;
        if (R.tag === wA && w) {
          var W = R.memoizedState !== null, nA = W || yh;
          if (nA) {
            hD(o, a, h);
            continue;
          } else {
            var sA = R.alternate, pA = sA !== null && sA.memoizedState !== null, LA = pA || OI, VA = yh, oe = OI;
            yh = nA, OI = LA, OI && !oe && (qe = R, GL(R));
            for (var Qe = L; Qe !== null; )
              qe = Qe, EM(
                Qe,
                // New root; bubble back up to here and stop.
                a,
                h
              ), Qe = Qe.sibling;
            qe = R, yh = VA, OI = oe, hD(o, a, h);
            continue;
          }
        }
        (R.subtreeFlags & ui) !== gA && L !== null ? (Do(L, R), qe = L) : hD(o, a, h);
      }
    }
    function hD(o, a, h) {
      for (; qe !== null; ) {
        var w = qe;
        if ((w.flags & ui) !== gA) {
          var R = w.alternate;
          ai(w);
          try {
            EL(a, R, w, h);
          } catch (W) {
            lg(W), cg(w, w.return, W);
          }
          Wn();
        }
        if (w === o) {
          qe = null;
          return;
        }
        var L = w.sibling;
        if (L !== null) {
          Do(L, w.return), qe = L;
          return;
        }
        qe = w.return;
      }
    }
    function FL(o) {
      for (; qe !== null; ) {
        var a = qe, h = a.child;
        switch (a.tag) {
          case G:
          case P:
          case Y:
          case rA: {
            if (a.mode & zt)
              try {
                po(), ur(xn, a, a.return);
              } finally {
                fo(a);
              }
            else
              ur(xn, a, a.return);
            break;
          }
          case k: {
            mh(a, a.return);
            var w = a.stateNode;
            typeof w.componentWillUnmount == "function" && ED(a, a.return, w);
            break;
          }
          case _: {
            mh(a, a.return);
            break;
          }
          case wA: {
            var R = a.memoizedState !== null;
            if (R) {
              lM(o);
              continue;
            }
            break;
          }
        }
        h !== null ? (h.return = a, qe = h) : lM(o);
      }
    }
    function lM(o) {
      for (; qe !== null; ) {
        var a = qe;
        if (a === o) {
          qe = null;
          return;
        }
        var h = a.sibling;
        if (h !== null) {
          h.return = a.return, qe = h;
          return;
        }
        qe = a.return;
      }
    }
    function GL(o) {
      for (; qe !== null; ) {
        var a = qe, h = a.child;
        if (a.tag === wA) {
          var w = a.memoizedState !== null;
          if (w) {
            cM(o);
            continue;
          }
        }
        h !== null ? (h.return = a, qe = h) : cM(o);
      }
    }
    function cM(o) {
      for (; qe !== null; ) {
        var a = qe;
        ai(a);
        try {
          lL(a);
        } catch (w) {
          lg(w), cg(a, a.return, w);
        }
        if (Wn(), a === o) {
          qe = null;
          return;
        }
        var h = a.sibling;
        if (h !== null) {
          h.return = a.return, qe = h;
          return;
        }
        qe = a.return;
      }
    }
    function vL(o, a) {
      qe = a, UL(a, o);
    }
    function UL(o, a) {
      for (; qe !== null; ) {
        var h = qe, w = h.child;
        (h.subtreeFlags & Li) !== gA && w !== null ? (Do(w, h), qe = w) : kL(o, a);
      }
    }
    function kL(o, a) {
      for (; qe !== null; ) {
        var h = qe;
        if ((h.flags & Nt) !== gA) {
          ai(h);
          try {
            xL(a, h);
          } catch (R) {
            lg(R), cg(h, h.return, R);
          }
          Wn();
        }
        if (h === o) {
          qe = null;
          return;
        }
        var w = h.sibling;
        if (w !== null) {
          Do(w, h.return), qe = w;
          return;
        }
        qe = h.return;
      }
    }
    function xL(o, a) {
      switch (a.tag) {
        case G:
        case P:
        case rA: {
          if (a.mode & zt) {
            Zp();
            try {
              xa(Qg | In, a);
            } finally {
              jp(a);
            }
          } else
            xa(Qg | In, a);
          break;
        }
      }
    }
    function LL(o) {
      qe = o, TL();
    }
    function TL() {
      for (; qe !== null; ) {
        var o = qe, a = o.child;
        if ((qe.flags & Me) !== gA) {
          var h = o.deletions;
          if (h !== null) {
            for (var w = 0; w < h.length; w++) {
              var R = h[w];
              qe = R, YL(R, o);
            }
            {
              var L = o.alternate;
              if (L !== null) {
                var W = L.child;
                if (W !== null) {
                  L.child = null;
                  do {
                    var nA = W.sibling;
                    W.sibling = null, W = nA;
                  } while (W !== null);
                }
              }
            }
            qe = o;
          }
        }
        (o.subtreeFlags & Li) !== gA && a !== null ? (Do(a, o), qe = a) : KL();
      }
    }
    function KL() {
      for (; qe !== null; ) {
        var o = qe;
        (o.flags & Nt) !== gA && (ai(o), bL(o), Wn());
        var a = o.sibling;
        if (a !== null) {
          Do(a, o.return), qe = a;
          return;
        }
        qe = o.return;
      }
    }
    function bL(o) {
      switch (o.tag) {
        case G:
        case P:
        case rA: {
          o.mode & zt ? (Zp(), ur(Qg | In, o, o.return), jp(o)) : ur(Qg | In, o, o.return);
          break;
        }
      }
    }
    function YL(o, a) {
      for (; qe !== null; ) {
        var h = qe;
        ai(h), _L(h, a), Wn();
        var w = h.child;
        w !== null ? (Do(w, h), qe = w) : HL(o);
      }
    }
    function HL(o) {
      for (; qe !== null; ) {
        var a = qe, h = a.sibling, w = a.return;
        if (sM(a), a === o) {
          qe = null;
          return;
        }
        if (h !== null) {
          Do(h, w), qe = h;
          return;
        }
        qe = w;
      }
    }
    function _L(o, a) {
      switch (o.tag) {
        case G:
        case P:
        case rA: {
          o.mode & zt ? (Zp(), ur(Qg, o, a), jp(o)) : ur(Qg, o, a);
          break;
        }
      }
    }
    var uM = !1;
    function Do(o, a) {
      !uM && o.return !== a && (uM = !0, I("Internal React error: Return pointer is inconsistent with parent.")), o.return = a;
    }
    function JL(o) {
      switch (o.tag) {
        case G:
        case P:
        case rA: {
          try {
            xa(xn | In, o);
          } catch (h) {
            lg(h), cg(o, o.return, h);
          }
          break;
        }
        case k: {
          var a = o.stateNode;
          try {
            a.componentDidMount();
          } catch (h) {
            lg(h), cg(o, o.return, h);
          }
          break;
        }
      }
    }
    function OL(o) {
      switch (o.tag) {
        case G:
        case P:
        case rA: {
          try {
            xa(Qg | In, o);
          } catch (a) {
            lg(a), cg(o, o.return, a);
          }
          break;
        }
      }
    }
    function qL(o) {
      switch (o.tag) {
        case G:
        case P:
        case rA: {
          try {
            ur(xn | In, o, o.return);
          } catch (h) {
            lg(h), cg(o, o.return, h);
          }
          break;
        }
        case k: {
          var a = o.stateNode;
          typeof a.componentWillUnmount == "function" && ED(o, o.return, a);
          break;
        }
      }
    }
    function PL(o) {
      switch (o.tag) {
        case G:
        case P:
        case rA:
          try {
            ur(Qg | In, o, o.return);
          } catch (a) {
            lg(a), cg(o, o.return, a);
          }
      }
    }
    var Rh = 0, Nh = 1, Fh = 2, Gh = 3, vh = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var Hl = Symbol.for;
      Rh = Hl("selector.component"), Nh = Hl("selector.has_pseudo_class"), Fh = Hl("selector.role"), Gh = Hl("selector.test_id"), vh = Hl("selector.text");
    }
    function WL(o) {
      return {
        $$typeof: Rh,
        value: o
      };
    }
    function zL(o) {
      return {
        $$typeof: Nh,
        value: o
      };
    }
    function VL(o) {
      return {
        $$typeof: Fh,
        value: o
      };
    }
    function jL(o) {
      return {
        $$typeof: vh,
        value: o
      };
    }
    function ZL(o) {
      return {
        $$typeof: Gh,
        value: o
      };
    }
    function dD(o) {
      var a = nI(o);
      if (a != null) {
        if (typeof a.memoizedProps["data-testname"] != "string")
          throw new Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");
        return a;
      } else {
        var h = Ur(o);
        if (h === null)
          throw new Error("Could not find React container within specified host subtree.");
        return h.stateNode.current;
      }
    }
    function fD(o, a) {
      switch (a.$$typeof) {
        case Rh:
          if (o.type === a.value)
            return !0;
          break;
        case Nh:
          return XL(o, a.value);
        case Fh:
          if (o.tag === _) {
            var h = o.stateNode;
            if (ra(h, a.value))
              return !0;
          }
          break;
        case vh:
          if (o.tag === _ || o.tag === j) {
            var w = $C(o);
            if (w !== null && w.indexOf(a.value) >= 0)
              return !0;
          }
          break;
        case Gh:
          if (o.tag === _) {
            var R = o.memoizedProps["data-testname"];
            if (typeof R == "string" && R.toLowerCase() === a.value.toLowerCase())
              return !0;
          }
          break;
        default:
          throw new Error("Invalid selector type specified.");
      }
      return !1;
    }
    function pD(o) {
      switch (o.$$typeof) {
        case Rh:
          var a = _A(o.value) || "Unknown";
          return "<" + a + ">";
        case Nh:
          return ":has(" + (pD(o) || "") + ")";
        case Fh:
          return '[role="' + o.value + '"]';
        case vh:
          return '"' + o.value + '"';
        case Gh:
          return '[data-testname="' + o.value + '"]';
        default:
          throw new Error("Invalid selector type specified.");
      }
    }
    function hM(o, a) {
      for (var h = [], w = [o, 0], R = 0; R < w.length; ) {
        var L = w[R++], W = w[R++], nA = a[W];
        if (!(L.tag === _ && ki(L))) {
          for (; nA != null && fD(L, nA); )
            W++, nA = a[W];
          if (W === a.length)
            h.push(L);
          else
            for (var sA = L.child; sA !== null; )
              w.push(sA, W), sA = sA.sibling;
        }
      }
      return h;
    }
    function XL(o, a) {
      for (var h = [o, 0], w = 0; w < h.length; ) {
        var R = h[w++], L = h[w++], W = a[L];
        if (!(R.tag === _ && ki(R))) {
          for (; W != null && fD(R, W); )
            L++, W = a[L];
          if (L === a.length)
            return !0;
          for (var nA = R.child; nA !== null; )
            h.push(nA, L), nA = nA.sibling;
        }
      }
      return !1;
    }
    function Uh(o, a) {
      if (!ao)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var h = dD(o), w = hM(h, a), R = [], L = Array.from(w), W = 0; W < L.length; ) {
        var nA = L[W++];
        if (nA.tag === _) {
          if (ki(nA))
            continue;
          R.push(nA.stateNode);
        } else
          for (var sA = nA.child; sA !== null; )
            L.push(sA), sA = sA.sibling;
      }
      return R;
    }
    function $L(o, a) {
      if (!ao)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var h = dD(o), w = 0, R = [], L = [h, 0], W = 0; W < L.length; ) {
        var nA = L[W++], sA = L[W++], pA = a[sA];
        if (!(nA.tag === _ && ki(nA)) && (fD(nA, pA) && (R.push(pD(pA)), sA++, sA > w && (w = sA)), sA < a.length))
          for (var LA = nA.child; LA !== null; )
            L.push(LA, sA), LA = LA.sibling;
      }
      if (w < a.length) {
        for (var VA = [], oe = w; oe < a.length; oe++)
          VA.push(pD(a[oe]));
        return `findAllNodes was able to match part of the selector:
` + ("  " + R.join(" > ") + `

`) + `No matching component was found for:
` + ("  " + VA.join(" > "));
      }
      return null;
    }
    function AT(o, a) {
      if (!ao)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var h = Uh(o, a), w = [], R = 0; R < h.length; R++)
        w.push(mB(h[R]));
      for (var L = w.length - 1; L > 0; L--)
        for (var W = w[L], nA = W.x, sA = nA + W.width, pA = W.y, LA = pA + W.height, VA = L - 1; VA >= 0; VA--)
          if (L !== VA) {
            var oe = w[VA], Qe = oe.x, me = Qe + oe.width, Ne = oe.y, nt = Ne + oe.height;
            if (nA >= Qe && pA >= Ne && sA <= me && LA <= nt) {
              w.splice(L, 1);
              break;
            } else if (nA === Qe && W.width === oe.width && !(nt < pA) && !(Ne > LA)) {
              Ne > pA && (oe.height += Ne - pA, oe.y = pA), nt < LA && (oe.height = LA - Ne), w.splice(L, 1);
              break;
            } else if (pA === Ne && W.height === oe.height && !(me < nA) && !(Qe > sA)) {
              Qe > nA && (oe.width += Qe - nA, oe.x = nA), me < sA && (oe.width = sA - Qe), w.splice(L, 1);
              break;
            }
          }
      return w;
    }
    function eT(o, a) {
      if (!ao)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var h = dD(o), w = hM(h, a), R = Array.from(w), L = 0; L < R.length; ) {
        var W = R[L++];
        if (!ki(W)) {
          if (W.tag === _) {
            var nA = W.stateNode;
            if (jE(nA))
              return !0;
          }
          for (var sA = W.child; sA !== null; )
            R.push(sA), sA = sA.sibling;
        }
      }
      return !1;
    }
    var kh = [];
    function tT() {
      ao && kh.forEach(function(o) {
        return o();
      });
    }
    function iT(o, a, h, w) {
      if (!ao)
        throw new Error("Test selector API is not supported by this renderer.");
      var R = Uh(o, a), L = SB(R, h, w), W = L.disconnect, nA = L.observe, sA = L.unobserve, pA = function() {
        var LA = Uh(o, a);
        R.forEach(function(VA) {
          LA.indexOf(VA) < 0 && sA(VA);
        }), LA.forEach(function(VA) {
          R.indexOf(VA) < 0 && nA(VA);
        });
      };
      return kh.push(pA), {
        disconnect: function() {
          var LA = kh.indexOf(pA);
          LA >= 0 && kh.splice(LA, 1), W();
        }
      };
    }
    var nT = n.ReactCurrentActQueue;
    function gT(o) {
      {
        var a = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), h = typeof jest < "u";
        return so && h && a !== !1;
      }
    }
    function dM() {
      {
        var o = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !o && nT.current !== null && I("The current testing environment is not configured to support act(...)"), o;
      }
    }
    var rT = Math.ceil, DD = n.ReactCurrentDispatcher, wD = n.ReactCurrentOwner, Bn = n.ReactCurrentBatchConfig, es = n.ReactCurrentActQueue, Hn = (
      /*             */
      0
    ), yD = (
      /*               */
      1
    ), xg = (
      /*                */
      2
    ), ts = (
      /*                */
      4
    ), La = 0, _l = 1, iC = 2, xh = 3, Jl = 4, fM = 5, mD = 6, bt = Hn, Lg = null, Cn = null, jn = De, Ws = De, SD = ht(De), Zn = La, Ol = null, Lh = De, ql = De, Th = De, Pl = null, hr = null, MD = 0, pM = 500, DM = 1 / 0, oT = 500;
    function xQ() {
      DM = on() + oT;
    }
    function wM() {
      return DM;
    }
    var Kh = !1, RD = null, LQ = null, nC = !1, Ta = null, Wl = De, ND = [], sT = 50, zl = 0, FD = null, aT = 50, bh = 0, Vl = Si, Yh = De;
    function Hh() {
      return Lg;
    }
    function Xg() {
      return (bt & (xg | ts)) !== Hn ? on() : (Vl !== Si || (Vl = on()), Vl);
    }
    function qI(o) {
      var a = o.mode;
      if ((a & si) === Ct)
        return Lt;
      if ((bt & xg) !== Hn && jn !== De)
        return wI(jn);
      var h = dl() !== Tu;
      if (h) {
        if (Bn.transition !== null) {
          var w = Bn.transition;
          w._updatedFibers || (w._updatedFibers = /* @__PURE__ */ new Set()), w._updatedFibers.add(o);
        }
        return Yh === nn && (Yh = Ru()), Yh;
      }
      var R = Wg();
      if (R !== nn)
        return R;
      var L = VE();
      return L;
    }
    function IT(o) {
      var a = o.mode;
      return (a & si) === Ct ? Lt : Nu();
    }
    function Xn(o, a, h) {
      TT();
      var w = _h(o, a);
      return w === null ? null : (pa(w, a, h), (bt & xg) !== De && w === Lg ? YT(o) : (Rg && gl(w, o, a), HT(o), w === Lg && ((bt & xg) === Hn && (ql = Gt(ql, a)), Zn === Jl && PI(w, jn)), dr(w, h), a === Lt && bt === Hn && (o.mode & si) === Ct && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !es.isBatchingLegacy && (xQ(), hl())), w);
    }
    function BT(o, a, h) {
      var w = o.current;
      w.lanes = a, pa(o, a, h), dr(o, h);
    }
    function _h(o, a) {
      o.lanes = Gt(o.lanes, a);
      var h = o.alternate;
      h !== null && (h.lanes = Gt(h.lanes, a)), h === null && (o.flags & (UA | Jt)) !== gA && TM(o);
      for (var w = o, R = o.return; R !== null; )
        R.childLanes = Gt(R.childLanes, a), h = R.alternate, h !== null ? h.childLanes = Gt(h.childLanes, a) : (R.flags & (UA | Jt)) !== gA && TM(o), w = R, R = R.return;
      if (w.tag === x) {
        var L = w.stateNode;
        return L;
      } else
        return null;
    }
    function yM(o, a) {
      return (
        // TODO: Optimize slightly by comparing to root that fiber belongs to.
        // Requires some refactoring. Not a big deal though since it's rare for
        // concurrent apps to have more than a single root.
        Lg !== null && (o.mode & si) !== Ct && // If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),
        // then don't treat this as an interleaved update. This pattern is
        // accompanied by a warning but we haven't fully deprecated it yet. We can
        // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.
        (bt & xg) === Hn
      );
    }
    function dr(o, a) {
      var h = o.callbackNode;
      Su(o, a);
      var w = bB(o, o === Lg ? jn : De);
      if (w === De) {
        h !== null && bM(h), o.callbackNode = null, o.callbackPriority = nn;
        return;
      }
      var R = Bo(w), L = o.callbackPriority;
      if (L === R && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(es.current !== null && h !== LD)) {
        h == null && L !== Lt && I("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      h != null && bM(h);
      var W;
      if (R === Lt)
        o.tag === qo ? (es.isBatchingLegacy !== null && (es.didScheduleLegacyUpdate = !0), xu(MM.bind(null, o))) : jo(MM.bind(null, o)), $t ? es.current !== null ? es.current.push(Qr) : XC(function() {
          bt === Hn && Qr();
        }) : Vh(ma, Qr), W = null;
      else {
        var nA;
        switch (sl(w)) {
          case Jr:
            nA = ma;
            break;
          case SI:
            nA = YB;
            break;
          case MI:
            nA = zo;
            break;
          case CQ:
            nA = RI;
            break;
          default:
            nA = zo;
            break;
        }
        W = Vh(nA, mM.bind(null, o));
      }
      o.callbackPriority = R, o.callbackNode = W;
    }
    function mM(o, a) {
      if (wx(), Vl = Si, Yh = De, (bt & (xg | ts)) !== Hn)
        throw new Error("Should not already be working.");
      var h = o.callbackNode, w = zs();
      if (w && o.callbackNode !== h)
        return null;
      var R = bB(o, o === Lg ? jn : De);
      if (R === De)
        return null;
      var L = !da(o, R) && !Mu(o, R) && !a, W = L ? mT(o, R) : Ph(o, R);
      if (W !== La) {
        if (W === iC) {
          var nA = oQ(o);
          nA !== De && (R = nA, W = GD(o, nA));
        }
        if (W === _l) {
          var sA = Ol;
          throw gC(o, De), PI(o, R), dr(o, on()), sA;
        }
        if (W === mD)
          PI(o, R);
        else {
          var pA = !da(o, R), LA = o.current.alternate;
          if (pA && !QT(LA)) {
            if (W = Ph(o, R), W === iC) {
              var VA = oQ(o);
              VA !== De && (R = VA, W = GD(o, VA));
            }
            if (W === _l) {
              var oe = Ol;
              throw gC(o, De), PI(o, R), dr(o, on()), oe;
            }
          }
          o.finishedWork = LA, o.finishedLanes = R, CT(o, W, R);
        }
      }
      return dr(o, on()), o.callbackNode === h ? mM.bind(null, o) : null;
    }
    function GD(o, a) {
      var h = Pl;
      if (Ys(o)) {
        var w = gC(o, a);
        w.flags |= he, Ig(o.containerInfo);
      }
      var R = Ph(o, a);
      if (R !== iC) {
        var L = hr;
        hr = h, L !== null && SM(L);
      }
      return R;
    }
    function SM(o) {
      hr === null ? hr = o : hr.push.apply(hr, o);
    }
    function CT(o, a, h) {
      switch (a) {
        case La:
        case _l:
          throw new Error("Root did not complete. This is a bug in React.");
        case iC: {
          rC(o, hr);
          break;
        }
        case xh: {
          if (PI(o, h), il(h) && // do not delay if we're inside an act() scope
          !YM()) {
            var w = MD + pM - on();
            if (w > 10) {
              var R = bB(o, De);
              if (R !== De)
                break;
              var L = o.suspendedLanes;
              if (!yI(L, h)) {
                Xg(), Gu(o, L);
                break;
              }
              o.timeoutHandle = iI(rC.bind(null, o, hr), w);
              break;
            }
          }
          rC(o, hr);
          break;
        }
        case Jl: {
          if (PI(o, h), aQ(h))
            break;
          if (!YM()) {
            var W = yu(o, h), nA = W, sA = on() - nA, pA = LT(sA) - sA;
            if (pA > 10) {
              o.timeoutHandle = iI(rC.bind(null, o, hr), pA);
              break;
            }
          }
          rC(o, hr);
          break;
        }
        case fM: {
          rC(o, hr);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function QT(o) {
      for (var a = o; ; ) {
        if (a.flags & Ri) {
          var h = a.updateQueue;
          if (h !== null) {
            var w = h.stores;
            if (w !== null)
              for (var R = 0; R < w.length; R++) {
                var L = w[R], W = L.getSnapshot, nA = L.value;
                try {
                  if (!Vg(W(), nA))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var sA = a.child;
        if (a.subtreeFlags & Ri && sA !== null) {
          sA.return = a, a = sA;
          continue;
        }
        if (a === o)
          return !0;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === o)
            return !0;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
      return !0;
    }
    function PI(o, a) {
      a = fa(a, Th), a = fa(a, ql), Fu(o, a);
    }
    function MM(o) {
      if (yx(), (bt & (xg | ts)) !== Hn)
        throw new Error("Should not already be working.");
      zs();
      var a = bB(o, De);
      if (!rn(a, Lt))
        return dr(o, on()), null;
      var h = Ph(o, a);
      if (o.tag !== qo && h === iC) {
        var w = oQ(o);
        w !== De && (a = w, h = GD(o, w));
      }
      if (h === _l) {
        var R = Ol;
        throw gC(o, De), PI(o, a), dr(o, on()), R;
      }
      if (h === mD)
        throw new Error("Root did not complete. This is a bug in React.");
      var L = o.current.alternate;
      return o.finishedWork = L, o.finishedLanes = a, rC(o, hr), dr(o, on()), null;
    }
    function ET(o, a) {
      a !== De && (wa(o, Gt(a, Lt)), dr(o, on()), (bt & (xg | ts)) === Hn && (xQ(), Qr()));
    }
    function lT(o) {
      var a = Wg(), h = Bn.transition;
      try {
        return Bn.transition = null, Un(MI), o();
      } finally {
        Un(a), Bn.transition = h;
      }
    }
    function cT(o, a) {
      var h = bt;
      bt |= yD;
      try {
        return o(a);
      } finally {
        bt = h, bt === Hn && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !es.isBatchingLegacy && (xQ(), hl());
      }
    }
    function uT(o, a, h, w, R) {
      var L = Wg(), W = Bn.transition;
      try {
        return Bn.transition = null, Un(Jr), o(a, h, w, R);
      } finally {
        Un(L), Bn.transition = W, bt === Hn && xQ();
      }
    }
    function Jh(o) {
      Ta !== null && Ta.tag === qo && (bt & (xg | ts)) === Hn && zs();
      var a = bt;
      bt |= yD;
      var h = Bn.transition, w = Wg();
      try {
        return Bn.transition = null, Un(Jr), o ? o() : void 0;
      } finally {
        Un(w), Bn.transition = h, bt = a, (bt & (xg | ts)) === Hn && Qr();
      }
    }
    function hT() {
      return (bt & (xg | ts)) !== Hn;
    }
    function dT(o) {
      var a = bt;
      bt |= yD;
      var h = Bn.transition, w = Wg();
      try {
        Bn.transition = null, Un(Jr), o();
      } finally {
        Un(w), Bn.transition = h, bt = a, bt === Hn && (xQ(), Qr());
      }
    }
    function Oh(o, a) {
      Ci(SD, Ws, o), Ws = Gt(Ws, a);
    }
    function vD(o) {
      Ws = SD.current, ji(SD, o);
    }
    function gC(o, a) {
      o.finishedWork = null, o.finishedLanes = De;
      var h = o.timeoutHandle;
      if (h !== fs && (o.timeoutHandle = fs, ro(h)), Cn !== null)
        for (var w = Cn.return; w !== null; ) {
          var R = w.alternate;
          jS(R, w), w = w.return;
        }
      Lg = o;
      var L = oC(o.current, null);
      return Cn = L, jn = Ws = a, Zn = La, Ol = null, Lh = De, ql = De, Th = De, Pl = null, hr = null, wi(), Er.discardPendingWarnings(), L;
    }
    function RM(o, a) {
      do {
        var h = Cn;
        try {
          if (l(), Vm(), Wn(), wD.current = null, h === null || h.return === null) {
            Zn = _l, Ol = a, Cn = null;
            return;
          }
          if (N && h.mode & zt && Eh(h, !0), m)
            if (Vo(), a !== null && typeof a == "object" && typeof a.then == "function") {
              var w = a;
              cQ(h, w, jn);
            } else
              Ts(h, a, jn);
          Nx(o, h.return, h, a, jn), vM(h);
        } catch (R) {
          a = R, Cn === h && h !== null ? (h = h.return, Cn = h) : h = Cn;
          continue;
        }
        return;
      } while (!0);
    }
    function NM() {
      var o = DD.current;
      return DD.current = ah, o === null ? ah : o;
    }
    function FM(o) {
      DD.current = o;
    }
    function fT() {
      MD = on();
    }
    function qh(o) {
      Lh = Gt(o, Lh);
    }
    function pT() {
      Zn === La && (Zn = xh);
    }
    function UD() {
      (Zn === La || Zn === xh || Zn === iC) && (Zn = Jl), Lg !== null && (sQ(Lh) || sQ(ql)) && PI(Lg, jn);
    }
    function DT(o) {
      Zn !== Jl && (Zn = iC), Pl === null ? Pl = [o] : Pl.push(o);
    }
    function wT() {
      return Zn === La;
    }
    function Ph(o, a) {
      var h = bt;
      bt |= xg;
      var w = NM();
      if (Lg !== o || jn !== a) {
        if (Rg) {
          var R = o.memoizedUpdaters;
          R.size > 0 && (jl(o, jn), R.clear()), rl(o, a);
        }
        gC(o, a);
      }
      OB(a);
      do
        try {
          yT();
          break;
        } catch (L) {
          RM(o, L);
        }
      while (!0);
      if (l(), bt = h, FM(w), Cn !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return ng(), Lg = null, jn = De, Zn;
    }
    function yT() {
      for (; Cn !== null; )
        GM(Cn);
    }
    function mT(o, a) {
      var h = bt;
      bt |= xg;
      var w = NM();
      if (Lg !== o || jn !== a) {
        if (Rg) {
          var R = o.memoizedUpdaters;
          R.size > 0 && (jl(o, jn), R.clear()), rl(o, a);
        }
        xQ(), gC(o, a);
      }
      OB(a);
      do
        try {
          ST();
          break;
        } catch (L) {
          RM(o, L);
        }
      while (!0);
      return l(), FM(w), bt = h, Cn !== null ? (hQ(), La) : (ng(), Lg = null, jn = De, Zn);
    }
    function ST() {
      for (; Cn !== null && !ku(); )
        GM(Cn);
    }
    function GM(o) {
      var a = o.alternate;
      ai(o);
      var h;
      (o.mode & zt) !== Ct ? (Vp(o), h = kD(a, o, Ws), Eh(o, !0)) : h = kD(a, o, Ws), Wn(), o.memoizedProps = o.pendingProps, h === null ? vM(o) : Cn = h, wD.current = null;
    }
    function vM(o) {
      var a = o;
      do {
        var h = a.alternate, w = a.return;
        if ((a.flags & se) === gA) {
          ai(a);
          var R = void 0;
          if ((a.mode & zt) === Ct ? R = NS(h, a, Ws) : (Vp(a), R = NS(h, a, Ws), Eh(a, !1)), Wn(), R !== null) {
            Cn = R;
            return;
          }
        } else {
          var L = tL(h, a);
          if (L !== null) {
            L.flags &= jA, Cn = L;
            return;
          }
          if ((a.mode & zt) !== Ct) {
            Eh(a, !1);
            for (var W = a.actualDuration, nA = a.child; nA !== null; )
              W += nA.actualDuration, nA = nA.sibling;
            a.actualDuration = W;
          }
          if (w !== null)
            w.flags |= se, w.subtreeFlags = gA, w.deletions = null;
          else {
            Zn = mD, Cn = null;
            return;
          }
        }
        var sA = a.sibling;
        if (sA !== null) {
          Cn = sA;
          return;
        }
        a = w, Cn = a;
      } while (a !== null);
      Zn === La && (Zn = fM);
    }
    function rC(o, a) {
      var h = Wg(), w = Bn.transition;
      try {
        Bn.transition = null, Un(Jr), MT(o, a, h);
      } finally {
        Bn.transition = w, Un(h);
      }
      return null;
    }
    function MT(o, a, h) {
      do
        zs();
      while (Ta !== null);
      if (KT(), (bt & (xg | ts)) !== Hn)
        throw new Error("Should not already be working.");
      var w = o.finishedWork, R = o.finishedLanes;
      if (kn(R), w === null)
        return FI(), null;
      if (R === De && I("root.finishedLanes should not be empty during a commit. This is a bug in React."), o.finishedWork = null, o.finishedLanes = De, w === o.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      o.callbackNode = null, o.callbackPriority = nn;
      var L = Gt(w.lanes, w.childLanes);
      Da(o, L), o === Lg && (Lg = null, Cn = null, jn = De), ((w.subtreeFlags & Li) !== gA || (w.flags & Li) !== gA) && (nC || (nC = !0, Vh(zo, function() {
        return zs(), null;
      })));
      var W = (w.subtreeFlags & (tt | Ft | ui | Li)) !== gA, nA = (w.flags & (tt | Ft | ui | Li)) !== gA;
      if (W || nA) {
        var sA = Bn.transition;
        Bn.transition = null;
        var pA = Wg();
        Un(Jr);
        var LA = bt;
        bt |= ts, wD.current = null, aL(o, w), fS(), mL(o, w, R), ZC(o.containerInfo), o.current = w, Ks(R), NL(w, o, R), uQ(), EQ(), bt = LA, Un(pA), Bn.transition = sA;
      } else
        o.current = w, fS();
      var VA = nC;
      if (nC && (nC = !1, Ta = o, Wl = R), L = o.pendingLanes, L === De && (LQ = null), VA || LM(o.current, !1), Tt(w.stateNode, h), Rg && o.memoizedUpdaters.clear(), tT(), dr(o, on()), a !== null)
        for (var oe = o.onRecoverableError, Qe = 0; Qe < a.length; Qe++) {
          var me = a[Qe];
          oe(me);
        }
      if (Kh) {
        Kh = !1;
        var Ne = RD;
        throw RD = null, Ne;
      }
      return rn(Wl, Lt) && o.tag !== qo && zs(), L = o.pendingLanes, rn(L, Lt) ? (Dx(), o === FD ? zl++ : (zl = 0, FD = o)) : zl = 0, Qr(), FI(), null;
    }
    function zs() {
      if (Ta !== null) {
        var o = sl(Wl), a = zf(MI, o), h = Bn.transition, w = Wg();
        try {
          return Bn.transition = null, Un(a), NT();
        } finally {
          Un(w), Bn.transition = h;
        }
      }
      return !1;
    }
    function RT(o) {
      ND.push(o), nC || (nC = !0, Vh(zo, function() {
        return zs(), null;
      }));
    }
    function NT() {
      if (Ta === null)
        return !1;
      var o = Ta, a = Wl;
      if (Ta = null, Wl = De, (bt & (xg | ts)) !== Hn)
        throw new Error("Cannot flush passive effects while already rendering.");
      JB(a);
      var h = bt;
      bt |= ts, LL(o.current), vL(o, o.current);
      {
        var w = ND;
        ND = [];
        for (var R = 0; R < w.length; R++) {
          var L = w[R];
          QL(o, L);
        }
      }
      cl(), LM(o.current, !0), bt = h, Qr(), bh = Ta === null ? 0 : bh + 1, pn(o);
      {
        var W = o.current.stateNode;
        W.effectDuration = 0, W.passiveEffectDuration = 0;
      }
      return !0;
    }
    function UM(o) {
      return LQ !== null && LQ.has(o);
    }
    function FT(o) {
      LQ === null ? LQ = /* @__PURE__ */ new Set([o]) : LQ.add(o);
    }
    function GT(o) {
      Kh || (Kh = !0, RD = o);
    }
    var vT = GT;
    function kM(o, a, h) {
      var w = lh(h, a), R = DS(o, w, Lt);
      Kt(o, R);
      var L = Xg(), W = _h(o, Lt);
      W !== null && (pa(W, Lt, L), dr(W, L));
    }
    function cg(o, a, h) {
      if (o.tag === x) {
        kM(o, o, h);
        return;
      }
      var w = null;
      for (w = a; w !== null; ) {
        if (w.tag === x) {
          kM(w, o, h);
          return;
        } else if (w.tag === k) {
          var R = w.type, L = w.stateNode;
          if (typeof R.getDerivedStateFromError == "function" || typeof L.componentDidCatch == "function" && !UM(L)) {
            var W = lh(h, o), nA = AD(w, W, Lt);
            Kt(w, nA);
            var sA = Xg(), pA = _h(w, Lt);
            pA !== null && (pa(pA, Lt, sA), dr(pA, sA));
            return;
          }
        }
        w = w.return;
      }
      I(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, h);
    }
    function UT(o, a, h) {
      var w = o.pingCache;
      w !== null && w.delete(a);
      var R = Xg();
      Gu(o, h), _T(o), Lg === o && yI(jn, h) && (Zn === Jl || Zn === xh && il(jn) && on() - MD < pM ? gC(o, De) : Th = Gt(Th, h)), dr(o, R);
    }
    function xM(o, a) {
      a === nn && (a = IT(o));
      var h = Xg(), w = _h(o, a);
      w !== null && (pa(w, a, h), dr(w, h));
    }
    function kT(o) {
      var a = o.memoizedState, h = nn;
      a !== null && (h = a.retryLane), xM(o, h);
    }
    function xT(o, a) {
      var h = nn, w;
      switch (o.tag) {
        case tA:
          w = o.stateNode;
          var R = o.memoizedState;
          R !== null && (h = R.retryLane);
          break;
        case hA:
          w = o.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      w !== null && w.delete(a), xM(o, h);
    }
    function LT(o) {
      return o < 120 ? 120 : o < 480 ? 480 : o < 1080 ? 1080 : o < 1920 ? 1920 : o < 3e3 ? 3e3 : o < 4320 ? 4320 : rT(o / 1960) * 1960;
    }
    function TT() {
      if (zl > sT)
        throw zl = 0, FD = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      bh > aT && (bh = 0, I("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function KT() {
      Er.flushLegacyContextWarning(), Er.flushPendingUnsafeLifecycleWarnings();
    }
    function LM(o, a) {
      ai(o), Wh(o, Bt, qL), a && Wh(o, ft, PL), Wh(o, Bt, JL), a && Wh(o, ft, OL), Wn();
    }
    function Wh(o, a, h) {
      for (var w = o, R = null; w !== null; ) {
        var L = w.subtreeFlags & a;
        w !== R && w.child !== null && L !== gA ? w = w.child : ((w.flags & a) !== gA && h(w), w.sibling !== null ? w = w.sibling : w = R = w.return);
      }
    }
    var zh = null;
    function TM(o) {
      {
        if ((bt & xg) !== Hn || !(o.mode & si))
          return;
        var a = o.tag;
        if (a !== v && a !== x && a !== k && a !== G && a !== P && a !== Y && a !== rA)
          return;
        var h = xA(o) || "ReactComponent";
        if (zh !== null) {
          if (zh.has(h))
            return;
          zh.add(h);
        } else
          zh = /* @__PURE__ */ new Set([h]);
        var w = jg;
        try {
          ai(o), I("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          w ? ai(o) : Wn();
        }
      }
    }
    var kD;
    {
      var bT = null;
      kD = function(o, a, h) {
        var w = qM(bT, a);
        try {
          return VS(o, a, h);
        } catch (L) {
          if (L !== null && typeof L == "object" && typeof L.then == "function")
            throw L;
          if (l(), Vm(), jS(o, a), qM(a, w), a.mode & zt && Vp(a), $S(null, VS, null, o, a, h), gL()) {
            var R = AM();
            typeof R == "object" && R !== null && R._suppressLogging && typeof L == "object" && L !== null && !L._suppressLogging && (L._suppressLogging = !0);
          }
          throw L;
        }
      };
    }
    var KM = !1, xD;
    xD = /* @__PURE__ */ new Set();
    function YT(o) {
      if (qr && !dx())
        switch (o.tag) {
          case G:
          case P:
          case rA: {
            var a = Cn && xA(Cn) || "Unknown", h = a;
            if (!xD.has(h)) {
              xD.add(h);
              var w = xA(o) || "Unknown";
              I("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", w, a, a);
            }
            break;
          }
          case k: {
            KM || (I("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), KM = !0);
            break;
          }
        }
    }
    function jl(o, a) {
      if (Rg) {
        var h = o.memoizedUpdaters;
        h.forEach(function(w) {
          gl(o, w, a);
        });
      }
    }
    var LD = {};
    function Vh(o, a) {
      {
        var h = es.current;
        return h !== null ? (h.push(a), LD) : al(o, a);
      }
    }
    function bM(o) {
      if (o !== LD)
        return Uu(o);
    }
    function YM() {
      return es.current !== null;
    }
    function HT(o) {
      {
        if (o.mode & si) {
          if (!dM())
            return;
        } else if (!gT() || bt !== Hn || o.tag !== G && o.tag !== P && o.tag !== rA)
          return;
        if (es.current === null) {
          var a = jg;
          try {
            ai(o), I(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, xA(o));
          } finally {
            a ? ai(o) : Wn();
          }
        }
      }
    }
    function _T(o) {
      o.tag !== qo && dM() && es.current === null && I(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    var wo = null, TQ = null, JT = function(o) {
      wo = o;
    };
    function KQ(o) {
      {
        if (wo === null)
          return o;
        var a = wo(o);
        return a === void 0 ? o : a.current;
      }
    }
    function TD(o) {
      return KQ(o);
    }
    function KD(o) {
      {
        if (wo === null)
          return o;
        var a = wo(o);
        if (a === void 0) {
          if (o != null && typeof o.render == "function") {
            var h = KQ(o.render);
            if (o.render !== h) {
              var w = {
                $$typeof: ie,
                render: h
              };
              return o.displayName !== void 0 && (w.displayName = o.displayName), w;
            }
          }
          return o;
        }
        return a.current;
      }
    }
    function HM(o, a) {
      {
        if (wo === null)
          return !1;
        var h = o.elementType, w = a.type, R = !1, L = typeof w == "object" && w !== null ? w.$$typeof : null;
        switch (o.tag) {
          case k: {
            typeof w == "function" && (R = !0);
            break;
          }
          case G: {
            (typeof w == "function" || L === q) && (R = !0);
            break;
          }
          case P: {
            (L === ie || L === q) && (R = !0);
            break;
          }
          case Y:
          case rA: {
            (L === AA || L === q) && (R = !0);
            break;
          }
          default:
            return !1;
        }
        if (R) {
          var W = wo(h);
          if (W !== void 0 && W === wo(w))
            return !0;
        }
        return !1;
      }
    }
    function _M(o) {
      {
        if (wo === null || typeof WeakSet != "function")
          return;
        TQ === null && (TQ = /* @__PURE__ */ new WeakSet()), TQ.add(o);
      }
    }
    var OT = function(o, a) {
      {
        if (wo === null)
          return;
        var h = a.staleFamilies, w = a.updatedFamilies;
        zs(), Jh(function() {
          bD(o.current, w, h);
        });
      }
    }, qT = function(o, a) {
      {
        if (o.context !== qt)
          return;
        zs(), Jh(function() {
          zM(a, o, null, null);
        });
      }
    };
    function bD(o, a, h) {
      {
        var w = o.alternate, R = o.child, L = o.sibling, W = o.tag, nA = o.type, sA = null;
        switch (W) {
          case G:
          case rA:
          case k:
            sA = nA;
            break;
          case P:
            sA = nA.render;
            break;
        }
        if (wo === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var pA = !1, LA = !1;
        if (sA !== null) {
          var VA = wo(sA);
          VA !== void 0 && (h.has(VA) ? LA = !0 : a.has(VA) && (W === k ? LA = !0 : pA = !0));
        }
        TQ !== null && (TQ.has(o) || w !== null && TQ.has(w)) && (LA = !0), LA && (o._debugNeedsRemount = !0), (LA || pA) && Xn(o, Lt, Si), R !== null && !LA && bD(R, a, h), L !== null && bD(L, a, h);
      }
    }
    var PT = function(o, a) {
      {
        var h = /* @__PURE__ */ new Set(), w = new Set(a.map(function(R) {
          return R.current;
        }));
        return YD(o.current, w, h), h;
      }
    };
    function YD(o, a, h) {
      {
        var w = o.child, R = o.sibling, L = o.tag, W = o.type, nA = null;
        switch (L) {
          case G:
          case rA:
          case k:
            nA = W;
            break;
          case P:
            nA = W.render;
            break;
        }
        var sA = !1;
        nA !== null && a.has(nA) && (sA = !0), sA ? WT(o, h) : w !== null && YD(w, a, h), R !== null && YD(R, a, h);
      }
    }
    function WT(o, a) {
      {
        var h = zT(o, a);
        if (h)
          return;
        for (var w = o; ; ) {
          switch (w.tag) {
            case _:
              a.add(w.stateNode);
              return;
            case H:
              a.add(w.stateNode.containerInfo);
              return;
            case x:
              a.add(w.stateNode.containerInfo);
              return;
          }
          if (w.return === null)
            throw new Error("Expected to reach root first.");
          w = w.return;
        }
      }
    }
    function zT(o, a) {
      for (var h = o, w = !1; ; ) {
        if (h.tag === _)
          w = !0, a.add(h.stateNode);
        else if (h.child !== null) {
          h.child.return = h, h = h.child;
          continue;
        }
        if (h === o)
          return w;
        for (; h.sibling === null; ) {
          if (h.return === null || h.return === o)
            return w;
          h = h.return;
        }
        h.sibling.return = h.return, h = h.sibling;
      }
      return !1;
    }
    var HD;
    {
      HD = !1;
      try {
        var JM = Object.preventExtensions({});
      } catch {
        HD = !0;
      }
    }
    function VT(o, a, h, w) {
      this.tag = o, this.key = h, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = a, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = w, this.flags = gA, this.subtreeFlags = gA, this.deletions = null, this.lanes = De, this.childLanes = De, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !HD && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Pr = function(o, a, h, w) {
      return new VT(o, a, h, w);
    };
    function _D(o) {
      var a = o.prototype;
      return !!(a && a.isReactComponent);
    }
    function jT(o) {
      return typeof o == "function" && !_D(o) && o.defaultProps === void 0;
    }
    function ZT(o) {
      if (typeof o == "function")
        return _D(o) ? k : G;
      if (o != null) {
        var a = o.$$typeof;
        if (a === ie)
          return P;
        if (a === AA)
          return Y;
      }
      return v;
    }
    function oC(o, a) {
      var h = o.alternate;
      h === null ? (h = Pr(o.tag, a, o.key, o.mode), h.elementType = o.elementType, h.type = o.type, h.stateNode = o.stateNode, h._debugSource = o._debugSource, h._debugOwner = o._debugOwner, h._debugHookTypes = o._debugHookTypes, h.alternate = o, o.alternate = h) : (h.pendingProps = a, h.type = o.type, h.flags = gA, h.subtreeFlags = gA, h.deletions = null, h.actualDuration = 0, h.actualStartTime = -1), h.flags = o.flags & $i, h.childLanes = o.childLanes, h.lanes = o.lanes, h.child = o.child, h.memoizedProps = o.memoizedProps, h.memoizedState = o.memoizedState, h.updateQueue = o.updateQueue;
      var w = o.dependencies;
      switch (h.dependencies = w === null ? null : {
        lanes: w.lanes,
        firstContext: w.firstContext
      }, h.sibling = o.sibling, h.index = o.index, h.ref = o.ref, h.selfBaseDuration = o.selfBaseDuration, h.treeBaseDuration = o.treeBaseDuration, h._debugNeedsRemount = o._debugNeedsRemount, h.tag) {
        case v:
        case G:
        case rA:
          h.type = KQ(o.type);
          break;
        case k:
          h.type = TD(o.type);
          break;
        case P:
          h.type = KD(o.type);
          break;
      }
      return h;
    }
    function XT(o, a) {
      o.flags &= $i | UA;
      var h = o.alternate;
      if (h === null)
        o.childLanes = De, o.lanes = a, o.child = null, o.subtreeFlags = gA, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null, o.selfBaseDuration = 0, o.treeBaseDuration = 0;
      else {
        o.childLanes = h.childLanes, o.lanes = h.lanes, o.child = h.child, o.subtreeFlags = gA, o.deletions = null, o.memoizedProps = h.memoizedProps, o.memoizedState = h.memoizedState, o.updateQueue = h.updateQueue, o.type = h.type;
        var w = h.dependencies;
        o.dependencies = w === null ? null : {
          lanes: w.lanes,
          firstContext: w.firstContext
        }, o.selfBaseDuration = h.selfBaseDuration, o.treeBaseDuration = h.treeBaseDuration;
      }
      return o;
    }
    function $T(o, a, h) {
      var w;
      return o === TB ? (w = si, a === !0 && (w |= Ki, w |= Sg)) : w = Ct, Rg && (w |= zt), Pr(x, null, null, w);
    }
    function JD(o, a, h, w, R, L) {
      var W = v, nA = o;
      if (typeof o == "function")
        _D(o) ? (W = k, nA = TD(nA)) : nA = KQ(nA);
      else if (typeof o == "string")
        W = _;
      else
        A:
          switch (o) {
            case JA:
              return WI(h.children, R, L, a);
            case ne:
              W = iA, R |= Ki, (R & si) !== Ct && (R |= Sg);
              break;
            case ee:
              return AK(h, R, L, a);
            case de:
              return eK(h, R, L, a);
            case O:
              return tK(h, R, L, a);
            case BA:
              return OM(h, R, L, a);
            case GA:
            case Z:
            case bA:
            case DA:
            case $:
            default: {
              if (typeof o == "object" && o !== null)
                switch (o.$$typeof) {
                  case pe:
                    W = oA;
                    break A;
                  case Ae:
                    W = eA;
                    break A;
                  case ie:
                    W = P, nA = KD(nA);
                    break A;
                  case AA:
                    W = Y;
                    break A;
                  case q:
                    W = QA, nA = null;
                    break A;
                }
              var sA = "";
              {
                (o === void 0 || typeof o == "object" && o !== null && Object.keys(o).length === 0) && (sA += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var pA = w ? xA(w) : null;
                pA && (sA += `

Check the render method of \`` + pA + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (o == null ? o : typeof o) + "." + sA));
            }
          }
      var LA = Pr(W, h, a, R);
      return LA.elementType = o, LA.type = nA, LA.lanes = L, LA._debugOwner = w, LA;
    }
    function OD(o, a, h) {
      var w = null;
      w = o._owner;
      var R = o.type, L = o.key, W = o.props, nA = JD(R, L, W, w, a, h);
      return nA._debugSource = o._source, nA._debugOwner = o._owner, nA;
    }
    function WI(o, a, h, w) {
      var R = Pr(V, o, w, a);
      return R.lanes = h, R;
    }
    function AK(o, a, h, w) {
      typeof o.id != "string" && I('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof o.id);
      var R = Pr(J, o, w, a | zt);
      return R.elementType = ee, R.lanes = h, R.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, R;
    }
    function eK(o, a, h, w) {
      var R = Pr(tA, o, w, a);
      return R.elementType = de, R.lanes = h, R;
    }
    function tK(o, a, h, w) {
      var R = Pr(hA, o, w, a);
      return R.elementType = O, R.lanes = h, R;
    }
    function OM(o, a, h, w) {
      var R = Pr(wA, o, w, a);
      R.elementType = BA, R.lanes = h;
      var L = {};
      return R.stateNode = L, R;
    }
    function qD(o, a, h) {
      var w = Pr(j, o, null, a);
      return w.lanes = h, w;
    }
    function iK() {
      var o = Pr(_, null, null, Ct);
      return o.elementType = "DELETED", o;
    }
    function nK(o) {
      var a = Pr(MA, null, null, Ct);
      return a.stateNode = o, a;
    }
    function PD(o, a, h) {
      var w = o.children !== null ? o.children : [], R = Pr(H, w, o.key, a);
      return R.lanes = h, R.stateNode = {
        containerInfo: o.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: o.implementation
      }, R;
    }
    function qM(o, a) {
      return o === null && (o = Pr(v, null, null, Ct)), o.tag = a.tag, o.key = a.key, o.elementType = a.elementType, o.type = a.type, o.stateNode = a.stateNode, o.return = a.return, o.child = a.child, o.sibling = a.sibling, o.index = a.index, o.ref = a.ref, o.pendingProps = a.pendingProps, o.memoizedProps = a.memoizedProps, o.updateQueue = a.updateQueue, o.memoizedState = a.memoizedState, o.dependencies = a.dependencies, o.mode = a.mode, o.flags = a.flags, o.subtreeFlags = a.subtreeFlags, o.deletions = a.deletions, o.lanes = a.lanes, o.childLanes = a.childLanes, o.alternate = a.alternate, o.actualDuration = a.actualDuration, o.actualStartTime = a.actualStartTime, o.selfBaseDuration = a.selfBaseDuration, o.treeBaseDuration = a.treeBaseDuration, o._debugSource = a._debugSource, o._debugOwner = a._debugOwner, o._debugNeedsRemount = a._debugNeedsRemount, o._debugHookTypes = a._debugHookTypes, o;
    }
    function gK(o, a, h, w, R) {
      this.tag = a, this.containerInfo = o, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = fs, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = nn, this.eventTimes = mI(De), this.expirationTimes = mI(Si), this.pendingLanes = De, this.suspendedLanes = De, this.pingedLanes = De, this.expiredLanes = De, this.mutableReadLanes = De, this.finishedLanes = De, this.entangledLanes = De, this.entanglements = mI(De), this.identifierPrefix = w, this.onRecoverableError = R, fn && (this.mutableSourceEagerHydrationData = null), this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var L = this.pendingUpdatersLaneMap = [], W = 0; W < ha; W++)
          L.push(/* @__PURE__ */ new Set());
      }
      switch (a) {
        case TB:
          this._debugRootType = h ? "hydrateRoot()" : "createRoot()";
          break;
        case qo:
          this._debugRootType = h ? "hydrate()" : "render()";
          break;
      }
    }
    function PM(o, a, h, w, R, L, W, nA, sA, pA) {
      var LA = new gK(o, a, h, nA, sA), VA = $T(a, L);
      LA.current = VA, VA.stateNode = LA;
      {
        var oe = {
          element: w,
          isDehydrated: h,
          cache: null,
          // not enabled yet
          transitions: null
        };
        VA.memoizedState = oe;
      }
      return Ze(VA), LA;
    }
    var rK = "18.0.0-fc46dba67-20220329";
    function oK(o, a, h) {
      var w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Xf(w), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: vA,
        key: w == null ? null : "" + w,
        children: o,
        containerInfo: a,
        implementation: h
      };
    }
    var WD, zD;
    WD = !1, zD = {};
    function WM(o) {
      if (!o)
        return qt;
      var a = c(o), h = hI(a);
      if (a.tag === k) {
        var w = a.type;
        if (mg(w))
          return Pg(a, w, h);
      }
      return h;
    }
    function sK(o) {
      var a = c(o);
      if (a === void 0) {
        if (typeof o.render == "function")
          throw new Error("Unable to find node on an unmounted component.");
        var h = Object.keys(o).join(",");
        throw new Error("Argument appears to not be a ReactComponent. Keys: " + h);
      }
      var w = Nn(a);
      return w === null ? null : w.stateNode;
    }
    function aK(o, a) {
      {
        var h = c(o);
        if (h === void 0) {
          if (typeof o.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var w = Object.keys(o).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + w);
        }
        var R = Nn(h);
        if (R === null)
          return null;
        if (R.mode & Ki) {
          var L = xA(h) || "Component";
          if (!zD[L]) {
            zD[L] = !0;
            var W = jg;
            try {
              ai(R), h.mode & Ki ? I("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", a, a, L) : I("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", a, a, L);
            } finally {
              W ? ai(W) : Wn();
            }
          }
        }
        return R.stateNode;
      }
    }
    function IK(o, a, h, w, R, L, W, nA) {
      var sA = !1, pA = null;
      return PM(o, a, sA, pA, h, w, R, L, W);
    }
    function BK(o, a, h, w, R, L, W, nA, sA, pA) {
      var LA = !0, VA = PM(h, w, LA, o, R, L, W, nA, sA);
      VA.context = WM(null);
      var oe = VA.current, Qe = Xg(), me = qI(oe), Ne = at(Qe, me);
      return Ne.callback = a ?? null, Kt(oe, Ne), BT(VA, me, Qe), VA;
    }
    function zM(o, a, h, w) {
      sn(a, o);
      var R = a.current, L = Xg(), W = qI(R);
      bs(W);
      var nA = WM(h);
      a.context === null ? a.context = nA : a.pendingContext = nA, qr && jg !== null && !WD && (WD = !0, I(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, xA(jg) || "Unknown"));
      var sA = at(L, W);
      sA.payload = {
        element: o
      }, w = w === void 0 ? null : w, w !== null && (typeof w != "function" && I("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", w), sA.callback = w), Kt(R, sA);
      var pA = Xn(R, W, L);
      return pA !== null && an(pA, R, W), W;
    }
    function CK(o) {
      var a = o.current;
      if (!a.child)
        return null;
      switch (a.child.tag) {
        case _:
          return sg(a.child.stateNode);
        default:
          return a.child.stateNode;
      }
    }
    function QK(o) {
      switch (o.tag) {
        case x:
          var a = o.stateNode;
          if (Ys(a)) {
            var h = el(a);
            ET(a, h);
          }
          break;
        case tA:
          var w = Xg();
          Jh(function() {
            return Xn(o, Lt, w);
          });
          var R = Lt;
          VD(o, R);
          break;
      }
    }
    function VM(o, a) {
      var h = o.memoizedState;
      h !== null && h.dehydrated !== null && (h.retryLane = Je(h.retryLane, a));
    }
    function VD(o, a) {
      VM(o, a);
      var h = o.alternate;
      h && VM(h, a);
    }
    function EK(o) {
      if (o.tag === tA) {
        var a = Xg(), h = bi;
        Xn(o, h, a), VD(o, h);
      }
    }
    function lK(o) {
      if (o.tag === tA) {
        var a = Xg(), h = qI(o);
        Xn(o, h, a), VD(o, h);
      }
    }
    function cK(o) {
      var a = ot(o);
      return a === null ? null : a.stateNode;
    }
    var jM = function(o) {
      return null;
    };
    function ZM(o) {
      return jM(o);
    }
    var XM = function(o) {
      return !1;
    };
    function $M(o) {
      return XM(o);
    }
    var AR = null, eR = null, tR = null, iR = null, nR = null, gR = null, rR = null, oR = null, sR = null;
    {
      var aR = function(o, a, h) {
        var w = a[h], R = Mt(o) ? o.slice() : C({}, o);
        return h + 1 === a.length ? (Mt(R) ? R.splice(w, 1) : delete R[w], R) : (R[w] = aR(o[w], a, h + 1), R);
      }, IR = function(o, a) {
        return aR(o, a, 0);
      }, BR = function(o, a, h, w) {
        var R = a[w], L = Mt(o) ? o.slice() : C({}, o);
        if (w + 1 === a.length) {
          var W = h[w];
          L[W] = L[R], Mt(L) ? L.splice(R, 1) : delete L[R];
        } else
          L[R] = BR(
            // $FlowFixMe number or string is fine here
            o[R],
            a,
            h,
            w + 1
          );
        return L;
      }, CR = function(o, a, h) {
        if (a.length !== h.length) {
          B("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var w = 0; w < h.length - 1; w++)
            if (a[w] !== h[w]) {
              B("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return BR(o, a, h, 0);
      }, QR = function(o, a, h, w) {
        if (h >= a.length)
          return w;
        var R = a[h], L = Mt(o) ? o.slice() : C({}, o);
        return L[R] = QR(o[R], a, h + 1, w), L;
      }, ER = function(o, a, h) {
        return QR(o, a, 0, h);
      }, jD = function(o, a) {
        for (var h = o.memoizedState; h !== null && a > 0; )
          h = h.next, a--;
        return h;
      };
      AR = function(o, a, h, w) {
        var R = jD(o, a);
        if (R !== null) {
          var L = ER(R.memoizedState, h, w);
          R.memoizedState = L, R.baseState = L, o.memoizedProps = C({}, o.memoizedProps), Xn(o, Lt, Si);
        }
      }, eR = function(o, a, h) {
        var w = jD(o, a);
        if (w !== null) {
          var R = IR(w.memoizedState, h);
          w.memoizedState = R, w.baseState = R, o.memoizedProps = C({}, o.memoizedProps), Xn(o, Lt, Si);
        }
      }, tR = function(o, a, h, w) {
        var R = jD(o, a);
        if (R !== null) {
          var L = CR(R.memoizedState, h, w);
          R.memoizedState = L, R.baseState = L, o.memoizedProps = C({}, o.memoizedProps), Xn(o, Lt, Si);
        }
      }, iR = function(o, a, h) {
        o.pendingProps = ER(o.memoizedProps, a, h), o.alternate && (o.alternate.pendingProps = o.pendingProps), Xn(o, Lt, Si);
      }, nR = function(o, a) {
        o.pendingProps = IR(o.memoizedProps, a), o.alternate && (o.alternate.pendingProps = o.pendingProps), Xn(o, Lt, Si);
      }, gR = function(o, a, h) {
        o.pendingProps = CR(o.memoizedProps, a, h), o.alternate && (o.alternate.pendingProps = o.pendingProps), Xn(o, Lt, Si);
      }, rR = function(o) {
        Xn(o, Lt, Si);
      }, oR = function(o) {
        jM = o;
      }, sR = function(o) {
        XM = o;
      };
    }
    function uK(o) {
      var a = Nn(o);
      return a === null ? null : a.stateNode;
    }
    function hK(o) {
      return null;
    }
    function dK() {
      return jg;
    }
    function fK(o) {
      var a = o.findFiberByHostInstance, h = n.ReactCurrentDispatcher;
      return Cl({
        bundleType: o.bundleType,
        version: o.version,
        rendererPackageName: o.rendererPackageName,
        rendererConfig: o.rendererConfig,
        overrideHookState: AR,
        overrideHookStateDeletePath: eR,
        overrideHookStateRenamePath: tR,
        overrideProps: iR,
        overridePropsDeletePath: nR,
        overridePropsRenamePath: gR,
        setErrorHandler: oR,
        setSuspenseHandler: sR,
        scheduleUpdate: rR,
        currentDispatcherRef: h,
        findHostInstanceByFiber: uK,
        findFiberByHostInstance: a || hK,
        // React Refresh
        findHostInstancesForRefresh: PT,
        scheduleRefresh: OT,
        scheduleRoot: qT,
        setRefreshHandler: JT,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: dK,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: rK
      });
    }
    return e.attemptContinuousHydration = EK, e.attemptHydrationAtCurrentPriority = lK, e.attemptSynchronousHydration = QK, e.batchedUpdates = cT, e.createComponentSelector = WL, e.createContainer = IK, e.createHasPseudoClassSelector = zL, e.createHydrationContainer = BK, e.createPortal = oK, e.createRoleSelector = VL, e.createTestNameSelector = ZL, e.createTextSelector = jL, e.deferredUpdates = lT, e.discreteUpdates = uT, e.findAllNodes = Uh, e.findBoundingRects = AT, e.findHostInstance = sK, e.findHostInstanceWithNoPortals = cK, e.findHostInstanceWithWarning = aK, e.flushControlled = dT, e.flushPassiveEffects = zs, e.flushSync = Jh, e.focusWithin = eT, e.getCurrentUpdatePriority = Wg, e.getFindAllNodesFailureDescription = $L, e.getPublicRootInstance = CK, e.injectIntoDevTools = fK, e.isAlreadyRendering = hT, e.observeVisibleRects = iT, e.registerMutableSourceForHydration = Qx, e.runWithPriority = ol, e.shouldError = ZM, e.shouldSuspend = $M, e.updateContainer = zM, e;
  })), Qf;
}
(function(g) {
  process.env.NODE_ENV === "production" ? g.exports = E3() : g.exports = c3();
})(I3);
const u3 = /* @__PURE__ */ mU(jw);
var Ef = {}, h3 = {
  get exports() {
    return Ef;
  },
  set exports(g) {
    Ef = g;
  }
}, v0 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $N;
function d3() {
  return $N || ($N = 1, function(g) {
    function A(P, J) {
      var tA = P.length;
      P.push(J);
      A:
        for (; 0 < tA; ) {
          var Y = tA - 1 >>> 1, rA = P[Y];
          if (0 < i(rA, J))
            P[Y] = J, P[tA] = rA, tA = Y;
          else
            break A;
        }
    }
    function e(P) {
      return P.length === 0 ? null : P[0];
    }
    function t(P) {
      if (P.length === 0)
        return null;
      var J = P[0], tA = P.pop();
      if (tA !== J) {
        P[0] = tA;
        A:
          for (var Y = 0, rA = P.length, QA = rA >>> 1; Y < QA; ) {
            var aA = 2 * (Y + 1) - 1, MA = P[aA], hA = aA + 1, fA = P[hA];
            if (0 > i(MA, tA))
              hA < rA && 0 > i(fA, MA) ? (P[Y] = fA, P[hA] = tA, Y = hA) : (P[Y] = MA, P[aA] = tA, Y = aA);
            else if (hA < rA && 0 > i(fA, tA))
              P[Y] = fA, P[hA] = tA, Y = hA;
            else
              break A;
          }
      }
      return J;
    }
    function i(P, J) {
      var tA = P.sortIndex - J.sortIndex;
      return tA !== 0 ? tA : P.id - J.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var n = performance;
      g.unstable_now = function() {
        return n.now();
      };
    } else {
      var r = Date, s = r.now();
      g.unstable_now = function() {
        return r.now() - s;
      };
    }
    var B = [], I = [], E = 1, C = null, c = 3, u = !1, d = !1, p = !1, D = typeof setTimeout == "function" ? setTimeout : null, f = typeof clearTimeout == "function" ? clearTimeout : null, S = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function y(P) {
      for (var J = e(I); J !== null; ) {
        if (J.callback === null)
          t(I);
        else if (J.startTime <= P)
          t(I), J.sortIndex = J.expirationTime, A(B, J);
        else
          break;
        J = e(I);
      }
    }
    function m(P) {
      if (p = !1, y(P), !d)
        if (e(B) !== null)
          d = !0, eA(N);
        else {
          var J = e(I);
          J !== null && oA(m, J.startTime - P);
        }
    }
    function N(P, J) {
      d = !1, p && (p = !1, f(k), k = -1), u = !0;
      var tA = c;
      try {
        for (y(J), C = e(B); C !== null && (!(C.expirationTime > J) || P && !H()); ) {
          var Y = C.callback;
          if (typeof Y == "function") {
            C.callback = null, c = C.priorityLevel;
            var rA = Y(C.expirationTime <= J);
            J = g.unstable_now(), typeof rA == "function" ? C.callback = rA : C === e(B) && t(B), y(J);
          } else
            t(B);
          C = e(B);
        }
        if (C !== null)
          var QA = !0;
        else {
          var aA = e(I);
          aA !== null && oA(m, aA.startTime - J), QA = !1;
        }
        return QA;
      } finally {
        C = null, c = tA, u = !1;
      }
    }
    var F = !1, G = null, k = -1, v = 5, x = -1;
    function H() {
      return !(g.unstable_now() - x < v);
    }
    function _() {
      if (G !== null) {
        var P = g.unstable_now();
        x = P;
        var J = !0;
        try {
          J = G(!0, P);
        } finally {
          J ? j() : (F = !1, G = null);
        }
      } else
        F = !1;
    }
    var j;
    if (typeof S == "function")
      j = function() {
        S(_);
      };
    else if (typeof MessageChannel < "u") {
      var V = new MessageChannel(), iA = V.port2;
      V.port1.onmessage = _, j = function() {
        iA.postMessage(null);
      };
    } else
      j = function() {
        D(_, 0);
      };
    function eA(P) {
      G = P, F || (F = !0, j());
    }
    function oA(P, J) {
      k = D(function() {
        P(g.unstable_now());
      }, J);
    }
    g.unstable_IdlePriority = 5, g.unstable_ImmediatePriority = 1, g.unstable_LowPriority = 4, g.unstable_NormalPriority = 3, g.unstable_Profiling = null, g.unstable_UserBlockingPriority = 2, g.unstable_cancelCallback = function(P) {
      P.callback = null;
    }, g.unstable_continueExecution = function() {
      d || u || (d = !0, eA(N));
    }, g.unstable_forceFrameRate = function(P) {
      0 > P || 125 < P ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : v = 0 < P ? Math.floor(1e3 / P) : 5;
    }, g.unstable_getCurrentPriorityLevel = function() {
      return c;
    }, g.unstable_getFirstCallbackNode = function() {
      return e(B);
    }, g.unstable_next = function(P) {
      switch (c) {
        case 1:
        case 2:
        case 3:
          var J = 3;
          break;
        default:
          J = c;
      }
      var tA = c;
      c = J;
      try {
        return P();
      } finally {
        c = tA;
      }
    }, g.unstable_pauseExecution = function() {
    }, g.unstable_requestPaint = function() {
    }, g.unstable_runWithPriority = function(P, J) {
      switch (P) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          P = 3;
      }
      var tA = c;
      c = P;
      try {
        return J();
      } finally {
        c = tA;
      }
    }, g.unstable_scheduleCallback = function(P, J, tA) {
      var Y = g.unstable_now();
      switch (typeof tA == "object" && tA !== null ? (tA = tA.delay, tA = typeof tA == "number" && 0 < tA ? Y + tA : Y) : tA = Y, P) {
        case 1:
          var rA = -1;
          break;
        case 2:
          rA = 250;
          break;
        case 5:
          rA = 1073741823;
          break;
        case 4:
          rA = 1e4;
          break;
        default:
          rA = 5e3;
      }
      return rA = tA + rA, P = { id: E++, callback: J, priorityLevel: P, startTime: tA, expirationTime: rA, sortIndex: -1 }, tA > Y ? (P.sortIndex = tA, A(I, P), e(B) === null && P === e(I) && (p ? (f(k), k = -1) : p = !0, oA(m, tA - Y))) : (P.sortIndex = rA, A(B, P), d || u || (d = !0, eA(N))), P;
    }, g.unstable_shouldYield = H, g.unstable_wrapCallback = function(P) {
      var J = c;
      return function() {
        var tA = c;
        c = J;
        try {
          return P.apply(this, arguments);
        } finally {
          c = tA;
        }
      };
    };
  }(v0)), v0;
}
var U0 = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var AF;
function f3() {
  return AF || (AF = 1, function(g) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var A = !1, e = !1, t = 5;
      function i(EA, mA) {
        var YA = EA.length;
        EA.push(mA), s(EA, mA, YA);
      }
      function n(EA) {
        return EA.length === 0 ? null : EA[0];
      }
      function r(EA) {
        if (EA.length === 0)
          return null;
        var mA = EA[0], YA = EA.pop();
        return YA !== mA && (EA[0] = YA, B(EA, YA, 0)), mA;
      }
      function s(EA, mA, YA) {
        for (var ZA = YA; ZA > 0; ) {
          var _A = ZA - 1 >>> 1, Se = EA[_A];
          if (I(Se, mA) > 0)
            EA[_A] = mA, EA[ZA] = Se, ZA = _A;
          else
            return;
        }
      }
      function B(EA, mA, YA) {
        for (var ZA = YA, _A = EA.length, Se = _A >>> 1; ZA < Se; ) {
          var cA = (ZA + 1) * 2 - 1, xA = EA[cA], gA = cA + 1, RA = EA[gA];
          if (I(xA, mA) < 0)
            gA < _A && I(RA, xA) < 0 ? (EA[ZA] = RA, EA[gA] = mA, ZA = gA) : (EA[ZA] = xA, EA[cA] = mA, ZA = cA);
          else if (gA < _A && I(RA, mA) < 0)
            EA[ZA] = RA, EA[gA] = mA, ZA = gA;
          else
            return;
        }
      }
      function I(EA, mA) {
        var YA = EA.sortIndex - mA.sortIndex;
        return YA !== 0 ? YA : EA.id - mA.id;
      }
      var E = 1, C = 2, c = 3, u = 4, d = 5;
      function p(EA, mA) {
      }
      var D = typeof performance == "object" && typeof performance.now == "function";
      if (D) {
        var f = performance;
        g.unstable_now = function() {
          return f.now();
        };
      } else {
        var S = Date, y = S.now();
        g.unstable_now = function() {
          return S.now() - y;
        };
      }
      var m = 1073741823, N = -1, F = 250, G = 5e3, k = 1e4, v = m, x = [], H = [], _ = 1, j = null, V = c, iA = !1, eA = !1, oA = !1, P = typeof setTimeout == "function" ? setTimeout : null, J = typeof clearTimeout == "function" ? clearTimeout : null, tA = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function Y(EA) {
        for (var mA = n(H); mA !== null; ) {
          if (mA.callback === null)
            r(H);
          else if (mA.startTime <= EA)
            r(H), mA.sortIndex = mA.expirationTime, i(x, mA);
          else
            return;
          mA = n(H);
        }
      }
      function rA(EA) {
        if (oA = !1, Y(EA), !eA)
          if (n(x) !== null)
            eA = !0, BA(QA);
          else {
            var mA = n(H);
            mA !== null && GA(rA, mA.startTime - EA);
          }
      }
      function QA(EA, mA) {
        eA = !1, oA && (oA = !1, bA()), iA = !0;
        var YA = V;
        try {
          var ZA;
          if (!e)
            return aA(EA, mA);
        } finally {
          j = null, V = YA, iA = !1;
        }
      }
      function aA(EA, mA) {
        var YA = mA;
        for (Y(YA), j = n(x); j !== null && !A && !(j.expirationTime > YA && (!EA || ie())); ) {
          var ZA = j.callback;
          if (typeof ZA == "function") {
            j.callback = null, V = j.priorityLevel;
            var _A = j.expirationTime <= YA, Se = ZA(_A);
            YA = g.unstable_now(), typeof Se == "function" ? j.callback = Se : j === n(x) && r(x), Y(YA);
          } else
            r(x);
          j = n(x);
        }
        if (j !== null)
          return !0;
        var cA = n(H);
        return cA !== null && GA(rA, cA.startTime - YA), !1;
      }
      function MA(EA, mA) {
        switch (EA) {
          case E:
          case C:
          case c:
          case u:
          case d:
            break;
          default:
            EA = c;
        }
        var YA = V;
        V = EA;
        try {
          return mA();
        } finally {
          V = YA;
        }
      }
      function hA(EA) {
        var mA;
        switch (V) {
          case E:
          case C:
          case c:
            mA = c;
            break;
          default:
            mA = V;
            break;
        }
        var YA = V;
        V = mA;
        try {
          return EA();
        } finally {
          V = YA;
        }
      }
      function fA(EA) {
        var mA = V;
        return function() {
          var YA = V;
          V = mA;
          try {
            return EA.apply(this, arguments);
          } finally {
            V = YA;
          }
        };
      }
      function wA(EA, mA, YA) {
        var ZA = g.unstable_now(), _A;
        if (typeof YA == "object" && YA !== null) {
          var Se = YA.delay;
          typeof Se == "number" && Se > 0 ? _A = ZA + Se : _A = ZA;
        } else
          _A = ZA;
        var cA;
        switch (EA) {
          case E:
            cA = N;
            break;
          case C:
            cA = F;
            break;
          case d:
            cA = v;
            break;
          case u:
            cA = k;
            break;
          case c:
          default:
            cA = G;
            break;
        }
        var xA = _A + cA, gA = {
          id: _++,
          callback: mA,
          priorityLevel: EA,
          startTime: _A,
          expirationTime: xA,
          sortIndex: -1
        };
        return _A > ZA ? (gA.sortIndex = _A, i(H, gA), n(x) === null && gA === n(H) && (oA ? bA() : oA = !0, GA(rA, _A - ZA))) : (gA.sortIndex = xA, i(x, gA), !eA && !iA && (eA = !0, BA(QA))), gA;
      }
      function yA() {
      }
      function kA() {
        !eA && !iA && (eA = !0, BA(QA));
      }
      function FA() {
        return n(x);
      }
      function dA(EA) {
        EA.callback = null;
      }
      function vA() {
        return V;
      }
      var JA = !1, ne = null, ee = -1, pe = t, Ae = -1;
      function ie() {
        var EA = g.unstable_now() - Ae;
        return !(EA < pe);
      }
      function de() {
      }
      function O(EA) {
        if (EA < 0 || EA > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        EA > 0 ? pe = Math.floor(1e3 / EA) : pe = t;
      }
      var AA = function() {
        if (ne !== null) {
          var EA = g.unstable_now();
          Ae = EA;
          var mA = !0, YA = !0;
          try {
            YA = ne(mA, EA);
          } finally {
            YA ? q() : (JA = !1, ne = null);
          }
        } else
          JA = !1;
      }, q;
      if (typeof tA == "function")
        q = function() {
          tA(AA);
        };
      else if (typeof MessageChannel < "u") {
        var Z = new MessageChannel(), $ = Z.port2;
        Z.port1.onmessage = AA, q = function() {
          $.postMessage(null);
        };
      } else
        q = function() {
          P(AA, 0);
        };
      function BA(EA) {
        ne = EA, JA || (JA = !0, q());
      }
      function GA(EA, mA) {
        ee = P(function() {
          EA(g.unstable_now());
        }, mA);
      }
      function bA() {
        J(ee), ee = -1;
      }
      var DA = de, SA = null;
      g.unstable_IdlePriority = d, g.unstable_ImmediatePriority = E, g.unstable_LowPriority = u, g.unstable_NormalPriority = c, g.unstable_Profiling = SA, g.unstable_UserBlockingPriority = C, g.unstable_cancelCallback = dA, g.unstable_continueExecution = kA, g.unstable_forceFrameRate = O, g.unstable_getCurrentPriorityLevel = vA, g.unstable_getFirstCallbackNode = FA, g.unstable_next = hA, g.unstable_pauseExecution = yA, g.unstable_requestPaint = DA, g.unstable_runWithPriority = MA, g.unstable_scheduleCallback = wA, g.unstable_shouldYield = ie, g.unstable_wrapCallback = fA, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(U0)), U0;
}
(function(g) {
  process.env.NODE_ENV === "production" ? g.exports = d3() : g.exports = f3();
})(h3);
function RU(g, A, e = (t, i) => t === i) {
  if (g === A)
    return !0;
  if (!g || !A)
    return !1;
  const t = g.length;
  if (A.length !== t)
    return !1;
  for (let i = 0; i < t; i++)
    if (!e(g[i], A[i]))
      return !1;
  return !0;
}
const Pa = [];
function NU(g, A, e = !1, t = {}) {
  for (const n of Pa)
    if (RU(A, n.keys, n.equal)) {
      if (e)
        return;
      if (Object.prototype.hasOwnProperty.call(n, "error"))
        throw n.error;
      if (Object.prototype.hasOwnProperty.call(n, "response"))
        return n.response;
      if (!e)
        throw n.promise;
    }
  const i = {
    keys: A,
    equal: t.equal,
    promise: (
      // Execute the promise
      g(...A).then((n) => i.response = n).then(() => {
        t.lifespan && t.lifespan > 0 && setTimeout(() => {
          const n = Pa.indexOf(i);
          n !== -1 && Pa.splice(n, 1);
        }, t.lifespan);
      }).catch((n) => i.error = n)
    )
  };
  if (Pa.push(i), !e)
    throw i.promise;
}
const p3 = (g, A, e) => NU(g, A, !1, e), D3 = (g, A, e) => void NU(g, A, !0, e), w3 = (g) => {
  if (g === void 0 || g.length === 0)
    Pa.splice(0, Pa.length);
  else {
    const A = Pa.find((e) => RU(g, e.keys, e.equal));
    if (A) {
      const e = Pa.indexOf(A);
      e !== -1 && Pa.splice(e, 1);
    }
  }
}, rm = {}, om = (g) => void Object.assign(rm, g);
function y3(g, A) {
  function e(E, {
    args: C = [],
    attach: c,
    ...u
  }, d) {
    let p = `${E[0].toUpperCase()}${E.slice(1)}`, D;
    if (E === "primitive") {
      if (u.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const f = u.object;
      D = lE(f, {
        type: E,
        root: d,
        attach: c,
        primitive: !0
      });
    } else {
      const f = rm[p];
      if (!f)
        throw new Error(`R3F: ${p} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
      if (!Array.isArray(C))
        throw new Error("R3F: The args prop must be an array!");
      D = lE(new f(...C), {
        type: E,
        root: d,
        attach: c,
        // Save args in case we need to reconstruct later for HMR
        memoizedProps: {
          args: C
        }
      });
    }
    return D.__r3f.attach === void 0 && (D instanceof ut ? D.__r3f.attach = "geometry" : D instanceof Sn && (D.__r3f.attach = "material")), p !== "inject" && x0(D, u), D;
  }
  function t(E, C) {
    let c = !1;
    if (C) {
      var u, d;
      (u = C.__r3f) != null && u.attach ? k0(E, C, C.__r3f.attach) : C.isObject3D && E.isObject3D && (E.add(C), c = !0), c || (d = E.__r3f) == null || d.objects.push(C), C.__r3f || lE(C, {}), C.__r3f.parent = E, Xw(C), cE(C);
    }
  }
  function i(E, C, c) {
    let u = !1;
    if (C) {
      var d, p;
      if ((d = C.__r3f) != null && d.attach)
        k0(E, C, C.__r3f.attach);
      else if (C.isObject3D && E.isObject3D) {
        C.parent = E, C.dispatchEvent({
          type: "added"
        });
        const D = E.children.filter((S) => S !== C), f = D.indexOf(c);
        E.children = [...D.slice(0, f), C, ...D.slice(f)], u = !0;
      }
      u || (p = E.__r3f) == null || p.objects.push(C), C.__r3f || lE(C, {}), C.__r3f.parent = E, Xw(C), cE(C);
    }
  }
  function n(E, C, c = !1) {
    E && [...E].forEach((u) => r(C, u, c));
  }
  function r(E, C, c) {
    if (C) {
      var u, d, p;
      if (C.__r3f && (C.__r3f.parent = null), (u = E.__r3f) != null && u.objects && (E.__r3f.objects = E.__r3f.objects.filter((m) => m !== C)), (d = C.__r3f) != null && d.attach)
        gF(E, C, C.__r3f.attach);
      else if (C.isObject3D && E.isObject3D) {
        var D;
        E.remove(C), (D = C.__r3f) != null && D.root && v3(C.__r3f.root, C);
      }
      const S = (p = C.__r3f) == null ? void 0 : p.primitive, y = c === void 0 ? C.dispose !== null && !S : c;
      if (!S) {
        var f;
        n((f = C.__r3f) == null ? void 0 : f.objects, C, y), n(C.children, C, y);
      }
      C.__r3f && (delete C.__r3f.root, delete C.__r3f.objects, delete C.__r3f.handlers, delete C.__r3f.memoizedProps, S || delete C.__r3f), y && C.dispose && C.type !== "Scene" && Ef.unstable_scheduleCallback(Ef.unstable_IdlePriority, () => {
        try {
          C.dispose();
        } catch {
        }
      }), cE(E);
    }
  }
  function s(E, C, c, u) {
    var d;
    const p = (d = E.__r3f) == null ? void 0 : d.parent;
    if (!p)
      return;
    const D = e(C, c, E.__r3f.root);
    if (E.children) {
      for (const f of E.children)
        f.__r3f && t(D, f);
      E.children = E.children.filter((f) => !f.__r3f);
    }
    E.__r3f.objects.forEach((f) => t(D, f)), E.__r3f.objects = [], E.__r3f.autoRemovedBeforeAppend || r(p, E), D.parent && (D.__r3f.autoRemovedBeforeAppend = !0), t(p, D), D.raycast && D.__r3f.eventCount && D.__r3f.root.getState().internal.interaction.push(D), [u, u.alternate].forEach((f) => {
      f !== null && (f.stateNode = D, f.ref && (typeof f.ref == "function" ? f.ref(D) : f.ref.current = D));
    });
  }
  const B = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");
  return {
    reconciler: u3({
      createInstance: e,
      removeChild: r,
      appendChild: t,
      appendInitialChild: t,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (E, C) => {
        if (!C)
          return;
        const c = E.getState().scene;
        c.__r3f && (c.__r3f.root = E, t(c, C));
      },
      removeChildFromContainer: (E, C) => {
        C && r(E.getState().scene, C);
      },
      insertInContainerBefore: (E, C, c) => {
        if (!C || !c)
          return;
        const u = E.getState().scene;
        u.__r3f && i(u, C, c);
      },
      getRootHostContext: () => null,
      getChildHostContext: (E) => E,
      finalizeInitialChildren(E) {
        var C;
        return !!((C = E?.__r3f) != null ? C : {}).handlers;
      },
      prepareUpdate(E, C, c, u) {
        if (E.__r3f.primitive && u.object && u.object !== E)
          return [!0];
        {
          const {
            args: d = [],
            children: p,
            ...D
          } = u, {
            args: f = [],
            children: S,
            ...y
          } = c;
          if (!Array.isArray(d))
            throw new Error("R3F: the args prop must be an array!");
          if (d.some((N, F) => N !== f[F]))
            return [!0];
          const m = LU(E, D, y, !0);
          return m.changes.length ? [!1, m] : null;
        }
      },
      commitUpdate(E, [C, c], u, d, p, D) {
        C ? s(E, u, p, D) : x0(E, c);
      },
      commitMount(E, C, c, u) {
        var d;
        const p = (d = E.__r3f) != null ? d : {};
        E.raycast && p.handlers && p.eventCount && E.__r3f.root.getState().internal.interaction.push(E);
      },
      getPublicInstance: (E) => E,
      prepareForCommit: () => null,
      preparePortalMount: (E) => lE(E.getState().scene),
      resetAfterCommit: () => {
      },
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(E) {
        var C;
        const {
          attach: c,
          parent: u
        } = (C = E.__r3f) != null ? C : {};
        c && u && gF(u, E, c), E.isObject3D && (E.visible = !1), cE(E);
      },
      unhideInstance(E, C) {
        var c;
        const {
          attach: u,
          parent: d
        } = (c = E.__r3f) != null ? c : {};
        u && d && k0(d, E, u), (E.isObject3D && C.visible == null || C.visible) && (E.visible = !0), cE(E);
      },
      createTextInstance: B,
      hideTextInstance: B,
      unhideTextInstance: B,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874
      // @ts-ignore
      getCurrentEventPriority: () => A ? A() : CB.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {
      },
      afterActiveInstanceBlur: () => {
      },
      detachDeletedInstance: () => {
      },
      now: typeof performance < "u" && Oi.fun(performance.now) ? performance.now : Oi.fun(Date.now) ? Date.now : () => 0,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503
      scheduleTimeout: Oi.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Oi.fun(clearTimeout) ? clearTimeout : void 0
    }),
    applyProps: x0
  };
}
var eF, tF;
const FU = () => {
  var g;
  return (g = rm.ColorManagement) != null ? g : null;
}, GU = (g) => g && g.isOrthographicCamera, m3 = (g) => g && g.hasOwnProperty("current"), cu = typeof window < "u" && ((eF = window.document) != null && eF.createElement || ((tF = window.navigator) == null ? void 0 : tF.product) === "ReactNative") ? Te.useLayoutEffect : Te.useEffect;
function vU(g) {
  const A = Te.useRef(g);
  return cu(() => void (A.current = g), [g]), A;
}
function S3({
  set: g
}) {
  return cu(() => (g(new Promise(() => null)), () => g(!1)), [g]), null;
}
class UU extends Te.Component {
  constructor(...A) {
    super(...A), this.state = {
      error: !1
    };
  }
  componentDidCatch(A) {
    this.props.set(A);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
UU.getDerivedStateFromError = () => ({
  error: !0
});
const kU = "__default", iF = /* @__PURE__ */ new Map(), M3 = (g) => g && !!g.memoized && !!g.changes;
function xU(g) {
  const A = typeof window < "u" ? window.devicePixelRatio : 1;
  return Array.isArray(g) ? Math.min(Math.max(g[0], A), g[1]) : g;
}
const Bc = (g) => {
  var A;
  return (A = g.__r3f) == null ? void 0 : A.root.getState();
}, Oi = {
  obj: (g) => g === Object(g) && !Oi.arr(g) && typeof g != "function",
  fun: (g) => typeof g == "function",
  str: (g) => typeof g == "string",
  num: (g) => typeof g == "number",
  boo: (g) => typeof g == "boolean",
  und: (g) => g === void 0,
  arr: (g) => Array.isArray(g),
  equ(g, A, {
    arrays: e = "shallow",
    objects: t = "reference",
    strict: i = !0
  } = {}) {
    if (typeof g != typeof A || !!g != !!A)
      return !1;
    if (Oi.str(g) || Oi.num(g))
      return g === A;
    const n = Oi.obj(g);
    if (n && t === "reference")
      return g === A;
    const r = Oi.arr(g);
    if (r && e === "reference")
      return g === A;
    if ((r || n) && g === A)
      return !0;
    let s;
    for (s in g)
      if (!(s in A))
        return !1;
    if (n && e === "shallow" && t === "shallow") {
      for (s in i ? A : g)
        if (!Oi.equ(g[s], A[s], {
          strict: i,
          objects: "reference"
        }))
          return !1;
    } else
      for (s in i ? A : g)
        if (g[s] !== A[s])
          return !1;
    if (Oi.und(s)) {
      if (r && g.length === 0 && A.length === 0 || n && Object.keys(g).length === 0 && Object.keys(A).length === 0)
        return !0;
      if (g !== A)
        return !1;
    }
    return !0;
  }
};
function R3(g) {
  const A = {
    nodes: {},
    materials: {}
  };
  return g && g.traverse((e) => {
    e.name && (A.nodes[e.name] = e), e.material && !A.materials[e.material.name] && (A.materials[e.material.name] = e.material);
  }), A;
}
function N3(g) {
  g.dispose && g.type !== "Scene" && g.dispose();
  for (const A in g)
    A.dispose == null || A.dispose(), delete g[A];
}
function lE(g, A) {
  const e = g;
  return (A != null && A.primitive || !e.__r3f) && (e.__r3f = {
    type: "",
    root: null,
    previousAttach: null,
    memoizedProps: {},
    eventCount: 0,
    handlers: {},
    objects: [],
    parent: null,
    ...A
  }), g;
}
function Zw(g, A) {
  let e = g;
  if (A.includes("-")) {
    const t = A.split("-"), i = t.pop();
    return e = t.reduce((n, r) => n[r], g), {
      target: e,
      key: i
    };
  } else
    return {
      target: e,
      key: A
    };
}
const nF = /-\d+$/;
function k0(g, A, e) {
  if (Oi.str(e)) {
    if (nF.test(e)) {
      const n = e.replace(nF, ""), {
        target: r,
        key: s
      } = Zw(g, n);
      Array.isArray(r[s]) || (r[s] = []);
    }
    const {
      target: t,
      key: i
    } = Zw(g, e);
    A.__r3f.previousAttach = t[i], t[i] = A;
  } else
    A.__r3f.previousAttach = e(g, A);
}
function gF(g, A, e) {
  var t, i;
  if (Oi.str(e)) {
    const {
      target: n,
      key: r
    } = Zw(g, e), s = A.__r3f.previousAttach;
    s === void 0 ? delete n[r] : n[r] = s;
  } else
    (t = A.__r3f) == null || t.previousAttach == null || t.previousAttach(g, A);
  (i = A.__r3f) == null || delete i.previousAttach;
}
function LU(g, {
  children: A,
  key: e,
  ref: t,
  ...i
}, {
  children: n,
  key: r,
  ref: s,
  ...B
} = {}, I = !1) {
  var E;
  const C = (E = g?.__r3f) != null ? E : {}, c = Object.entries(i), u = [];
  if (I) {
    const p = Object.keys(B);
    for (let D = 0; D < p.length; D++)
      i.hasOwnProperty(p[D]) || c.unshift([p[D], kU + "remove"]);
  }
  c.forEach(([p, D]) => {
    var f;
    if ((f = g.__r3f) != null && f.primitive && p === "object" || Oi.equ(D, B[p]))
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(p))
      return u.push([p, D, !0, []]);
    let S = [];
    p.includes("-") && (S = p.split("-")), u.push([p, D, !1, S]);
    for (const y in i) {
      const m = i[y];
      y.startsWith(`${p}-`) && u.push([y, m, !1, y.split("-")]);
    }
  });
  const d = {
    ...i
  };
  return C.memoizedProps && C.memoizedProps.args && (d.args = C.memoizedProps.args), C.memoizedProps && C.memoizedProps.attach && (d.attach = C.memoizedProps.attach), {
    memoized: d,
    changes: u
  };
}
function x0(g, A) {
  var e, t, i;
  const n = (e = g.__r3f) != null ? e : {}, r = n.root, s = (t = r == null || r.getState == null ? void 0 : r.getState()) != null ? t : {}, {
    memoized: B,
    changes: I
  } = M3(A) ? A : LU(g, A), E = n.eventCount;
  g.__r3f && (g.__r3f.memoizedProps = B);
  for (let c = 0; c < I.length; c++) {
    let [u, d, p, D] = I[c], f = g, S = f[u];
    if (D.length && (S = D.reduce((y, m) => y[m], g), !(S && S.set))) {
      const [y, ...m] = D.reverse();
      f = m.reverse().reduce((N, F) => N[F], g), u = y;
    }
    if (d === kU + "remove")
      if (f.constructor) {
        let y = iF.get(f.constructor);
        y || (y = new f.constructor(), iF.set(f.constructor, y)), d = y[u];
      } else
        d = 0;
    if (p)
      d ? n.handlers[u] = d : delete n.handlers[u], n.eventCount = Object.keys(n.handlers).length;
    else if (S && S.set && (S.copy || S instanceof GC)) {
      if (Array.isArray(d))
        S.fromArray ? S.fromArray(d) : S.set(...d);
      else if (S.copy && d && d.constructor && S.constructor === d.constructor)
        S.copy(d);
      else if (d !== void 0) {
        const y = S instanceof ke;
        !y && S.setScalar ? S.setScalar(d) : S instanceof GC && d instanceof GC ? S.mask = d.mask : S.set(d), !FU() && !s.linear && y && S.convertSRGBToLinear();
      }
    } else
      f[u] = d, !s.linear && f[u] instanceof xi && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129
      f[u].format === tr && f[u].type === Va && (f[u].encoding = Ht);
    cE(g);
  }
  if (n.parent && s.internal && g.raycast && E !== n.eventCount) {
    const c = s.internal.interaction.indexOf(g);
    c > -1 && s.internal.interaction.splice(c, 1), n.eventCount && s.internal.interaction.push(g);
  }
  return !(I.length === 1 && I[0][0] === "onUpdate") && I.length && (i = g.__r3f) != null && i.parent && Xw(g), g;
}
function cE(g) {
  var A, e;
  const t = (A = g.__r3f) == null || (e = A.root) == null || e.getState == null ? void 0 : e.getState();
  t && t.internal.frames === 0 && t.invalidate();
}
function Xw(g) {
  g.onUpdate == null || g.onUpdate(g);
}
function F3(g, A) {
  g.manual || (GU(g) ? (g.left = A.width / -2, g.right = A.width / 2, g.top = A.height / 2, g.bottom = A.height / -2) : g.aspect = A.width / A.height, g.updateProjectionMatrix(), g.updateMatrixWorld());
}
function Yd(g) {
  return (g.eventObject || g.object).uuid + "/" + g.index + g.instanceId;
}
function G3() {
  var g;
  const A = typeof self < "u" && self || typeof window < "u" && window;
  if (!A)
    return CB.DefaultEventPriority;
  switch ((g = A.event) == null ? void 0 : g.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return CB.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return CB.ContinuousEventPriority;
    default:
      return CB.DefaultEventPriority;
  }
}
function TU(g, A, e, t) {
  const i = e.get(A);
  i && (e.delete(A), e.size === 0 && (g.delete(t), i.target.releasePointerCapture(t)));
}
function v3(g, A) {
  const {
    internal: e
  } = g.getState();
  e.interaction = e.interaction.filter((t) => t !== A), e.initialHits = e.initialHits.filter((t) => t !== A), e.hovered.forEach((t, i) => {
    (t.eventObject === A || t.object === A) && e.hovered.delete(i);
  }), e.capturedMap.forEach((t, i) => {
    TU(e.capturedMap, A, t, i);
  });
}
function U3(g) {
  function A(B) {
    const {
      internal: I
    } = g.getState(), E = B.offsetX - I.initialClick[0], C = B.offsetY - I.initialClick[1];
    return Math.round(Math.sqrt(E * E + C * C));
  }
  function e(B) {
    return B.filter((I) => ["Move", "Over", "Enter", "Out", "Leave"].some((E) => {
      var C;
      return (C = I.__r3f) == null ? void 0 : C.handlers["onPointer" + E];
    }));
  }
  function t(B, I) {
    const E = g.getState(), C = /* @__PURE__ */ new Set(), c = [], u = I ? I(E.internal.interaction) : E.internal.interaction;
    for (let f = 0; f < u.length; f++) {
      const S = Bc(u[f]);
      S && (S.raycaster.camera = void 0);
    }
    E.previousRoot || E.events.compute == null || E.events.compute(B, E);
    function d(f) {
      const S = Bc(f);
      if (!S || !S.events.enabled || S.raycaster.camera === null)
        return [];
      if (S.raycaster.camera === void 0) {
        var y;
        S.events.compute == null || S.events.compute(B, S, (y = S.previousRoot) == null ? void 0 : y.getState()), S.raycaster.camera === void 0 && (S.raycaster.camera = null);
      }
      return S.raycaster.camera ? S.raycaster.intersectObject(f, !0) : [];
    }
    let p = u.flatMap(d).sort((f, S) => {
      const y = Bc(f.object), m = Bc(S.object);
      return !y || !m ? f.distance - S.distance : m.events.priority - y.events.priority || f.distance - S.distance;
    }).filter((f) => {
      const S = Yd(f);
      return C.has(S) ? !1 : (C.add(S), !0);
    });
    E.events.filter && (p = E.events.filter(p, E));
    for (const f of p) {
      let S = f.object;
      for (; S; ) {
        var D;
        (D = S.__r3f) != null && D.eventCount && c.push({
          ...f,
          eventObject: S
        }), S = S.parent;
      }
    }
    if ("pointerId" in B && E.internal.capturedMap.has(B.pointerId))
      for (let f of E.internal.capturedMap.get(B.pointerId).values())
        C.has(Yd(f.intersection)) || c.push(f.intersection);
    return c;
  }
  function i(B, I, E, C) {
    const c = g.getState();
    if (B.length) {
      const u = {
        stopped: !1
      };
      for (const d of B) {
        const p = Bc(d.object) || c, {
          raycaster: D,
          pointer: f,
          camera: S,
          internal: y
        } = p, m = new IA(f.x, f.y, 0).unproject(S), N = (x) => {
          var H, _;
          return (H = (_ = y.capturedMap.get(x)) == null ? void 0 : _.has(d.eventObject)) != null ? H : !1;
        }, F = (x) => {
          const H = {
            intersection: d,
            target: I.target
          };
          y.capturedMap.has(x) ? y.capturedMap.get(x).set(d.eventObject, H) : y.capturedMap.set(x, /* @__PURE__ */ new Map([[d.eventObject, H]])), I.target.setPointerCapture(x);
        }, G = (x) => {
          const H = y.capturedMap.get(x);
          H && TU(y.capturedMap, d.eventObject, H, x);
        };
        let k = {};
        for (let x in I) {
          let H = I[x];
          typeof H != "function" && (k[x] = H);
        }
        let v = {
          ...d,
          ...k,
          pointer: f,
          intersections: B,
          stopped: u.stopped,
          delta: E,
          unprojectedPoint: m,
          ray: D.ray,
          camera: S,
          // Hijack stopPropagation, which just sets a flag
          stopPropagation() {
            const x = "pointerId" in I && y.capturedMap.get(I.pointerId);
            if (
              // ...if this pointer hasn't been captured
              (!x || // ... or if the hit object is capturing the pointer
              x.has(d.eventObject)) && (v.stopped = u.stopped = !0, y.hovered.size && Array.from(y.hovered.values()).find((H) => H.eventObject === d.eventObject))
            ) {
              const H = B.slice(0, B.indexOf(d));
              n([...H, d]);
            }
          },
          // there should be a distinction between target and currentTarget
          target: {
            hasPointerCapture: N,
            setPointerCapture: F,
            releasePointerCapture: G
          },
          currentTarget: {
            hasPointerCapture: N,
            setPointerCapture: F,
            releasePointerCapture: G
          },
          nativeEvent: I
        };
        if (C(v), u.stopped === !0)
          break;
      }
    }
    return B;
  }
  function n(B) {
    const {
      internal: I
    } = g.getState();
    for (const E of I.hovered.values())
      if (!B.length || !B.find((C) => C.object === E.object && C.index === E.index && C.instanceId === E.instanceId)) {
        const c = E.eventObject.__r3f, u = c?.handlers;
        if (I.hovered.delete(Yd(E)), c != null && c.eventCount) {
          const d = {
            ...E,
            intersections: B
          };
          u.onPointerOut == null || u.onPointerOut(d), u.onPointerLeave == null || u.onPointerLeave(d);
        }
      }
  }
  function r(B, I) {
    for (let E = 0; E < I.length; E++) {
      const C = I[E].__r3f;
      C == null || C.handlers.onPointerMissed == null || C.handlers.onPointerMissed(B);
    }
  }
  function s(B) {
    switch (B) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => n([]);
      case "onLostPointerCapture":
        return (I) => {
          const {
            internal: E
          } = g.getState();
          "pointerId" in I && E.capturedMap.has(I.pointerId) && requestAnimationFrame(() => {
            E.capturedMap.has(I.pointerId) && (E.capturedMap.delete(I.pointerId), n([]));
          });
        };
    }
    return function(E) {
      const {
        onPointerMissed: C,
        internal: c
      } = g.getState();
      c.lastEvent.current = E;
      const u = B === "onPointerMove", d = B === "onClick" || B === "onContextMenu" || B === "onDoubleClick", D = t(E, u ? e : void 0), f = d ? A(E) : 0;
      B === "onPointerDown" && (c.initialClick = [E.offsetX, E.offsetY], c.initialHits = D.map((y) => y.eventObject)), d && !D.length && f <= 2 && (r(E, c.interaction), C && C(E)), u && n(D);
      function S(y) {
        const m = y.eventObject, N = m.__r3f, F = N?.handlers;
        if (N != null && N.eventCount)
          if (u) {
            if (F.onPointerOver || F.onPointerEnter || F.onPointerOut || F.onPointerLeave) {
              const G = Yd(y), k = c.hovered.get(G);
              k ? k.stopped && y.stopPropagation() : (c.hovered.set(G, y), F.onPointerOver == null || F.onPointerOver(y), F.onPointerEnter == null || F.onPointerEnter(y));
            }
            F.onPointerMove == null || F.onPointerMove(y);
          } else {
            const G = F[B];
            G ? (!d || c.initialHits.includes(m)) && (r(E, c.interaction.filter((k) => !c.initialHits.includes(k))), G(y)) : d && c.initialHits.includes(m) && r(E, c.interaction.filter((k) => !c.initialHits.includes(k)));
          }
      }
      i(D, E, f, S);
    };
  }
  return {
    handlePointer: s
  };
}
const KU = (g) => !!(g != null && g.render), bU = /* @__PURE__ */ Te.createContext(null), k3 = (g, A) => {
  const e = SU((s, B) => {
    const I = new IA(), E = new IA(), C = new IA();
    function c(f = B().camera, S = E, y = B().size) {
      const {
        width: m,
        height: N,
        top: F,
        left: G
      } = y, k = m / N;
      S instanceof IA ? C.copy(S) : C.set(...S);
      const v = f.getWorldPosition(I).distanceTo(C);
      if (GU(f))
        return {
          width: m / f.zoom,
          height: N / f.zoom,
          top: F,
          left: G,
          factor: 1,
          distance: v,
          aspect: k
        };
      {
        const x = f.fov * Math.PI / 180, H = 2 * Math.tan(x / 2) * v, _ = H * (m / N);
        return {
          width: _,
          height: H,
          top: F,
          left: G,
          factor: m / _,
          distance: v,
          aspect: k
        };
      }
    }
    let u;
    const d = (f) => s((S) => ({
      performance: {
        ...S.performance,
        current: f
      }
    })), p = new ue();
    return {
      set: s,
      get: B,
      // Mock objects that have to be configured
      gl: null,
      camera: null,
      raycaster: null,
      events: {
        priority: 1,
        enabled: !0,
        connected: !1
      },
      xr: null,
      scene: null,
      invalidate: (f = 1) => g(B(), f),
      advance: (f, S) => A(f, S, B()),
      legacy: !1,
      linear: !1,
      flat: !1,
      controls: null,
      clock: new Am(),
      pointer: p,
      mouse: p,
      frameloop: "always",
      onPointerMissed: void 0,
      performance: {
        current: 1,
        min: 0.5,
        max: 1,
        debounce: 200,
        regress: () => {
          const f = B();
          u && clearTimeout(u), f.performance.current !== f.performance.min && d(f.performance.min), u = setTimeout(() => d(B().performance.max), f.performance.debounce);
        }
      },
      size: {
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        updateStyle: !1
      },
      viewport: {
        initialDpr: 0,
        dpr: 0,
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        aspect: 0,
        distance: 0,
        factor: 0,
        getCurrentViewport: c
      },
      setEvents: (f) => s((S) => ({
        ...S,
        events: {
          ...S.events,
          ...f
        }
      })),
      setSize: (f, S, y, m, N) => {
        const F = B().camera, G = {
          width: f,
          height: S,
          top: m || 0,
          left: N || 0,
          updateStyle: y
        };
        s((k) => ({
          size: G,
          viewport: {
            ...k.viewport,
            ...c(F, E, G)
          }
        }));
      },
      setDpr: (f) => s((S) => {
        const y = xU(f);
        return {
          viewport: {
            ...S.viewport,
            dpr: y,
            initialDpr: S.viewport.initialDpr || y
          }
        };
      }),
      setFrameloop: (f = "always") => {
        const S = B().clock;
        S.stop(), S.elapsedTime = 0, f !== "never" && (S.start(), S.elapsedTime = 0), s(() => ({
          frameloop: f
        }));
      },
      previousRoot: void 0,
      internal: {
        active: !1,
        priority: 0,
        frames: 0,
        lastEvent: /* @__PURE__ */ Te.createRef(),
        interaction: [],
        hovered: /* @__PURE__ */ new Map(),
        subscribers: [],
        initialClick: [0, 0],
        initialHits: [],
        capturedMap: /* @__PURE__ */ new Map(),
        subscribe: (f, S, y) => {
          const m = B().internal;
          return m.priority = m.priority + (S > 0 ? 1 : 0), m.subscribers.push({
            ref: f,
            priority: S,
            store: y
          }), m.subscribers = m.subscribers.sort((N, F) => N.priority - F.priority), () => {
            const N = B().internal;
            N != null && N.subscribers && (N.priority = N.priority - (S > 0 ? 1 : 0), N.subscribers = N.subscribers.filter((F) => F.ref !== f));
          };
        }
      }
    };
  }), t = e.getState();
  let i = t.size, n = t.viewport.dpr, r = t.camera;
  return e.subscribe(() => {
    const {
      camera: s,
      size: B,
      viewport: I,
      gl: E,
      set: C
    } = e.getState();
    if (B !== i || I.dpr !== n) {
      var c;
      i = B, n = I.dpr, F3(s, B), E.setPixelRatio(I.dpr);
      const u = (c = B.updateStyle) != null ? c : typeof HTMLCanvasElement < "u" && E.domElement instanceof HTMLCanvasElement;
      E.setSize(B.width, B.height, u);
    }
    s !== r && (r = s, C((u) => ({
      viewport: {
        ...u.viewport,
        ...u.viewport.getCurrentViewport(s)
      }
    })));
  }), e.subscribe((s) => g(s)), e;
};
let Hd, x3 = /* @__PURE__ */ new Set(), L3 = /* @__PURE__ */ new Set(), T3 = /* @__PURE__ */ new Set();
function L0(g, A) {
  if (g.size)
    for (const {
      callback: e
    } of g.values())
      e(A);
}
function Cc(g, A) {
  switch (g) {
    case "before":
      return L0(x3, A);
    case "after":
      return L0(L3, A);
    case "tail":
      return L0(T3, A);
  }
}
let T0, K0;
function b0(g, A, e) {
  let t = A.clock.getDelta();
  for (A.frameloop === "never" && typeof g == "number" && (t = g - A.clock.elapsedTime, A.clock.oldTime = A.clock.elapsedTime, A.clock.elapsedTime = g), T0 = A.internal.subscribers, Hd = 0; Hd < T0.length; Hd++)
    K0 = T0[Hd], K0.ref.current(K0.store.getState(), t, e);
  return !A.internal.priority && A.gl.render && A.gl.render(A.scene, A.camera), A.internal.frames = Math.max(0, A.internal.frames - 1), A.frameloop === "always" ? 1 : A.internal.frames;
}
function K3(g) {
  let A = !1, e, t, i;
  function n(B) {
    t = requestAnimationFrame(n), A = !0, e = 0, Cc("before", B);
    for (const E of g.values()) {
      var I;
      i = E.store.getState(), i.internal.active && (i.frameloop === "always" || i.internal.frames > 0) && !((I = i.gl.xr) != null && I.isPresenting) && (e += b0(B, i));
    }
    if (Cc("after", B), e === 0)
      return Cc("tail", B), A = !1, cancelAnimationFrame(t);
  }
  function r(B, I = 1) {
    var E;
    if (!B)
      return g.forEach((C) => r(C.store.getState()), I);
    (E = B.gl.xr) != null && E.isPresenting || !B.internal.active || B.frameloop === "never" || (B.internal.frames = Math.min(60, B.internal.frames + I), A || (A = !0, requestAnimationFrame(n)));
  }
  function s(B, I = !0, E, C) {
    if (I && Cc("before", B), E)
      b0(B, E, C);
    else
      for (const c of g.values())
        b0(B, c.store.getState());
    I && Cc("after", B);
  }
  return {
    loop: n,
    /**
     * Invalidates the view, requesting a frame to be rendered. Will globally invalidate unless passed a root's state.
     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#invalidate
     */
    invalidate: r,
    /**
     * Advances the frameloop and runs render effects, useful for when manually rendering via `frameloop="never"`.
     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#advance
     */
    advance: s
  };
}
function YU() {
  const g = Te.useContext(bU);
  if (!g)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return g;
}
function mr(g = (e) => e, A) {
  return YU()(g, A);
}
function qE(g, A = 0) {
  const e = YU(), t = e.getState().internal.subscribe, i = vU(g);
  return cu(() => t(i, A, e), [A, t, e]), null;
}
function HU(g, A) {
  return function(e, ...t) {
    const i = new e();
    return g && g(i), Promise.all(t.map((n) => new Promise((r, s) => i.load(n, (B) => {
      B.scene && Object.assign(B, R3(B.scene)), r(B);
    }, A, (B) => s(new Error(`Could not load ${n}: ${B.message})`))))));
  };
}
function sm(g, A, e, t) {
  const i = Array.isArray(A) ? A : [A], n = p3(HU(e, t), [g, ...i], {
    equal: Oi.equ
  });
  return Array.isArray(A) ? n : n[0];
}
sm.preload = function(g, A, e) {
  const t = Array.isArray(A) ? A : [A];
  return D3(HU(e), [g, ...t]);
};
sm.clear = function(g, A) {
  const e = Array.isArray(A) ? A : [A];
  return w3([g, ...e]);
};
const LE = /* @__PURE__ */ new Map(), {
  invalidate: rF,
  advance: oF
} = K3(LE), {
  reconciler: lf,
  applyProps: Qc
} = y3(LE, G3), aE = {
  objects: "shallow",
  strict: !1
}, b3 = (g, A) => {
  const e = typeof g == "function" ? g(A) : g;
  return KU(e) ? e : new vy({
    powerPreference: "high-performance",
    canvas: A,
    antialias: !0,
    alpha: !0,
    ...g
  });
};
function Y3(g, A) {
  if (A)
    return A;
  if (typeof HTMLCanvasElement < "u" && g instanceof HTMLCanvasElement && g.parentElement) {
    const {
      width: e,
      height: t,
      top: i,
      left: n
    } = g.parentElement.getBoundingClientRect();
    return {
      width: e,
      height: t,
      top: i,
      left: n
    };
  } else if (typeof OffscreenCanvas < "u" && g instanceof OffscreenCanvas)
    return {
      width: g.width,
      height: g.height,
      top: 0,
      left: 0
    };
  return {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  };
}
function H3(g) {
  const A = LE.get(g), e = A?.fiber, t = A?.store;
  A && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? (
    // In modern browsers, reportError will dispatch an error event,
    // emulating an uncaught JavaScript error.
    reportError
  ) : (
    // In older browsers and test environments, fallback to console.error.
    console.error
  ), n = t || k3(rF, oF), r = e || lf.createContainer(n, CB.ConcurrentRoot, null, !1, null, "", i, null);
  A || LE.set(g, {
    fiber: r,
    store: n
  });
  let s, B = !1, I;
  return {
    configure(E = {}) {
      let {
        gl: C,
        size: c,
        scene: u,
        events: d,
        onCreated: p,
        shadows: D = !1,
        linear: f = !1,
        flat: S = !1,
        legacy: y = !1,
        orthographic: m = !1,
        frameloop: N = "always",
        dpr: F = [1, 2],
        performance: G,
        raycaster: k,
        camera: v,
        onPointerMissed: x
      } = E, H = n.getState(), _ = H.gl;
      H.gl || H.set({
        gl: _ = b3(C, g)
      });
      let j = H.raycaster;
      j || H.set({
        raycaster: j = new nm()
      });
      const {
        params: V,
        ...iA
      } = k || {};
      if (Oi.equ(iA, j, aE) || Qc(j, {
        ...iA
      }), Oi.equ(V, j.params, aE) || Qc(j, {
        params: {
          ...j.params,
          ...V
        }
      }), !H.camera || H.camera === I && !Oi.equ(I, v, aE)) {
        I = v;
        const Y = v instanceof $c, rA = Y ? v : m ? new $a(0, 0, 0, 0, 0.1, 1e3) : new mn(75, 0, 0.1, 1e3);
        Y || (rA.position.z = 5, v && Qc(rA, v), !H.camera && !(v != null && v.rotation) && rA.lookAt(0, 0, 0)), H.set({
          camera: rA
        });
      }
      if (!H.scene) {
        let Y;
        u instanceof UE ? Y = u : (Y = new UE(), u && Qc(Y, u)), H.set({
          scene: lE(Y)
        });
      }
      if (!H.xr) {
        const Y = (aA, MA) => {
          const hA = n.getState();
          hA.frameloop !== "never" && oF(aA, !0, hA, MA);
        }, rA = () => {
          const aA = n.getState();
          aA.gl.xr.enabled = aA.gl.xr.isPresenting, aA.gl.xr.setAnimationLoop(aA.gl.xr.isPresenting ? Y : null), aA.gl.xr.isPresenting || rF(aA);
        }, QA = {
          connect() {
            const aA = n.getState().gl;
            aA.xr.addEventListener("sessionstart", rA), aA.xr.addEventListener("sessionend", rA);
          },
          disconnect() {
            const aA = n.getState().gl;
            aA.xr.removeEventListener("sessionstart", rA), aA.xr.removeEventListener("sessionend", rA);
          }
        };
        _.xr && QA.connect(), H.set({
          xr: QA
        });
      }
      if (_.shadowMap) {
        const Y = _.shadowMap.enabled, rA = _.shadowMap.type;
        if (_.shadowMap.enabled = !!D, Oi.boo(D))
          _.shadowMap.type = Sc;
        else if (Oi.str(D)) {
          var eA;
          const QA = {
            basic: FG,
            percentage: mf,
            soft: Sc,
            variance: DC
          };
          _.shadowMap.type = (eA = QA[D]) != null ? eA : Sc;
        } else
          Oi.obj(D) && Object.assign(_.shadowMap, D);
        (Y !== _.shadowMap.enabled || rA !== _.shadowMap.type) && (_.shadowMap.needsUpdate = !0);
      }
      const oA = FU();
      oA && ("enabled" in oA ? oA.enabled = !y : "legacyMode" in oA && (oA.legacyMode = y));
      const P = f ? ta : Ht, J = S ? Is : dy;
      _.outputEncoding !== P && (_.outputEncoding = P), _.toneMapping !== J && (_.toneMapping = J), H.legacy !== y && H.set(() => ({
        legacy: y
      })), H.linear !== f && H.set(() => ({
        linear: f
      })), H.flat !== S && H.set(() => ({
        flat: S
      })), C && !Oi.fun(C) && !KU(C) && !Oi.equ(C, _, aE) && Qc(_, C), d && !H.events.handlers && H.set({
        events: d(n)
      });
      const tA = Y3(g, c);
      return Oi.equ(tA, H.size, aE) || H.setSize(tA.width, tA.height, tA.updateStyle, tA.top, tA.left), F && H.viewport.dpr !== xU(F) && H.setDpr(F), H.frameloop !== N && H.setFrameloop(N), H.onPointerMissed || H.set({
        onPointerMissed: x
      }), G && !Oi.equ(G, H.performance, aE) && H.set((Y) => ({
        performance: {
          ...Y.performance,
          ...G
        }
      })), s = p, B = !0, this;
    },
    render(E) {
      return B || this.configure(), lf.updateContainer(/* @__PURE__ */ Te.createElement(_3, {
        store: n,
        children: E,
        onCreated: s,
        rootElement: g
      }), r, null, () => {
      }), n;
    },
    unmount() {
      _U(g);
    }
  };
}
function _3({
  store: g,
  children: A,
  onCreated: e,
  rootElement: t
}) {
  return cu(() => {
    const i = g.getState();
    i.set((n) => ({
      internal: {
        ...n.internal,
        active: !0
      }
    })), e && e(i), g.getState().events.connected || i.events.connect == null || i.events.connect(t);
  }, []), /* @__PURE__ */ Te.createElement(bU.Provider, {
    value: g
  }, A);
}
function _U(g, A) {
  const e = LE.get(g), t = e?.fiber;
  if (t) {
    const i = e?.store.getState();
    i && (i.internal.active = !1), lf.updateContainer(null, t, null, () => {
      i && setTimeout(() => {
        try {
          var n, r, s, B;
          i.events.disconnect == null || i.events.disconnect(), (n = i.gl) == null || (r = n.renderLists) == null || r.dispose == null || r.dispose(), (s = i.gl) == null || s.forceContextLoss == null || s.forceContextLoss(), (B = i.gl) != null && B.xr && i.xr.disconnect(), N3(i), LE.delete(g), A && A(g);
        } catch {
        }
      }, 500);
    });
  }
}
lf.injectIntoDevTools({
  bundleType: process.env.NODE_ENV === "production" ? 0 : 1,
  rendererPackageName: "@react-three/fiber",
  version: Te.version
});
function $w(g, A, e) {
  var t, i, n, r, s;
  A == null && (A = 100);
  function B() {
    var E = Date.now() - r;
    E < A && E >= 0 ? t = setTimeout(B, A - E) : (t = null, e || (s = g.apply(n, i), n = i = null));
  }
  var I = function() {
    n = this, i = arguments, r = Date.now();
    var E = e && !t;
    return t || (t = setTimeout(B, A)), E && (s = g.apply(n, i), n = i = null), s;
  };
  return I.clear = function() {
    t && (clearTimeout(t), t = null);
  }, I.flush = function() {
    t && (s = g.apply(n, i), n = i = null, clearTimeout(t), t = null);
  }, I;
}
$w.debounce = $w;
var sF = $w;
function J3(g) {
  let {
    debounce: A,
    scroll: e,
    polyfill: t,
    offsetSize: i
  } = g === void 0 ? {
    debounce: 0,
    scroll: !1,
    offsetSize: !1
  } : g;
  const n = t || (typeof window > "u" ? class {
  } : window.ResizeObserver);
  if (!n)
    throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [r, s] = cn({
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    bottom: 0,
    right: 0,
    x: 0,
    y: 0
  }), B = Dt({
    element: null,
    scrollContainers: null,
    resizeObserver: null,
    lastBounds: r
  }), I = A ? typeof A == "number" ? A : A.scroll : null, E = A ? typeof A == "number" ? A : A.resize : null, C = Dt(!1);
  gi(() => (C.current = !0, () => void (C.current = !1)));
  const [c, u, d] = ni(() => {
    const S = () => {
      if (!B.current.element)
        return;
      const {
        left: y,
        top: m,
        width: N,
        height: F,
        bottom: G,
        right: k,
        x: v,
        y: x
      } = B.current.element.getBoundingClientRect(), H = {
        left: y,
        top: m,
        width: N,
        height: F,
        bottom: G,
        right: k,
        x: v,
        y: x
      };
      B.current.element instanceof HTMLElement && i && (H.height = B.current.element.offsetHeight, H.width = B.current.element.offsetWidth), Object.freeze(H), C.current && !W3(B.current.lastBounds, H) && s(B.current.lastBounds = H);
    };
    return [S, E ? sF(S, E) : S, I ? sF(S, I) : S];
  }, [s, i, I, E]);
  function p() {
    B.current.scrollContainers && (B.current.scrollContainers.forEach((S) => S.removeEventListener("scroll", d, !0)), B.current.scrollContainers = null), B.current.resizeObserver && (B.current.resizeObserver.disconnect(), B.current.resizeObserver = null);
  }
  function D() {
    B.current.element && (B.current.resizeObserver = new n(d), B.current.resizeObserver.observe(B.current.element), e && B.current.scrollContainers && B.current.scrollContainers.forEach((S) => S.addEventListener("scroll", d, {
      capture: !0,
      passive: !0
    })));
  }
  const f = (S) => {
    !S || S === B.current.element || (p(), B.current.element = S, B.current.scrollContainers = JU(S), D());
  };
  return q3(d, !!e), O3(u), gi(() => {
    p(), D();
  }, [e, d, u]), gi(() => p, []), [f, r, c];
}
function O3(g) {
  gi(() => {
    const A = g;
    return window.addEventListener("resize", A), () => void window.removeEventListener("resize", A);
  }, [g]);
}
function q3(g, A) {
  gi(() => {
    if (A) {
      const e = g;
      return window.addEventListener("scroll", e, {
        capture: !0,
        passive: !0
      }), () => void window.removeEventListener("scroll", e, !0);
    }
  }, [g, A]);
}
function JU(g) {
  const A = [];
  if (!g || g === document.body)
    return A;
  const {
    overflow: e,
    overflowX: t,
    overflowY: i
  } = window.getComputedStyle(g);
  return [e, t, i].some((n) => n === "auto" || n === "scroll") && A.push(g), [...A, ...JU(g.parentElement)];
}
const P3 = ["x", "y", "top", "bottom", "left", "right", "width", "height"], W3 = (g, A) => P3.every((e) => g[e] === A[e]);
var z3 = Object.defineProperty, V3 = Object.defineProperties, j3 = Object.getOwnPropertyDescriptors, aF = Object.getOwnPropertySymbols, Z3 = Object.prototype.hasOwnProperty, X3 = Object.prototype.propertyIsEnumerable, IF = (g, A, e) => A in g ? z3(g, A, { enumerable: !0, configurable: !0, writable: !0, value: e }) : g[A] = e, BF = (g, A) => {
  for (var e in A || (A = {}))
    Z3.call(A, e) && IF(g, e, A[e]);
  if (aF)
    for (var e of aF(A))
      X3.call(A, e) && IF(g, e, A[e]);
  return g;
}, $3 = (g, A) => V3(g, j3(A));
function OU(g, A, e) {
  if (!g)
    return;
  if (e(g) === !0)
    return g;
  let t = A ? g.return : g.child;
  for (; t; ) {
    const i = OU(t, A, e);
    if (i)
      return i;
    t = A ? null : t.sibling;
  }
}
function qU(g) {
  try {
    return Object.defineProperties(g, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {
        }
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {
        }
      }
    });
  } catch {
    return g;
  }
}
const am = qU(Te.createContext(null));
class PU extends Te.Component {
  render() {
    return /* @__PURE__ */ Te.createElement(am.Provider, {
      value: this._reactInternals
    }, this.props.children);
  }
}
const { ReactCurrentOwner: CF, ReactCurrentDispatcher: QF } = Te.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function A4() {
  const g = Te.useContext(am);
  if (g === null)
    throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const A = Te.useId();
  return Te.useMemo(
    () => {
      var t;
      return (t = CF?.current) != null ? t : OU(g, !1, (i) => {
        let n = i.memoizedState;
        for (; n; ) {
          if (n.memoizedState === A)
            return !0;
          n = n.next;
        }
      });
    },
    [g, A]
  );
}
function e4() {
  var g, A;
  const e = A4(), [t] = Te.useState(() => /* @__PURE__ */ new Map());
  t.clear();
  let i = e;
  for (; i; ) {
    const n = (g = i.type) == null ? void 0 : g._context;
    n && n !== am && !t.has(n) && t.set(n, (A = QF?.current) == null ? void 0 : A.readContext(qU(n))), i = i.return;
  }
  return t;
}
function t4() {
  const g = e4();
  return Te.useMemo(
    () => Array.from(g.keys()).reduce(
      (A, e) => (t) => /* @__PURE__ */ Te.createElement(A, null, /* @__PURE__ */ Te.createElement(e.Provider, $3(BF({}, t), {
        value: g.get(e)
      }))),
      (A) => /* @__PURE__ */ Te.createElement(PU, BF({}, A))
    ),
    [g]
  );
}
const Y0 = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0]
};
function i4(g) {
  const {
    handlePointer: A
  } = U3(g);
  return {
    priority: 1,
    enabled: !0,
    compute(e, t, i) {
      t.pointer.set(e.offsetX / t.size.width * 2 - 1, -(e.offsetY / t.size.height) * 2 + 1), t.raycaster.setFromCamera(t.pointer, t.camera);
    },
    connected: void 0,
    handlers: Object.keys(Y0).reduce((e, t) => ({
      ...e,
      [t]: A(t)
    }), {}),
    update: () => {
      var e;
      const {
        events: t,
        internal: i
      } = g.getState();
      (e = i.lastEvent) != null && e.current && t.handlers && t.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (e) => {
      var t;
      const {
        set: i,
        events: n
      } = g.getState();
      n.disconnect == null || n.disconnect(), i((r) => ({
        events: {
          ...r.events,
          connected: e
        }
      })), Object.entries((t = n.handlers) != null ? t : []).forEach(([r, s]) => {
        const [B, I] = Y0[r];
        e.addEventListener(B, s, {
          passive: I
        });
      });
    },
    disconnect: () => {
      const {
        set: e,
        events: t
      } = g.getState();
      if (t.connected) {
        var i;
        Object.entries((i = t.handlers) != null ? i : []).forEach(([n, r]) => {
          if (t && t.connected instanceof HTMLElement) {
            const [s] = Y0[n];
            t.connected.removeEventListener(s, r);
          }
        }), e((n) => ({
          events: {
            ...n.events,
            connected: void 0
          }
        }));
      }
    }
  };
}
const n4 = /* @__PURE__ */ Te.forwardRef(function({
  children: A,
  fallback: e,
  resize: t,
  style: i,
  gl: n,
  events: r = i4,
  eventSource: s,
  eventPrefix: B,
  shadows: I,
  linear: E,
  flat: C,
  legacy: c,
  orthographic: u,
  frameloop: d,
  dpr: p,
  performance: D,
  raycaster: f,
  camera: S,
  onPointerMissed: y,
  onCreated: m,
  ...N
}, F) {
  Te.useMemo(() => om(dU), []);
  const G = t4(), [k, v] = J3({
    scroll: !0,
    debounce: {
      scroll: 50,
      resize: 0
    },
    ...t
  }), x = Te.useRef(null), H = Te.useRef(null);
  Te.useImperativeHandle(F, () => x.current);
  const _ = vU(y), [j, V] = Te.useState(!1), [iA, eA] = Te.useState(!1);
  if (j)
    throw j;
  if (iA)
    throw iA;
  const oA = Te.useRef(null);
  cu(() => {
    const J = x.current;
    v.width > 0 && v.height > 0 && J && (oA.current || (oA.current = H3(J)), oA.current.configure({
      gl: n,
      events: r,
      shadows: I,
      linear: E,
      flat: C,
      legacy: c,
      orthographic: u,
      frameloop: d,
      dpr: p,
      performance: D,
      raycaster: f,
      camera: S,
      size: v,
      // Pass mutable reference to onPointerMissed so it's free to update
      onPointerMissed: (...tA) => _.current == null ? void 0 : _.current(...tA),
      onCreated: (tA) => {
        tA.events.connect == null || tA.events.connect(s ? m3(s) ? s.current : s : H.current), B && tA.setEvents({
          compute: (Y, rA) => {
            const QA = Y[B + "X"], aA = Y[B + "Y"];
            rA.pointer.set(QA / rA.size.width * 2 - 1, -(aA / rA.size.height) * 2 + 1), rA.raycaster.setFromCamera(rA.pointer, rA.camera);
          }
        }), m?.(tA);
      }
    }), oA.current.render(/* @__PURE__ */ Te.createElement(G, null, /* @__PURE__ */ Te.createElement(UU, {
      set: eA
    }, /* @__PURE__ */ Te.createElement(Te.Suspense, {
      fallback: /* @__PURE__ */ Te.createElement(S3, {
        set: V
      })
    }, A)))));
  }), Te.useEffect(() => {
    const J = x.current;
    if (J)
      return () => _U(J);
  }, []);
  const P = s ? "none" : "auto";
  return /* @__PURE__ */ Te.createElement("div", OC({
    ref: H,
    style: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: P,
      ...i
    }
  }, N), /* @__PURE__ */ Te.createElement("div", {
    ref: k,
    style: {
      width: "100%",
      height: "100%"
    }
  }, /* @__PURE__ */ Te.createElement("canvas", {
    ref: x,
    style: {
      display: "block"
    }
  }, e)));
}), g4 = /* @__PURE__ */ Te.forwardRef(function(A, e) {
  return /* @__PURE__ */ Te.createElement(PU, null, /* @__PURE__ */ Te.createElement(n4, OC({}, A, {
    ref: e
  })));
}), uu = new IA(), Im = new IA(), r4 = new IA();
function o4(g, A, e) {
  const t = uu.setFromMatrixPosition(g.matrixWorld);
  t.project(A);
  const i = e.width / 2, n = e.height / 2;
  return [t.x * i + i, -(t.y * n) + n];
}
function s4(g, A) {
  const e = uu.setFromMatrixPosition(g.matrixWorld), t = Im.setFromMatrixPosition(A.matrixWorld), i = e.sub(t), n = A.getWorldDirection(r4);
  return i.angleTo(n) > Math.PI / 2;
}
function a4(g, A, e, t) {
  const i = uu.setFromMatrixPosition(g.matrixWorld), n = i.clone();
  n.project(A), e.setFromCamera(n, A);
  const r = e.intersectObjects(t, !0);
  if (r.length) {
    const s = r[0].distance;
    return i.distanceTo(e.ray.origin) < s;
  }
  return !0;
}
function I4(g, A) {
  if (A instanceof $a)
    return A.zoom;
  if (A instanceof mn) {
    const e = uu.setFromMatrixPosition(g.matrixWorld), t = Im.setFromMatrixPosition(A.matrixWorld), i = A.fov * Math.PI / 180, n = e.distanceTo(t);
    return 1 / (2 * Math.tan(i / 2) * n);
  } else
    return 1;
}
function B4(g, A, e) {
  if (A instanceof mn || A instanceof $a) {
    const t = uu.setFromMatrixPosition(g.matrixWorld), i = Im.setFromMatrixPosition(A.matrixWorld), n = t.distanceTo(i), r = (e[1] - e[0]) / (A.far - A.near), s = e[1] - r * A.far;
    return Math.round(r * n + s);
  }
}
const Ay = (g) => Math.abs(g) < 1e-10 ? 0 : g;
function WU(g, A, e = "") {
  let t = "matrix3d(";
  for (let i = 0; i !== 16; i++)
    t += Ay(A[i] * g.elements[i]) + (i !== 15 ? "," : ")");
  return e + t;
}
const C4 = ((g) => (A) => WU(A, g))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), Q4 = ((g) => (A, e) => WU(A, g(e), "translate(-50%,-50%)"))((g) => [1 / g, 1 / g, 1 / g, 1, -1 / g, -1 / g, -1 / g, -1, 1 / g, 1 / g, 1 / g, 1, 1, 1, 1, 1]);
function E4(g) {
  return g && typeof g == "object" && "current" in g;
}
const l4 = /* @__PURE__ */ Te.forwardRef(({
  children: g,
  eps: A = 1e-3,
  style: e,
  className: t,
  prepend: i,
  center: n,
  fullscreen: r,
  portal: s,
  distanceFactor: B,
  sprite: I = !1,
  transform: E = !1,
  occlude: C,
  onOcclude: c,
  castShadow: u,
  receiveShadow: d,
  material: p,
  geometry: D,
  zIndexRange: f = [16777271, 0],
  calculatePosition: S = o4,
  as: y = "div",
  wrapperClass: m,
  pointerEvents: N = "auto",
  ...F
}, G) => {
  const {
    gl: k,
    camera: v,
    scene: x,
    size: H,
    raycaster: _,
    events: j,
    viewport: V
  } = mr(), [iA] = Te.useState(() => document.createElement(y)), eA = Te.useRef(), oA = Te.useRef(null), P = Te.useRef(0), J = Te.useRef([0, 0]), tA = Te.useRef(null), Y = Te.useRef(null), rA = s?.current || j.connected || k.domElement.parentNode, QA = Te.useRef(null), aA = Te.useRef(!1), MA = Te.useMemo(() => C && C !== "blending" || Array.isArray(C) && C.length && E4(C[0]), [C]);
  Te.useLayoutEffect(() => {
    const kA = k.domElement;
    C && C === "blending" ? (kA.style.zIndex = `${Math.floor(f[0] / 2)}`, kA.style.position = "absolute", kA.style.pointerEvents = "none") : (kA.style.zIndex = null, kA.style.position = null, kA.style.pointerEvents = null);
  }, [C]), Te.useLayoutEffect(() => {
    if (oA.current) {
      const kA = eA.current = Vw(iA);
      if (x.updateMatrixWorld(), E)
        iA.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
      else {
        const FA = S(oA.current, v, H);
        iA.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${FA[0]}px,${FA[1]}px,0);transform-origin:0 0;`;
      }
      return rA && (i ? rA.prepend(iA) : rA.appendChild(iA)), () => {
        rA && rA.removeChild(iA), kA.unmount();
      };
    }
  }, [rA, E]), Te.useLayoutEffect(() => {
    m && (iA.className = m);
  }, [m]);
  const hA = Te.useMemo(() => E ? {
    position: "absolute",
    top: 0,
    left: 0,
    width: H.width,
    height: H.height,
    transformStyle: "preserve-3d",
    pointerEvents: "none"
  } : {
    position: "absolute",
    transform: n ? "translate3d(-50%,-50%,0)" : "none",
    ...r && {
      top: -H.height / 2,
      left: -H.width / 2,
      width: H.width,
      height: H.height
    },
    ...e
  }, [e, n, r, H, E]), fA = Te.useMemo(() => ({
    position: "absolute",
    pointerEvents: N
  }), [N]);
  Te.useLayoutEffect(() => {
    if (aA.current = !1, E) {
      var kA;
      (kA = eA.current) == null || kA.render(/* @__PURE__ */ Te.createElement("div", {
        ref: tA,
        style: hA
      }, /* @__PURE__ */ Te.createElement("div", {
        ref: Y,
        style: fA
      }, /* @__PURE__ */ Te.createElement("div", {
        ref: G,
        className: t,
        style: e,
        children: g
      }))));
    } else {
      var FA;
      (FA = eA.current) == null || FA.render(/* @__PURE__ */ Te.createElement("div", {
        ref: G,
        style: hA,
        className: t,
        children: g
      }));
    }
  });
  const wA = Te.useRef(!0);
  qE((kA) => {
    if (oA.current) {
      v.updateMatrixWorld(), oA.current.updateWorldMatrix(!0, !1);
      const FA = E ? J.current : S(oA.current, v, H);
      if (E || Math.abs(P.current - v.zoom) > A || Math.abs(J.current[0] - FA[0]) > A || Math.abs(J.current[1] - FA[1]) > A) {
        const dA = s4(oA.current, v);
        let vA = !1;
        MA && (C !== "blending" ? vA = [x] : Array.isArray(C) && (vA = C.map((pe) => pe.current)));
        const JA = wA.current;
        if (vA) {
          const pe = a4(oA.current, v, _, vA);
          wA.current = pe && !dA;
        } else
          wA.current = !dA;
        JA !== wA.current && (c ? c(!wA.current) : iA.style.display = wA.current ? "block" : "none");
        const ne = Math.floor(f[0] / 2), ee = C ? MA ? [f[0], ne] : [ne - 1, 0] : f;
        if (iA.style.zIndex = `${B4(oA.current, v, ee)}`, E) {
          const [pe, Ae] = [H.width / 2, H.height / 2], ie = v.projectionMatrix.elements[5] * Ae, {
            isOrthographicCamera: de,
            top: O,
            left: AA,
            bottom: q,
            right: Z
          } = v, $ = C4(v.matrixWorldInverse), BA = de ? `scale(${ie})translate(${Ay(-(Z + AA) / 2)}px,${Ay((O + q) / 2)}px)` : `translateZ(${ie}px)`;
          let GA = oA.current.matrixWorld;
          I && (GA = v.matrixWorldInverse.clone().transpose().copyPosition(GA).scale(oA.current.scale), GA.elements[3] = GA.elements[7] = GA.elements[11] = 0, GA.elements[15] = 1), iA.style.width = H.width + "px", iA.style.height = H.height + "px", iA.style.perspective = de ? "" : `${ie}px`, tA.current && Y.current && (tA.current.style.transform = `${BA}${$}translate(${pe}px,${Ae}px)`, Y.current.style.transform = Q4(GA, 1 / ((B || 10) / 400)));
        } else {
          const pe = B === void 0 ? 1 : I4(oA.current, v) * B;
          iA.style.transform = `translate3d(${FA[0]}px,${FA[1]}px,0) scale(${pe})`;
        }
        J.current = FA, P.current = v.zoom;
      }
    }
    if (!MA && QA.current && !aA.current)
      if (E) {
        if (tA.current) {
          const FA = tA.current.children[0];
          if (FA != null && FA.clientWidth && FA != null && FA.clientHeight) {
            const {
              isOrthographicCamera: dA
            } = v;
            if (dA || D)
              F.scale && (Array.isArray(F.scale) ? F.scale instanceof IA ? QA.current.scale.copy(F.scale.clone().divideScalar(1)) : QA.current.scale.set(1 / F.scale[0], 1 / F.scale[1], 1 / F.scale[2]) : QA.current.scale.setScalar(1 / F.scale));
            else {
              const vA = (B || 10) / 400, JA = FA.clientWidth * vA, ne = FA.clientHeight * vA;
              QA.current.scale.set(JA, ne, 1);
            }
            aA.current = !0;
          }
        }
      } else {
        const FA = iA.children[0];
        if (FA != null && FA.clientWidth && FA != null && FA.clientHeight) {
          const dA = 1 / V.factor, vA = FA.clientWidth * dA, JA = FA.clientHeight * dA;
          QA.current.scale.set(vA, JA, 1), aA.current = !0;
        }
        QA.current.lookAt(kA.camera.position);
      }
  });
  const yA = Te.useMemo(() => ({
    vertexShader: E ? void 0 : (
      /* glsl */
      `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `
    ),
    fragmentShader: (
      /* glsl */
      `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `
    )
  }), [E]);
  return /* @__PURE__ */ Te.createElement("group", OC({}, F, {
    ref: oA
  }), C && !MA && /* @__PURE__ */ Te.createElement("mesh", {
    castShadow: u,
    receiveShadow: d,
    ref: QA
  }, D || /* @__PURE__ */ Te.createElement("planeGeometry", null), p || /* @__PURE__ */ Te.createElement("shaderMaterial", {
    side: Rr,
    vertexShader: yA.vertexShader,
    fragmentShader: yA.fragmentShader
  })));
});
let Ec = 0;
const c4 = SU((g) => (pE.onStart = (A, e, t) => {
  g({
    active: !0,
    item: A,
    loaded: e,
    total: t,
    progress: (e - Ec) / (t - Ec) * 100
  });
}, pE.onLoad = () => {
  g({
    active: !1
  });
}, pE.onError = (A) => g((e) => ({
  errors: [...e.errors, A]
})), pE.onProgress = (A, e, t) => {
  e === t && (Ec = t), g({
    active: !0,
    item: A,
    loaded: e,
    total: t,
    progress: (e - Ec) / (t - Ec) * 100 || 100
  });
}, {
  errors: [],
  active: !1,
  progress: 0,
  item: "",
  loaded: 0,
  total: 0
}));
function u4(g) {
  return function(A) {
    g.forEach(function(e) {
      typeof e == "function" ? e(A) : e != null && (e.current = A);
    });
  };
}
function h4(g, A, e) {
  return Math.max(A, Math.min(g, e));
}
const Yg = {
  toVector(g, A) {
    return g === void 0 && (g = A), Array.isArray(g) ? g : [g, g];
  },
  add(g, A) {
    return [g[0] + A[0], g[1] + A[1]];
  },
  sub(g, A) {
    return [g[0] - A[0], g[1] - A[1]];
  },
  addTo(g, A) {
    g[0] += A[0], g[1] += A[1];
  },
  subTo(g, A) {
    g[0] -= A[0], g[1] -= A[1];
  }
};
function EF(g, A, e) {
  return A === 0 || Math.abs(A) === 1 / 0 ? Math.pow(g, e * 5) : g * A * e / (A + e * g);
}
function lF(g, A, e, t = 0.15) {
  return t === 0 ? h4(g, A, e) : g < A ? -EF(A - g, e - A, t) + A : g > e ? +EF(g - e, e - A, t) + e : g;
}
function d4(g, [A, e], [t, i]) {
  const [[n, r], [s, B]] = g;
  return [lF(A, n, r, t), lF(e, s, B, i)];
}
function f4(g, A) {
  if (typeof g != "object" || g === null)
    return g;
  var e = g[Symbol.toPrimitive];
  if (e !== void 0) {
    var t = e.call(g, A || "default");
    if (typeof t != "object")
      return t;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (A === "string" ? String : Number)(g);
}
function p4(g) {
  var A = f4(g, "string");
  return typeof A == "symbol" ? A : String(A);
}
function yr(g, A, e) {
  return A = p4(A), A in g ? Object.defineProperty(g, A, {
    value: e,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : g[A] = e, g;
}
function cF(g, A) {
  var e = Object.keys(g);
  if (Object.getOwnPropertySymbols) {
    var t = Object.getOwnPropertySymbols(g);
    A && (t = t.filter(function(i) {
      return Object.getOwnPropertyDescriptor(g, i).enumerable;
    })), e.push.apply(e, t);
  }
  return e;
}
function dn(g) {
  for (var A = 1; A < arguments.length; A++) {
    var e = arguments[A] != null ? arguments[A] : {};
    A % 2 ? cF(Object(e), !0).forEach(function(t) {
      yr(g, t, e[t]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(g, Object.getOwnPropertyDescriptors(e)) : cF(Object(e)).forEach(function(t) {
      Object.defineProperty(g, t, Object.getOwnPropertyDescriptor(e, t));
    });
  }
  return g;
}
const zU = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function uF(g) {
  return g ? g[0].toUpperCase() + g.slice(1) : "";
}
const D4 = ["enter", "leave"];
function w4(g = !1, A) {
  return g && !D4.includes(A);
}
function y4(g, A = "", e = !1) {
  const t = zU[g], i = t && t[A] || A;
  return "on" + uF(g) + uF(i) + (w4(e, i) ? "Capture" : "");
}
const m4 = ["gotpointercapture", "lostpointercapture"];
function S4(g) {
  let A = g.substring(2).toLowerCase();
  const e = !!~A.indexOf("passive");
  e && (A = A.replace("passive", ""));
  const t = m4.includes(A) ? "capturecapture" : "capture", i = !!~A.indexOf(t);
  return i && (A = A.replace("capture", "")), {
    device: A,
    capture: i,
    passive: e
  };
}
function M4(g, A = "") {
  const e = zU[g], t = e && e[A] || A;
  return g + t;
}
function _f(g) {
  return "touches" in g;
}
function VU(g) {
  return _f(g) ? "touch" : "pointerType" in g ? g.pointerType : "mouse";
}
function R4(g) {
  return Array.from(g.touches).filter((A) => {
    var e, t;
    return A.target === g.currentTarget || ((e = g.currentTarget) === null || e === void 0 || (t = e.contains) === null || t === void 0 ? void 0 : t.call(e, A.target));
  });
}
function N4(g) {
  return g.type === "touchend" || g.type === "touchcancel" ? g.changedTouches : g.targetTouches;
}
function jU(g) {
  return _f(g) ? N4(g)[0] : g;
}
function F4(g) {
  return R4(g).map((A) => A.identifier);
}
function H0(g) {
  const A = jU(g);
  return _f(g) ? A.identifier : A.pointerId;
}
function hF(g) {
  const A = jU(g);
  return [A.clientX, A.clientY];
}
function G4(g) {
  const A = {};
  if ("buttons" in g && (A.buttons = g.buttons), "shiftKey" in g) {
    const {
      shiftKey: e,
      altKey: t,
      metaKey: i,
      ctrlKey: n
    } = g;
    Object.assign(A, {
      shiftKey: e,
      altKey: t,
      metaKey: i,
      ctrlKey: n
    });
  }
  return A;
}
function cf(g, ...A) {
  return typeof g == "function" ? g(...A) : g;
}
function v4() {
}
function U4(...g) {
  return g.length === 0 ? v4 : g.length === 1 ? g[0] : function() {
    let A;
    for (const e of g)
      A = e.apply(this, arguments) || A;
    return A;
  };
}
function dF(g, A) {
  return Object.assign({}, A, g || {});
}
const k4 = 32;
class x4 {
  constructor(A, e, t) {
    this.ctrl = A, this.args = e, this.key = t, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset());
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(A) {
    this.ctrl.state[this.key] = A;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state: A,
      shared: e,
      ingKey: t,
      args: i
    } = this;
    e[t] = A._active = A.active = A._blocked = A._force = !1, A._step = [!1, !1], A.intentional = !1, A._movement = [0, 0], A._distance = [0, 0], A._direction = [0, 0], A._delta = [0, 0], A._bounds = [[-1 / 0, 1 / 0], [-1 / 0, 1 / 0]], A.args = i, A.axis = void 0, A.memo = void 0, A.elapsedTime = 0, A.direction = [0, 0], A.distance = [0, 0], A.overflow = [0, 0], A._movementBound = [!1, !1], A.velocity = [0, 0], A.movement = [0, 0], A.delta = [0, 0], A.timeStamp = 0;
  }
  start(A) {
    const e = this.state, t = this.config;
    e._active || (this.reset(), this.computeInitial(), e._active = !0, e.target = A.target, e.currentTarget = A.currentTarget, e.lastOffset = t.from ? cf(t.from, e) : e.offset, e.offset = e.lastOffset, e.startTime = e.timeStamp = A.timeStamp);
  }
  computeValues(A) {
    const e = this.state;
    e._values = A, e.values = this.config.transform(A);
  }
  computeInitial() {
    const A = this.state;
    A._initial = A._values, A.initial = A.values;
  }
  compute(A) {
    const {
      state: e,
      config: t,
      shared: i
    } = this;
    e.args = this.args;
    let n = 0;
    if (A && (e.event = A, t.preventDefault && A.cancelable && e.event.preventDefault(), e.type = A.type, i.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, i.locked = !!document.pointerLockElement, Object.assign(i, G4(A)), i.down = i.pressed = i.buttons % 2 === 1 || i.touches > 0, n = A.timeStamp - e.timeStamp, e.timeStamp = A.timeStamp, e.elapsedTime = e.timeStamp - e.startTime), e._active) {
      const F = e._delta.map(Math.abs);
      Yg.addTo(e._distance, F);
    }
    this.axisIntent && this.axisIntent(A);
    const [r, s] = e._movement, [B, I] = t.threshold, {
      _step: E,
      values: C
    } = e;
    if (t.hasCustomTransform ? (E[0] === !1 && (E[0] = Math.abs(r) >= B && C[0]), E[1] === !1 && (E[1] = Math.abs(s) >= I && C[1])) : (E[0] === !1 && (E[0] = Math.abs(r) >= B && Math.sign(r) * B), E[1] === !1 && (E[1] = Math.abs(s) >= I && Math.sign(s) * I)), e.intentional = E[0] !== !1 || E[1] !== !1, !e.intentional)
      return;
    const c = [0, 0];
    if (t.hasCustomTransform) {
      const [F, G] = C;
      c[0] = E[0] !== !1 ? F - E[0] : 0, c[1] = E[1] !== !1 ? G - E[1] : 0;
    } else
      c[0] = E[0] !== !1 ? r - E[0] : 0, c[1] = E[1] !== !1 ? s - E[1] : 0;
    this.restrictToAxis && !e._blocked && this.restrictToAxis(c);
    const u = e.offset, d = e._active && !e._blocked || e.active;
    d && (e.first = e._active && !e.active, e.last = !e._active && e.active, e.active = i[this.ingKey] = e._active, A && (e.first && ("bounds" in t && (e._bounds = cf(t.bounds, e)), this.setup && this.setup()), e.movement = c, this.computeOffset()));
    const [p, D] = e.offset, [[f, S], [y, m]] = e._bounds;
    e.overflow = [p < f ? -1 : p > S ? 1 : 0, D < y ? -1 : D > m ? 1 : 0], e._movementBound[0] = e.overflow[0] ? e._movementBound[0] === !1 ? e._movement[0] : e._movementBound[0] : !1, e._movementBound[1] = e.overflow[1] ? e._movementBound[1] === !1 ? e._movement[1] : e._movementBound[1] : !1;
    const N = e._active ? t.rubberband || [0, 0] : [0, 0];
    if (e.offset = d4(e._bounds, e.offset, N), e.delta = Yg.sub(e.offset, u), this.computeMovement(), d && (!e.last || n > k4)) {
      e.delta = Yg.sub(e.offset, u);
      const F = e.delta.map(Math.abs);
      Yg.addTo(e.distance, F), e.direction = e.delta.map(Math.sign), e._direction = e._delta.map(Math.sign), !e.first && n > 0 && (e.velocity = [F[0] / n, F[1] / n]);
    }
  }
  emit() {
    const A = this.state, e = this.shared, t = this.config;
    if (A._active || this.clean(), (A._blocked || !A.intentional) && !A._force && !t.triggerAllEvents)
      return;
    const i = this.handler(dn(dn(dn({}, e), A), {}, {
      [this.aliasKey]: A.values
    }));
    i !== void 0 && (A.memo = i);
  }
  clean() {
    this.eventStore.clean(), this.timeoutStore.clean();
  }
}
function L4([g, A], e) {
  const t = Math.abs(g), i = Math.abs(A);
  if (t > i && t > e)
    return "x";
  if (i > t && i > e)
    return "y";
}
class T4 extends x4 {
  constructor(...A) {
    super(...A), yr(this, "aliasKey", "xy");
  }
  reset() {
    super.reset(), this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0], this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = Yg.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = Yg.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(A) {
    const e = this.state, t = this.config;
    if (!e.axis && A) {
      const i = typeof t.axisThreshold == "object" ? t.axisThreshold[VU(A)] : t.axisThreshold;
      e.axis = L4(e._movement, i);
    }
    e._blocked = (t.lockDirection || !!t.axis) && !e.axis || !!t.axis && t.axis !== e.axis;
  }
  restrictToAxis(A) {
    if (this.config.axis || this.config.lockDirection)
      switch (this.state.axis) {
        case "x":
          A[1] = 0;
          break;
        case "y":
          A[0] = 0;
          break;
      }
  }
}
const fF = (g) => g, pF = 0.15, Bm = {
  enabled(g = !0) {
    return g;
  },
  eventOptions(g, A, e) {
    return dn(dn({}, e.shared.eventOptions), g);
  },
  preventDefault(g = !1) {
    return g;
  },
  triggerAllEvents(g = !1) {
    return g;
  },
  rubberband(g = 0) {
    switch (g) {
      case !0:
        return [pF, pF];
      case !1:
        return [0, 0];
      default:
        return Yg.toVector(g);
    }
  },
  from(g) {
    if (typeof g == "function")
      return g;
    if (g != null)
      return Yg.toVector(g);
  },
  transform(g, A, e) {
    const t = g || e.shared.transform;
    if (this.hasCustomTransform = !!t, process.env.NODE_ENV === "development") {
      const i = t || fF;
      return (n) => {
        const r = i(n);
        return (!isFinite(r[0]) || !isFinite(r[1])) && console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`), r;
      };
    }
    return t || fF;
  },
  threshold(g) {
    return Yg.toVector(g, 0);
  }
};
process.env.NODE_ENV === "development" && Object.assign(Bm, {
  domTarget(g) {
    if (g !== void 0)
      throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
    return NaN;
  },
  lockDirection(g) {
    if (g !== void 0)
      throw Error("[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`");
    return NaN;
  },
  initial(g) {
    if (g !== void 0)
      throw Error("[@use-gesture]: `initial` option has been renamed to `from`.");
    return NaN;
  }
});
const K4 = 0, hu = dn(dn({}, Bm), {}, {
  axis(g, A, {
    axis: e
  }) {
    if (this.lockDirection = e === "lock", !this.lockDirection)
      return e;
  },
  axisThreshold(g = K4) {
    return g;
  },
  bounds(g = {}) {
    if (typeof g == "function")
      return (n) => hu.bounds(g(n));
    if ("current" in g)
      return () => g.current;
    if (typeof HTMLElement == "function" && g instanceof HTMLElement)
      return g;
    const {
      left: A = -1 / 0,
      right: e = 1 / 0,
      top: t = -1 / 0,
      bottom: i = 1 / 0
    } = g;
    return [[A, e], [t, i]];
  }
}), DF = {
  ArrowRight: (g, A = 1) => [g * A, 0],
  ArrowLeft: (g, A = 1) => [-1 * g * A, 0],
  ArrowUp: (g, A = 1) => [0, -1 * g * A],
  ArrowDown: (g, A = 1) => [0, g * A]
};
class b4 extends T4 {
  constructor(...A) {
    super(...A), yr(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const A = this.state;
    A._pointerId = void 0, A._pointerActive = !1, A._keyboardActive = !1, A._preventScroll = !1, A._delayed = !1, A.swipe = [0, 0], A.tap = !1, A.canceled = !1, A.cancel = this.cancel.bind(this);
  }
  setup() {
    const A = this.state;
    if (A._bounds instanceof HTMLElement) {
      const e = A._bounds.getBoundingClientRect(), t = A.currentTarget.getBoundingClientRect(), i = {
        left: e.left - t.left + A.offset[0],
        right: e.right - t.right + A.offset[0],
        top: e.top - t.top + A.offset[1],
        bottom: e.bottom - t.bottom + A.offset[1]
      };
      A._bounds = hu.bounds(i);
    }
  }
  cancel() {
    const A = this.state;
    A.canceled || (A.canceled = !0, A._active = !1, setTimeout(() => {
      this.compute(), this.emit();
    }, 0));
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean(), this.state._pointerActive = !1, this.state._keyboardActive = !1, super.clean();
  }
  pointerDown(A) {
    const e = this.config, t = this.state;
    if (A.buttons != null && (Array.isArray(e.pointerButtons) ? !e.pointerButtons.includes(A.buttons) : e.pointerButtons !== -1 && e.pointerButtons !== A.buttons))
      return;
    const i = this.ctrl.setEventIds(A);
    e.pointerCapture && A.target.setPointerCapture(A.pointerId), !(i && i.size > 1 && t._pointerActive) && (this.start(A), this.setupPointer(A), t._pointerId = H0(A), t._pointerActive = !0, this.computeValues(hF(A)), this.computeInitial(), e.preventScrollAxis && VU(A) !== "mouse" ? (t._active = !1, this.setupScrollPrevention(A)) : e.delay > 0 ? (this.setupDelayTrigger(A), e.triggerAllEvents && (this.compute(A), this.emit())) : this.startPointerDrag(A));
  }
  startPointerDrag(A) {
    const e = this.state;
    e._active = !0, e._preventScroll = !0, e._delayed = !1, this.compute(A), this.emit();
  }
  pointerMove(A) {
    const e = this.state, t = this.config;
    if (!e._pointerActive || e.type === A.type && A.timeStamp === e.timeStamp)
      return;
    const i = H0(A);
    if (e._pointerId !== void 0 && i !== e._pointerId)
      return;
    const n = hF(A);
    if (document.pointerLockElement === A.target ? e._delta = [A.movementX, A.movementY] : (e._delta = Yg.sub(n, e._values), this.computeValues(n)), Yg.addTo(e._movement, e._delta), this.compute(A), e._delayed && e.intentional) {
      this.timeoutStore.remove("dragDelay"), e.active = !1, this.startPointerDrag(A);
      return;
    }
    if (t.preventScrollAxis && !e._preventScroll)
      if (e.axis)
        if (e.axis === t.preventScrollAxis || t.preventScrollAxis === "xy") {
          e._active = !1, this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag"), this.startPointerDrag(A);
          return;
        }
      else
        return;
    this.emit();
  }
  pointerUp(A) {
    this.ctrl.setEventIds(A);
    try {
      this.config.pointerCapture && A.target.hasPointerCapture(A.pointerId) && A.target.releasePointerCapture(A.pointerId);
    } catch {
      process.env.NODE_ENV === "development" && console.warn("[@use-gesture]: If you see this message, it's likely that you're using an outdated version of `@react-three/fiber`. \n\nPlease upgrade to the latest version.");
    }
    const e = this.state, t = this.config;
    if (!e._active || !e._pointerActive)
      return;
    const i = H0(A);
    if (e._pointerId !== void 0 && i !== e._pointerId)
      return;
    this.state._pointerActive = !1, this.setActive(), this.compute(A);
    const [n, r] = e._distance;
    if (e.tap = n <= t.tapsThreshold && r <= t.tapsThreshold, e.tap && t.filterTaps)
      e._force = !0;
    else {
      const [s, B] = e.direction, [I, E] = e.velocity, [C, c] = e.movement, [u, d] = t.swipe.velocity, [p, D] = t.swipe.distance, f = t.swipe.duration;
      e.elapsedTime < f && (Math.abs(I) > u && Math.abs(C) > p && (e.swipe[0] = s), Math.abs(E) > d && Math.abs(c) > D && (e.swipe[1] = B));
    }
    this.emit();
  }
  pointerClick(A) {
    !this.state.tap && A.detail > 0 && (A.preventDefault(), A.stopPropagation());
  }
  setupPointer(A) {
    const e = this.config, t = e.device;
    if (process.env.NODE_ENV === "development")
      try {
        if (t === "pointer" && e.preventScrollDelay === void 0) {
          const i = "uv" in A ? A.sourceEvent.currentTarget : A.currentTarget;
          window.getComputedStyle(i).touchAction === "auto" && console.warn("[@use-gesture]: The drag target has its `touch-action` style property set to `auto`. It is recommended to add `touch-action: 'none'` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\n\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.", i);
        }
      } catch {
      }
    e.pointerLock && A.currentTarget.requestPointerLock(), e.pointerCapture || (this.eventStore.add(this.sharedConfig.window, t, "change", this.pointerMove.bind(this)), this.eventStore.add(this.sharedConfig.window, t, "end", this.pointerUp.bind(this)), this.eventStore.add(this.sharedConfig.window, t, "cancel", this.pointerUp.bind(this)));
  }
  pointerClean() {
    this.config.pointerLock && document.pointerLockElement === this.state.currentTarget && document.exitPointerLock();
  }
  preventScroll(A) {
    this.state._preventScroll && A.cancelable && A.preventDefault();
  }
  setupScrollPrevention(A) {
    this.state._preventScroll = !1, Y4(A);
    const e = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: !1
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", e), this.eventStore.add(this.sharedConfig.window, "touch", "cancel", e), this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, A);
  }
  setupDelayTrigger(A) {
    this.state._delayed = !0, this.timeoutStore.add("dragDelay", () => {
      this.state._step = [0, 0], this.startPointerDrag(A);
    }, this.config.delay);
  }
  keyDown(A) {
    const e = DF[A.key];
    if (e) {
      const t = this.state, i = A.shiftKey ? 10 : A.altKey ? 0.1 : 1;
      this.start(A), t._delta = e(this.config.keyboardDisplacement, i), t._keyboardActive = !0, Yg.addTo(t._movement, t._delta), this.compute(A), this.emit();
    }
  }
  keyUp(A) {
    A.key in DF && (this.state._keyboardActive = !1, this.setActive(), this.compute(A), this.emit());
  }
  bind(A) {
    const e = this.config.device;
    A(e, "start", this.pointerDown.bind(this)), this.config.pointerCapture && (A(e, "change", this.pointerMove.bind(this)), A(e, "end", this.pointerUp.bind(this)), A(e, "cancel", this.pointerUp.bind(this)), A("lostPointerCapture", "", this.pointerUp.bind(this))), this.config.keys && (A("key", "down", this.keyDown.bind(this)), A("key", "up", this.keyUp.bind(this))), this.config.filterTaps && A("click", "", this.pointerClick.bind(this), {
      capture: !0,
      passive: !1
    });
  }
}
function Y4(g) {
  "persist" in g && typeof g.persist == "function" && g.persist();
}
const du = typeof window < "u" && window.document && window.document.createElement;
function H4() {
  return du && "ontouchstart" in window;
}
function wF() {
  return H4() || du && window.navigator.maxTouchPoints > 1;
}
function _4() {
  return du && "onpointerdown" in window;
}
function J4() {
  return du && "exitPointerLock" in window.document;
}
function O4() {
  try {
    return "constructor" in GestureEvent;
  } catch {
    return !1;
  }
}
const Go = {
  isBrowser: du,
  gesture: O4(),
  touch: wF(),
  touchscreen: wF(),
  pointer: _4(),
  pointerLock: J4()
}, q4 = 250, P4 = 180, W4 = 0.5, z4 = 50, V4 = 250, j4 = 10, yF = {
  mouse: 0,
  touch: 0,
  pen: 8
}, ZU = dn(dn({}, hu), {}, {
  device(g, A, {
    pointer: {
      touch: e = !1,
      lock: t = !1,
      mouse: i = !1
    } = {}
  }) {
    return this.pointerLock = t && Go.pointerLock, Go.touch && e ? "touch" : this.pointerLock ? "mouse" : Go.pointer && !i ? "pointer" : Go.touch ? "touch" : "mouse";
  },
  preventScrollAxis(g, A, {
    preventScroll: e
  }) {
    if (this.preventScrollDelay = typeof e == "number" ? e : e || e === void 0 && g ? q4 : void 0, !(!Go.touchscreen || e === !1))
      return g || (e !== void 0 ? "y" : void 0);
  },
  pointerCapture(g, A, {
    pointer: {
      capture: e = !0,
      buttons: t = 1,
      keys: i = !0
    } = {}
  }) {
    return this.pointerButtons = t, this.keys = i, !this.pointerLock && this.device === "pointer" && e;
  },
  threshold(g, A, {
    filterTaps: e = !1,
    tapsThreshold: t = 3,
    axis: i = void 0
  }) {
    const n = Yg.toVector(g, e ? t : i ? 1 : 0);
    return this.filterTaps = e, this.tapsThreshold = t, n;
  },
  swipe({
    velocity: g = W4,
    distance: A = z4,
    duration: e = V4
  } = {}) {
    return {
      velocity: this.transform(Yg.toVector(g)),
      distance: this.transform(Yg.toVector(A)),
      duration: e
    };
  },
  delay(g = 0) {
    switch (g) {
      case !0:
        return P4;
      case !1:
        return 0;
      default:
        return g;
    }
  },
  axisThreshold(g) {
    return g ? dn(dn({}, yF), g) : yF;
  },
  keyboardDisplacement(g = j4) {
    return g;
  }
});
process.env.NODE_ENV === "development" && Object.assign(ZU, {
  useTouch(g) {
    if (g !== void 0)
      throw Error("[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.");
    return NaN;
  },
  experimental_preventWindowScrollY(g) {
    if (g !== void 0)
      throw Error("[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.");
    return NaN;
  },
  swipeVelocity(g) {
    if (g !== void 0)
      throw Error("[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.");
    return NaN;
  },
  swipeDistance(g) {
    if (g !== void 0)
      throw Error("[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.");
    return NaN;
  },
  swipeDuration(g) {
    if (g !== void 0)
      throw Error("[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.");
    return NaN;
  }
});
dn(dn({}, Bm), {}, {
  device(g, A, {
    shared: e,
    pointer: {
      touch: t = !1
    } = {}
  }) {
    if (e.target && !Go.touch && Go.gesture)
      return "gesture";
    if (Go.touch && t)
      return "touch";
    if (Go.touchscreen) {
      if (Go.pointer)
        return "pointer";
      if (Go.touch)
        return "touch";
    }
  },
  bounds(g, A, {
    scaleBounds: e = {},
    angleBounds: t = {}
  }) {
    const i = (r) => {
      const s = dF(cf(e, r), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [s.min, s.max];
    }, n = (r) => {
      const s = dF(cf(t, r), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [s.min, s.max];
    };
    return typeof e != "function" && typeof t != "function" ? [i(), n()] : (r) => [i(r), n(r)];
  },
  threshold(g, A, e) {
    return this.lockDirection = e.axis === "lock", Yg.toVector(g, this.lockDirection ? [0.1, 3] : 0);
  },
  modifierKey(g) {
    return g === void 0 ? "ctrlKey" : g;
  },
  pinchOnWheel(g = !0) {
    return g;
  }
});
dn(dn({}, hu), {}, {
  mouseOnly: (g = !0) => g
});
dn(dn({}, hu), {}, {
  mouseOnly: (g = !0) => g
});
const XU = /* @__PURE__ */ new Map(), ey = /* @__PURE__ */ new Map();
function Z4(g) {
  XU.set(g.key, g.engine), ey.set(g.key, g.resolver);
}
const X4 = {
  key: "drag",
  engine: b4,
  resolver: ZU
};
function $4(g, A) {
  if (g == null)
    return {};
  var e = {}, t = Object.keys(g), i, n;
  for (n = 0; n < t.length; n++)
    i = t[n], !(A.indexOf(i) >= 0) && (e[i] = g[i]);
  return e;
}
function Aq(g, A) {
  if (g == null)
    return {};
  var e = $4(g, A), t, i;
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(g);
    for (i = 0; i < n.length; i++)
      t = n[i], !(A.indexOf(t) >= 0) && Object.prototype.propertyIsEnumerable.call(g, t) && (e[t] = g[t]);
  }
  return e;
}
const eq = {
  target(g) {
    if (g)
      return () => "current" in g ? g.current : g;
  },
  enabled(g = !0) {
    return g;
  },
  window(g = Go.isBrowser ? window : void 0) {
    return g;
  },
  eventOptions({
    passive: g = !0,
    capture: A = !1
  } = {}) {
    return {
      passive: g,
      capture: A
    };
  },
  transform(g) {
    return g;
  }
}, tq = ["target", "eventOptions", "window", "enabled", "transform"];
function rf(g = {}, A) {
  const e = {};
  for (const [t, i] of Object.entries(A))
    switch (typeof i) {
      case "function":
        if (process.env.NODE_ENV === "development") {
          const n = i.call(e, g[t], t, g);
          Number.isNaN(n) || (e[t] = n);
        } else
          e[t] = i.call(e, g[t], t, g);
        break;
      case "object":
        e[t] = rf(g[t], i);
        break;
      case "boolean":
        i && (e[t] = g[t]);
        break;
    }
  return e;
}
function iq(g, A, e = {}) {
  const t = g, {
    target: i,
    eventOptions: n,
    window: r,
    enabled: s,
    transform: B
  } = t, I = Aq(t, tq);
  if (e.shared = rf({
    target: i,
    eventOptions: n,
    window: r,
    enabled: s,
    transform: B
  }, eq), A) {
    const E = ey.get(A);
    e[A] = rf(dn({
      shared: e.shared
    }, I), E);
  } else
    for (const E in I) {
      const C = ey.get(E);
      if (C)
        e[E] = rf(dn({
          shared: e.shared
        }, I[E]), C);
      else if (process.env.NODE_ENV === "development" && !["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(E)) {
        if (E === "domTarget")
          throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
        console.warn(`[@use-gesture]: Unknown config key \`${E}\` was used. Please read the documentation for further information.`);
      }
    }
  return e;
}
class $U {
  constructor(A, e) {
    yr(this, "_listeners", /* @__PURE__ */ new Set()), this._ctrl = A, this._gestureKey = e;
  }
  add(A, e, t, i, n) {
    const r = this._listeners, s = M4(e, t), B = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}, I = dn(dn({}, B), n);
    A.addEventListener(s, i, I);
    const E = () => {
      A.removeEventListener(s, i, I), r.delete(E);
    };
    return r.add(E), E;
  }
  clean() {
    this._listeners.forEach((A) => A()), this._listeners.clear();
  }
}
class nq {
  constructor() {
    yr(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(A, e, t = 140, ...i) {
    this.remove(A), this._timeouts.set(A, window.setTimeout(e, t, ...i));
  }
  remove(A) {
    const e = this._timeouts.get(A);
    e && window.clearTimeout(e);
  }
  clean() {
    this._timeouts.forEach((A) => void window.clearTimeout(A)), this._timeouts.clear();
  }
}
class gq {
  constructor(A) {
    yr(this, "gestures", /* @__PURE__ */ new Set()), yr(this, "_targetEventStore", new $U(this)), yr(this, "gestureEventStores", {}), yr(this, "gestureTimeoutStores", {}), yr(this, "handlers", {}), yr(this, "config", {}), yr(this, "pointerIds", /* @__PURE__ */ new Set()), yr(this, "touchIds", /* @__PURE__ */ new Set()), yr(this, "state", {
      shared: {
        shiftKey: !1,
        metaKey: !1,
        ctrlKey: !1,
        altKey: !1
      }
    }), rq(this, A);
  }
  setEventIds(A) {
    if (_f(A))
      return this.touchIds = new Set(F4(A)), this.touchIds;
    if ("pointerId" in A)
      return A.type === "pointerup" || A.type === "pointercancel" ? this.pointerIds.delete(A.pointerId) : A.type === "pointerdown" && this.pointerIds.add(A.pointerId), this.pointerIds;
  }
  applyHandlers(A, e) {
    this.handlers = A, this.nativeHandlers = e;
  }
  applyConfig(A, e) {
    this.config = iq(A, e, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const A of this.gestures)
      this.gestureEventStores[A].clean(), this.gestureTimeoutStores[A].clean();
  }
  effect() {
    return this.config.shared.target && this.bind(), () => this._targetEventStore.clean();
  }
  bind(...A) {
    const e = this.config.shared, t = {};
    let i;
    if (!(e.target && (i = e.target(), !i))) {
      if (e.enabled) {
        for (const r of this.gestures) {
          const s = this.config[r], B = mF(t, s.eventOptions, !!i);
          if (s.enabled) {
            const I = XU.get(r);
            new I(this, A, r).bind(B);
          }
        }
        const n = mF(t, e.eventOptions, !!i);
        for (const r in this.nativeHandlers)
          n(r, "", (s) => this.nativeHandlers[r](dn(dn({}, this.state.shared), {}, {
            event: s,
            args: A
          })), void 0, !0);
      }
      for (const n in t)
        t[n] = U4(...t[n]);
      if (!i)
        return t;
      for (const n in t) {
        const {
          device: r,
          capture: s,
          passive: B
        } = S4(n);
        this._targetEventStore.add(i, r, "", t[n], {
          capture: s,
          passive: B
        });
      }
    }
  }
}
function IE(g, A) {
  g.gestures.add(A), g.gestureEventStores[A] = new $U(g, A), g.gestureTimeoutStores[A] = new nq();
}
function rq(g, A) {
  A.drag && IE(g, "drag"), A.wheel && IE(g, "wheel"), A.scroll && IE(g, "scroll"), A.move && IE(g, "move"), A.pinch && IE(g, "pinch"), A.hover && IE(g, "hover");
}
const mF = (g, A, e) => (t, i, n, r = {}, s = !1) => {
  var B, I;
  const E = (B = r.capture) !== null && B !== void 0 ? B : A.capture, C = (I = r.passive) !== null && I !== void 0 ? I : A.passive;
  let c = s ? t : y4(t, i, E);
  e && C && (c += "Passive"), g[c] = g[c] || [], g[c].push(n);
};
function oq(g, A = {}, e, t) {
  const i = qi.useMemo(() => new gq(g), []);
  if (i.applyHandlers(g, t), i.applyConfig(A, e), qi.useEffect(i.effect.bind(i)), qi.useEffect(() => i.clean.bind(i), []), A.target === void 0)
    return i.bind.bind(i);
}
function Ak(g, A) {
  return Z4(X4), oq({
    drag: g
  }, A || {}, "drag");
}
function sq(g, A, e) {
  const {
    gl: t,
    size: i,
    viewport: n
  } = mr(), r = typeof g == "number" ? g : i.width * n.dpr, s = typeof A == "number" ? A : i.height * n.dpr, B = (typeof g == "number" ? e : g) || {}, {
    samples: I = 0,
    depth: E,
    ...C
  } = B, c = Te.useMemo(() => {
    let u;
    return u = new Uo(r, s, {
      minFilter: Gi,
      magFilter: Gi,
      encoding: t.outputEncoding,
      type: xC,
      ...C
    }), E && (u.depthTexture = new Gy(r, s, $s)), u.samples = I, u;
  }, []);
  return Te.useLayoutEffect(() => {
    c.setSize(r, s), I && (c.samples = I);
  }, [I, c, r, s]), Te.useEffect(() => () => c.dispose(), []), c;
}
const aq = (g) => typeof g == "function", Iq = /* @__PURE__ */ Te.forwardRef(({
  envMap: g,
  resolution: A = 256,
  frames: e = 1 / 0,
  makeDefault: t,
  children: i,
  ...n
}, r) => {
  const s = mr(({
    set: D
  }) => D), B = mr(({
    camera: D
  }) => D), I = mr(({
    size: D
  }) => D), E = Te.useRef(null), C = Te.useRef(null), c = sq(A);
  Te.useLayoutEffect(() => {
    n.manual || (E.current.aspect = I.width / I.height);
  }, [I, n]), Te.useLayoutEffect(() => {
    E.current.updateProjectionMatrix();
  });
  let u = 0, d = null;
  const p = aq(i);
  return qE((D) => {
    p && (e === 1 / 0 || u < e) && (C.current.visible = !1, D.gl.setRenderTarget(c), d = D.scene.background, g && (D.scene.background = g), D.gl.render(D.scene, E.current), D.scene.background = d, D.gl.setRenderTarget(null), C.current.visible = !0, u++);
  }), Te.useLayoutEffect(() => {
    if (t) {
      const D = B;
      return s(() => ({
        camera: E.current
      })), () => s(() => ({
        camera: D
      }));
    }
  }, [E, t, s]), /* @__PURE__ */ Te.createElement(Te.Fragment, null, /* @__PURE__ */ Te.createElement("perspectiveCamera", OC({
    ref: u4([E, r])
  }, n), !p && i), /* @__PURE__ */ Te.createElement("group", {
    ref: C
  }, p && i(c.texture)));
});
/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
const yt = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
}, Ie = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
});
function uC(g) {
  return g.isPerspectiveCamera;
}
function gB(g) {
  return g.isOrthographicCamera;
}
const BE = Math.PI * 2, SF = Math.PI / 2, ek = 1e-5, lc = Math.PI / 180;
function uE(g, A, e) {
  return Math.max(A, Math.min(e, g));
}
function Zi(g, A = ek) {
  return Math.abs(g) < A;
}
function Fi(g, A, e = ek) {
  return Zi(g - A, e);
}
function MF(g, A) {
  return Math.round(g / A) * A;
}
function cc(g) {
  return isFinite(g) ? g : g < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function uc(g) {
  return Math.abs(g) < Number.MAX_VALUE ? g : g * (1 / 0);
}
function _d(g, A, e, t, i = 1 / 0, n) {
  t = Math.max(1e-4, t);
  const r = 2 / t, s = r * n, B = 1 / (1 + s + 0.48 * s * s + 0.235 * s * s * s);
  let I = g - A;
  const E = A, C = i * t;
  I = uE(I, -C, C), A = g - I;
  const c = (e.value + r * I) * n;
  e.value = (e.value - r * c) * B;
  let u = A + (I + c) * B;
  return E - g > 0 == u > E && (u = E, e.value = (u - E) / n), u;
}
function RF(g, A, e, t, i = 1 / 0, n, r) {
  t = Math.max(1e-4, t);
  const s = 2 / t, B = s * n, I = 1 / (1 + B + 0.48 * B * B + 0.235 * B * B * B);
  let E = A.x, C = A.y, c = A.z, u = g.x - E, d = g.y - C, p = g.z - c;
  const D = E, f = C, S = c, y = i * t, m = y * y, N = u * u + d * d + p * p;
  if (N > m) {
    const iA = Math.sqrt(N);
    u = u / iA * y, d = d / iA * y, p = p / iA * y;
  }
  E = g.x - u, C = g.y - d, c = g.z - p;
  const F = (e.x + s * u) * n, G = (e.y + s * d) * n, k = (e.z + s * p) * n;
  e.x = (e.x - s * F) * I, e.y = (e.y - s * G) * I, e.z = (e.z - s * k) * I, r.x = E + (u + F) * I, r.y = C + (d + G) * I, r.z = c + (p + k) * I;
  const v = D - g.x, x = f - g.y, H = S - g.z, _ = r.x - D, j = r.y - f, V = r.z - S;
  return v * _ + x * j + H * V > 0 && (r.x = D, r.y = f, r.z = S, e.x = (r.x - D) / n, e.y = (r.y - f) / n, e.z = (r.z - S) / n), r;
}
function _0(g, A) {
  A.set(0, 0), g.forEach((e) => {
    A.x += e.clientX, A.y += e.clientY;
  }), A.x /= g.length, A.y /= g.length;
}
function J0(g, A) {
  return gB(g) ? (console.warn(`${A} is not supported in OrthographicCamera`), !0) : !1;
}
class Bq {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(A, e) {
    const t = this._listeners;
    t[A] === void 0 && (t[A] = []), t[A].indexOf(e) === -1 && t[A].push(e);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(A, e) {
    const t = this._listeners;
    return t[A] !== void 0 && t[A].indexOf(e) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(A, e) {
    const i = this._listeners[A];
    if (i !== void 0) {
      const n = i.indexOf(e);
      n !== -1 && i.splice(n, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(A) {
    if (!A) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[A]) && (this._listeners[A].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(A) {
    const t = this._listeners[A.type];
    if (t !== void 0) {
      A.target = this;
      const i = t.slice(0);
      for (let n = 0, r = i.length; n < r; n++)
        i[n].call(this, A);
    }
  }
}
const Cq = "2.3.4", Jd = 1 / 8, tk = typeof window < "u", Qq = tk && /Mac/.test(navigator.platform), Eq = !(tk && "PointerEvent" in window);
let wt, NF, Od, O0, fr, mt, yi, CE, Zs, Xs, hC, FF, GF, So, hc, QE, vF, q0, UF, P0, W0, qd, z0 = class ty extends Bq {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(A) {
    wt = A.THREE, NF = Object.freeze(new wt.Vector3(0, 0, 0)), Od = Object.freeze(new wt.Vector3(0, 1, 0)), O0 = Object.freeze(new wt.Vector3(0, 0, 1)), fr = new wt.Vector2(), mt = new wt.Vector3(), yi = new wt.Vector3(), CE = new wt.Vector3(), Zs = new wt.Vector3(), Xs = new wt.Vector3(), hC = new wt.Vector3(), FF = new wt.Vector3(), GF = new wt.Vector3(), So = new wt.Spherical(), hc = new wt.Spherical(), QE = new wt.Box3(), vF = new wt.Box3(), q0 = new wt.Sphere(), UF = new wt.Quaternion(), P0 = new wt.Quaternion(), W0 = new wt.Matrix4(), qd = new wt.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return Ie;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(A, e) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = 0, this.maxDistance = 1 / 0, this.infinityDolly = !1, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = !1, this.truckSpeed = 2, this.dollyToCursor = !1, this.dragToOffset = !1, this.verticalDragToForward = !1, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = !0, this._state = Ie.NONE, this._viewport = null, this._dollyControlAmount = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect(), this._activePointers = [], this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._isUserControllingOffset = !1, this._isUserControllingZoom = !1, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new wt.Vector3(), this._focalOffsetVelocity = new wt.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (S, y, m) => {
      if (uC(this._camera)) {
        const N = mt.copy(this._camera.position).sub(this._target), F = this._camera.getEffectiveFOV() * lc, G = N.length() * Math.tan(F * 0.5), k = this.truckSpeed * S * G / this._elementRect.height, v = this.truckSpeed * y * G / this._elementRect.height;
        this.verticalDragToForward ? (m ? this.setFocalOffset(this._focalOffsetEnd.x + k, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(k, 0, !0), this.forward(-v, !0)) : m ? this.setFocalOffset(this._focalOffsetEnd.x + k, this._focalOffsetEnd.y + v, this._focalOffsetEnd.z, !0) : this.truck(k, v, !0);
      } else if (gB(this._camera)) {
        const N = this._camera, F = S * (N.right - N.left) / N.zoom / this._elementRect.width, G = y * (N.top - N.bottom) / N.zoom / this._elementRect.height;
        m ? this.setFocalOffset(this._focalOffsetEnd.x + F, this._focalOffsetEnd.y + G, this._focalOffsetEnd.z, !0) : this.truck(F, G, !0);
      }
    }, this._rotateInternal = (S, y) => {
      const m = BE * this.azimuthRotateSpeed * S / this._elementRect.height, N = BE * this.polarRotateSpeed * y / this._elementRect.height;
      this.rotate(m, N, !0);
    }, this._dollyInternal = (S, y, m) => {
      const N = Math.pow(0.95, -S * this.dollySpeed), F = this._sphericalEnd.radius * N, G = this._sphericalEnd.radius, k = G * (S >= 0 ? -1 : 1);
      this.dollyTo(F), this.infinityDolly && (F < this.minDistance || this.maxDistance === this.minDistance) && (this._camera.getWorldDirection(mt), this._targetEnd.add(mt.normalize().multiplyScalar(k)), this._target.add(mt.normalize().multiplyScalar(k))), this.dollyToCursor && (this._dollyControlAmount += this._sphericalEnd.radius - G, this.infinityDolly && (F < this.minDistance || this.maxDistance === this.minDistance) && (this._dollyControlAmount -= k), this._dollyControlCoord.set(y, m));
    }, this._zoomInternal = (S, y, m) => {
      const N = Math.pow(0.95, S * this.dollySpeed), F = this._zoomEnd;
      this.zoomTo(this._zoom * N), this.dollyToCursor && (this._dollyControlAmount += this._zoomEnd - F, this._dollyControlCoord.set(y, m));
    }, typeof wt > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = A, this._yAxisUpSpace = new wt.Quaternion().setFromUnitVectors(this._camera.up, Od), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = Ie.NONE, this._target = new wt.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new wt.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new wt.Spherical().setFromVector3(mt.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._nearPlaneCorners = [
      new wt.Vector3(),
      new wt.Vector3(),
      new wt.Vector3(),
      new wt.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new wt.Box3(new wt.Vector3(-1 / 0, -1 / 0, -1 / 0), new wt.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlAmount = 0, this._dollyControlCoord = new wt.Vector2(), this.mouseButtons = {
      left: Ie.ROTATE,
      middle: Ie.DOLLY,
      right: Ie.TRUCK,
      wheel: uC(this._camera) ? Ie.DOLLY : gB(this._camera) ? Ie.ZOOM : Ie.NONE
    }, this.touches = {
      one: Ie.TOUCH_ROTATE,
      two: uC(this._camera) ? Ie.TOUCH_DOLLY_TRUCK : gB(this._camera) ? Ie.TOUCH_ZOOM_TRUCK : Ie.NONE,
      three: Ie.TOUCH_TRUCK
    };
    const t = new wt.Vector2(), i = new wt.Vector2(), n = new wt.Vector2(), r = (S) => {
      if (!this._enabled || !this._domElement)
        return;
      const y = S.pointerType !== "mouse" ? null : (S.buttons & yt.LEFT) === yt.LEFT ? yt.LEFT : (S.buttons & yt.MIDDLE) === yt.MIDDLE ? yt.MIDDLE : (S.buttons & yt.RIGHT) === yt.RIGHT ? yt.RIGHT : null;
      if (y !== null) {
        const N = this._findPointerByMouseButton(y);
        N && this._activePointers.splice(this._activePointers.indexOf(N), 1);
      }
      const m = {
        pointerId: S.pointerId,
        clientX: S.clientX,
        clientY: S.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: y
      };
      this._activePointers.push(m), this._domElement.ownerDocument.removeEventListener("pointermove", B, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", E), this._domElement.ownerDocument.addEventListener("pointermove", B, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", E), p(S);
    }, s = (S) => {
      if (!this._enabled || !this._domElement)
        return;
      const y = (S.buttons & yt.LEFT) === yt.LEFT ? yt.LEFT : (S.buttons & yt.MIDDLE) === yt.MIDDLE ? yt.MIDDLE : (S.buttons & yt.RIGHT) === yt.RIGHT ? yt.RIGHT : null;
      if (y !== null) {
        const N = this._findPointerByMouseButton(y);
        N && this._activePointers.splice(this._activePointers.indexOf(N), 1);
      }
      const m = {
        pointerId: 0,
        clientX: S.clientX,
        clientY: S.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: (S.buttons & yt.LEFT) === yt.LEFT ? yt.LEFT : (S.buttons & yt.MIDDLE) === yt.LEFT ? yt.MIDDLE : (S.buttons & yt.RIGHT) === yt.LEFT ? yt.RIGHT : null
      };
      this._activePointers.push(m), this._domElement.ownerDocument.removeEventListener("mousemove", I), this._domElement.ownerDocument.removeEventListener("mouseup", C), this._domElement.ownerDocument.addEventListener("mousemove", I), this._domElement.ownerDocument.addEventListener("mouseup", C), p(S);
    }, B = (S) => {
      S.cancelable && S.preventDefault();
      const y = S.pointerId, m = this._findPointerById(y);
      if (m) {
        if (m.clientX = S.clientX, m.clientY = S.clientY, m.deltaX = S.movementX, m.deltaY = S.movementY, S.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = 0, (S.buttons & yt.LEFT) === yt.LEFT && (this._state = this._state | this.mouseButtons.left), (S.buttons & yt.MIDDLE) === yt.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (S.buttons & yt.RIGHT) === yt.RIGHT && (this._state = this._state | this.mouseButtons.right);
        D();
      }
    }, I = (S) => {
      const y = this._findPointerById(0);
      y && (y.clientX = S.clientX, y.clientY = S.clientY, y.deltaX = S.movementX, y.deltaY = S.movementY, this._state = 0, (S.buttons & yt.LEFT) === yt.LEFT && (this._state = this._state | this.mouseButtons.left), (S.buttons & yt.MIDDLE) === yt.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (S.buttons & yt.RIGHT) === yt.RIGHT && (this._state = this._state | this.mouseButtons.right), D());
    }, E = (S) => {
      const y = S.pointerId, m = this._findPointerById(y);
      if (m && this._activePointers.splice(this._activePointers.indexOf(m), 1), S.pointerType === "touch")
        switch (this._activePointers.length) {
          case 0:
            this._state = Ie.NONE;
            break;
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        this._state = Ie.NONE;
      f();
    }, C = () => {
      const S = this._findPointerById(0);
      S && this._activePointers.splice(this._activePointers.indexOf(S), 1), this._state = Ie.NONE, f();
    };
    let c = -1;
    const u = (S) => {
      if (!this._enabled || this.mouseButtons.wheel === Ie.NONE)
        return;
      if (S.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === Ie.ROTATE || this.mouseButtons.wheel === Ie.TRUCK) {
        const G = performance.now();
        c - G < 1e3 && this._getClientRect(this._elementRect), c = G;
      }
      const y = Qq ? -1 : -3, m = S.deltaMode === 1 ? S.deltaY / y : S.deltaY / (y * 10), N = this.dollyToCursor ? (S.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, F = this.dollyToCursor ? (S.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case Ie.ROTATE: {
          this._rotateInternal(S.deltaX, S.deltaY), this._isUserControllingRotate = !0;
          break;
        }
        case Ie.TRUCK: {
          this._truckInternal(S.deltaX, S.deltaY, !1), this._isUserControllingTruck = !0;
          break;
        }
        case Ie.OFFSET: {
          this._truckInternal(S.deltaX, S.deltaY, !0), this._isUserControllingOffset = !0;
          break;
        }
        case Ie.DOLLY: {
          this._dollyInternal(-m, N, F), this._isUserControllingDolly = !0;
          break;
        }
        case Ie.ZOOM: {
          this._zoomInternal(-m, N, F), this._isUserControllingZoom = !0;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, d = (S) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === ty.ACTION.NONE) {
          const y = S instanceof PointerEvent ? S.pointerId : (S instanceof MouseEvent, 0), m = this._findPointerById(y);
          m && this._activePointers.splice(this._activePointers.indexOf(m), 1), this._domElement.ownerDocument.removeEventListener("pointermove", B, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", E), this._domElement.ownerDocument.removeEventListener("mousemove", I), this._domElement.ownerDocument.removeEventListener("mouseup", C);
          return;
        }
        S.preventDefault();
      }
    }, p = (S) => {
      if (!this._enabled)
        return;
      if (_0(this._activePointers, fr), this._getClientRect(this._elementRect), t.copy(fr), i.copy(fr), this._activePointers.length >= 2) {
        const m = fr.x - this._activePointers[1].clientX, N = fr.y - this._activePointers[1].clientY, F = Math.sqrt(m * m + N * N);
        n.set(0, F);
        const G = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, k = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        i.set(G, k);
      }
      if ("pointerType" in S && S.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        this._state = 0, (S.buttons & yt.LEFT) === yt.LEFT && (this._state = this._state | this.mouseButtons.left), (S.buttons & yt.MIDDLE) === yt.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (S.buttons & yt.RIGHT) === yt.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & Ie.ROTATE) === Ie.ROTATE || (this._state & Ie.TOUCH_ROTATE) === Ie.TOUCH_ROTATE || (this._state & Ie.TOUCH_DOLLY_ROTATE) === Ie.TOUCH_DOLLY_ROTATE || (this._state & Ie.TOUCH_ZOOM_ROTATE) === Ie.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & Ie.TRUCK) === Ie.TRUCK || (this._state & Ie.TOUCH_TRUCK) === Ie.TOUCH_TRUCK || (this._state & Ie.TOUCH_DOLLY_TRUCK) === Ie.TOUCH_DOLLY_TRUCK || (this._state & Ie.TOUCH_ZOOM_TRUCK) === Ie.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & Ie.DOLLY) === Ie.DOLLY || (this._state & Ie.TOUCH_DOLLY) === Ie.TOUCH_DOLLY || (this._state & Ie.TOUCH_DOLLY_TRUCK) === Ie.TOUCH_DOLLY_TRUCK || (this._state & Ie.TOUCH_DOLLY_OFFSET) === Ie.TOUCH_DOLLY_OFFSET || (this._state & Ie.TOUCH_DOLLY_ROTATE) === Ie.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & Ie.ZOOM) === Ie.ZOOM || (this._state & Ie.TOUCH_ZOOM) === Ie.TOUCH_ZOOM || (this._state & Ie.TOUCH_ZOOM_TRUCK) === Ie.TOUCH_ZOOM_TRUCK || (this._state & Ie.TOUCH_ZOOM_OFFSET) === Ie.TOUCH_ZOOM_OFFSET || (this._state & Ie.TOUCH_ZOOM_ROTATE) === Ie.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & Ie.OFFSET) === Ie.OFFSET || (this._state & Ie.TOUCH_OFFSET) === Ie.TOUCH_OFFSET || (this._state & Ie.TOUCH_DOLLY_OFFSET) === Ie.TOUCH_DOLLY_OFFSET || (this._state & Ie.TOUCH_ZOOM_OFFSET) === Ie.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, D = () => {
      if (!this._enabled)
        return;
      _0(this._activePointers, fr);
      const S = this._domElement && document.pointerLockElement === this._domElement, y = S ? -this._activePointers[0].deltaX : i.x - fr.x, m = S ? -this._activePointers[0].deltaY : i.y - fr.y;
      if (i.copy(fr), ((this._state & Ie.ROTATE) === Ie.ROTATE || (this._state & Ie.TOUCH_ROTATE) === Ie.TOUCH_ROTATE || (this._state & Ie.TOUCH_DOLLY_ROTATE) === Ie.TOUCH_DOLLY_ROTATE || (this._state & Ie.TOUCH_ZOOM_ROTATE) === Ie.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(y, m), this._isUserControllingRotate = !0), (this._state & Ie.DOLLY) === Ie.DOLLY || (this._state & Ie.ZOOM) === Ie.ZOOM) {
        const N = this.dollyToCursor ? (t.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, F = this.dollyToCursor ? (t.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, G = this.dollyDragInverted ? -1 : 1;
        (this._state & Ie.DOLLY) === Ie.DOLLY ? (this._dollyInternal(G * m * Jd, N, F), this._isUserControllingDolly = !0) : (this._zoomInternal(G * m * Jd, N, F), this._isUserControllingZoom = !0);
      }
      if ((this._state & Ie.TOUCH_DOLLY) === Ie.TOUCH_DOLLY || (this._state & Ie.TOUCH_ZOOM) === Ie.TOUCH_ZOOM || (this._state & Ie.TOUCH_DOLLY_TRUCK) === Ie.TOUCH_DOLLY_TRUCK || (this._state & Ie.TOUCH_ZOOM_TRUCK) === Ie.TOUCH_ZOOM_TRUCK || (this._state & Ie.TOUCH_DOLLY_OFFSET) === Ie.TOUCH_DOLLY_OFFSET || (this._state & Ie.TOUCH_ZOOM_OFFSET) === Ie.TOUCH_ZOOM_OFFSET || (this._state & Ie.TOUCH_DOLLY_ROTATE) === Ie.TOUCH_DOLLY_ROTATE || (this._state & Ie.TOUCH_ZOOM_ROTATE) === Ie.TOUCH_ZOOM_ROTATE) {
        const N = fr.x - this._activePointers[1].clientX, F = fr.y - this._activePointers[1].clientY, G = Math.sqrt(N * N + F * F), k = n.y - G;
        n.set(0, G);
        const v = this.dollyToCursor ? (i.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, x = this.dollyToCursor ? (i.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & Ie.TOUCH_DOLLY) === Ie.TOUCH_DOLLY || (this._state & Ie.TOUCH_DOLLY_ROTATE) === Ie.TOUCH_DOLLY_ROTATE || (this._state & Ie.TOUCH_DOLLY_TRUCK) === Ie.TOUCH_DOLLY_TRUCK || (this._state & Ie.TOUCH_DOLLY_OFFSET) === Ie.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(k * Jd, v, x), this._isUserControllingDolly = !0) : (this._zoomInternal(k * Jd, v, x), this._isUserControllingZoom = !0);
      }
      ((this._state & Ie.TRUCK) === Ie.TRUCK || (this._state & Ie.TOUCH_TRUCK) === Ie.TOUCH_TRUCK || (this._state & Ie.TOUCH_DOLLY_TRUCK) === Ie.TOUCH_DOLLY_TRUCK || (this._state & Ie.TOUCH_ZOOM_TRUCK) === Ie.TOUCH_ZOOM_TRUCK) && (this._truckInternal(y, m, !1), this._isUserControllingTruck = !0), ((this._state & Ie.OFFSET) === Ie.OFFSET || (this._state & Ie.TOUCH_OFFSET) === Ie.TOUCH_OFFSET || (this._state & Ie.TOUCH_DOLLY_OFFSET) === Ie.TOUCH_DOLLY_OFFSET || (this._state & Ie.TOUCH_ZOOM_OFFSET) === Ie.TOUCH_ZOOM_OFFSET) && (this._truckInternal(y, m, !0), this._isUserControllingOffset = !0), this.dispatchEvent({ type: "control" });
    }, f = () => {
      _0(this._activePointers, fr), i.copy(fr), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", B, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("mousemove", I), this._domElement.ownerDocument.removeEventListener("pointerup", E), this._domElement.ownerDocument.removeEventListener("mouseup", C), this.dispatchEvent({ type: "controlend" }));
    };
    this._addAllEventListeners = (S) => {
      this._domElement = S, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", r), Eq && this._domElement.addEventListener("mousedown", s), this._domElement.addEventListener("pointercancel", E), this._domElement.addEventListener("wheel", u, { passive: !1 }), this._domElement.addEventListener("contextmenu", d);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", r), this._domElement.removeEventListener("mousedown", s), this._domElement.removeEventListener("pointercancel", E), this._domElement.removeEventListener("wheel", u, { passive: !1 }), this._domElement.removeEventListener("contextmenu", d), this._domElement.ownerDocument.removeEventListener("pointermove", B, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("mousemove", I), this._domElement.ownerDocument.removeEventListener("pointerup", E), this._domElement.ownerDocument.removeEventListener("mouseup", C));
    }, this.cancel = () => {
      this._state !== Ie.NONE && (this._state = Ie.NONE, this._activePointers.length = 0, f());
    }, e && this.connect(e), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(A) {
    this._camera = A, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(A) {
    this._enabled = A, this._domElement && (A ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(A) {
    this._spherical.radius === A && this._sphericalEnd.radius === A || (this._spherical.radius = A, this._sphericalEnd.radius = A, this._needsUpdate = !0);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(A) {
    this._spherical.theta === A && this._sphericalEnd.theta === A || (this._spherical.theta = A, this._sphericalEnd.theta = A, this._needsUpdate = !0);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(A) {
    this._spherical.phi === A && this._sphericalEnd.phi === A || (this._spherical.phi = A, this._sphericalEnd.phi = A, this._needsUpdate = !0);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(A) {
    this._boundaryEnclosesCamera = A, this._needsUpdate = !0;
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches.  |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera.  |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` . |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(A, e) {
    super.addEventListener(A, e);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(A, e) {
    super.removeEventListener(A, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(A, e, t = !1) {
    return this.rotateTo(this._sphericalEnd.theta + A, this._sphericalEnd.phi + e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(A, e = !1) {
    return this.rotateTo(A, this._sphericalEnd.phi, e);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(A, e = !1) {
    return this.rotateTo(this._sphericalEnd.theta, A, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0
   *         \
   * 90 -----+----- -90
   *           \
   *           180
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0                     |
   * | left      | 90 (`Math.PI / 2`)    |
   * | right     | -90 (`- Math.PI / 2`) |
   * | back      | 180 (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180
   *      |
   *      90
   *      |
   *      0
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180 (`Math.PI`)       |
   * | horizontal from view | 90 (`Math.PI / 2`)    |
   * | bottom/floor         | 0                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(A, e, t = !1) {
    this._isUserControllingRotate = !1;
    const i = uE(A, this.minAzimuthAngle, this.maxAzimuthAngle), n = uE(e, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = i, this._sphericalEnd.phi = n, this._sphericalEnd.makeSafe(), this._needsUpdate = !0, t || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const r = !t || Fi(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Fi(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(A, e = !1) {
    return this.dollyTo(this._sphericalEnd.radius - A, e);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(A, e = !1) {
    this._isUserControllingDolly = !1;
    const t = this._sphericalEnd.radius, i = uE(A, this.minDistance, this.maxDistance);
    if (this.colliderMeshes.length >= 1) {
      const s = this._collisionTest(), B = Fi(s, this._spherical.radius);
      if (!(t > i) && B)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(i, s);
    } else
      this._sphericalEnd.radius = i;
    this._needsUpdate = !0, e || (this._spherical.radius = this._sphericalEnd.radius);
    const r = !e || Fi(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(A, e = !1) {
    return this.zoomTo(this._zoomEnd + A, e);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(A, e = !1) {
    this._isUserControllingZoom = !1, this._zoomEnd = uE(A, this.minZoom, this.maxZoom), this._needsUpdate = !0, e || (this._zoom = this._zoomEnd);
    const t = !e || Fi(this._zoom, this._zoomEnd, this.restThreshold);
    return this._createOnRestPromise(t);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(A, e, t = !1) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(A, e, t);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(A, e, t = !1) {
    this._camera.updateMatrix(), Zs.setFromMatrixColumn(this._camera.matrix, 0), Xs.setFromMatrixColumn(this._camera.matrix, 1), Zs.multiplyScalar(A), Xs.multiplyScalar(-e);
    const i = mt.copy(Zs).add(Xs), n = yi.copy(this._targetEnd).add(i);
    return this.moveTo(n.x, n.y, n.z, t);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(A, e = !1) {
    mt.setFromMatrixColumn(this._camera.matrix, 0), mt.crossVectors(this._camera.up, mt), mt.multiplyScalar(A);
    const t = yi.copy(this._targetEnd).add(mt);
    return this.moveTo(t.x, t.y, t.z, e);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(A, e = !1) {
    return mt.copy(this._camera.up).multiplyScalar(A), this.moveTo(this._targetEnd.x + mt.x, this._targetEnd.y + mt.y, this._targetEnd.z + mt.z, e);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(A, e, t, i = !1) {
    this._isUserControllingTruck = !1;
    const n = mt.set(A, e, t).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, n, this.boundaryFriction), this._needsUpdate = !0, i || this._target.copy(this._targetEnd);
    const r = !i || Fi(this._target.x, this._targetEnd.x, this.restThreshold) && Fi(this._target.y, this._targetEnd.y, this.restThreshold) && Fi(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(A, e, t, i = !1) {
    const s = mt.set(A, e, t).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius);
    return this.setPosition(s.x, s.y, s.z, i);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(A, e, { cover: t = !1, paddingLeft: i = 0, paddingRight: n = 0, paddingBottom: r = 0, paddingTop: s = 0 } = {}) {
    const B = [], I = A.isBox3 ? QE.copy(A) : QE.setFromObject(A);
    I.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const E = MF(this._sphericalEnd.theta, SF), C = MF(this._sphericalEnd.phi, SF);
    B.push(this.rotateTo(E, C, e));
    const c = mt.setFromSpherical(this._sphericalEnd).normalize(), u = UF.setFromUnitVectors(c, O0), d = Fi(Math.abs(c.y), 1);
    d && u.multiply(P0.setFromAxisAngle(Od, E)), u.multiply(this._yAxisUpSpaceInverse);
    const p = vF.makeEmpty();
    yi.copy(I.min).applyQuaternion(u), p.expandByPoint(yi), yi.copy(I.min).setX(I.max.x).applyQuaternion(u), p.expandByPoint(yi), yi.copy(I.min).setY(I.max.y).applyQuaternion(u), p.expandByPoint(yi), yi.copy(I.max).setZ(I.min.z).applyQuaternion(u), p.expandByPoint(yi), yi.copy(I.min).setZ(I.max.z).applyQuaternion(u), p.expandByPoint(yi), yi.copy(I.max).setY(I.min.y).applyQuaternion(u), p.expandByPoint(yi), yi.copy(I.max).setX(I.min.x).applyQuaternion(u), p.expandByPoint(yi), yi.copy(I.max).applyQuaternion(u), p.expandByPoint(yi), p.min.x -= i, p.min.y -= r, p.max.x += n, p.max.y += s, u.setFromUnitVectors(O0, c), d && u.premultiply(P0.invert()), u.premultiply(this._yAxisUpSpace);
    const D = p.getSize(mt), f = p.getCenter(yi).applyQuaternion(u);
    if (uC(this._camera)) {
      const S = this.getDistanceToFitBox(D.x, D.y, D.z, t);
      B.push(this.moveTo(f.x, f.y, f.z, e)), B.push(this.dollyTo(S, e)), B.push(this.setFocalOffset(0, 0, 0, e));
    } else if (gB(this._camera)) {
      const S = this._camera, y = S.right - S.left, m = S.top - S.bottom, N = t ? Math.max(y / D.x, m / D.y) : Math.min(y / D.x, m / D.y);
      B.push(this.moveTo(f.x, f.y, f.z, e)), B.push(this.zoomTo(N, e)), B.push(this.setFocalOffset(0, 0, 0, e));
    }
    return Promise.all(B);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(A, e) {
    const t = [], n = A instanceof wt.Sphere ? q0.copy(A) : ty.createBoundingSphere(A, q0);
    if (t.push(this.moveTo(n.center.x, n.center.y, n.center.z, e)), uC(this._camera)) {
      const r = this.getDistanceToFitSphere(n.radius);
      t.push(this.dollyTo(r, e));
    } else if (gB(this._camera)) {
      const r = this._camera.right - this._camera.left, s = this._camera.top - this._camera.bottom, B = 2 * n.radius, I = Math.min(r / B, s / B);
      t.push(this.zoomTo(I, e));
    }
    return t.push(this.setFocalOffset(0, 0, 0, e)), Promise.all(t);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(A, e, t, i, n, r, s = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1;
    const B = yi.set(i, n, r), I = mt.set(A, e, t);
    this._targetEnd.copy(B), this._sphericalEnd.setFromVector3(I.sub(B).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = !0, s || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const E = !s || Fi(this._target.x, this._targetEnd.x, this.restThreshold) && Fi(this._target.y, this._targetEnd.y, this.restThreshold) && Fi(this._target.z, this._targetEnd.z, this.restThreshold) && Fi(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Fi(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && Fi(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(E);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(A, e, t, i, n, r, s, B, I, E, C, c, u, d = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1;
    const p = mt.set(i, n, r), D = yi.set(A, e, t);
    So.setFromVector3(D.sub(p).applyQuaternion(this._yAxisUpSpace));
    const f = CE.set(E, C, c), S = yi.set(s, B, I);
    hc.setFromVector3(S.sub(f).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(p.lerp(f, u));
    const y = hc.theta - So.theta, m = hc.phi - So.phi, N = hc.radius - So.radius;
    this._sphericalEnd.set(So.radius + N * u, So.phi + m * u, So.theta + y * u), this.normalizeRotations(), this._needsUpdate = !0, d || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const F = !d || Fi(this._target.x, this._targetEnd.x, this.restThreshold) && Fi(this._target.y, this._targetEnd.y, this.restThreshold) && Fi(this._target.z, this._targetEnd.z, this.restThreshold) && Fi(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Fi(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && Fi(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(F);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(A, e, t, i = !1) {
    return this.setLookAt(A, e, t, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, i);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(A, e, t, i = !1) {
    const n = this.getPosition(mt), r = this.setLookAt(n.x, n.y, n.z, A, e, t, i);
    return this._sphericalEnd.phi = uE(this.polarAngle, this.minPolarAngle, this.maxPolarAngle), r;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(A, e, t, i = !1) {
    this._isUserControllingOffset = !1, this._focalOffsetEnd.set(A, e, t), this._needsUpdate = !0, i || this._focalOffset.copy(this._focalOffsetEnd);
    const n = !i || Fi(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && Fi(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && Fi(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(A, e, t) {
    this._camera.updateMatrixWorld(), Zs.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), Xs.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), hC.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const i = mt.set(A, e, t), n = i.distanceTo(this._camera.position), r = i.sub(this._camera.position);
    Zs.multiplyScalar(r.x), Xs.multiplyScalar(r.y), hC.multiplyScalar(r.z), mt.copy(Zs).add(Xs).add(hC), mt.z = mt.z + n, this.dollyTo(n, !1), this.setFocalOffset(-mt.x, mt.y, -mt.z, !1), this.moveTo(A, e, t, !1);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(A) {
    if (!A) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = !0;
      return;
    }
    this._boundary.copy(A), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = !0;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(A, e, t, i) {
    if (A === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new wt.Vector4(), typeof A == "number" ? this._viewport.set(A, e, t, i) : this._viewport.copy(A);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(A, e, t, i = !1) {
    if (J0(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const n = A / e, r = this._camera.getEffectiveFOV() * lc, s = this._camera.aspect;
    return ((i ? n > s : n < s) ? e : A / s) * 0.5 / Math.tan(r * 0.5) + t * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(A) {
    if (J0(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const e = this._camera.getEffectiveFOV() * lc, t = Math.atan(Math.tan(e * 0.5) * this._camera.aspect) * 2, i = 1 < this._camera.aspect ? e : t;
    return A / Math.sin(i * 0.5);
  }
  /**
   * Returns its current gazing target, which is the center position of the orbit.
   * @param out current gazing target
   * @category Methods
   */
  getTarget(A) {
    return (A && A.isVector3 ? A : new wt.Vector3()).copy(this._targetEnd);
  }
  /**
   * Returns its current position.
   * @param out current position
   * @category Methods
   */
  getPosition(A) {
    return (A && A.isVector3 ? A : new wt.Vector3()).setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).add(this._targetEnd);
  }
  /**
   * Returns its current focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out current focal offset
   * @category Methods
   */
  getFocalOffset(A) {
    return (A && A.isVector3 ? A : new wt.Vector3()).copy(this._focalOffsetEnd);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % BE, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += BE), this._spherical.theta += BE * Math.round((this._sphericalEnd.theta - this._spherical.theta) / BE);
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(A = !1) {
    if (!Fi(this._camera.up.x, this._cameraUp0.x) || !Fi(this._camera.up.y, this._cameraUp0.y) || !Fi(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const t = this.getPosition(mt);
      this.updateCameraUp(), this.setPosition(t.x, t.y, t.z);
    }
    const e = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, A),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, A),
      this.zoomTo(this._zoom0, A)
    ];
    return Promise.all(e);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, Od), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const A = mt.subVectors(this._target, this._camera.position).normalize(), e = yi.crossVectors(A, this._camera.up).normalize();
    this._camera.up.crossVectors(e, A).normalize(), this._camera.updateMatrixWorld();
    const t = this.getPosition(mt);
    this.updateCameraUp(), this.setPosition(t.x, t.y, t.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(A) {
    const e = this._sphericalEnd.theta - this._spherical.theta, t = this._sphericalEnd.phi - this._spherical.phi, i = this._sphericalEnd.radius - this._spherical.radius, n = FF.subVectors(this._targetEnd, this._target), r = GF.subVectors(this._focalOffsetEnd, this._focalOffset), s = this._zoomEnd - this._zoom;
    if (Zi(e))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const C = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = _d(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, C, 1 / 0, A), this._needsUpdate = !0;
    }
    if (Zi(t))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const C = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = _d(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, C, 1 / 0, A), this._needsUpdate = !0;
    }
    if (Zi(i))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const C = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = _d(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, C, this.maxSpeed, A), this._needsUpdate = !0;
    }
    if (Zi(n.x) && Zi(n.y) && Zi(n.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const C = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      RF(this._target, this._targetEnd, this._targetVelocity, C, this.maxSpeed, A, this._target), this._needsUpdate = !0;
    }
    if (Zi(r.x) && Zi(r.y) && Zi(r.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const C = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      RF(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, C, this.maxSpeed, A, this._focalOffset), this._needsUpdate = !0;
    }
    if (this._dollyControlAmount !== 0) {
      if (uC(this._camera)) {
        const C = this._camera, c = mt.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).normalize().negate(), u = yi.copy(c).cross(C.up).normalize();
        u.lengthSq() === 0 && (u.x = 1);
        const d = CE.crossVectors(u, c), p = this._sphericalEnd.radius * Math.tan(C.getEffectiveFOV() * lc * 0.5), f = (this._sphericalEnd.radius - this._dollyControlAmount - this._sphericalEnd.radius) / this._sphericalEnd.radius, S = mt.copy(this._targetEnd).add(u.multiplyScalar(this._dollyControlCoord.x * p * C.aspect)).add(d.multiplyScalar(this._dollyControlCoord.y * p));
        this._targetEnd.lerp(S, f);
      } else if (gB(this._camera)) {
        const C = this._camera, c = mt.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (C.near + C.far) / (C.near - C.far)).unproject(C), u = yi.set(0, 0, -1).applyQuaternion(C.quaternion), d = CE.copy(c).add(u.multiplyScalar(-c.dot(C.up))), D = -(this._zoom - this._dollyControlAmount - this._zoomEnd) / this._zoom, f = mt.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).normalize().negate(), S = this._targetEnd.dot(f);
        this._targetEnd.lerp(d, D);
        const y = this._targetEnd.dot(f), m = f.multiplyScalar(y - S);
        this._targetEnd.sub(m);
      }
      this._target.copy(this._targetEnd), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._dollyControlAmount = 0;
    }
    if (Zi(s))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const C = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = _d(this._zoom, this._zoomEnd, this._zoomVelocity, C, 1 / 0, A);
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0);
    const B = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, B), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!Zi(this._focalOffset.x) || !Zi(this._focalOffset.y) || !Zi(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), Zs.setFromMatrixColumn(this._camera.matrix, 0), Xs.setFromMatrixColumn(this._camera.matrix, 1), hC.setFromMatrixColumn(this._camera.matrix, 2), Zs.multiplyScalar(this._focalOffset.x), Xs.multiplyScalar(-this._focalOffset.y), hC.multiplyScalar(this._focalOffset.z), mt.copy(Zs).add(Xs).add(hC), this._camera.position.add(mt)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), mt.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const E = this._needsUpdate;
    return E && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : E ? (this.dispatchEvent({ type: "update" }), Zi(e, this.restThreshold) && Zi(t, this.restThreshold) && Zi(i, this.restThreshold) && Zi(n.x, this.restThreshold) && Zi(n.y, this.restThreshold) && Zi(n.z, this.restThreshold) && Zi(r.x, this.restThreshold) && Zi(r.y, this.restThreshold) && Zi(r.z, this.restThreshold) && Zi(s, this.restThreshold) && !this._hasRested && (this._hasRested = !0, this.dispatchEvent({ type: "rest" }))) : !E && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._updatedLastTime = E, this._needsUpdate = !1, E;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: cc(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: cc(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: cc(this.maxPolarAngle),
      minAzimuthAngle: cc(this.minAzimuthAngle),
      maxAzimuthAngle: cc(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: mt.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(A, e = !1) {
    const t = JSON.parse(A);
    this.enabled = t.enabled, this.minDistance = t.minDistance, this.maxDistance = uc(t.maxDistance), this.minZoom = t.minZoom, this.maxZoom = uc(t.maxZoom), this.minPolarAngle = t.minPolarAngle, this.maxPolarAngle = uc(t.maxPolarAngle), this.minAzimuthAngle = uc(t.minAzimuthAngle), this.maxAzimuthAngle = uc(t.maxAzimuthAngle), this.smoothTime = t.smoothTime, this.draggingSmoothTime = t.draggingSmoothTime, this.dollySpeed = t.dollySpeed, this.truckSpeed = t.truckSpeed, this.dollyToCursor = t.dollyToCursor, this.verticalDragToForward = t.verticalDragToForward, this._target0.fromArray(t.target0), this._position0.fromArray(t.position0), this._zoom0 = t.zoom0, this._focalOffset0.fromArray(t.focalOffset0), this.moveTo(t.target[0], t.target[1], t.target[2], e), So.setFromVector3(mt.fromArray(t.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(So.theta, So.phi, e), this.dollyTo(So.radius, e), this.zoomTo(t.zoom, e), this.setFocalOffset(t.focalOffset[0], t.focalOffset[1], t.focalOffset[2], e), this._needsUpdate = !0;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(A) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    A.setAttribute("data-camera-controls-version", Cq), this._addAllEventListeners(A);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  _findPointerById(A) {
    return this._activePointers.find((e) => e.pointerId === A);
  }
  _findPointerByMouseButton(A) {
    return this._activePointers.find((e) => e.mouseButton === A);
  }
  _encloseToBoundary(A, e, t) {
    const i = e.lengthSq();
    if (i === 0)
      return A;
    const n = yi.copy(e).add(A), s = this._boundary.clampPoint(n, CE).sub(n), B = s.lengthSq();
    if (B === 0)
      return A.add(e);
    if (B === i)
      return A;
    if (t === 0)
      return A.add(e).add(s);
    {
      const I = 1 + t * B / e.dot(s);
      return A.add(yi.copy(e).multiplyScalar(I)).add(s.multiplyScalar(1 - t));
    }
  }
  _updateNearPlaneCorners() {
    if (uC(this._camera)) {
      const A = this._camera, e = A.near, t = A.getEffectiveFOV() * lc, i = Math.tan(t * 0.5) * e, n = i * A.aspect;
      this._nearPlaneCorners[0].set(-n, -i, 0), this._nearPlaneCorners[1].set(n, -i, 0), this._nearPlaneCorners[2].set(n, i, 0), this._nearPlaneCorners[3].set(-n, i, 0);
    } else if (gB(this._camera)) {
      const A = this._camera, e = 1 / A.zoom, t = A.left * e, i = A.right * e, n = A.top * e, r = A.bottom * e;
      this._nearPlaneCorners[0].set(t, n, 0), this._nearPlaneCorners[1].set(i, n, 0), this._nearPlaneCorners[2].set(i, r, 0), this._nearPlaneCorners[3].set(t, r, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let A = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || J0(this._camera, "_collisionTest"))
      return A;
    const t = mt.setFromSpherical(this._spherical).divideScalar(this._spherical.radius);
    W0.lookAt(NF, t, this._camera.up);
    for (let i = 0; i < 4; i++) {
      const n = yi.copy(this._nearPlaneCorners[i]);
      n.applyMatrix4(W0);
      const r = CE.addVectors(this._target, n);
      qd.set(r, t), qd.far = this._spherical.radius + 1;
      const s = qd.intersectObjects(this.colliderMeshes);
      s.length !== 0 && s[0].distance < A && (A = s[0].distance);
    }
    return A;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(A) {
    if (!this._domElement)
      return;
    const e = this._domElement.getBoundingClientRect();
    return A.x = e.left, A.y = e.top, this._viewport ? (A.x += this._viewport.x, A.y += e.height - this._viewport.w - this._viewport.y, A.width = this._viewport.z, A.height = this._viewport.w) : (A.width = e.width, A.height = e.height), A;
  }
  _createOnRestPromise(A) {
    return A ? Promise.resolve() : (this._hasRested = !1, this.dispatchEvent({ type: "transitionstart" }), new Promise((e) => {
      const t = () => {
        this.removeEventListener("rest", t), e();
      };
      this.addEventListener("rest", t);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(A) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(A) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(A) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(A, e = new wt.Sphere()) {
    const t = e, i = t.center;
    QE.makeEmpty(), A.traverseVisible((r) => {
      r.isMesh && QE.expandByObject(r);
    }), QE.getCenter(i);
    let n = 0;
    return A.traverseVisible((r) => {
      if (!r.isMesh)
        return;
      const s = r, B = s.geometry.clone();
      B.applyMatrix4(s.matrixWorld);
      const E = B.attributes.position;
      for (let C = 0, c = E.count; C < c; C++)
        mt.fromBufferAttribute(E, C), n = Math.max(n, i.distanceToSquared(mt));
    }), t.radius = Math.sqrt(n), t;
  }
};
const lq = /* @__PURE__ */ zc((g, A) => {
  ni(() => {
    z0.install({
      THREE: dU
    }), om({
      CameraControlsImpl: z0
    });
  }, []);
  const {
    camera: e,
    domElement: t,
    makeDefault: i,
    onStart: n,
    onEnd: r,
    onChange: s,
    regress: B,
    ...I
  } = g, E = mr((N) => N.camera), C = mr((N) => N.gl), c = mr((N) => N.invalidate), u = mr((N) => N.events), d = mr((N) => N.setEvents), p = mr((N) => N.set), D = mr((N) => N.get), f = mr((N) => N.performance), S = e || E, y = t || u.connected || C.domElement, m = ni(() => new z0(S), [S]);
  return qE((N, F) => {
    m.enabled && m.update(F);
  }, -1), gi(() => (m.connect(y), () => void m.disconnect()), [y, m]), Te.useEffect(() => {
    const N = (k) => {
      c(), B && f.regress(), s && s(k);
    }, F = (k) => {
      n && n(k);
    }, G = (k) => {
      r && r(k);
    };
    return m.addEventListener("update", N), m.addEventListener("controlstart", F), m.addEventListener("controlend", G), () => {
      m.removeEventListener("update", N), m.removeEventListener("controlstart", F), m.removeEventListener("controlend", G);
    };
  }, [m, n, r, c, d, B, s]), gi(() => {
    if (i) {
      const N = D().controls;
      return p({
        controls: m
      }), () => p({
        controls: N
      });
    }
  }, [i, m]), /* @__PURE__ */ Te.createElement("primitive", OC({
    ref: A,
    object: m
  }, I));
}), cq = () => {
  const { progress: g } = c4(), A = 70, e = 4, t = (A - e) / 2, i = `0 0 ${A} ${A}`, n = t * Math.PI * 2, r = n - n * Math.floor(g) / 100;
  return /* @__PURE__ */ fe(l4, { center: !0, children: /* @__PURE__ */ Wi("svg", { width: A, height: A, viewBox: i, children: [
    /* @__PURE__ */ fe(
      "circle",
      {
        className: "circle-background",
        cx: A / 2,
        cy: A / 2,
        r: t,
        strokeWidth: `${e}px`
      }
    ),
    /* @__PURE__ */ fe(
      "circle",
      {
        className: "circle-progress",
        cx: A / 2,
        cy: A / 2,
        r: t,
        strokeWidth: `${e}px`,
        transform: `rotate(-90 ${A / 2} ${A / 2})`,
        style: {
          strokeDasharray: n,
          strokeDashoffset: r
        }
      }
    ),
    /* @__PURE__ */ fe(
      "text",
      {
        className: "circle-text",
        x: "50%",
        y: "50%",
        dy: ".3em",
        textAnchor: "middle",
        children: `${Math.floor(g)}%`
      }
    )
  ] }) });
};
function uq(g, A = 1e-4) {
  A = Math.max(A, Number.EPSILON);
  const e = {}, t = g.getIndex(), i = g.getAttribute("position"), n = t ? t.count : i.count;
  let r = 0;
  const s = Object.keys(g.attributes), B = {}, I = {}, E = [], C = ["getX", "getY", "getZ", "getW"], c = ["setX", "setY", "setZ", "setW"];
  for (let D = 0, f = s.length; D < f; D++) {
    const S = s[D], y = g.attributes[S];
    B[S] = new Pt(
      new y.array.constructor(y.count * y.itemSize),
      y.itemSize,
      y.normalized
    );
    const m = g.morphAttributes[S];
    m && (I[S] = new Pt(
      new m.array.constructor(m.count * m.itemSize),
      m.itemSize,
      m.normalized
    ));
  }
  const u = Math.log10(1 / A), d = Math.pow(10, u);
  for (let D = 0; D < n; D++) {
    const f = t ? t.getX(D) : D;
    let S = "";
    for (let y = 0, m = s.length; y < m; y++) {
      const N = s[y], F = g.getAttribute(N), G = F.itemSize;
      for (let k = 0; k < G; k++)
        S += `${~~(F[C[k]](f) * d)},`;
    }
    if (S in e)
      E.push(e[S]);
    else {
      for (let y = 0, m = s.length; y < m; y++) {
        const N = s[y], F = g.getAttribute(N), G = g.morphAttributes[N], k = F.itemSize, v = B[N], x = I[N];
        for (let H = 0; H < k; H++) {
          const _ = C[H], j = c[H];
          if (v[j](r, F[_](f)), G)
            for (let V = 0, iA = G.length; V < iA; V++)
              x[V][j](r, G[V][_](f));
        }
      }
      e[S] = r, E.push(r), r++;
    }
  }
  const p = g.clone();
  for (const D in g.attributes) {
    const f = B[D];
    if (p.setAttribute(D, new Pt(
      f.array.slice(0, r * f.itemSize),
      f.itemSize,
      f.normalized
    )), D in I)
      for (let S = 0; S < I[D].length; S++) {
        const y = I[D][S];
        p.morphAttributes[D][S] = new Pt(
          y.array.slice(0, r * y.itemSize),
          y.itemSize,
          y.normalized
        );
      }
  }
  return p.setIndex(E), p;
}
function kF(g, A) {
  if (A === fv)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), g;
  if (A === If || A === Dy) {
    let e = g.getIndex();
    if (e === null) {
      const r = [], s = g.getAttribute("position");
      if (s !== void 0) {
        for (let B = 0; B < s.count; B++)
          r.push(B);
        g.setIndex(r), e = g.getIndex();
      } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), g;
    }
    const t = e.count - 2, i = [];
    if (A === If)
      for (let r = 1; r <= t; r++)
        i.push(e.getX(0)), i.push(e.getX(r)), i.push(e.getX(r + 1));
    else
      for (let r = 0; r < t; r++)
        r % 2 === 0 ? (i.push(e.getX(r)), i.push(e.getX(r + 1)), i.push(e.getX(r + 2))) : (i.push(e.getX(r + 2)), i.push(e.getX(r + 1)), i.push(e.getX(r)));
    i.length / 3 !== t && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const n = g.clone();
    return n.setIndex(i), n.clearGroups(), n;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", A), g;
}
class xF extends Hg {
  constructor(A) {
    super(A), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(e) {
      return new Dq(e);
    }), this.register(function(e) {
      return new Nq(e);
    }), this.register(function(e) {
      return new Fq(e);
    }), this.register(function(e) {
      return new Gq(e);
    }), this.register(function(e) {
      return new yq(e);
    }), this.register(function(e) {
      return new mq(e);
    }), this.register(function(e) {
      return new Sq(e);
    }), this.register(function(e) {
      return new Mq(e);
    }), this.register(function(e) {
      return new pq(e);
    }), this.register(function(e) {
      return new Rq(e);
    }), this.register(function(e) {
      return new wq(e);
    }), this.register(function(e) {
      return new dq(e);
    }), this.register(function(e) {
      return new vq(e);
    }), this.register(function(e) {
      return new Uq(e);
    });
  }
  load(A, e, t, i) {
    const n = this;
    let r;
    this.resourcePath !== "" ? r = this.resourcePath : this.path !== "" ? r = this.path : r = JC.extractUrlBase(A), this.manager.itemStart(A);
    const s = function(I) {
      i ? i(I) : console.error(I), n.manager.itemError(A), n.manager.itemEnd(A);
    }, B = new go(this.manager);
    B.setPath(this.path), B.setResponseType("arraybuffer"), B.setRequestHeader(this.requestHeader), B.setWithCredentials(this.withCredentials), B.load(A, function(I) {
      try {
        n.parse(I, r, function(E) {
          e(E), n.manager.itemEnd(A);
        }, s);
      } catch (E) {
        s(E);
      }
    }, t, s);
  }
  setDRACOLoader(A) {
    return this.dracoLoader = A, this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(A) {
    return this.ktx2Loader = A, this;
  }
  setMeshoptDecoder(A) {
    return this.meshoptDecoder = A, this;
  }
  register(A) {
    return this.pluginCallbacks.indexOf(A) === -1 && this.pluginCallbacks.push(A), this;
  }
  unregister(A) {
    return this.pluginCallbacks.indexOf(A) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(A), 1), this;
  }
  parse(A, e, t, i) {
    let n;
    const r = {}, s = {}, B = new TextDecoder();
    if (typeof A == "string")
      n = JSON.parse(A);
    else if (A instanceof ArrayBuffer)
      if (B.decode(new Uint8Array(A, 0, 4)) === ik) {
        try {
          r[oi.KHR_BINARY_GLTF] = new kq(A);
        } catch (C) {
          i && i(C);
          return;
        }
        n = JSON.parse(r[oi.KHR_BINARY_GLTF].content);
      } else
        n = JSON.parse(B.decode(A));
    else
      n = A;
    if (n.asset === void 0 || n.asset.version[0] < 2) {
      i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const I = new Wq(n, {
      path: e || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    I.fileLoader.setRequestHeader(this.requestHeader);
    for (let E = 0; E < this.pluginCallbacks.length; E++) {
      const C = this.pluginCallbacks[E](I);
      s[C.name] = C, r[C.name] = !0;
    }
    if (n.extensionsUsed)
      for (let E = 0; E < n.extensionsUsed.length; ++E) {
        const C = n.extensionsUsed[E], c = n.extensionsRequired || [];
        switch (C) {
          case oi.KHR_MATERIALS_UNLIT:
            r[C] = new fq();
            break;
          case oi.KHR_DRACO_MESH_COMPRESSION:
            r[C] = new xq(n, this.dracoLoader);
            break;
          case oi.KHR_TEXTURE_TRANSFORM:
            r[C] = new Lq();
            break;
          case oi.KHR_MESH_QUANTIZATION:
            r[C] = new Tq();
            break;
          default:
            c.indexOf(C) >= 0 && s[C] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + C + '".');
        }
      }
    I.setExtensions(r), I.setPlugins(s), I.parse(t, i);
  }
  parseAsync(A, e) {
    const t = this;
    return new Promise(function(i, n) {
      t.parse(A, e, i, n);
    });
  }
}
function hq() {
  let g = {};
  return {
    get: function(A) {
      return g[A];
    },
    add: function(A, e) {
      g[A] = e;
    },
    remove: function(A) {
      delete g[A];
    },
    removeAll: function() {
      g = {};
    }
  };
}
const oi = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class dq {
  constructor(A) {
    this.parser = A, this.name = oi.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const A = this.parser, e = this.parser.json.nodes || [];
    for (let t = 0, i = e.length; t < i; t++) {
      const n = e[t];
      n.extensions && n.extensions[this.name] && n.extensions[this.name].light !== void 0 && A._addNodeRef(this.cache, n.extensions[this.name].light);
    }
  }
  _loadLight(A) {
    const e = this.parser, t = "light:" + A;
    let i = e.cache.get(t);
    if (i)
      return i;
    const n = e.json, B = ((n.extensions && n.extensions[this.name] || {}).lights || [])[A];
    let I;
    const E = new ke(16777215);
    B.color !== void 0 && E.fromArray(B.color);
    const C = B.range !== void 0 ? B.range : 0;
    switch (B.type) {
      case "directional":
        I = new bf(E), I.target.position.set(0, 0, -1), I.add(I.target);
        break;
      case "point":
        I = new Oc(E), I.distance = C;
        break;
      case "spot":
        I = new Kf(E), I.distance = C, B.spot = B.spot || {}, B.spot.innerConeAngle = B.spot.innerConeAngle !== void 0 ? B.spot.innerConeAngle : 0, B.spot.outerConeAngle = B.spot.outerConeAngle !== void 0 ? B.spot.outerConeAngle : Math.PI / 4, I.angle = B.spot.outerConeAngle, I.penumbra = 1 - B.spot.innerConeAngle / B.spot.outerConeAngle, I.target.position.set(0, 0, -1), I.add(I.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + B.type);
    }
    return I.position.set(0, 0, 0), I.decay = 2, oB(I, B), B.intensity !== void 0 && (I.intensity = B.intensity), I.name = e.createUniqueName(B.name || "light_" + A), i = Promise.resolve(I), e.cache.add(t, i), i;
  }
  getDependency(A, e) {
    if (A === "light")
      return this._loadLight(e);
  }
  createNodeAttachment(A) {
    const e = this, t = this.parser, n = t.json.nodes[A], s = (n.extensions && n.extensions[this.name] || {}).light;
    return s === void 0 ? null : this._loadLight(s).then(function(B) {
      return t._getNodeRef(e.cache, s, B);
    });
  }
}
let fq = class {
  constructor() {
    this.name = oi.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Ao;
  }
  extendParams(A, e, t) {
    const i = [];
    A.color = new ke(1, 1, 1), A.opacity = 1;
    const n = e.pbrMetallicRoughness;
    if (n) {
      if (Array.isArray(n.baseColorFactor)) {
        const r = n.baseColorFactor;
        A.color.fromArray(r), A.opacity = r[3];
      }
      n.baseColorTexture !== void 0 && i.push(t.assignTexture(A, "map", n.baseColorTexture, Ht));
    }
    return Promise.all(i);
  }
}, pq = class {
  constructor(A) {
    this.parser = A, this.name = oi.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(A, e) {
    const i = this.parser.json.materials[A];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const n = i.extensions[this.name].emissiveStrength;
    return n !== void 0 && (e.emissiveIntensity = n), Promise.resolve();
  }
}, Dq = class {
  constructor(A) {
    this.parser = A, this.name = oi.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(A) {
    const t = this.parser.json.materials[A];
    return !t.extensions || !t.extensions[this.name] ? null : eI;
  }
  extendMaterialParams(A, e) {
    const t = this.parser, i = t.json.materials[A];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const n = [], r = i.extensions[this.name];
    if (r.clearcoatFactor !== void 0 && (e.clearcoat = r.clearcoatFactor), r.clearcoatTexture !== void 0 && n.push(t.assignTexture(e, "clearcoatMap", r.clearcoatTexture)), r.clearcoatRoughnessFactor !== void 0 && (e.clearcoatRoughness = r.clearcoatRoughnessFactor), r.clearcoatRoughnessTexture !== void 0 && n.push(t.assignTexture(e, "clearcoatRoughnessMap", r.clearcoatRoughnessTexture)), r.clearcoatNormalTexture !== void 0 && (n.push(t.assignTexture(e, "clearcoatNormalMap", r.clearcoatNormalTexture)), r.clearcoatNormalTexture.scale !== void 0)) {
      const s = r.clearcoatNormalTexture.scale;
      e.clearcoatNormalScale = new ue(s, s);
    }
    return Promise.all(n);
  }
}, wq = class {
  constructor(A) {
    this.parser = A, this.name = oi.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(A) {
    const t = this.parser.json.materials[A];
    return !t.extensions || !t.extensions[this.name] ? null : eI;
  }
  extendMaterialParams(A, e) {
    const t = this.parser, i = t.json.materials[A];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const n = [], r = i.extensions[this.name];
    return r.iridescenceFactor !== void 0 && (e.iridescence = r.iridescenceFactor), r.iridescenceTexture !== void 0 && n.push(t.assignTexture(e, "iridescenceMap", r.iridescenceTexture)), r.iridescenceIor !== void 0 && (e.iridescenceIOR = r.iridescenceIor), e.iridescenceThicknessRange === void 0 && (e.iridescenceThicknessRange = [100, 400]), r.iridescenceThicknessMinimum !== void 0 && (e.iridescenceThicknessRange[0] = r.iridescenceThicknessMinimum), r.iridescenceThicknessMaximum !== void 0 && (e.iridescenceThicknessRange[1] = r.iridescenceThicknessMaximum), r.iridescenceThicknessTexture !== void 0 && n.push(t.assignTexture(e, "iridescenceThicknessMap", r.iridescenceThicknessTexture)), Promise.all(n);
  }
}, yq = class {
  constructor(A) {
    this.parser = A, this.name = oi.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(A) {
    const t = this.parser.json.materials[A];
    return !t.extensions || !t.extensions[this.name] ? null : eI;
  }
  extendMaterialParams(A, e) {
    const t = this.parser, i = t.json.materials[A];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const n = [];
    e.sheenColor = new ke(0, 0, 0), e.sheenRoughness = 0, e.sheen = 1;
    const r = i.extensions[this.name];
    return r.sheenColorFactor !== void 0 && e.sheenColor.fromArray(r.sheenColorFactor), r.sheenRoughnessFactor !== void 0 && (e.sheenRoughness = r.sheenRoughnessFactor), r.sheenColorTexture !== void 0 && n.push(t.assignTexture(e, "sheenColorMap", r.sheenColorTexture, Ht)), r.sheenRoughnessTexture !== void 0 && n.push(t.assignTexture(e, "sheenRoughnessMap", r.sheenRoughnessTexture)), Promise.all(n);
  }
}, mq = class {
  constructor(A) {
    this.parser = A, this.name = oi.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(A) {
    const t = this.parser.json.materials[A];
    return !t.extensions || !t.extensions[this.name] ? null : eI;
  }
  extendMaterialParams(A, e) {
    const t = this.parser, i = t.json.materials[A];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const n = [], r = i.extensions[this.name];
    return r.transmissionFactor !== void 0 && (e.transmission = r.transmissionFactor), r.transmissionTexture !== void 0 && n.push(t.assignTexture(e, "transmissionMap", r.transmissionTexture)), Promise.all(n);
  }
}, Sq = class {
  constructor(A) {
    this.parser = A, this.name = oi.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(A) {
    const t = this.parser.json.materials[A];
    return !t.extensions || !t.extensions[this.name] ? null : eI;
  }
  extendMaterialParams(A, e) {
    const t = this.parser, i = t.json.materials[A];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const n = [], r = i.extensions[this.name];
    e.thickness = r.thicknessFactor !== void 0 ? r.thicknessFactor : 0, r.thicknessTexture !== void 0 && n.push(t.assignTexture(e, "thicknessMap", r.thicknessTexture)), e.attenuationDistance = r.attenuationDistance || 1 / 0;
    const s = r.attenuationColor || [1, 1, 1];
    return e.attenuationColor = new ke(s[0], s[1], s[2]), Promise.all(n);
  }
}, Mq = class {
  constructor(A) {
    this.parser = A, this.name = oi.KHR_MATERIALS_IOR;
  }
  getMaterialType(A) {
    const t = this.parser.json.materials[A];
    return !t.extensions || !t.extensions[this.name] ? null : eI;
  }
  extendMaterialParams(A, e) {
    const i = this.parser.json.materials[A];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const n = i.extensions[this.name];
    return e.ior = n.ior !== void 0 ? n.ior : 1.5, Promise.resolve();
  }
}, Rq = class {
  constructor(A) {
    this.parser = A, this.name = oi.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(A) {
    const t = this.parser.json.materials[A];
    return !t.extensions || !t.extensions[this.name] ? null : eI;
  }
  extendMaterialParams(A, e) {
    const t = this.parser, i = t.json.materials[A];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const n = [], r = i.extensions[this.name];
    e.specularIntensity = r.specularFactor !== void 0 ? r.specularFactor : 1, r.specularTexture !== void 0 && n.push(t.assignTexture(e, "specularIntensityMap", r.specularTexture));
    const s = r.specularColorFactor || [1, 1, 1];
    return e.specularColor = new ke(s[0], s[1], s[2]), r.specularColorTexture !== void 0 && n.push(t.assignTexture(e, "specularColorMap", r.specularColorTexture, Ht)), Promise.all(n);
  }
};
class Nq {
  constructor(A) {
    this.parser = A, this.name = oi.KHR_TEXTURE_BASISU;
  }
  loadTexture(A) {
    const e = this.parser, t = e.json, i = t.textures[A];
    if (!i.extensions || !i.extensions[this.name])
      return null;
    const n = i.extensions[this.name], r = e.options.ktx2Loader;
    if (!r) {
      if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return e.loadTextureImage(A, n.source, r);
  }
}
class Fq {
  constructor(A) {
    this.parser = A, this.name = oi.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(A) {
    const e = this.name, t = this.parser, i = t.json, n = i.textures[A];
    if (!n.extensions || !n.extensions[e])
      return null;
    const r = n.extensions[e], s = i.images[r.source];
    let B = t.textureLoader;
    if (s.uri) {
      const I = t.options.manager.getHandler(s.uri);
      I !== null && (B = I);
    }
    return this.detectSupport().then(function(I) {
      if (I)
        return t.loadTextureImage(A, r.source, B);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return t.loadTexture(A);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(A) {
      const e = new Image();
      e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function() {
        A(e.height === 1);
      };
    })), this.isSupported;
  }
}
class Gq {
  constructor(A) {
    this.parser = A, this.name = oi.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(A) {
    const e = this.name, t = this.parser, i = t.json, n = i.textures[A];
    if (!n.extensions || !n.extensions[e])
      return null;
    const r = n.extensions[e], s = i.images[r.source];
    let B = t.textureLoader;
    if (s.uri) {
      const I = t.options.manager.getHandler(s.uri);
      I !== null && (B = I);
    }
    return this.detectSupport().then(function(I) {
      if (I)
        return t.loadTextureImage(A, r.source, B);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return t.loadTexture(A);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(A) {
      const e = new Image();
      e.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", e.onload = e.onerror = function() {
        A(e.height === 1);
      };
    })), this.isSupported;
  }
}
class vq {
  constructor(A) {
    this.name = oi.EXT_MESHOPT_COMPRESSION, this.parser = A;
  }
  loadBufferView(A) {
    const e = this.parser.json, t = e.bufferViews[A];
    if (t.extensions && t.extensions[this.name]) {
      const i = t.extensions[this.name], n = this.parser.getDependency("buffer", i.buffer), r = this.parser.options.meshoptDecoder;
      if (!r || !r.supported) {
        if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return n.then(function(s) {
        const B = i.byteOffset || 0, I = i.byteLength || 0, E = i.count, C = i.byteStride, c = new Uint8Array(s, B, I);
        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(E, C, c, i.mode, i.filter).then(function(u) {
          return u.buffer;
        }) : r.ready.then(function() {
          const u = new ArrayBuffer(E * C);
          return r.decodeGltfBuffer(new Uint8Array(u), E, C, c, i.mode, i.filter), u;
        });
      });
    } else
      return null;
  }
}
class Uq {
  constructor(A) {
    this.name = oi.EXT_MESH_GPU_INSTANCING, this.parser = A;
  }
  createNodeMesh(A) {
    const e = this.parser.json, t = e.nodes[A];
    if (!t.extensions || !t.extensions[this.name] || t.mesh === void 0)
      return null;
    const i = e.meshes[t.mesh];
    for (const I of i.primitives)
      if (I.mode !== Ro.TRIANGLES && I.mode !== Ro.TRIANGLE_STRIP && I.mode !== Ro.TRIANGLE_FAN && I.mode !== void 0)
        return null;
    const r = t.extensions[this.name].attributes, s = [], B = {};
    for (const I in r)
      s.push(this.parser.getDependency("accessor", r[I]).then((E) => (B[I] = E, B[I])));
    return s.length < 1 ? null : (s.push(this.parser.createNodeMesh(A)), Promise.all(s).then((I) => {
      const E = I.pop(), C = E.isGroup ? E.children : [E], c = I[0].count, u = [];
      for (const d of C) {
        const p = new Ve(), D = new IA(), f = new On(), S = new IA(1, 1, 1), y = new ky(d.geometry, d.material, c);
        for (let m = 0; m < c; m++)
          B.TRANSLATION && D.fromBufferAttribute(B.TRANSLATION, m), B.ROTATION && f.fromBufferAttribute(B.ROTATION, m), B.SCALE && S.fromBufferAttribute(B.SCALE, m), y.setMatrixAt(m, p.compose(D, f, S));
        for (const m in B)
          m !== "TRANSLATION" && m !== "ROTATION" && m !== "SCALE" && d.geometry.setAttribute(m, B[m]);
        Xt.prototype.copy.call(y, d), this.parser.assignFinalMaterial(y), u.push(y);
      }
      return E.isGroup ? (E.clear(), E.add(...u), E) : u[0];
    }));
  }
}
const ik = "glTF", dc = 12, LF = { JSON: 1313821514, BIN: 5130562 };
class kq {
  constructor(A) {
    this.name = oi.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const e = new DataView(A, 0, dc), t = new TextDecoder();
    if (this.header = {
      magic: t.decode(new Uint8Array(A.slice(0, 4))),
      version: e.getUint32(4, !0),
      length: e.getUint32(8, !0)
    }, this.header.magic !== ik)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const i = this.header.length - dc, n = new DataView(A, dc);
    let r = 0;
    for (; r < i; ) {
      const s = n.getUint32(r, !0);
      r += 4;
      const B = n.getUint32(r, !0);
      if (r += 4, B === LF.JSON) {
        const I = new Uint8Array(A, dc + r, s);
        this.content = t.decode(I);
      } else if (B === LF.BIN) {
        const I = dc + r;
        this.body = A.slice(I, I + s);
      }
      r += s;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class xq {
  constructor(A, e) {
    if (!e)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = oi.KHR_DRACO_MESH_COMPRESSION, this.json = A, this.dracoLoader = e, this.dracoLoader.preload();
  }
  decodePrimitive(A, e) {
    const t = this.json, i = this.dracoLoader, n = A.extensions[this.name].bufferView, r = A.extensions[this.name].attributes, s = {}, B = {}, I = {};
    for (const E in r) {
      const C = iy[E] || E.toLowerCase();
      s[C] = r[E];
    }
    for (const E in A.attributes) {
      const C = iy[E] || E.toLowerCase();
      if (r[E] !== void 0) {
        const c = t.accessors[A.attributes[E]], u = mE[c.componentType];
        I[C] = u.name, B[C] = c.normalized === !0;
      }
    }
    return e.getDependency("bufferView", n).then(function(E) {
      return new Promise(function(C) {
        i.decodeDracoFile(E, function(c) {
          for (const u in c.attributes) {
            const d = c.attributes[u], p = B[u];
            p !== void 0 && (d.normalized = p);
          }
          C(c);
        }, s, I);
      });
    });
  }
}
class Lq {
  constructor() {
    this.name = oi.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(A, e) {
    return (e.texCoord === void 0 || e.texCoord === A.channel) && e.offset === void 0 && e.rotation === void 0 && e.scale === void 0 || (A = A.clone(), e.texCoord !== void 0 && (A.channel = e.texCoord), e.offset !== void 0 && A.offset.fromArray(e.offset), e.rotation !== void 0 && (A.rotation = e.rotation), e.scale !== void 0 && A.repeat.fromArray(e.scale), A.needsUpdate = !0), A;
  }
}
class Tq {
  constructor() {
    this.name = oi.KHR_MESH_QUANTIZATION;
  }
}
class nk extends OE {
  constructor(A, e, t, i) {
    super(A, e, t, i);
  }
  copySampleValue_(A) {
    const e = this.resultBuffer, t = this.sampleValues, i = this.valueSize, n = A * i * 3 + i;
    for (let r = 0; r !== i; r++)
      e[r] = t[n + r];
    return e;
  }
  interpolate_(A, e, t, i) {
    const n = this.resultBuffer, r = this.sampleValues, s = this.valueSize, B = s * 2, I = s * 3, E = i - e, C = (t - e) / E, c = C * C, u = c * C, d = A * I, p = d - I, D = -2 * u + 3 * c, f = u - c, S = 1 - D, y = f - c + C;
    for (let m = 0; m !== s; m++) {
      const N = r[p + m + s], F = r[p + m + B] * E, G = r[d + m + s], k = r[d + m] * E;
      n[m] = S * N + y * F + D * G + f * k;
    }
    return n;
  }
}
const Kq = new On();
class bq extends nk {
  interpolate_(A, e, t, i) {
    const n = super.interpolate_(A, e, t, i);
    return Kq.fromArray(n).normalize().toArray(n), n;
  }
}
const Ro = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, mE = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, TF = {
  9728: un,
  9729: Gi,
  9984: NE,
  9985: Zc,
  9986: RC,
  9987: Cs
}, KF = {
  33071: Jn,
  33648: kC,
  10497: Bs
}, V0 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, iy = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv2",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, tB = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, Yq = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: uB,
  STEP: TC
}, j0 = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function Hq(g) {
  return g.DefaultMaterial === void 0 && (g.DefaultMaterial = new lu({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: ea
  })), g.DefaultMaterial;
}
function fc(g, A, e) {
  for (const t in e.extensions)
    g[t] === void 0 && (A.userData.gltfExtensions = A.userData.gltfExtensions || {}, A.userData.gltfExtensions[t] = e.extensions[t]);
}
function oB(g, A) {
  A.extras !== void 0 && (typeof A.extras == "object" ? Object.assign(g.userData, A.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + A.extras));
}
function _q(g, A, e) {
  let t = !1, i = !1, n = !1;
  for (let I = 0, E = A.length; I < E; I++) {
    const C = A[I];
    if (C.POSITION !== void 0 && (t = !0), C.NORMAL !== void 0 && (i = !0), C.COLOR_0 !== void 0 && (n = !0), t && i && n)
      break;
  }
  if (!t && !i && !n)
    return Promise.resolve(g);
  const r = [], s = [], B = [];
  for (let I = 0, E = A.length; I < E; I++) {
    const C = A[I];
    if (t) {
      const c = C.POSITION !== void 0 ? e.getDependency("accessor", C.POSITION) : g.attributes.position;
      r.push(c);
    }
    if (i) {
      const c = C.NORMAL !== void 0 ? e.getDependency("accessor", C.NORMAL) : g.attributes.normal;
      s.push(c);
    }
    if (n) {
      const c = C.COLOR_0 !== void 0 ? e.getDependency("accessor", C.COLOR_0) : g.attributes.color;
      B.push(c);
    }
  }
  return Promise.all([
    Promise.all(r),
    Promise.all(s),
    Promise.all(B)
  ]).then(function(I) {
    const E = I[0], C = I[1], c = I[2];
    return t && (g.morphAttributes.position = E), i && (g.morphAttributes.normal = C), n && (g.morphAttributes.color = c), g.morphTargetsRelative = !0, g;
  });
}
function Jq(g, A) {
  if (g.updateMorphTargets(), A.weights !== void 0)
    for (let e = 0, t = A.weights.length; e < t; e++)
      g.morphTargetInfluences[e] = A.weights[e];
  if (A.extras && Array.isArray(A.extras.targetNames)) {
    const e = A.extras.targetNames;
    if (g.morphTargetInfluences.length === e.length) {
      g.morphTargetDictionary = {};
      for (let t = 0, i = e.length; t < i; t++)
        g.morphTargetDictionary[e[t]] = t;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function Oq(g) {
  const A = g.extensions && g.extensions[oi.KHR_DRACO_MESH_COMPRESSION];
  let e;
  return A ? e = "draco:" + A.bufferView + ":" + A.indices + ":" + bF(A.attributes) : e = g.indices + ":" + bF(g.attributes) + ":" + g.mode, e;
}
function bF(g) {
  let A = "";
  const e = Object.keys(g).sort();
  for (let t = 0, i = e.length; t < i; t++)
    A += e[t] + ":" + g[e[t]] + ";";
  return A;
}
function ny(g) {
  switch (g) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function qq(g) {
  return g.search(/\.jpe?g($|\?)/i) > 0 || g.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : g.search(/\.webp($|\?)/i) > 0 || g.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const Pq = new Ve();
class Wq {
  constructor(A = {}, e = {}) {
    this.json = A, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new hq(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let t = !1, i = !1, n = -1;
    typeof navigator < "u" && (t = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, i = navigator.userAgent.indexOf("Firefox") > -1, n = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || t || i && n < 98 ? this.textureLoader = new Tf(this.options.manager) : this.textureLoader = new EU(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new go(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(A) {
    this.extensions = A;
  }
  setPlugins(A) {
    this.plugins = A;
  }
  parse(A, e) {
    const t = this, i = this.json, n = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(r) {
      return r._markDefs && r._markDefs();
    }), Promise.all(this._invokeAll(function(r) {
      return r.beforeRoot && r.beforeRoot();
    })).then(function() {
      return Promise.all([
        t.getDependencies("scene"),
        t.getDependencies("animation"),
        t.getDependencies("camera")
      ]);
    }).then(function(r) {
      const s = {
        scene: r[0][i.scene || 0],
        scenes: r[0],
        animations: r[1],
        cameras: r[2],
        asset: i.asset,
        parser: t,
        userData: {}
      };
      fc(n, s, i), oB(s, i), Promise.all(t._invokeAll(function(B) {
        return B.afterRoot && B.afterRoot(s);
      })).then(function() {
        A(s);
      });
    }).catch(e);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const A = this.json.nodes || [], e = this.json.skins || [], t = this.json.meshes || [];
    for (let i = 0, n = e.length; i < n; i++) {
      const r = e[i].joints;
      for (let s = 0, B = r.length; s < B; s++)
        A[r[s]].isBone = !0;
    }
    for (let i = 0, n = A.length; i < n; i++) {
      const r = A[i];
      r.mesh !== void 0 && (this._addNodeRef(this.meshCache, r.mesh), r.skin !== void 0 && (t[r.mesh].isSkinnedMesh = !0)), r.camera !== void 0 && this._addNodeRef(this.cameraCache, r.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(A, e) {
    e !== void 0 && (A.refs[e] === void 0 && (A.refs[e] = A.uses[e] = 0), A.refs[e]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(A, e, t) {
    if (A.refs[e] <= 1)
      return t;
    const i = t.clone(), n = (r, s) => {
      const B = this.associations.get(r);
      B != null && this.associations.set(s, B);
      for (const [I, E] of r.children.entries())
        n(E, s.children[I]);
    };
    return n(t, i), i.name += "_instance_" + A.uses[e]++, i;
  }
  _invokeOne(A) {
    const e = Object.values(this.plugins);
    e.push(this);
    for (let t = 0; t < e.length; t++) {
      const i = A(e[t]);
      if (i)
        return i;
    }
    return null;
  }
  _invokeAll(A) {
    const e = Object.values(this.plugins);
    e.unshift(this);
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const n = A(e[i]);
      n && t.push(n);
    }
    return t;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(A, e) {
    const t = A + ":" + e;
    let i = this.cache.get(t);
    if (!i) {
      switch (A) {
        case "scene":
          i = this.loadScene(e);
          break;
        case "node":
          i = this._invokeOne(function(n) {
            return n.loadNode && n.loadNode(e);
          });
          break;
        case "mesh":
          i = this._invokeOne(function(n) {
            return n.loadMesh && n.loadMesh(e);
          });
          break;
        case "accessor":
          i = this.loadAccessor(e);
          break;
        case "bufferView":
          i = this._invokeOne(function(n) {
            return n.loadBufferView && n.loadBufferView(e);
          });
          break;
        case "buffer":
          i = this.loadBuffer(e);
          break;
        case "material":
          i = this._invokeOne(function(n) {
            return n.loadMaterial && n.loadMaterial(e);
          });
          break;
        case "texture":
          i = this._invokeOne(function(n) {
            return n.loadTexture && n.loadTexture(e);
          });
          break;
        case "skin":
          i = this.loadSkin(e);
          break;
        case "animation":
          i = this._invokeOne(function(n) {
            return n.loadAnimation && n.loadAnimation(e);
          });
          break;
        case "camera":
          i = this.loadCamera(e);
          break;
        default:
          if (i = this._invokeOne(function(n) {
            return n != this && n.getDependency && n.getDependency(A, e);
          }), !i)
            throw new Error("Unknown type: " + A);
          break;
      }
      this.cache.add(t, i);
    }
    return i;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(A) {
    let e = this.cache.get(A);
    if (!e) {
      const t = this, i = this.json[A + (A === "mesh" ? "es" : "s")] || [];
      e = Promise.all(i.map(function(n, r) {
        return t.getDependency(A, r);
      })), this.cache.add(A, e);
    }
    return e;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(A) {
    const e = this.json.buffers[A], t = this.fileLoader;
    if (e.type && e.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
    if (e.uri === void 0 && A === 0)
      return Promise.resolve(this.extensions[oi.KHR_BINARY_GLTF].body);
    const i = this.options;
    return new Promise(function(n, r) {
      t.load(JC.resolveURL(e.uri, i.path), n, void 0, function() {
        r(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(A) {
    const e = this.json.bufferViews[A];
    return this.getDependency("buffer", e.buffer).then(function(t) {
      const i = e.byteLength || 0, n = e.byteOffset || 0;
      return t.slice(n, n + i);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(A) {
    const e = this, t = this.json, i = this.json.accessors[A];
    if (i.bufferView === void 0 && i.sparse === void 0) {
      const r = V0[i.type], s = mE[i.componentType], B = i.normalized === !0, I = new s(i.count * r);
      return Promise.resolve(new Pt(I, r, B));
    }
    const n = [];
    return i.bufferView !== void 0 ? n.push(this.getDependency("bufferView", i.bufferView)) : n.push(null), i.sparse !== void 0 && (n.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), n.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(n).then(function(r) {
      const s = r[0], B = V0[i.type], I = mE[i.componentType], E = I.BYTES_PER_ELEMENT, C = E * B, c = i.byteOffset || 0, u = i.bufferView !== void 0 ? t.bufferViews[i.bufferView].byteStride : void 0, d = i.normalized === !0;
      let p, D;
      if (u && u !== C) {
        const f = Math.floor(c / u), S = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + f + ":" + i.count;
        let y = e.cache.get(S);
        y || (p = new I(s, f * u, i.count * u / E), y = new eu(p, u / E), e.cache.add(S, y)), D = new hB(y, B, c % u / E, d);
      } else
        s === null ? p = new I(i.count * B) : p = new I(s, c, i.count * B), D = new Pt(p, B, d);
      if (i.sparse !== void 0) {
        const f = V0.SCALAR, S = mE[i.sparse.indices.componentType], y = i.sparse.indices.byteOffset || 0, m = i.sparse.values.byteOffset || 0, N = new S(r[1], y, i.sparse.count * f), F = new I(r[2], m, i.sparse.count * B);
        s !== null && (D = new Pt(D.array.slice(), D.itemSize, D.normalized));
        for (let G = 0, k = N.length; G < k; G++) {
          const v = N[G];
          if (D.setX(v, F[G * B]), B >= 2 && D.setY(v, F[G * B + 1]), B >= 3 && D.setZ(v, F[G * B + 2]), B >= 4 && D.setW(v, F[G * B + 3]), B >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return D;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(A) {
    const e = this.json, t = this.options, n = e.textures[A].source, r = e.images[n];
    let s = this.textureLoader;
    if (r.uri) {
      const B = t.manager.getHandler(r.uri);
      B !== null && (s = B);
    }
    return this.loadTextureImage(A, n, s);
  }
  loadTextureImage(A, e, t) {
    const i = this, n = this.json, r = n.textures[A], s = n.images[e], B = (s.uri || s.bufferView) + ":" + r.sampler;
    if (this.textureCache[B])
      return this.textureCache[B];
    const I = this.loadImageSource(e, t).then(function(E) {
      E.flipY = !1, E.name = r.name || s.name || "", E.name === "" && typeof s.uri == "string" && s.uri.startsWith("data:image/") === !1 && (E.name = s.uri);
      const c = (n.samplers || {})[r.sampler] || {};
      return E.magFilter = TF[c.magFilter] || Gi, E.minFilter = TF[c.minFilter] || Cs, E.wrapS = KF[c.wrapS] || Bs, E.wrapT = KF[c.wrapT] || Bs, i.associations.set(E, { textures: A }), E;
    }).catch(function() {
      return null;
    });
    return this.textureCache[B] = I, I;
  }
  loadImageSource(A, e) {
    const t = this, i = this.json, n = this.options;
    if (this.sourceCache[A] !== void 0)
      return this.sourceCache[A].then((C) => C.clone());
    const r = i.images[A], s = self.URL || self.webkitURL;
    let B = r.uri || "", I = !1;
    if (r.bufferView !== void 0)
      B = t.getDependency("bufferView", r.bufferView).then(function(C) {
        I = !0;
        const c = new Blob([C], { type: r.mimeType });
        return B = s.createObjectURL(c), B;
      });
    else if (r.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + A + " is missing URI and bufferView");
    const E = Promise.resolve(B).then(function(C) {
      return new Promise(function(c, u) {
        let d = c;
        e.isImageBitmapLoader === !0 && (d = function(p) {
          const D = new xi(p);
          D.needsUpdate = !0, c(D);
        }), e.load(JC.resolveURL(C, n.path), d, void 0, u);
      });
    }).then(function(C) {
      return I === !0 && s.revokeObjectURL(B), C.userData.mimeType = r.mimeType || qq(r.uri), C;
    }).catch(function(C) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", B), C;
    });
    return this.sourceCache[A] = E, E;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(A, e, t, i) {
    const n = this;
    return this.getDependency("texture", t.index).then(function(r) {
      if (!r)
        return null;
      if (t.texCoord !== void 0 && t.texCoord > 0 && (r = r.clone(), r.channel = t.texCoord), n.extensions[oi.KHR_TEXTURE_TRANSFORM]) {
        const s = t.extensions !== void 0 ? t.extensions[oi.KHR_TEXTURE_TRANSFORM] : void 0;
        if (s) {
          const B = n.associations.get(r);
          r = n.extensions[oi.KHR_TEXTURE_TRANSFORM].extendTexture(r, s), n.associations.set(r, B);
        }
      }
      return i !== void 0 && (r.encoding = i), A[e] = r, r;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(A) {
    const e = A.geometry;
    let t = A.material;
    const i = e.attributes.tangent === void 0, n = e.attributes.color !== void 0, r = e.attributes.normal === void 0;
    if (A.isPoints) {
      const s = "PointsMaterial:" + t.uuid;
      let B = this.cache.get(s);
      B || (B = new BB(), Sn.prototype.copy.call(B, t), B.color.copy(t.color), B.map = t.map, B.sizeAttenuation = !1, this.cache.add(s, B)), t = B;
    } else if (A.isLine) {
      const s = "LineBasicMaterial:" + t.uuid;
      let B = this.cache.get(s);
      B || (B = new Mn(), Sn.prototype.copy.call(B, t), B.color.copy(t.color), B.map = t.map, this.cache.add(s, B)), t = B;
    }
    if (i || n || r) {
      let s = "ClonedMaterial:" + t.uuid + ":";
      i && (s += "derivative-tangents:"), n && (s += "vertex-colors:"), r && (s += "flat-shading:");
      let B = this.cache.get(s);
      B || (B = t.clone(), n && (B.vertexColors = !0), r && (B.flatShading = !0), i && (B.normalScale && (B.normalScale.y *= -1), B.clearcoatNormalScale && (B.clearcoatNormalScale.y *= -1)), this.cache.add(s, B), this.associations.set(B, this.associations.get(t))), t = B;
    }
    A.material = t;
  }
  getMaterialType() {
    return lu;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(A) {
    const e = this, t = this.json, i = this.extensions, n = t.materials[A];
    let r;
    const s = {}, B = n.extensions || {}, I = [];
    if (B[oi.KHR_MATERIALS_UNLIT]) {
      const C = i[oi.KHR_MATERIALS_UNLIT];
      r = C.getMaterialType(), I.push(C.extendParams(s, n, e));
    } else {
      const C = n.pbrMetallicRoughness || {};
      if (s.color = new ke(1, 1, 1), s.opacity = 1, Array.isArray(C.baseColorFactor)) {
        const c = C.baseColorFactor;
        s.color.fromArray(c), s.opacity = c[3];
      }
      C.baseColorTexture !== void 0 && I.push(e.assignTexture(s, "map", C.baseColorTexture, Ht)), s.metalness = C.metallicFactor !== void 0 ? C.metallicFactor : 1, s.roughness = C.roughnessFactor !== void 0 ? C.roughnessFactor : 1, C.metallicRoughnessTexture !== void 0 && (I.push(e.assignTexture(s, "metalnessMap", C.metallicRoughnessTexture)), I.push(e.assignTexture(s, "roughnessMap", C.metallicRoughnessTexture))), r = this._invokeOne(function(c) {
        return c.getMaterialType && c.getMaterialType(A);
      }), I.push(Promise.all(this._invokeAll(function(c) {
        return c.extendMaterialParams && c.extendMaterialParams(A, s);
      })));
    }
    n.doubleSided === !0 && (s.side = Rr);
    const E = n.alphaMode || j0.OPAQUE;
    if (E === j0.BLEND ? (s.transparent = !0, s.depthWrite = !1) : (s.transparent = !1, E === j0.MASK && (s.alphaTest = n.alphaCutoff !== void 0 ? n.alphaCutoff : 0.5)), n.normalTexture !== void 0 && r !== Ao && (I.push(e.assignTexture(s, "normalMap", n.normalTexture)), s.normalScale = new ue(1, 1), n.normalTexture.scale !== void 0)) {
      const C = n.normalTexture.scale;
      s.normalScale.set(C, C);
    }
    return n.occlusionTexture !== void 0 && r !== Ao && (I.push(e.assignTexture(s, "aoMap", n.occlusionTexture)), n.occlusionTexture.strength !== void 0 && (s.aoMapIntensity = n.occlusionTexture.strength)), n.emissiveFactor !== void 0 && r !== Ao && (s.emissive = new ke().fromArray(n.emissiveFactor)), n.emissiveTexture !== void 0 && r !== Ao && I.push(e.assignTexture(s, "emissiveMap", n.emissiveTexture, Ht)), Promise.all(I).then(function() {
      const C = new r(s);
      return n.name && (C.name = n.name), oB(C, n), e.associations.set(C, { materials: A }), n.extensions && fc(i, C, n), C;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(A) {
    const e = xt.sanitizeNodeName(A || "");
    let t = e;
    for (let i = 1; this.nodeNamesUsed[t]; ++i)
      t = e + "_" + i;
    return this.nodeNamesUsed[t] = !0, t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(A) {
    const e = this, t = this.extensions, i = this.primitiveCache;
    function n(s) {
      return t[oi.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(s, e).then(function(B) {
        return YF(B, s, e);
      });
    }
    const r = [];
    for (let s = 0, B = A.length; s < B; s++) {
      const I = A[s], E = Oq(I), C = i[E];
      if (C)
        r.push(C.promise);
      else {
        let c;
        I.extensions && I.extensions[oi.KHR_DRACO_MESH_COMPRESSION] ? c = n(I) : c = YF(new ut(), I, e), i[E] = { primitive: I, promise: c }, r.push(c);
      }
    }
    return Promise.all(r);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(A) {
    const e = this, t = this.json, i = this.extensions, n = t.meshes[A], r = n.primitives, s = [];
    for (let B = 0, I = r.length; B < I; B++) {
      const E = r[B].material === void 0 ? Hq(this.cache) : this.getDependency("material", r[B].material);
      s.push(E);
    }
    return s.push(e.loadGeometries(r)), Promise.all(s).then(function(B) {
      const I = B.slice(0, B.length - 1), E = B[B.length - 1], C = [];
      for (let u = 0, d = E.length; u < d; u++) {
        const p = E[u], D = r[u];
        let f;
        const S = I[u];
        if (D.mode === Ro.TRIANGLES || D.mode === Ro.TRIANGLE_STRIP || D.mode === Ro.TRIANGLE_FAN || D.mode === void 0)
          f = n.isSkinnedMesh === !0 ? new kf(p, S) : new Xi(p, S), f.isSkinnedMesh === !0 && f.normalizeSkinWeights(), D.mode === Ro.TRIANGLE_STRIP ? f.geometry = kF(f.geometry, Dy) : D.mode === Ro.TRIANGLE_FAN && (f.geometry = kF(f.geometry, If));
        else if (D.mode === Ro.LINES)
          f = new no(p, S);
        else if (D.mode === Ro.LINE_STRIP)
          f = new Qs(p, S);
        else if (D.mode === Ro.LINE_LOOP)
          f = new xy(p, S);
        else if (D.mode === Ro.POINTS)
          f = new yE(p, S);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + D.mode);
        Object.keys(f.geometry.morphAttributes).length > 0 && Jq(f, n), f.name = e.createUniqueName(n.name || "mesh_" + A), oB(f, n), D.extensions && fc(i, f, D), e.assignFinalMaterial(f), C.push(f);
      }
      for (let u = 0, d = C.length; u < d; u++)
        e.associations.set(C[u], {
          meshes: A,
          primitives: u
        });
      if (C.length === 1)
        return C[0];
      const c = new eo();
      e.associations.set(c, { meshes: A });
      for (let u = 0, d = C.length; u < d; u++)
        c.add(C[u]);
      return c;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(A) {
    let e;
    const t = this.json.cameras[A], i = t[t.type];
    if (!i) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return t.type === "perspective" ? e = new mn(bg.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : t.type === "orthographic" && (e = new $a(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), t.name && (e.name = this.createUniqueName(t.name)), oB(e, t), Promise.resolve(e);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(A) {
    const e = this.json.skins[A], t = [];
    for (let i = 0, n = e.joints.length; i < n; i++)
      t.push(this._loadNodeShallow(e.joints[i]));
    return e.inverseBindMatrices !== void 0 ? t.push(this.getDependency("accessor", e.inverseBindMatrices)) : t.push(null), Promise.all(t).then(function(i) {
      const n = i.pop(), r = i, s = [], B = [];
      for (let I = 0, E = r.length; I < E; I++) {
        const C = r[I];
        if (C) {
          s.push(C);
          const c = new Ve();
          n !== null && c.fromArray(n.array, I * 16), B.push(c);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[I]);
      }
      return new YE(s, B);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(A) {
    const t = this.json.animations[A], i = t.name ? t.name : "animation_" + A, n = [], r = [], s = [], B = [], I = [];
    for (let E = 0, C = t.channels.length; E < C; E++) {
      const c = t.channels[E], u = t.samplers[c.sampler], d = c.target, p = d.node, D = t.parameters !== void 0 ? t.parameters[u.input] : u.input, f = t.parameters !== void 0 ? t.parameters[u.output] : u.output;
      d.node !== void 0 && (n.push(this.getDependency("node", p)), r.push(this.getDependency("accessor", D)), s.push(this.getDependency("accessor", f)), B.push(u), I.push(d));
    }
    return Promise.all([
      Promise.all(n),
      Promise.all(r),
      Promise.all(s),
      Promise.all(B),
      Promise.all(I)
    ]).then(function(E) {
      const C = E[0], c = E[1], u = E[2], d = E[3], p = E[4], D = [];
      for (let f = 0, S = C.length; f < S; f++) {
        const y = C[f], m = c[f], N = u[f], F = d[f], G = p[f];
        if (y === void 0)
          continue;
        y.updateMatrix();
        let k;
        switch (tB[G.path]) {
          case tB.weights:
            k = bC;
            break;
          case tB.rotation:
            k = ja;
            break;
          case tB.position:
          case tB.scale:
          default:
            k = YC;
            break;
        }
        const v = y.name ? y.name : y.uuid, x = F.interpolation !== void 0 ? Yq[F.interpolation] : uB, H = [];
        tB[G.path] === tB.weights ? y.traverse(function(j) {
          j.morphTargetInfluences && H.push(j.name ? j.name : j.uuid);
        }) : H.push(v);
        let _ = N.array;
        if (N.normalized) {
          const j = ny(_.constructor), V = new Float32Array(_.length);
          for (let iA = 0, eA = _.length; iA < eA; iA++)
            V[iA] = _[iA] * j;
          _ = V;
        }
        for (let j = 0, V = H.length; j < V; j++) {
          const iA = new k(
            H[j] + "." + tB[G.path],
            m.array,
            _,
            x
          );
          F.interpolation === "CUBICSPLINE" && (iA.createInterpolant = function(oA) {
            const P = this instanceof ja ? bq : nk;
            return new P(this.times, this.values, this.getValueSize() / 3, oA);
          }, iA.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), D.push(iA);
        }
      }
      return new HC(i, void 0, D);
    });
  }
  createNodeMesh(A) {
    const e = this.json, t = this, i = e.nodes[A];
    return i.mesh === void 0 ? null : t.getDependency("mesh", i.mesh).then(function(n) {
      const r = t._getNodeRef(t.meshCache, i.mesh, n);
      return i.weights !== void 0 && r.traverse(function(s) {
        if (s.isMesh)
          for (let B = 0, I = i.weights.length; B < I; B++)
            s.morphTargetInfluences[B] = i.weights[B];
      }), r;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(A) {
    const e = this.json, t = this, i = e.nodes[A], n = t._loadNodeShallow(A), r = [], s = i.children || [];
    for (let I = 0, E = s.length; I < E; I++)
      r.push(t.getDependency("node", s[I]));
    const B = i.skin === void 0 ? Promise.resolve(null) : t.getDependency("skin", i.skin);
    return Promise.all([
      n,
      Promise.all(r),
      B
    ]).then(function(I) {
      const E = I[0], C = I[1], c = I[2];
      c !== null && E.traverse(function(u) {
        u.isSkinnedMesh && u.bind(c, Pq);
      });
      for (let u = 0, d = C.length; u < d; u++)
        E.add(C[u]);
      return E;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(A) {
    const e = this.json, t = this.extensions, i = this;
    if (this.nodeCache[A] !== void 0)
      return this.nodeCache[A];
    const n = e.nodes[A], r = n.name ? i.createUniqueName(n.name) : "", s = [], B = i._invokeOne(function(I) {
      return I.createNodeMesh && I.createNodeMesh(A);
    });
    return B && s.push(B), n.camera !== void 0 && s.push(i.getDependency("camera", n.camera).then(function(I) {
      return i._getNodeRef(i.cameraCache, n.camera, I);
    })), i._invokeAll(function(I) {
      return I.createNodeAttachment && I.createNodeAttachment(A);
    }).forEach(function(I) {
      s.push(I);
    }), this.nodeCache[A] = Promise.all(s).then(function(I) {
      let E;
      if (n.isBone === !0 ? E = new kE() : I.length > 1 ? E = new eo() : I.length === 1 ? E = I[0] : E = new Xt(), E !== I[0])
        for (let C = 0, c = I.length; C < c; C++)
          E.add(I[C]);
      if (n.name && (E.userData.name = n.name, E.name = r), oB(E, n), n.extensions && fc(t, E, n), n.matrix !== void 0) {
        const C = new Ve();
        C.fromArray(n.matrix), E.applyMatrix4(C);
      } else
        n.translation !== void 0 && E.position.fromArray(n.translation), n.rotation !== void 0 && E.quaternion.fromArray(n.rotation), n.scale !== void 0 && E.scale.fromArray(n.scale);
      return i.associations.has(E) || i.associations.set(E, {}), i.associations.get(E).nodes = A, E;
    }), this.nodeCache[A];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(A) {
    const e = this.extensions, t = this.json.scenes[A], i = this, n = new eo();
    t.name && (n.name = i.createUniqueName(t.name)), oB(n, t), t.extensions && fc(e, n, t);
    const r = t.nodes || [], s = [];
    for (let B = 0, I = r.length; B < I; B++)
      s.push(i.getDependency("node", r[B]));
    return Promise.all(s).then(function(B) {
      for (let E = 0, C = B.length; E < C; E++)
        n.add(B[E]);
      const I = (E) => {
        const C = /* @__PURE__ */ new Map();
        for (const [c, u] of i.associations)
          (c instanceof Sn || c instanceof xi) && C.set(c, u);
        return E.traverse((c) => {
          const u = i.associations.get(c);
          u != null && C.set(c, u);
        }), C;
      };
      return i.associations = I(n), n;
    });
  }
}
function zq(g, A, e) {
  const t = A.attributes, i = new cs();
  if (t.POSITION !== void 0) {
    const s = e.json.accessors[t.POSITION], B = s.min, I = s.max;
    if (B !== void 0 && I !== void 0) {
      if (i.set(
        new IA(B[0], B[1], B[2]),
        new IA(I[0], I[1], I[2])
      ), s.normalized) {
        const E = ny(mE[s.componentType]);
        i.min.multiplyScalar(E), i.max.multiplyScalar(E);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const n = A.targets;
  if (n !== void 0) {
    const s = new IA(), B = new IA();
    for (let I = 0, E = n.length; I < E; I++) {
      const C = n[I];
      if (C.POSITION !== void 0) {
        const c = e.json.accessors[C.POSITION], u = c.min, d = c.max;
        if (u !== void 0 && d !== void 0) {
          if (B.setX(Math.max(Math.abs(u[0]), Math.abs(d[0]))), B.setY(Math.max(Math.abs(u[1]), Math.abs(d[1]))), B.setZ(Math.max(Math.abs(u[2]), Math.abs(d[2]))), c.normalized) {
            const p = ny(mE[c.componentType]);
            B.multiplyScalar(p);
          }
          s.max(B);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    i.expandByVector(s);
  }
  g.boundingBox = i;
  const r = new us();
  i.getCenter(r.center), r.radius = i.min.distanceTo(i.max) / 2, g.boundingSphere = r;
}
function YF(g, A, e) {
  const t = A.attributes, i = [];
  function n(r, s) {
    return e.getDependency("accessor", r).then(function(B) {
      g.setAttribute(s, B);
    });
  }
  for (const r in t) {
    const s = iy[r] || r.toLowerCase();
    s in g.attributes || i.push(n(t[r], s));
  }
  if (A.indices !== void 0 && !g.index) {
    const r = e.getDependency("accessor", A.indices).then(function(s) {
      g.setIndex(s);
    });
    i.push(r);
  }
  return oB(g, A), zq(g, A, e), Promise.all(i).then(function() {
    return A.targets !== void 0 ? _q(g, A.targets, e) : g;
  });
}
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
var HF = function(g) {
  return URL.createObjectURL(new Blob([g], { type: "text/javascript" }));
};
try {
  URL.revokeObjectURL(HF(""));
} catch {
  HF = function(A) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(A);
  };
}
var vo = Uint8Array, QB = Uint16Array, gy = Uint32Array, gk = new vo([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), rk = new vo([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), Vq = new vo([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), ok = function(g, A) {
  for (var e = new QB(31), t = 0; t < 31; ++t)
    e[t] = A += 1 << g[t - 1];
  for (var i = new gy(e[30]), t = 1; t < 30; ++t)
    for (var n = e[t]; n < e[t + 1]; ++n)
      i[n] = n - e[t] << 5 | t;
  return [e, i];
}, sk = ok(gk, 2), ak = sk[0], jq = sk[1];
ak[28] = 258, jq[258] = 28;
var Zq = ok(rk, 0), Xq = Zq[0], ry = new QB(32768);
for (var Pi = 0; Pi < 32768; ++Pi) {
  var iB = (Pi & 43690) >>> 1 | (Pi & 21845) << 1;
  iB = (iB & 52428) >>> 2 | (iB & 13107) << 2, iB = (iB & 61680) >>> 4 | (iB & 3855) << 4, ry[Pi] = ((iB & 65280) >>> 8 | (iB & 255) << 8) >>> 1;
}
var Fc = function(g, A, e) {
  for (var t = g.length, i = 0, n = new QB(A); i < t; ++i)
    ++n[g[i] - 1];
  var r = new QB(A);
  for (i = 0; i < A; ++i)
    r[i] = r[i - 1] + n[i - 1] << 1;
  var s;
  if (e) {
    s = new QB(1 << A);
    var B = 15 - A;
    for (i = 0; i < t; ++i)
      if (g[i])
        for (var I = i << 4 | g[i], E = A - g[i], C = r[g[i] - 1]++ << E, c = C | (1 << E) - 1; C <= c; ++C)
          s[ry[C] >>> B] = I;
  } else
    for (s = new QB(t), i = 0; i < t; ++i)
      g[i] && (s[i] = ry[r[g[i] - 1]++] >>> 15 - g[i]);
  return s;
}, fu = new vo(288);
for (var Pi = 0; Pi < 144; ++Pi)
  fu[Pi] = 8;
for (var Pi = 144; Pi < 256; ++Pi)
  fu[Pi] = 9;
for (var Pi = 256; Pi < 280; ++Pi)
  fu[Pi] = 7;
for (var Pi = 280; Pi < 288; ++Pi)
  fu[Pi] = 8;
var Ik = new vo(32);
for (var Pi = 0; Pi < 32; ++Pi)
  Ik[Pi] = 5;
var $q = /* @__PURE__ */ Fc(fu, 9, 1), AP = /* @__PURE__ */ Fc(Ik, 5, 1), Z0 = function(g) {
  for (var A = g[0], e = 1; e < g.length; ++e)
    g[e] > A && (A = g[e]);
  return A;
}, os = function(g, A, e) {
  var t = A / 8 | 0;
  return (g[t] | g[t + 1] << 8) >> (A & 7) & e;
}, X0 = function(g, A) {
  var e = A / 8 | 0;
  return (g[e] | g[e + 1] << 8 | g[e + 2] << 16) >> (A & 7);
}, eP = function(g) {
  return (g / 8 | 0) + (g & 7 && 1);
}, tP = function(g, A, e) {
  (A == null || A < 0) && (A = 0), (e == null || e > g.length) && (e = g.length);
  var t = new (g instanceof QB ? QB : g instanceof gy ? gy : vo)(e - A);
  return t.set(g.subarray(A, e)), t;
}, iP = function(g, A, e) {
  var t = g.length;
  if (!t || e && !e.l && t < 5)
    return A || new vo(0);
  var i = !A || e, n = !e || e.i;
  e || (e = {}), A || (A = new vo(t * 3));
  var r = function(hA) {
    var fA = A.length;
    if (hA > fA) {
      var wA = new vo(Math.max(fA * 2, hA));
      wA.set(A), A = wA;
    }
  }, s = e.f || 0, B = e.p || 0, I = e.b || 0, E = e.l, C = e.d, c = e.m, u = e.n, d = t * 8;
  do {
    if (!E) {
      e.f = s = os(g, B, 1);
      var p = os(g, B + 1, 3);
      if (B += 3, p)
        if (p == 1)
          E = $q, C = AP, c = 9, u = 5;
        else if (p == 2) {
          var y = os(g, B, 31) + 257, m = os(g, B + 10, 15) + 4, N = y + os(g, B + 5, 31) + 1;
          B += 14;
          for (var F = new vo(N), G = new vo(19), k = 0; k < m; ++k)
            G[Vq[k]] = os(g, B + k * 3, 7);
          B += m * 3;
          for (var v = Z0(G), x = (1 << v) - 1, H = Fc(G, v, 1), k = 0; k < N; ) {
            var _ = H[os(g, B, x)];
            B += _ & 15;
            var D = _ >>> 4;
            if (D < 16)
              F[k++] = D;
            else {
              var j = 0, V = 0;
              for (D == 16 ? (V = 3 + os(g, B, 3), B += 2, j = F[k - 1]) : D == 17 ? (V = 3 + os(g, B, 7), B += 3) : D == 18 && (V = 11 + os(g, B, 127), B += 7); V--; )
                F[k++] = j;
            }
          }
          var iA = F.subarray(0, y), eA = F.subarray(y);
          c = Z0(iA), u = Z0(eA), E = Fc(iA, c, 1), C = Fc(eA, u, 1);
        } else
          throw "invalid block type";
      else {
        var D = eP(B) + 4, f = g[D - 4] | g[D - 3] << 8, S = D + f;
        if (S > t) {
          if (n)
            throw "unexpected EOF";
          break;
        }
        i && r(I + f), A.set(g.subarray(D, S), I), e.b = I += f, e.p = B = S * 8;
        continue;
      }
      if (B > d) {
        if (n)
          throw "unexpected EOF";
        break;
      }
    }
    i && r(I + 131072);
    for (var oA = (1 << c) - 1, P = (1 << u) - 1, J = B; ; J = B) {
      var j = E[X0(g, B) & oA], tA = j >>> 4;
      if (B += j & 15, B > d) {
        if (n)
          throw "unexpected EOF";
        break;
      }
      if (!j)
        throw "invalid length/literal";
      if (tA < 256)
        A[I++] = tA;
      else if (tA == 256) {
        J = B, E = null;
        break;
      } else {
        var Y = tA - 254;
        if (tA > 264) {
          var k = tA - 257, rA = gk[k];
          Y = os(g, B, (1 << rA) - 1) + ak[k], B += rA;
        }
        var QA = C[X0(g, B) & P], aA = QA >>> 4;
        if (!QA)
          throw "invalid distance";
        B += QA & 15;
        var eA = Xq[aA];
        if (aA > 3) {
          var rA = rk[aA];
          eA += X0(g, B) & (1 << rA) - 1, B += rA;
        }
        if (B > d) {
          if (n)
            throw "unexpected EOF";
          break;
        }
        i && r(I + 131072);
        for (var MA = I + Y; I < MA; I += 4)
          A[I] = A[I - eA], A[I + 1] = A[I + 1 - eA], A[I + 2] = A[I + 2 - eA], A[I + 3] = A[I + 3 - eA];
        I = MA;
      }
    }
    e.l = E, e.p = J, e.b = I, E && (s = 1, e.m = c, e.d = C, e.n = u);
  } while (!s);
  return I == A.length ? A : tP(A, 0, I);
}, nP = /* @__PURE__ */ new vo(0), gP = function(g) {
  if ((g[0] & 15) != 8 || g[0] >>> 4 > 7 || (g[0] << 8 | g[1]) % 31)
    throw "invalid zlib data";
  if (g[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function rP(g, A) {
  return iP((gP(g), g.subarray(2, -4)), A);
}
var oP = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), sP = 0;
try {
  oP.decode(nP, { stream: !0 }), sP = 1;
} catch {
}
function Bk(g, A, e) {
  const t = e.length - g - 1;
  if (A >= e[t])
    return t - 1;
  if (A <= e[g])
    return g;
  let i = g, n = t, r = Math.floor((i + n) / 2);
  for (; A < e[r] || A >= e[r + 1]; )
    A < e[r] ? n = r : i = r, r = Math.floor((i + n) / 2);
  return r;
}
function aP(g, A, e, t) {
  const i = [], n = [], r = [];
  i[0] = 1;
  for (let s = 1; s <= e; ++s) {
    n[s] = A - t[g + 1 - s], r[s] = t[g + s] - A;
    let B = 0;
    for (let I = 0; I < s; ++I) {
      const E = r[I + 1], C = n[s - I], c = i[I] / (E + C);
      i[I] = B + E * c, B = C * c;
    }
    i[s] = B;
  }
  return i;
}
function IP(g, A, e, t) {
  const i = Bk(g, t, A), n = aP(i, t, g, A), r = new Bi(0, 0, 0, 0);
  for (let s = 0; s <= g; ++s) {
    const B = e[i - g + s], I = n[s], E = B.w * I;
    r.x += B.x * E, r.y += B.y * E, r.z += B.z * E, r.w += B.w * I;
  }
  return r;
}
function BP(g, A, e, t, i) {
  const n = [];
  for (let C = 0; C <= e; ++C)
    n[C] = 0;
  const r = [];
  for (let C = 0; C <= t; ++C)
    r[C] = n.slice(0);
  const s = [];
  for (let C = 0; C <= e; ++C)
    s[C] = n.slice(0);
  s[0][0] = 1;
  const B = n.slice(0), I = n.slice(0);
  for (let C = 1; C <= e; ++C) {
    B[C] = A - i[g + 1 - C], I[C] = i[g + C] - A;
    let c = 0;
    for (let u = 0; u < C; ++u) {
      const d = I[u + 1], p = B[C - u];
      s[C][u] = d + p;
      const D = s[u][C - 1] / s[C][u];
      s[u][C] = c + d * D, c = p * D;
    }
    s[C][C] = c;
  }
  for (let C = 0; C <= e; ++C)
    r[0][C] = s[C][e];
  for (let C = 0; C <= e; ++C) {
    let c = 0, u = 1;
    const d = [];
    for (let p = 0; p <= e; ++p)
      d[p] = n.slice(0);
    d[0][0] = 1;
    for (let p = 1; p <= t; ++p) {
      let D = 0;
      const f = C - p, S = e - p;
      C >= p && (d[u][0] = d[c][0] / s[S + 1][f], D = d[u][0] * s[f][S]);
      const y = f >= -1 ? 1 : -f, m = C - 1 <= S ? p - 1 : e - C;
      for (let F = y; F <= m; ++F)
        d[u][F] = (d[c][F] - d[c][F - 1]) / s[S + 1][f + F], D += d[u][F] * s[f + F][S];
      C <= S && (d[u][p] = -d[c][p - 1] / s[S + 1][C], D += d[u][p] * s[C][S]), r[p][C] = D;
      const N = c;
      c = u, u = N;
    }
  }
  let E = e;
  for (let C = 1; C <= t; ++C) {
    for (let c = 0; c <= e; ++c)
      r[C][c] *= E;
    E *= e - C;
  }
  return r;
}
function CP(g, A, e, t, i) {
  const n = i < g ? i : g, r = [], s = Bk(g, t, A), B = BP(s, t, g, n, A), I = [];
  for (let E = 0; E < e.length; ++E) {
    const C = e[E].clone(), c = C.w;
    C.x *= c, C.y *= c, C.z *= c, I[E] = C;
  }
  for (let E = 0; E <= n; ++E) {
    const C = I[s - g].clone().multiplyScalar(B[E][0]);
    for (let c = 1; c <= g; ++c)
      C.add(I[s - g + c].clone().multiplyScalar(B[E][c]));
    r[E] = C;
  }
  for (let E = n + 1; E <= i + 1; ++E)
    r[E] = new Bi(0, 0, 0);
  return r;
}
function QP(g, A) {
  let e = 1;
  for (let i = 2; i <= g; ++i)
    e *= i;
  let t = 1;
  for (let i = 2; i <= A; ++i)
    t *= i;
  for (let i = 2; i <= g - A; ++i)
    t *= i;
  return e / t;
}
function EP(g) {
  const A = g.length, e = [], t = [];
  for (let n = 0; n < A; ++n) {
    const r = g[n];
    e[n] = new IA(r.x, r.y, r.z), t[n] = r.w;
  }
  const i = [];
  for (let n = 0; n < A; ++n) {
    const r = e[n].clone();
    for (let s = 1; s <= n; ++s)
      r.sub(i[n - s].clone().multiplyScalar(QP(n, s) * t[s]));
    i[n] = r.divideScalar(t[0]);
  }
  return i;
}
function lP(g, A, e, t, i) {
  const n = CP(g, A, e, t, i);
  return EP(n);
}
class cP extends ko {
  constructor(A, e, t, i, n) {
    super(), this.degree = A, this.knots = e, this.controlPoints = [], this.startKnot = i || 0, this.endKnot = n || this.knots.length - 1;
    for (let r = 0; r < t.length; ++r) {
      const s = t[r];
      this.controlPoints[r] = new Bi(s.x, s.y, s.z, s.w);
    }
  }
  getPoint(A, e = new IA()) {
    const t = e, i = this.knots[this.startKnot] + A * (this.knots[this.endKnot] - this.knots[this.startKnot]), n = IP(this.degree, this.knots, this.controlPoints, i);
    return n.w !== 1 && n.divideScalar(n.w), t.set(n.x, n.y, n.z);
  }
  getTangent(A, e = new IA()) {
    const t = e, i = this.knots[0] + A * (this.knots[this.knots.length - 1] - this.knots[0]), n = lP(this.degree, this.knots, this.controlPoints, i, 1);
    return t.copy(n[1]).normalize(), t;
  }
}
let Zt, bn, wr;
class uP extends Hg {
  constructor(A) {
    super(A);
  }
  load(A, e, t, i) {
    const n = this, r = n.path === "" ? JC.extractUrlBase(A) : n.path, s = new go(this.manager);
    s.setPath(n.path), s.setResponseType("arraybuffer"), s.setRequestHeader(n.requestHeader), s.setWithCredentials(n.withCredentials), s.load(A, function(B) {
      try {
        e(n.parse(B, r));
      } catch (I) {
        i ? i(I) : console.error(I), n.manager.itemError(A);
      }
    }, t, i);
  }
  parse(A, e) {
    if (wP(A))
      Zt = new DP().parse(A);
    else {
      const i = lk(A);
      if (!yP(i))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (JF(i) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + JF(i));
      Zt = new pP().parse(i);
    }
    const t = new Tf(this.manager).setPath(this.resourcePath || e).setCrossOrigin(this.crossOrigin);
    return new hP(t, this.manager).parse(Zt);
  }
}
class hP {
  constructor(A, e) {
    this.textureLoader = A, this.manager = e;
  }
  parse() {
    bn = this.parseConnections();
    const A = this.parseImages(), e = this.parseTextures(A), t = this.parseMaterials(e), i = this.parseDeformers(), n = new dP().parse(i);
    return this.parseScene(i, n, t), wr;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const A = /* @__PURE__ */ new Map();
    return "Connections" in Zt && Zt.Connections.connections.forEach(function(t) {
      const i = t[0], n = t[1], r = t[2];
      A.has(i) || A.set(i, {
        parents: [],
        children: []
      });
      const s = { ID: n, relationship: r };
      A.get(i).parents.push(s), A.has(n) || A.set(n, {
        parents: [],
        children: []
      });
      const B = { ID: i, relationship: r };
      A.get(n).children.push(B);
    }), A;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const A = {}, e = {};
    if ("Video" in Zt.Objects) {
      const t = Zt.Objects.Video;
      for (const i in t) {
        const n = t[i], r = parseInt(i);
        if (A[r] = n.RelativeFilename || n.Filename, "Content" in n) {
          const s = n.Content instanceof ArrayBuffer && n.Content.byteLength > 0, B = typeof n.Content == "string" && n.Content !== "";
          if (s || B) {
            const I = this.parseImage(t[i]);
            e[n.RelativeFilename || n.Filename] = I;
          }
        }
      }
    }
    for (const t in A) {
      const i = A[t];
      e[i] !== void 0 ? A[t] = e[i] : A[t] = A[t].split("\\").pop();
    }
    return A;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(A) {
    const e = A.Content, t = A.RelativeFilename || A.Filename, i = t.slice(t.lastIndexOf(".") + 1).toLowerCase();
    let n;
    switch (i) {
      case "bmp":
        n = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        n = "image/jpeg";
        break;
      case "png":
        n = "image/png";
        break;
      case "tif":
        n = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", t), n = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + i + '" is not supported.');
        return;
    }
    if (typeof e == "string")
      return "data:" + n + ";base64," + e;
    {
      const r = new Uint8Array(e);
      return window.URL.createObjectURL(new Blob([r], { type: n }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(A) {
    const e = /* @__PURE__ */ new Map();
    if ("Texture" in Zt.Objects) {
      const t = Zt.Objects.Texture;
      for (const i in t) {
        const n = this.parseTexture(t[i], A);
        e.set(parseInt(i), n);
      }
    }
    return e;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(A, e) {
    const t = this.loadTexture(A, e);
    t.ID = A.id, t.name = A.attrName;
    const i = A.WrapModeU, n = A.WrapModeV, r = i !== void 0 ? i.value : 0, s = n !== void 0 ? n.value : 0;
    if (t.wrapS = r === 0 ? Bs : Jn, t.wrapT = s === 0 ? Bs : Jn, "Scaling" in A) {
      const B = A.Scaling.value;
      t.repeat.x = B[0], t.repeat.y = B[1];
    }
    if ("Translation" in A) {
      const B = A.Translation.value;
      t.offset.x = B[0], t.offset.y = B[1];
    }
    return t;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(A, e) {
    let t;
    const i = this.textureLoader.path, n = bn.get(A.id).children;
    n !== void 0 && n.length > 0 && e[n[0].ID] !== void 0 && (t = e[n[0].ID], (t.indexOf("blob:") === 0 || t.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
    let r;
    const s = A.FileName.slice(-3).toLowerCase();
    if (s === "tga") {
      const B = this.manager.getHandler(".tga");
      B === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", A.RelativeFilename), r = new xi()) : (B.setPath(this.textureLoader.path), r = B.load(t));
    } else
      s === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", A.RelativeFilename), r = new xi()) : r = this.textureLoader.load(t);
    return this.textureLoader.setPath(i), r;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(A) {
    const e = /* @__PURE__ */ new Map();
    if ("Material" in Zt.Objects) {
      const t = Zt.Objects.Material;
      for (const i in t) {
        const n = this.parseMaterial(t[i], A);
        n !== null && e.set(parseInt(i), n);
      }
    }
    return e;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(A, e) {
    const t = A.id, i = A.attrName;
    let n = A.ShadingModel;
    if (typeof n == "object" && (n = n.value), !bn.has(t))
      return null;
    const r = this.parseParameters(A, e, t);
    let s;
    switch (n.toLowerCase()) {
      case "phong":
        s = new UC();
        break;
      case "lambert":
        s = new qy();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', n), s = new UC();
        break;
    }
    return s.setValues(r), s.name = i, s;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(A, e, t) {
    const i = {};
    A.BumpFactor && (i.bumpScale = A.BumpFactor.value), A.Diffuse ? i.color = new ke().fromArray(A.Diffuse.value).convertSRGBToLinear() : A.DiffuseColor && (A.DiffuseColor.type === "Color" || A.DiffuseColor.type === "ColorRGB") && (i.color = new ke().fromArray(A.DiffuseColor.value).convertSRGBToLinear()), A.DisplacementFactor && (i.displacementScale = A.DisplacementFactor.value), A.Emissive ? i.emissive = new ke().fromArray(A.Emissive.value).convertSRGBToLinear() : A.EmissiveColor && (A.EmissiveColor.type === "Color" || A.EmissiveColor.type === "ColorRGB") && (i.emissive = new ke().fromArray(A.EmissiveColor.value).convertSRGBToLinear()), A.EmissiveFactor && (i.emissiveIntensity = parseFloat(A.EmissiveFactor.value)), A.Opacity && (i.opacity = parseFloat(A.Opacity.value)), i.opacity < 1 && (i.transparent = !0), A.ReflectionFactor && (i.reflectivity = A.ReflectionFactor.value), A.Shininess && (i.shininess = A.Shininess.value), A.Specular ? i.specular = new ke().fromArray(A.Specular.value).convertSRGBToLinear() : A.SpecularColor && A.SpecularColor.type === "Color" && (i.specular = new ke().fromArray(A.SpecularColor.value).convertSRGBToLinear());
    const n = this;
    return bn.get(t).children.forEach(function(r) {
      const s = r.relationship;
      switch (s) {
        case "Bump":
          i.bumpMap = n.getTexture(e, r.ID);
          break;
        case "Maya|TEX_ao_map":
          i.aoMap = n.getTexture(e, r.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          i.map = n.getTexture(e, r.ID), i.map !== void 0 && (i.map.encoding = Ht);
          break;
        case "DisplacementColor":
          i.displacementMap = n.getTexture(e, r.ID);
          break;
        case "EmissiveColor":
          i.emissiveMap = n.getTexture(e, r.ID), i.emissiveMap !== void 0 && (i.emissiveMap.encoding = Ht);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          i.normalMap = n.getTexture(e, r.ID);
          break;
        case "ReflectionColor":
          i.envMap = n.getTexture(e, r.ID), i.envMap !== void 0 && (i.envMap.mapping = RE, i.envMap.encoding = Ht);
          break;
        case "SpecularColor":
          i.specularMap = n.getTexture(e, r.ID), i.specularMap !== void 0 && (i.specularMap.encoding = Ht);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          i.alphaMap = n.getTexture(e, r.ID), i.transparent = !0;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", s);
          break;
      }
    }), i;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(A, e) {
    return "LayeredTexture" in Zt.Objects && e in Zt.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), e = bn.get(e).children[0].ID), A.get(e);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const A = {}, e = {};
    if ("Deformer" in Zt.Objects) {
      const t = Zt.Objects.Deformer;
      for (const i in t) {
        const n = t[i], r = bn.get(parseInt(i));
        if (n.attrType === "Skin") {
          const s = this.parseSkeleton(r, t);
          s.ID = i, r.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), s.geometryID = r.parents[0].ID, A[i] = s;
        } else if (n.attrType === "BlendShape") {
          const s = {
            id: i
          };
          s.rawTargets = this.parseMorphTargets(r, t), s.id = i, r.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), e[i] = s;
        }
      }
    }
    return {
      skeletons: A,
      morphTargets: e
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(A, e) {
    const t = [];
    return A.children.forEach(function(i) {
      const n = e[i.ID];
      if (n.attrType !== "Cluster")
        return;
      const r = {
        ID: i.ID,
        indices: [],
        weights: [],
        transformLink: new Ve().fromArray(n.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      "Indexes" in n && (r.indices = n.Indexes.a, r.weights = n.Weights.a), t.push(r);
    }), {
      rawBones: t,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(A, e) {
    const t = [];
    for (let i = 0; i < A.children.length; i++) {
      const n = A.children[i], r = e[n.ID], s = {
        name: r.attrName,
        initialWeight: r.DeformPercent,
        id: r.id,
        fullWeights: r.FullWeights.a
      };
      if (r.attrType !== "BlendShapeChannel")
        return;
      s.geoID = bn.get(parseInt(n.ID)).children.filter(function(B) {
        return B.relationship === void 0;
      })[0].ID, t.push(s);
    }
    return t;
  }
  // create the main Group() to be returned by the loader
  parseScene(A, e, t) {
    wr = new eo();
    const i = this.parseModels(A.skeletons, e, t), n = Zt.Objects.Model, r = this;
    i.forEach(function(B) {
      const I = n[B.ID];
      r.setLookAtProperties(B, I), bn.get(B.ID).parents.forEach(function(C) {
        const c = i.get(C.ID);
        c !== void 0 && c.add(B);
      }), B.parent === null && wr.add(B);
    }), this.bindSkeleton(A.skeletons, e, i), this.createAmbientLight(), wr.traverse(function(B) {
      if (B.userData.transformData) {
        B.parent && (B.userData.transformData.parentMatrix = B.parent.matrix, B.userData.transformData.parentMatrixWorld = B.parent.matrixWorld);
        const I = Qk(B.userData.transformData);
        B.applyMatrix4(I), B.updateWorldMatrix();
      }
    });
    const s = new fP().parse();
    wr.children.length === 1 && wr.children[0].isGroup && (wr.children[0].animations = s, wr = wr.children[0]), wr.animations = s;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(A, e, t) {
    const i = /* @__PURE__ */ new Map(), n = Zt.Objects.Model;
    for (const r in n) {
      const s = parseInt(r), B = n[r], I = bn.get(s);
      let E = this.buildSkeleton(I, A, s, B.attrName);
      if (!E) {
        switch (B.attrType) {
          case "Camera":
            E = this.createCamera(I);
            break;
          case "Light":
            E = this.createLight(I);
            break;
          case "Mesh":
            E = this.createMesh(I, e, t);
            break;
          case "NurbsCurve":
            E = this.createCurve(I, e);
            break;
          case "LimbNode":
          case "Root":
            E = new kE();
            break;
          case "Null":
          default:
            E = new eo();
            break;
        }
        E.name = B.attrName ? xt.sanitizeNodeName(B.attrName) : "", E.ID = s;
      }
      this.getTransformData(E, B), i.set(s, E);
    }
    return i;
  }
  buildSkeleton(A, e, t, i) {
    let n = null;
    return A.parents.forEach(function(r) {
      for (const s in e) {
        const B = e[s];
        B.rawBones.forEach(function(I, E) {
          if (I.ID === r.ID) {
            const C = n;
            n = new kE(), n.matrixWorld.copy(I.transformLink), n.name = i ? xt.sanitizeNodeName(i) : "", n.ID = t, B.bones[E] = n, C !== null && n.add(C);
          }
        });
      }
    }), n;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(A) {
    let e, t;
    if (A.children.forEach(function(i) {
      const n = Zt.Objects.NodeAttribute[i.ID];
      n !== void 0 && (t = n);
    }), t === void 0)
      e = new Xt();
    else {
      let i = 0;
      t.CameraProjectionType !== void 0 && t.CameraProjectionType.value === 1 && (i = 1);
      let n = 1;
      t.NearPlane !== void 0 && (n = t.NearPlane.value / 1e3);
      let r = 1e3;
      t.FarPlane !== void 0 && (r = t.FarPlane.value / 1e3);
      let s = window.innerWidth, B = window.innerHeight;
      t.AspectWidth !== void 0 && t.AspectHeight !== void 0 && (s = t.AspectWidth.value, B = t.AspectHeight.value);
      const I = s / B;
      let E = 45;
      t.FieldOfView !== void 0 && (E = t.FieldOfView.value);
      const C = t.FocalLength ? t.FocalLength.value : null;
      switch (i) {
        case 0:
          e = new mn(E, I, n, r), C !== null && e.setFocalLength(C);
          break;
        case 1:
          e = new $a(-s / 2, s / 2, B / 2, -B / 2, n, r);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + i + "."), e = new Xt();
          break;
      }
    }
    return e;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(A) {
    let e, t;
    if (A.children.forEach(function(i) {
      const n = Zt.Objects.NodeAttribute[i.ID];
      n !== void 0 && (t = n);
    }), t === void 0)
      e = new Xt();
    else {
      let i;
      t.LightType === void 0 ? i = 0 : i = t.LightType.value;
      let n = 16777215;
      t.Color !== void 0 && (n = new ke().fromArray(t.Color.value).convertSRGBToLinear());
      let r = t.Intensity === void 0 ? 1 : t.Intensity.value / 100;
      t.CastLightOnObject !== void 0 && t.CastLightOnObject.value === 0 && (r = 0);
      let s = 0;
      t.FarAttenuationEnd !== void 0 && (t.EnableFarAttenuation !== void 0 && t.EnableFarAttenuation.value === 0 ? s = 0 : s = t.FarAttenuationEnd.value);
      const B = 1;
      switch (i) {
        case 0:
          e = new Oc(n, r, s, B);
          break;
        case 1:
          e = new bf(n, r);
          break;
        case 2:
          let I = Math.PI / 3;
          t.InnerAngle !== void 0 && (I = bg.degToRad(t.InnerAngle.value));
          let E = 0;
          t.OuterAngle !== void 0 && (E = bg.degToRad(t.OuterAngle.value), E = Math.max(E, 1)), e = new Kf(n, r, s, I, E, B);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + t.LightType.value + ", defaulting to a PointLight."), e = new Oc(n, r);
          break;
      }
      t.CastShadows !== void 0 && t.CastShadows.value === 1 && (e.castShadow = !0);
    }
    return e;
  }
  createMesh(A, e, t) {
    let i, n = null, r = null;
    const s = [];
    return A.children.forEach(function(B) {
      e.has(B.ID) && (n = e.get(B.ID)), t.has(B.ID) && s.push(t.get(B.ID));
    }), s.length > 1 ? r = s : s.length > 0 ? r = s[0] : (r = new UC({ color: 13421772 }), s.push(r)), "color" in n.attributes && s.forEach(function(B) {
      B.vertexColors = !0;
    }), n.FBX_Deformer ? (i = new kf(n, r), i.normalizeSkinWeights()) : i = new Xi(n, r), i;
  }
  createCurve(A, e) {
    const t = A.children.reduce(function(n, r) {
      return e.has(r.ID) && (n = e.get(r.ID)), n;
    }, null), i = new Mn({ color: 3342591, linewidth: 1 });
    return new Qs(t, i);
  }
  // parse the model node for transform data
  getTransformData(A, e) {
    const t = {};
    "InheritType" in e && (t.inheritType = parseInt(e.InheritType.value)), "RotationOrder" in e ? t.eulerOrder = Ek(e.RotationOrder.value) : t.eulerOrder = "ZYX", "Lcl_Translation" in e && (t.translation = e.Lcl_Translation.value), "PreRotation" in e && (t.preRotation = e.PreRotation.value), "Lcl_Rotation" in e && (t.rotation = e.Lcl_Rotation.value), "PostRotation" in e && (t.postRotation = e.PostRotation.value), "Lcl_Scaling" in e && (t.scale = e.Lcl_Scaling.value), "ScalingOffset" in e && (t.scalingOffset = e.ScalingOffset.value), "ScalingPivot" in e && (t.scalingPivot = e.ScalingPivot.value), "RotationOffset" in e && (t.rotationOffset = e.RotationOffset.value), "RotationPivot" in e && (t.rotationPivot = e.RotationPivot.value), A.userData.transformData = t;
  }
  setLookAtProperties(A, e) {
    "LookAtProperty" in e && bn.get(A.ID).children.forEach(function(i) {
      if (i.relationship === "LookAtProperty") {
        const n = Zt.Objects.Model[i.ID];
        if ("Lcl_Translation" in n) {
          const r = n.Lcl_Translation.value;
          A.target !== void 0 ? (A.target.position.fromArray(r), wr.add(A.target)) : A.lookAt(new IA().fromArray(r));
        }
      }
    });
  }
  bindSkeleton(A, e, t) {
    const i = this.parsePoseNodes();
    for (const n in A) {
      const r = A[n];
      bn.get(parseInt(r.ID)).parents.forEach(function(B) {
        if (e.has(B.ID)) {
          const I = B.ID;
          bn.get(I).parents.forEach(function(C) {
            t.has(C.ID) && t.get(C.ID).bind(new YE(r.bones), i[C.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const A = {};
    if ("Pose" in Zt.Objects) {
      const e = Zt.Objects.Pose;
      for (const t in e)
        if (e[t].attrType === "BindPose" && e[t].NbPoseNodes > 0) {
          const i = e[t].PoseNode;
          Array.isArray(i) ? i.forEach(function(n) {
            A[n.Node] = new Ve().fromArray(n.Matrix.a);
          }) : A[i.Node] = new Ve().fromArray(i.Matrix.a);
        }
    }
    return A;
  }
  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  createAmbientLight() {
    if ("GlobalSettings" in Zt && "AmbientColor" in Zt.GlobalSettings) {
      const A = Zt.GlobalSettings.AmbientColor.value, e = A[0], t = A[1], i = A[2];
      if (e !== 0 || t !== 0 || i !== 0) {
        const n = new ke(e, t, i).convertSRGBToLinear();
        wr.add(new Xy(n, 1));
      }
    }
  }
}
class dP {
  constructor() {
    this.negativeMaterialIndices = !1;
  }
  // Parse nodes in FBXTree.Objects.Geometry
  parse(A) {
    const e = /* @__PURE__ */ new Map();
    if ("Geometry" in Zt.Objects) {
      const t = Zt.Objects.Geometry;
      for (const i in t) {
        const n = bn.get(parseInt(i)), r = this.parseGeometry(n, t[i], A);
        e.set(parseInt(i), r);
      }
    }
    return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), e;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(A, e, t) {
    switch (e.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(A, e, t);
      case "NurbsCurve":
        return this.parseNurbsGeometry(e);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(A, e, t) {
    const i = t.skeletons, n = [], r = A.parents.map(function(C) {
      return Zt.Objects.Model[C.ID];
    });
    if (r.length === 0)
      return;
    const s = A.children.reduce(function(C, c) {
      return i[c.ID] !== void 0 && (C = i[c.ID]), C;
    }, null);
    A.children.forEach(function(C) {
      t.morphTargets[C.ID] !== void 0 && n.push(t.morphTargets[C.ID]);
    });
    const B = r[0], I = {};
    "RotationOrder" in B && (I.eulerOrder = Ek(B.RotationOrder.value)), "InheritType" in B && (I.inheritType = parseInt(B.InheritType.value)), "GeometricTranslation" in B && (I.translation = B.GeometricTranslation.value), "GeometricRotation" in B && (I.rotation = B.GeometricRotation.value), "GeometricScaling" in B && (I.scale = B.GeometricScaling.value);
    const E = Qk(I);
    return this.genGeometry(e, s, n, E);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(A, e, t, i) {
    const n = new ut();
    A.attrName && (n.name = A.attrName);
    const r = this.parseGeoNode(A, e), s = this.genBuffers(r), B = new Oe(s.vertex, 3);
    if (B.applyMatrix4(i), n.setAttribute("position", B), s.colors.length > 0 && n.setAttribute("color", new Oe(s.colors, 3)), e && (n.setAttribute("skinIndex", new Nf(s.weightsIndices, 4)), n.setAttribute("skinWeight", new Oe(s.vertexWeights, 4)), n.FBX_Deformer = e), s.normal.length > 0) {
      const I = new kt().getNormalMatrix(i), E = new Oe(s.normal, 3);
      E.applyNormalMatrix(I), n.setAttribute("normal", E);
    }
    if (s.uvs.forEach(function(I, E) {
      let C = "uv" + (E + 1).toString();
      E === 0 && (C = "uv"), n.setAttribute(C, new Oe(s.uvs[E], 2));
    }), r.material && r.material.mappingType !== "AllSame") {
      let I = s.materialIndex[0], E = 0;
      if (s.materialIndex.forEach(function(C, c) {
        C !== I && (n.addGroup(E, c - E, I), I = C, E = c);
      }), n.groups.length > 0) {
        const C = n.groups[n.groups.length - 1], c = C.start + C.count;
        c !== s.materialIndex.length && n.addGroup(c, s.materialIndex.length - c, I);
      }
      n.groups.length === 0 && n.addGroup(0, s.materialIndex.length, s.materialIndex[0]);
    }
    return this.addMorphTargets(n, A, t, i), n;
  }
  parseGeoNode(A, e) {
    const t = {};
    if (t.vertexPositions = A.Vertices !== void 0 ? A.Vertices.a : [], t.vertexIndices = A.PolygonVertexIndex !== void 0 ? A.PolygonVertexIndex.a : [], A.LayerElementColor && (t.color = this.parseVertexColors(A.LayerElementColor[0])), A.LayerElementMaterial && (t.material = this.parseMaterialIndices(A.LayerElementMaterial[0])), A.LayerElementNormal && (t.normal = this.parseNormals(A.LayerElementNormal[0])), A.LayerElementUV) {
      t.uv = [];
      let i = 0;
      for (; A.LayerElementUV[i]; )
        A.LayerElementUV[i].UV && t.uv.push(this.parseUVs(A.LayerElementUV[i])), i++;
    }
    return t.weightTable = {}, e !== null && (t.skeleton = e, e.rawBones.forEach(function(i, n) {
      i.indices.forEach(function(r, s) {
        t.weightTable[r] === void 0 && (t.weightTable[r] = []), t.weightTable[r].push({
          id: n,
          weight: i.weights[s]
        });
      });
    })), t;
  }
  genBuffers(A) {
    const e = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let t = 0, i = 0, n = !1, r = [], s = [], B = [], I = [], E = [], C = [];
    const c = this;
    return A.vertexIndices.forEach(function(u, d) {
      let p, D = !1;
      u < 0 && (u = u ^ -1, D = !0);
      let f = [], S = [];
      if (r.push(u * 3, u * 3 + 1, u * 3 + 2), A.color) {
        const y = Pd(d, t, u, A.color);
        B.push(y[0], y[1], y[2]);
      }
      if (A.skeleton) {
        if (A.weightTable[u] !== void 0 && A.weightTable[u].forEach(function(y) {
          S.push(y.weight), f.push(y.id);
        }), S.length > 4) {
          n || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), n = !0);
          const y = [0, 0, 0, 0], m = [0, 0, 0, 0];
          S.forEach(function(N, F) {
            let G = N, k = f[F];
            m.forEach(function(v, x, H) {
              if (G > v) {
                H[x] = G, G = v;
                const _ = y[x];
                y[x] = k, k = _;
              }
            });
          }), f = y, S = m;
        }
        for (; S.length < 4; )
          S.push(0), f.push(0);
        for (let y = 0; y < 4; ++y)
          E.push(S[y]), C.push(f[y]);
      }
      if (A.normal) {
        const y = Pd(d, t, u, A.normal);
        s.push(y[0], y[1], y[2]);
      }
      A.material && A.material.mappingType !== "AllSame" && (p = Pd(d, t, u, A.material)[0], p < 0 && (c.negativeMaterialIndices = !0, p = 0)), A.uv && A.uv.forEach(function(y, m) {
        const N = Pd(d, t, u, y);
        I[m] === void 0 && (I[m] = []), I[m].push(N[0]), I[m].push(N[1]);
      }), i++, D && (i > 4 && console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."), c.genFace(e, A, r, p, s, B, I, E, C, i), t++, i = 0, r = [], s = [], B = [], I = [], E = [], C = []);
    }), e;
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(A, e, t, i, n, r, s, B, I, E) {
    for (let C = 2; C < E; C++)
      A.vertex.push(e.vertexPositions[t[0]]), A.vertex.push(e.vertexPositions[t[1]]), A.vertex.push(e.vertexPositions[t[2]]), A.vertex.push(e.vertexPositions[t[(C - 1) * 3]]), A.vertex.push(e.vertexPositions[t[(C - 1) * 3 + 1]]), A.vertex.push(e.vertexPositions[t[(C - 1) * 3 + 2]]), A.vertex.push(e.vertexPositions[t[C * 3]]), A.vertex.push(e.vertexPositions[t[C * 3 + 1]]), A.vertex.push(e.vertexPositions[t[C * 3 + 2]]), e.skeleton && (A.vertexWeights.push(B[0]), A.vertexWeights.push(B[1]), A.vertexWeights.push(B[2]), A.vertexWeights.push(B[3]), A.vertexWeights.push(B[(C - 1) * 4]), A.vertexWeights.push(B[(C - 1) * 4 + 1]), A.vertexWeights.push(B[(C - 1) * 4 + 2]), A.vertexWeights.push(B[(C - 1) * 4 + 3]), A.vertexWeights.push(B[C * 4]), A.vertexWeights.push(B[C * 4 + 1]), A.vertexWeights.push(B[C * 4 + 2]), A.vertexWeights.push(B[C * 4 + 3]), A.weightsIndices.push(I[0]), A.weightsIndices.push(I[1]), A.weightsIndices.push(I[2]), A.weightsIndices.push(I[3]), A.weightsIndices.push(I[(C - 1) * 4]), A.weightsIndices.push(I[(C - 1) * 4 + 1]), A.weightsIndices.push(I[(C - 1) * 4 + 2]), A.weightsIndices.push(I[(C - 1) * 4 + 3]), A.weightsIndices.push(I[C * 4]), A.weightsIndices.push(I[C * 4 + 1]), A.weightsIndices.push(I[C * 4 + 2]), A.weightsIndices.push(I[C * 4 + 3])), e.color && (A.colors.push(r[0]), A.colors.push(r[1]), A.colors.push(r[2]), A.colors.push(r[(C - 1) * 3]), A.colors.push(r[(C - 1) * 3 + 1]), A.colors.push(r[(C - 1) * 3 + 2]), A.colors.push(r[C * 3]), A.colors.push(r[C * 3 + 1]), A.colors.push(r[C * 3 + 2])), e.material && e.material.mappingType !== "AllSame" && (A.materialIndex.push(i), A.materialIndex.push(i), A.materialIndex.push(i)), e.normal && (A.normal.push(n[0]), A.normal.push(n[1]), A.normal.push(n[2]), A.normal.push(n[(C - 1) * 3]), A.normal.push(n[(C - 1) * 3 + 1]), A.normal.push(n[(C - 1) * 3 + 2]), A.normal.push(n[C * 3]), A.normal.push(n[C * 3 + 1]), A.normal.push(n[C * 3 + 2])), e.uv && e.uv.forEach(function(c, u) {
        A.uvs[u] === void 0 && (A.uvs[u] = []), A.uvs[u].push(s[u][0]), A.uvs[u].push(s[u][1]), A.uvs[u].push(s[u][(C - 1) * 2]), A.uvs[u].push(s[u][(C - 1) * 2 + 1]), A.uvs[u].push(s[u][C * 2]), A.uvs[u].push(s[u][C * 2 + 1]);
      });
  }
  addMorphTargets(A, e, t, i) {
    if (t.length === 0)
      return;
    A.morphTargetsRelative = !0, A.morphAttributes.position = [];
    const n = this;
    t.forEach(function(r) {
      r.rawTargets.forEach(function(s) {
        const B = Zt.Objects.Geometry[s.geoID];
        B !== void 0 && n.genMorphGeometry(A, e, B, i, s.name);
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(A, e, t, i, n) {
    const r = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], s = t.Vertices !== void 0 ? t.Vertices.a : [], B = t.Indexes !== void 0 ? t.Indexes.a : [], I = A.attributes.position.count * 3, E = new Float32Array(I);
    for (let d = 0; d < B.length; d++) {
      const p = B[d] * 3;
      E[p] = s[d * 3], E[p + 1] = s[d * 3 + 1], E[p + 2] = s[d * 3 + 2];
    }
    const C = {
      vertexIndices: r,
      vertexPositions: E
    }, c = this.genBuffers(C), u = new Oe(c.vertex, 3);
    u.name = n || t.attrName, u.applyMatrix4(i), A.morphAttributes.position.push(u);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(A) {
    const e = A.MappingInformationType, t = A.ReferenceInformationType, i = A.Normals.a;
    let n = [];
    return t === "IndexToDirect" && ("NormalIndex" in A ? n = A.NormalIndex.a : "NormalsIndex" in A && (n = A.NormalsIndex.a)), {
      dataSize: 3,
      buffer: i,
      indices: n,
      mappingType: e,
      referenceType: t
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(A) {
    const e = A.MappingInformationType, t = A.ReferenceInformationType, i = A.UV.a;
    let n = [];
    return t === "IndexToDirect" && (n = A.UVIndex.a), {
      dataSize: 2,
      buffer: i,
      indices: n,
      mappingType: e,
      referenceType: t
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(A) {
    const e = A.MappingInformationType, t = A.ReferenceInformationType, i = A.Colors.a;
    let n = [];
    t === "IndexToDirect" && (n = A.ColorIndex.a);
    for (let r = 0, s = new ke(); r < i.length; r += 4)
      s.fromArray(i, r).convertSRGBToLinear().toArray(i, r);
    return {
      dataSize: 4,
      buffer: i,
      indices: n,
      mappingType: e,
      referenceType: t
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(A) {
    const e = A.MappingInformationType, t = A.ReferenceInformationType;
    if (e === "NoMappingInformation")
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: t
      };
    const i = A.Materials.a, n = [];
    for (let r = 0; r < i.length; ++r)
      n.push(r);
    return {
      dataSize: 1,
      buffer: i,
      indices: n,
      mappingType: e,
      referenceType: t
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(A) {
    const e = parseInt(A.Order);
    if (isNaN(e))
      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", A.Order, A.id), new ut();
    const t = e - 1, i = A.KnotVector.a, n = [], r = A.Points.a;
    for (let C = 0, c = r.length; C < c; C += 4)
      n.push(new Bi().fromArray(r, C));
    let s, B;
    if (A.Form === "Closed")
      n.push(n[0]);
    else if (A.Form === "Periodic") {
      s = t, B = i.length - 1 - s;
      for (let C = 0; C < t; ++C)
        n.push(n[C]);
    }
    const E = new cP(t, i, n, s, B).getPoints(n.length * 12);
    return new ut().setFromPoints(E);
  }
}
class fP {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const A = [], e = this.parseClips();
    if (e !== void 0)
      for (const t in e) {
        const i = e[t], n = this.addClip(i);
        A.push(n);
      }
    return A;
  }
  parseClips() {
    if (Zt.Objects.AnimationCurve === void 0)
      return;
    const A = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(A);
    const e = this.parseAnimationLayers(A);
    return this.parseAnimStacks(e);
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const A = Zt.Objects.AnimationCurveNode, e = /* @__PURE__ */ new Map();
    for (const t in A) {
      const i = A[t];
      if (i.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const n = {
          id: i.id,
          attr: i.attrName,
          curves: {}
        };
        e.set(n.id, n);
      }
    }
    return e;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(A) {
    const e = Zt.Objects.AnimationCurve;
    for (const t in e) {
      const i = {
        id: e[t].id,
        times: e[t].KeyTime.a.map(mP),
        values: e[t].KeyValueFloat.a
      }, n = bn.get(i.id);
      if (n !== void 0) {
        const r = n.parents[0].ID, s = n.parents[0].relationship;
        s.match(/X/) ? A.get(r).curves.x = i : s.match(/Y/) ? A.get(r).curves.y = i : s.match(/Z/) ? A.get(r).curves.z = i : s.match(/DeformPercent/) && A.has(r) && (A.get(r).curves.morph = i);
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(A) {
    const e = Zt.Objects.AnimationLayer, t = /* @__PURE__ */ new Map();
    for (const i in e) {
      const n = [], r = bn.get(parseInt(i));
      r !== void 0 && (r.children.forEach(function(B, I) {
        if (A.has(B.ID)) {
          const E = A.get(B.ID);
          if (E.curves.x !== void 0 || E.curves.y !== void 0 || E.curves.z !== void 0) {
            if (n[I] === void 0) {
              const C = bn.get(B.ID).parents.filter(function(c) {
                return c.relationship !== void 0;
              })[0].ID;
              if (C !== void 0) {
                const c = Zt.Objects.Model[C.toString()];
                if (c === void 0) {
                  console.warn("THREE.FBXLoader: Encountered a unused curve.", B);
                  return;
                }
                const u = {
                  modelName: c.attrName ? xt.sanitizeNodeName(c.attrName) : "",
                  ID: c.id,
                  initialPosition: [0, 0, 0],
                  initialRotation: [0, 0, 0],
                  initialScale: [1, 1, 1]
                };
                wr.traverse(function(d) {
                  d.ID === c.id && (u.transform = d.matrix, d.userData.transformData && (u.eulerOrder = d.userData.transformData.eulerOrder));
                }), u.transform || (u.transform = new Ve()), "PreRotation" in c && (u.preRotation = c.PreRotation.value), "PostRotation" in c && (u.postRotation = c.PostRotation.value), n[I] = u;
              }
            }
            n[I] && (n[I][E.attr] = E);
          } else if (E.curves.morph !== void 0) {
            if (n[I] === void 0) {
              const C = bn.get(B.ID).parents.filter(function(f) {
                return f.relationship !== void 0;
              })[0].ID, c = bn.get(C).parents[0].ID, u = bn.get(c).parents[0].ID, d = bn.get(u).parents[0].ID, p = Zt.Objects.Model[d], D = {
                modelName: p.attrName ? xt.sanitizeNodeName(p.attrName) : "",
                morphName: Zt.Objects.Deformer[C].attrName
              };
              n[I] = D;
            }
            n[I][E.attr] = E;
          }
        }
      }), t.set(parseInt(i), n));
    }
    return t;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(A) {
    const e = Zt.Objects.AnimationStack, t = {};
    for (const i in e) {
      const n = bn.get(parseInt(i)).children;
      n.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      const r = A.get(n[0].ID);
      t[i] = {
        name: e[i].attrName,
        layer: r
      };
    }
    return t;
  }
  addClip(A) {
    let e = [];
    const t = this;
    return A.layer.forEach(function(i) {
      e = e.concat(t.generateTracks(i));
    }), new HC(A.name, -1, e);
  }
  generateTracks(A) {
    const e = [];
    let t = new IA(), i = new On(), n = new IA();
    if (A.transform && A.transform.decompose(t, i, n), t = t.toArray(), i = new Nr().setFromQuaternion(i, A.eulerOrder).toArray(), n = n.toArray(), A.T !== void 0 && Object.keys(A.T.curves).length > 0) {
      const r = this.generateVectorTrack(A.modelName, A.T.curves, t, "position");
      r !== void 0 && e.push(r);
    }
    if (A.R !== void 0 && Object.keys(A.R.curves).length > 0) {
      const r = this.generateRotationTrack(A.modelName, A.R.curves, i, A.preRotation, A.postRotation, A.eulerOrder);
      r !== void 0 && e.push(r);
    }
    if (A.S !== void 0 && Object.keys(A.S.curves).length > 0) {
      const r = this.generateVectorTrack(A.modelName, A.S.curves, n, "scale");
      r !== void 0 && e.push(r);
    }
    if (A.DeformPercent !== void 0) {
      const r = this.generateMorphTrack(A);
      r !== void 0 && e.push(r);
    }
    return e;
  }
  generateVectorTrack(A, e, t, i) {
    const n = this.getTimesForAllAxes(e), r = this.getKeyframeTrackValues(n, e, t);
    return new YC(A + "." + i, n, r);
  }
  generateRotationTrack(A, e, t, i, n, r) {
    e.x !== void 0 && (this.interpolateRotations(e.x), e.x.values = e.x.values.map(bg.degToRad)), e.y !== void 0 && (this.interpolateRotations(e.y), e.y.values = e.y.values.map(bg.degToRad)), e.z !== void 0 && (this.interpolateRotations(e.z), e.z.values = e.z.values.map(bg.degToRad));
    const s = this.getTimesForAllAxes(e), B = this.getKeyframeTrackValues(s, e, t);
    i !== void 0 && (i = i.map(bg.degToRad), i.push(r), i = new Nr().fromArray(i), i = new On().setFromEuler(i)), n !== void 0 && (n = n.map(bg.degToRad), n.push(r), n = new Nr().fromArray(n), n = new On().setFromEuler(n).invert());
    const I = new On(), E = new Nr(), C = [];
    for (let c = 0; c < B.length; c += 3)
      E.set(B[c], B[c + 1], B[c + 2], r), I.setFromEuler(E), i !== void 0 && I.premultiply(i), n !== void 0 && I.multiply(n), I.toArray(C, c / 3 * 4);
    return new ja(A + ".quaternion", s, C);
  }
  generateMorphTrack(A) {
    const e = A.DeformPercent.curves.morph, t = e.values.map(function(n) {
      return n / 100;
    }), i = wr.getObjectByName(A.modelName).morphTargetDictionary[A.morphName];
    return new bC(A.modelName + ".morphTargetInfluences[" + i + "]", e.times, t);
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(A) {
    let e = [];
    if (A.x !== void 0 && (e = e.concat(A.x.times)), A.y !== void 0 && (e = e.concat(A.y.times)), A.z !== void 0 && (e = e.concat(A.z.times)), e = e.sort(function(t, i) {
      return t - i;
    }), e.length > 1) {
      let t = 1, i = e[0];
      for (let n = 1; n < e.length; n++) {
        const r = e[n];
        r !== i && (e[t] = r, i = r, t++);
      }
      e = e.slice(0, t);
    }
    return e;
  }
  getKeyframeTrackValues(A, e, t) {
    const i = t, n = [];
    let r = -1, s = -1, B = -1;
    return A.forEach(function(I) {
      if (e.x && (r = e.x.times.indexOf(I)), e.y && (s = e.y.times.indexOf(I)), e.z && (B = e.z.times.indexOf(I)), r !== -1) {
        const E = e.x.values[r];
        n.push(E), i[0] = E;
      } else
        n.push(i[0]);
      if (s !== -1) {
        const E = e.y.values[s];
        n.push(E), i[1] = E;
      } else
        n.push(i[1]);
      if (B !== -1) {
        const E = e.z.values[B];
        n.push(E), i[2] = E;
      } else
        n.push(i[2]);
    }), n;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(A) {
    for (let e = 1; e < A.values.length; e++) {
      const t = A.values[e - 1], i = A.values[e] - t, n = Math.abs(i);
      if (n >= 180) {
        const r = n / 180, s = i / r;
        let B = t + s;
        const I = A.times[e - 1], C = (A.times[e] - I) / r;
        let c = I + C;
        const u = [], d = [];
        for (; c < A.times[e]; )
          u.push(c), c += C, d.push(B), B += s;
        A.times = OF(A.times, e, u), A.values = OF(A.values, e, d);
      }
    }
  }
}
class pP {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(A) {
    this.nodeStack.push(A), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(A, e) {
    this.currentProp = A, this.currentPropName = e;
  }
  parse(A) {
    this.currentIndent = 0, this.allNodes = new Ck(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const e = this, t = A.split(/[\r\n]+/);
    return t.forEach(function(i, n) {
      const r = i.match(/^[\s\t]*;/), s = i.match(/^[\s\t]*$/);
      if (r || s)
        return;
      const B = i.match("^\\t{" + e.currentIndent + "}(\\w+):(.*){", ""), I = i.match("^\\t{" + e.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), E = i.match("^\\t{" + (e.currentIndent - 1) + "}}");
      B ? e.parseNodeBegin(i, B) : I ? e.parseNodeProperty(i, I, t[++n]) : E ? e.popStack() : i.match(/^[^\s\t}]/) && e.parseNodePropertyContinued(i);
    }), this.allNodes;
  }
  parseNodeBegin(A, e) {
    const t = e[1].trim().replace(/^"/, "").replace(/"$/, ""), i = e[2].split(",").map(function(B) {
      return B.trim().replace(/^"/, "").replace(/"$/, "");
    }), n = { name: t }, r = this.parseNodeAttr(i), s = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(t, n) : t in s ? (t === "PoseNode" ? s.PoseNode.push(n) : s[t].id !== void 0 && (s[t] = {}, s[t][s[t].id] = s[t]), r.id !== "" && (s[t][r.id] = n)) : typeof r.id == "number" ? (s[t] = {}, s[t][r.id] = n) : t !== "Properties70" && (t === "PoseNode" ? s[t] = [n] : s[t] = n), typeof r.id == "number" && (n.id = r.id), r.name !== "" && (n.attrName = r.name), r.type !== "" && (n.attrType = r.type), this.pushStack(n);
  }
  parseNodeAttr(A) {
    let e = A[0];
    A[0] !== "" && (e = parseInt(A[0]), isNaN(e) && (e = A[0]));
    let t = "", i = "";
    return A.length > 1 && (t = A[1].replace(/^(\w+)::/, ""), i = A[2]), { id: e, name: t, type: i };
  }
  parseNodeProperty(A, e, t) {
    let i = e[1].replace(/^"/, "").replace(/"$/, "").trim(), n = e[2].replace(/^"/, "").replace(/"$/, "").trim();
    i === "Content" && n === "," && (n = t.replace(/"/g, "").replace(/,$/, "").trim());
    const r = this.getCurrentNode();
    if (r.name === "Properties70") {
      this.parseNodeSpecialProperty(A, i, n);
      return;
    }
    if (i === "C") {
      const B = n.split(",").slice(1), I = parseInt(B[0]), E = parseInt(B[1]);
      let C = n.split(",").slice(3);
      C = C.map(function(c) {
        return c.trim().replace(/^"/, "");
      }), i = "connections", n = [I, E], MP(n, C), r[i] === void 0 && (r[i] = []);
    }
    i === "Node" && (r.id = n), i in r && Array.isArray(r[i]) ? r[i].push(n) : i !== "a" ? r[i] = n : r.a = n, this.setCurrentProp(r, i), i === "a" && n.slice(-1) !== "," && (r.a = Aw(n));
  }
  parseNodePropertyContinued(A) {
    const e = this.getCurrentNode();
    e.a += A, A.slice(-1) !== "," && (e.a = Aw(e.a));
  }
  // parse "Property70"
  parseNodeSpecialProperty(A, e, t) {
    const i = t.split('",').map(function(E) {
      return E.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), n = i[0], r = i[1], s = i[2], B = i[3];
    let I = i[4];
    switch (r) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        I = parseFloat(I);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        I = Aw(I);
        break;
    }
    this.getPrevNode()[n] = {
      type: r,
      type2: s,
      flag: B,
      value: I
    }, this.setCurrentProp(this.getPrevNode(), n);
  }
}
class DP {
  parse(A) {
    const e = new _F(A);
    e.skip(23);
    const t = e.getUint32();
    if (t < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + t);
    const i = new Ck();
    for (; !this.endOfContent(e); ) {
      const n = this.parseNode(e, t);
      n !== null && i.add(n.name, n);
    }
    return i;
  }
  // Check if reader has reached the end of content.
  endOfContent(A) {
    return A.size() % 16 === 0 ? (A.getOffset() + 160 + 16 & -16) >= A.size() : A.getOffset() + 160 + 16 >= A.size();
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(A, e) {
    const t = {}, i = e >= 7500 ? A.getUint64() : A.getUint32(), n = e >= 7500 ? A.getUint64() : A.getUint32();
    e >= 7500 ? A.getUint64() : A.getUint32();
    const r = A.getUint8(), s = A.getString(r);
    if (i === 0)
      return null;
    const B = [];
    for (let c = 0; c < n; c++)
      B.push(this.parseProperty(A));
    const I = B.length > 0 ? B[0] : "", E = B.length > 1 ? B[1] : "", C = B.length > 2 ? B[2] : "";
    for (t.singleProperty = n === 1 && A.getOffset() === i; i > A.getOffset(); ) {
      const c = this.parseNode(A, e);
      c !== null && this.parseSubNode(s, t, c);
    }
    return t.propertyList = B, typeof I == "number" && (t.id = I), E !== "" && (t.attrName = E), C !== "" && (t.attrType = C), s !== "" && (t.name = s), t;
  }
  parseSubNode(A, e, t) {
    if (t.singleProperty === !0) {
      const i = t.propertyList[0];
      Array.isArray(i) ? (e[t.name] = t, t.a = i) : e[t.name] = i;
    } else if (A === "Connections" && t.name === "C") {
      const i = [];
      t.propertyList.forEach(function(n, r) {
        r !== 0 && i.push(n);
      }), e.connections === void 0 && (e.connections = []), e.connections.push(i);
    } else if (t.name === "Properties70")
      Object.keys(t).forEach(function(n) {
        e[n] = t[n];
      });
    else if (A === "Properties70" && t.name === "P") {
      let i = t.propertyList[0], n = t.propertyList[1];
      const r = t.propertyList[2], s = t.propertyList[3];
      let B;
      i.indexOf("Lcl ") === 0 && (i = i.replace("Lcl ", "Lcl_")), n.indexOf("Lcl ") === 0 && (n = n.replace("Lcl ", "Lcl_")), n === "Color" || n === "ColorRGB" || n === "Vector" || n === "Vector3D" || n.indexOf("Lcl_") === 0 ? B = [
        t.propertyList[4],
        t.propertyList[5],
        t.propertyList[6]
      ] : B = t.propertyList[4], e[i] = {
        type: n,
        type2: r,
        flag: s,
        value: B
      };
    } else
      e[t.name] === void 0 ? typeof t.id == "number" ? (e[t.name] = {}, e[t.name][t.id] = t) : e[t.name] = t : t.name === "PoseNode" ? (Array.isArray(e[t.name]) || (e[t.name] = [e[t.name]]), e[t.name].push(t)) : e[t.name][t.id] === void 0 && (e[t.name][t.id] = t);
  }
  parseProperty(A) {
    const e = A.getString(1);
    let t;
    switch (e) {
      case "C":
        return A.getBoolean();
      case "D":
        return A.getFloat64();
      case "F":
        return A.getFloat32();
      case "I":
        return A.getInt32();
      case "L":
        return A.getInt64();
      case "R":
        return t = A.getUint32(), A.getArrayBuffer(t);
      case "S":
        return t = A.getUint32(), A.getString(t);
      case "Y":
        return A.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const i = A.getUint32(), n = A.getUint32(), r = A.getUint32();
        if (n === 0)
          switch (e) {
            case "b":
            case "c":
              return A.getBooleanArray(i);
            case "d":
              return A.getFloat64Array(i);
            case "f":
              return A.getFloat32Array(i);
            case "i":
              return A.getInt32Array(i);
            case "l":
              return A.getInt64Array(i);
          }
        const s = rP(new Uint8Array(A.getArrayBuffer(r))), B = new _F(s.buffer);
        switch (e) {
          case "b":
          case "c":
            return B.getBooleanArray(i);
          case "d":
            return B.getFloat64Array(i);
          case "f":
            return B.getFloat32Array(i);
          case "i":
            return B.getInt32Array(i);
          case "l":
            return B.getInt64Array(i);
        }
        break;
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + e);
    }
  }
}
class _F {
  constructor(A, e) {
    this.dv = new DataView(A), this.offset = 0, this.littleEndian = e !== void 0 ? e : !0, this._textDecoder = new TextDecoder();
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(A) {
    this.offset += A;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(A) {
    const e = [];
    for (let t = 0; t < A; t++)
      e.push(this.getBoolean());
    return e;
  }
  getUint8() {
    const A = this.dv.getUint8(this.offset);
    return this.offset += 1, A;
  }
  getInt16() {
    const A = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, A;
  }
  getInt32() {
    const A = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, A;
  }
  getInt32Array(A) {
    const e = [];
    for (let t = 0; t < A; t++)
      e.push(this.getInt32());
    return e;
  }
  getUint32() {
    const A = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, A;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let A, e;
    return this.littleEndian ? (A = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), A = this.getUint32()), e & 2147483648 ? (e = ~e & 4294967295, A = ~A & 4294967295, A === 4294967295 && (e = e + 1 & 4294967295), A = A + 1 & 4294967295, -(e * 4294967296 + A)) : e * 4294967296 + A;
  }
  getInt64Array(A) {
    const e = [];
    for (let t = 0; t < A; t++)
      e.push(this.getInt64());
    return e;
  }
  // Note: see getInt64() comment
  getUint64() {
    let A, e;
    return this.littleEndian ? (A = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), A = this.getUint32()), e * 4294967296 + A;
  }
  getFloat32() {
    const A = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, A;
  }
  getFloat32Array(A) {
    const e = [];
    for (let t = 0; t < A; t++)
      e.push(this.getFloat32());
    return e;
  }
  getFloat64() {
    const A = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, A;
  }
  getFloat64Array(A) {
    const e = [];
    for (let t = 0; t < A; t++)
      e.push(this.getFloat64());
    return e;
  }
  getArrayBuffer(A) {
    const e = this.dv.buffer.slice(this.offset, this.offset + A);
    return this.offset += A, e;
  }
  getString(A) {
    const e = this.offset;
    let t = new Uint8Array(this.dv.buffer, e, A);
    this.skip(A);
    const i = t.indexOf(0);
    return i >= 0 && (t = new Uint8Array(this.dv.buffer, e, i)), this._textDecoder.decode(t);
  }
}
class Ck {
  add(A, e) {
    this[A] = e;
  }
}
function wP(g) {
  const A = "Kaydara FBX Binary  \0";
  return g.byteLength >= A.length && A === lk(g, 0, A.length);
}
function yP(g) {
  const A = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
  let e = 0;
  function t(i) {
    const n = g[i - 1];
    return g = g.slice(e + i), e++, n;
  }
  for (let i = 0; i < A.length; ++i)
    if (t(1) === A[i])
      return !1;
  return !0;
}
function JF(g) {
  const A = /FBXVersion: (\d+)/, e = g.match(A);
  if (e)
    return parseInt(e[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function mP(g) {
  return g / 46186158e3;
}
const SP = [];
function Pd(g, A, e, t) {
  let i;
  switch (t.mappingType) {
    case "ByPolygonVertex":
      i = g;
      break;
    case "ByPolygon":
      i = A;
      break;
    case "ByVertice":
      i = e;
      break;
    case "AllSame":
      i = t.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + t.mappingType);
  }
  t.referenceType === "IndexToDirect" && (i = t.indices[i]);
  const n = i * t.dataSize, r = n + t.dataSize;
  return RP(SP, t.buffer, n, r);
}
const $0 = new Nr(), EE = new IA();
function Qk(g) {
  const A = new Ve(), e = new Ve(), t = new Ve(), i = new Ve(), n = new Ve(), r = new Ve(), s = new Ve(), B = new Ve(), I = new Ve(), E = new Ve(), C = new Ve(), c = new Ve(), u = g.inheritType ? g.inheritType : 0;
  if (g.translation && A.setPosition(EE.fromArray(g.translation)), g.preRotation) {
    const x = g.preRotation.map(bg.degToRad);
    x.push(g.eulerOrder || Nr.DEFAULT_ORDER), e.makeRotationFromEuler($0.fromArray(x));
  }
  if (g.rotation) {
    const x = g.rotation.map(bg.degToRad);
    x.push(g.eulerOrder || Nr.DEFAULT_ORDER), t.makeRotationFromEuler($0.fromArray(x));
  }
  if (g.postRotation) {
    const x = g.postRotation.map(bg.degToRad);
    x.push(g.eulerOrder || Nr.DEFAULT_ORDER), i.makeRotationFromEuler($0.fromArray(x)), i.invert();
  }
  g.scale && n.scale(EE.fromArray(g.scale)), g.scalingOffset && s.setPosition(EE.fromArray(g.scalingOffset)), g.scalingPivot && r.setPosition(EE.fromArray(g.scalingPivot)), g.rotationOffset && B.setPosition(EE.fromArray(g.rotationOffset)), g.rotationPivot && I.setPosition(EE.fromArray(g.rotationPivot)), g.parentMatrixWorld && (C.copy(g.parentMatrix), E.copy(g.parentMatrixWorld));
  const d = e.clone().multiply(t).multiply(i), p = new Ve();
  p.extractRotation(E);
  const D = new Ve();
  D.copyPosition(E);
  const f = D.clone().invert().multiply(E), S = p.clone().invert().multiply(f), y = n, m = new Ve();
  if (u === 0)
    m.copy(p).multiply(d).multiply(S).multiply(y);
  else if (u === 1)
    m.copy(p).multiply(S).multiply(d).multiply(y);
  else {
    const H = new Ve().scale(new IA().setFromMatrixScale(C)).clone().invert(), _ = S.clone().multiply(H);
    m.copy(p).multiply(d).multiply(_).multiply(y);
  }
  const N = I.clone().invert(), F = r.clone().invert();
  let G = A.clone().multiply(B).multiply(I).multiply(e).multiply(t).multiply(i).multiply(N).multiply(s).multiply(r).multiply(n).multiply(F);
  const k = new Ve().copyPosition(G), v = E.clone().multiply(k);
  return c.copyPosition(v), G = c.clone().multiply(m), G.premultiply(E.invert()), G;
}
function Ek(g) {
  g = g || 0;
  const A = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  return g === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), A[0]) : A[g];
}
function Aw(g) {
  return g.split(",").map(function(e) {
    return parseFloat(e);
  });
}
function lk(g, A, e) {
  return A === void 0 && (A = 0), e === void 0 && (e = g.byteLength), new TextDecoder().decode(new Uint8Array(g, A, e));
}
function MP(g, A) {
  for (let e = 0, t = g.length, i = A.length; e < i; e++, t++)
    g[t] = A[e];
}
function RP(g, A, e, t) {
  for (let i = e, n = 0; i < t; i++, n++)
    g[n] = A[i];
  return g;
}
function OF(g, A, e) {
  return g.slice(0, A).concat(e).concat(g.slice(A));
}
const NP = /^[og]\s*(.+)?/, FP = /^mtllib /, GP = /^usemtl /, vP = /^usemap /, qF = /\s+/, PF = new IA(), ew = new IA(), WF = new IA(), zF = new IA(), Mo = new IA(), Wd = new ke();
function UP() {
  const g = {
    objects: [],
    object: {},
    vertices: [],
    normals: [],
    colors: [],
    uvs: [],
    materials: {},
    materialLibraries: [],
    startObject: function(A, e) {
      if (this.object && this.object.fromDeclaration === !1) {
        this.object.name = A, this.object.fromDeclaration = e !== !1;
        return;
      }
      const t = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
      if (this.object && typeof this.object._finalize == "function" && this.object._finalize(!0), this.object = {
        name: A || "",
        fromDeclaration: e !== !1,
        geometry: {
          vertices: [],
          normals: [],
          colors: [],
          uvs: [],
          hasUVIndices: !1
        },
        materials: [],
        smooth: !0,
        startMaterial: function(i, n) {
          const r = this._finalize(!1);
          r && (r.inherited || r.groupCount <= 0) && this.materials.splice(r.index, 1);
          const s = {
            index: this.materials.length,
            name: i || "",
            mtllib: Array.isArray(n) && n.length > 0 ? n[n.length - 1] : "",
            smooth: r !== void 0 ? r.smooth : this.smooth,
            groupStart: r !== void 0 ? r.groupEnd : 0,
            groupEnd: -1,
            groupCount: -1,
            inherited: !1,
            clone: function(B) {
              const I = {
                index: typeof B == "number" ? B : this.index,
                name: this.name,
                mtllib: this.mtllib,
                smooth: this.smooth,
                groupStart: 0,
                groupEnd: -1,
                groupCount: -1,
                inherited: !1
              };
              return I.clone = this.clone.bind(I), I;
            }
          };
          return this.materials.push(s), s;
        },
        currentMaterial: function() {
          if (this.materials.length > 0)
            return this.materials[this.materials.length - 1];
        },
        _finalize: function(i) {
          const n = this.currentMaterial();
          if (n && n.groupEnd === -1 && (n.groupEnd = this.geometry.vertices.length / 3, n.groupCount = n.groupEnd - n.groupStart, n.inherited = !1), i && this.materials.length > 1)
            for (let r = this.materials.length - 1; r >= 0; r--)
              this.materials[r].groupCount <= 0 && this.materials.splice(r, 1);
          return i && this.materials.length === 0 && this.materials.push({
            name: "",
            smooth: this.smooth
          }), n;
        }
      }, t && t.name && typeof t.clone == "function") {
        const i = t.clone(0);
        i.inherited = !0, this.object.materials.push(i);
      }
      this.objects.push(this.object);
    },
    finalize: function() {
      this.object && typeof this.object._finalize == "function" && this.object._finalize(!0);
    },
    parseVertexIndex: function(A, e) {
      const t = parseInt(A, 10);
      return (t >= 0 ? t - 1 : t + e / 3) * 3;
    },
    parseNormalIndex: function(A, e) {
      const t = parseInt(A, 10);
      return (t >= 0 ? t - 1 : t + e / 3) * 3;
    },
    parseUVIndex: function(A, e) {
      const t = parseInt(A, 10);
      return (t >= 0 ? t - 1 : t + e / 2) * 2;
    },
    addVertex: function(A, e, t) {
      const i = this.vertices, n = this.object.geometry.vertices;
      n.push(i[A + 0], i[A + 1], i[A + 2]), n.push(i[e + 0], i[e + 1], i[e + 2]), n.push(i[t + 0], i[t + 1], i[t + 2]);
    },
    addVertexPoint: function(A) {
      const e = this.vertices;
      this.object.geometry.vertices.push(e[A + 0], e[A + 1], e[A + 2]);
    },
    addVertexLine: function(A) {
      const e = this.vertices;
      this.object.geometry.vertices.push(e[A + 0], e[A + 1], e[A + 2]);
    },
    addNormal: function(A, e, t) {
      const i = this.normals, n = this.object.geometry.normals;
      n.push(i[A + 0], i[A + 1], i[A + 2]), n.push(i[e + 0], i[e + 1], i[e + 2]), n.push(i[t + 0], i[t + 1], i[t + 2]);
    },
    addFaceNormal: function(A, e, t) {
      const i = this.vertices, n = this.object.geometry.normals;
      PF.fromArray(i, A), ew.fromArray(i, e), WF.fromArray(i, t), Mo.subVectors(WF, ew), zF.subVectors(PF, ew), Mo.cross(zF), Mo.normalize(), n.push(Mo.x, Mo.y, Mo.z), n.push(Mo.x, Mo.y, Mo.z), n.push(Mo.x, Mo.y, Mo.z);
    },
    addColor: function(A, e, t) {
      const i = this.colors, n = this.object.geometry.colors;
      i[A] !== void 0 && n.push(i[A + 0], i[A + 1], i[A + 2]), i[e] !== void 0 && n.push(i[e + 0], i[e + 1], i[e + 2]), i[t] !== void 0 && n.push(i[t + 0], i[t + 1], i[t + 2]);
    },
    addUV: function(A, e, t) {
      const i = this.uvs, n = this.object.geometry.uvs;
      n.push(i[A + 0], i[A + 1]), n.push(i[e + 0], i[e + 1]), n.push(i[t + 0], i[t + 1]);
    },
    addDefaultUV: function() {
      const A = this.object.geometry.uvs;
      A.push(0, 0), A.push(0, 0), A.push(0, 0);
    },
    addUVLine: function(A) {
      const e = this.uvs;
      this.object.geometry.uvs.push(e[A + 0], e[A + 1]);
    },
    addFace: function(A, e, t, i, n, r, s, B, I) {
      const E = this.vertices.length;
      let C = this.parseVertexIndex(A, E), c = this.parseVertexIndex(e, E), u = this.parseVertexIndex(t, E);
      if (this.addVertex(C, c, u), this.addColor(C, c, u), s !== void 0 && s !== "") {
        const d = this.normals.length;
        C = this.parseNormalIndex(s, d), c = this.parseNormalIndex(B, d), u = this.parseNormalIndex(I, d), this.addNormal(C, c, u);
      } else
        this.addFaceNormal(C, c, u);
      if (i !== void 0 && i !== "") {
        const d = this.uvs.length;
        C = this.parseUVIndex(i, d), c = this.parseUVIndex(n, d), u = this.parseUVIndex(r, d), this.addUV(C, c, u), this.object.geometry.hasUVIndices = !0;
      } else
        this.addDefaultUV();
    },
    addPointGeometry: function(A) {
      this.object.geometry.type = "Points";
      const e = this.vertices.length;
      for (let t = 0, i = A.length; t < i; t++) {
        const n = this.parseVertexIndex(A[t], e);
        this.addVertexPoint(n), this.addColor(n);
      }
    },
    addLineGeometry: function(A, e) {
      this.object.geometry.type = "Line";
      const t = this.vertices.length, i = this.uvs.length;
      for (let n = 0, r = A.length; n < r; n++)
        this.addVertexLine(this.parseVertexIndex(A[n], t));
      for (let n = 0, r = e.length; n < r; n++)
        this.addUVLine(this.parseUVIndex(e[n], i));
    }
  };
  return g.startObject("", !1), g;
}
class kP extends Hg {
  constructor(A) {
    super(A), this.materials = null;
  }
  load(A, e, t, i) {
    const n = this, r = new go(this.manager);
    r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(A, function(s) {
      try {
        e(n.parse(s));
      } catch (B) {
        i ? i(B) : console.error(B), n.manager.itemError(A);
      }
    }, t, i);
  }
  setMaterials(A) {
    return this.materials = A, this;
  }
  parse(A) {
    const e = new UP();
    A.indexOf(`\r
`) !== -1 && (A = A.replace(/\r\n/g, `
`)), A.indexOf(`\\
`) !== -1 && (A = A.replace(/\\\n/g, ""));
    const t = A.split(`
`);
    let i = [];
    for (let s = 0, B = t.length; s < B; s++) {
      const I = t[s].trimStart();
      if (I.length === 0)
        continue;
      const E = I.charAt(0);
      if (E !== "#")
        if (E === "v") {
          const C = I.split(qF);
          switch (C[0]) {
            case "v":
              e.vertices.push(
                parseFloat(C[1]),
                parseFloat(C[2]),
                parseFloat(C[3])
              ), C.length >= 7 ? (Wd.setRGB(
                parseFloat(C[4]),
                parseFloat(C[5]),
                parseFloat(C[6])
              ).convertSRGBToLinear(), e.colors.push(Wd.r, Wd.g, Wd.b)) : e.colors.push(void 0, void 0, void 0);
              break;
            case "vn":
              e.normals.push(
                parseFloat(C[1]),
                parseFloat(C[2]),
                parseFloat(C[3])
              );
              break;
            case "vt":
              e.uvs.push(
                parseFloat(C[1]),
                parseFloat(C[2])
              );
              break;
          }
        } else if (E === "f") {
          const c = I.slice(1).trim().split(qF), u = [];
          for (let p = 0, D = c.length; p < D; p++) {
            const f = c[p];
            if (f.length > 0) {
              const S = f.split("/");
              u.push(S);
            }
          }
          const d = u[0];
          for (let p = 1, D = u.length - 1; p < D; p++) {
            const f = u[p], S = u[p + 1];
            e.addFace(
              d[0],
              f[0],
              S[0],
              d[1],
              f[1],
              S[1],
              d[2],
              f[2],
              S[2]
            );
          }
        } else if (E === "l") {
          const C = I.substring(1).trim().split(" ");
          let c = [];
          const u = [];
          if (I.indexOf("/") === -1)
            c = C;
          else
            for (let d = 0, p = C.length; d < p; d++) {
              const D = C[d].split("/");
              D[0] !== "" && c.push(D[0]), D[1] !== "" && u.push(D[1]);
            }
          e.addLineGeometry(c, u);
        } else if (E === "p") {
          const c = I.slice(1).trim().split(" ");
          e.addPointGeometry(c);
        } else if ((i = NP.exec(I)) !== null) {
          const C = (" " + i[0].slice(1).trim()).slice(1);
          e.startObject(C);
        } else if (GP.test(I))
          e.object.startMaterial(I.substring(7).trim(), e.materialLibraries);
        else if (FP.test(I))
          e.materialLibraries.push(I.substring(7).trim());
        else if (vP.test(I))
          console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
        else if (E === "s") {
          if (i = I.split(" "), i.length > 1) {
            const c = i[1].trim().toLowerCase();
            e.object.smooth = c !== "0" && c !== "off";
          } else
            e.object.smooth = !0;
          const C = e.object.currentMaterial();
          C && (C.smooth = e.object.smooth);
        } else {
          if (I === "\0")
            continue;
          console.warn('THREE.OBJLoader: Unexpected line: "' + I + '"');
        }
    }
    e.finalize();
    const n = new eo();
    if (n.materialLibraries = [].concat(e.materialLibraries), !(e.objects.length === 1 && e.objects[0].geometry.vertices.length === 0) === !0)
      for (let s = 0, B = e.objects.length; s < B; s++) {
        const I = e.objects[s], E = I.geometry, C = I.materials, c = E.type === "Line", u = E.type === "Points";
        let d = !1;
        if (E.vertices.length === 0)
          continue;
        const p = new ut();
        p.setAttribute("position", new Oe(E.vertices, 3)), E.normals.length > 0 && p.setAttribute("normal", new Oe(E.normals, 3)), E.colors.length > 0 && (d = !0, p.setAttribute("color", new Oe(E.colors, 3))), E.hasUVIndices === !0 && p.setAttribute("uv", new Oe(E.uvs, 2));
        const D = [];
        for (let S = 0, y = C.length; S < y; S++) {
          const m = C[S], N = m.name + "_" + m.smooth + "_" + d;
          let F = e.materials[N];
          if (this.materials !== null) {
            if (F = this.materials.create(m.name), c && F && !(F instanceof Mn)) {
              const G = new Mn();
              Sn.prototype.copy.call(G, F), G.color.copy(F.color), F = G;
            } else if (u && F && !(F instanceof BB)) {
              const G = new BB({ size: 10, sizeAttenuation: !1 });
              Sn.prototype.copy.call(G, F), G.color.copy(F.color), G.map = F.map, F = G;
            }
          }
          F === void 0 && (c ? F = new Mn() : u ? F = new BB({ size: 1, sizeAttenuation: !1 }) : F = new UC(), F.name = m.name, F.flatShading = !m.smooth, F.vertexColors = d, e.materials[N] = F), D.push(F);
        }
        let f;
        if (D.length > 1) {
          for (let S = 0, y = C.length; S < y; S++) {
            const m = C[S];
            p.addGroup(m.groupStart, m.groupCount, S);
          }
          c ? f = new no(p, D) : u ? f = new yE(p, D) : f = new Xi(p, D);
        } else
          c ? f = new no(p, D[0]) : u ? f = new yE(p, D[0]) : f = new Xi(p, D[0]);
        f.name = I.name, n.add(f);
      }
    else if (e.vertices.length > 0) {
      const s = new BB({ size: 1, sizeAttenuation: !1 }), B = new ut();
      B.setAttribute("position", new Oe(e.vertices, 3)), e.colors.length > 0 && e.colors[0] !== void 0 && (B.setAttribute("color", new Oe(e.colors, 3)), s.vertexColors = !0);
      const I = new yE(B, s);
      n.add(I);
    }
    return n;
  }
}
const oy = (g) => {
  for (const A of g.children)
    if (A instanceof Xi)
      return A;
  return null;
}, xP = () => {
  const { model: g, modelScaleFactor: A } = dB(), e = g.split(".")?.pop()?.toLowerCase();
  let t;
  switch (e) {
    case "gltf":
    case "glb":
      t = xF;
      break;
    case "fbx":
      t = uP;
      break;
    case "obj":
      t = kP;
      break;
    default:
      throw new Error(`Unsupported format ${e}`);
  }
  const i = sm(t, g);
  return ni(() => {
    const r = t === xF ? i.scene : i, s = oy(r);
    if (!s)
      throw new Error("Model has no mesh");
    const B = s.geometry.clone(), I = new ut();
    return I.setAttribute("position", B.getAttribute("position")), I.setAttribute("normal", B.getAttribute("normal")), B.index || (s.geometry = uq(I)), A && s.geometry.scale(
      A,
      A,
      A
    ), r;
  }, [t, i, A]);
}, LP = ({
  id: g,
  mesh: A,
  index: e,
  selected: t = !1,
  onClick: i,
  onDrag: n,
  texture: r
}) => {
  const s = Dt(null), B = Ak(t ? n : () => {
  }, {
    threshold: 5
  });
  return /* @__PURE__ */ fe("group", { ...B(), children: /* @__PURE__ */ fe(
    "mesh",
    {
      ...A,
      name: `STICKER_${g}`,
      onPointerUp: i,
      ref: s,
      renderOrder: e,
      children: /* @__PURE__ */ fe(
        "meshStandardMaterial",
        {
          map: r,
          depthWrite: !1,
          transparent: !0,
          metalness: 0.5
        }
      )
    }
  ) });
};
class TP extends Qs {
}
om({ ThreeLine: TP });
const VF = (g, A, e, t) => new IA(
  g + e * Math.cos(t),
  A + e * Math.sin(t),
  0
), KP = (g, A) => [
  new IA(g * Math.cos(A), g * Math.sin(A), 0),
  new IA(
    (g + 0.2) * Math.cos(A),
    (g + 0.35) * Math.sin(A),
    0
  )
], pc = 2.5, bP = zc((g, A) => {
  const {
    selectedSticker: e,
    pastedStickers: t,
    scale: i,
    setScale: n,
    setRotation: r,
    rotation: s,
    isDragging: B,
    isRotating: I,
    setIsDragging: E,
    setIsRotating: C
  } = dB(), c = [0, Math.PI / 2, Math.PI * 3 / 2, Math.PI], u = ni(() => new PC(0.12, 0.12), []), d = ni(
    () => new Jy(u),
    [u]
  ), p = ni(
    () => new UC({
      color: 15724527,
      opacity: 0.5,
      side: Rr,
      polygonOffset: !0,
      polygonOffsetFactor: -0.5,
      depthTest: !1
    }),
    []
  ), D = ni(
    () => new Mn({
      color: 0,
      linewidth: 3,
      depthTest: !1,
      transparent: !0
    }),
    []
  ), f = Dt(null), S = ni(
    () => new ut().setFromPoints(
      new tu(
        0,
        0,
        i * pc,
        i * pc,
        // xRadius, yRadius
        0,
        2 * Math.PI,
        !1,
        0
      ).getPoints(50)
    ),
    [i]
  ), y = ni(
    () => new Mn({
      color: 0,
      linewidth: 10,
      depthTest: !1,
      transparent: !0
    }),
    []
  ), m = (v) => {
    C(!0), v.stopPropagation();
  }, N = (v) => {
    E(!0), v.stopPropagation();
  }, F = (v) => {
    E(!1), C(!1), v.stopPropagation();
  }, G = (v) => {
    if (B) {
      const x = v.point.distanceTo(
        A?.current.position
      ), H = 1.3, _ = 0.1, j = Math.min(Math.max(x * 0.5, _), H);
      n(j);
      return;
    }
    if (I) {
      const x = v.point, H = new IA(), _ = f.current?.getWorldPosition(H), j = t.find((Y) => Y.id === e);
      if (!j)
        return;
      const V = j.position, iA = _.clone().sub(V), eA = x.clone().sub(V), oA = j.mh.position.clone().normalize(), P = iA.clone().cross(eA).dot(oA), J = iA.clone().dot(eA), tA = Math.atan2(P, J);
      r((Y) => Y + tA / Math.PI * 15);
      return;
    }
  }, k = KP(
    i * pc,
    s / 50 * Math.PI + Math.PI / 2
  );
  return /* @__PURE__ */ Wi(
    "threeLine",
    {
      userData: { hideOnExport: !0 },
      geometry: S,
      material: y,
      ref: A,
      visible: !!e,
      renderOrder: 1e3,
      children: [
        /* @__PURE__ */ fe(
          "mesh",
          {
            geometry: u,
            material: p,
            scale: [200, 200, 1],
            visible: !1,
            onPointerMove: G,
            onPointerUp: F
          }
        ),
        c.map((v) => /* @__PURE__ */ Wi(qi.Fragment, { children: [
          /* @__PURE__ */ fe(
            "mesh",
            {
              onPointerDown: N,
              position: VF(
                0,
                0,
                i * pc,
                v
              ),
              geometry: u,
              material: p,
              renderOrder: 1e3
            }
          ),
          /* @__PURE__ */ fe(
            "threeLine",
            {
              position: VF(
                0,
                0,
                i * pc,
                v
              ),
              geometry: d,
              material: D,
              renderOrder: 1e3
            }
          ),
          /* @__PURE__ */ fe(
            "mesh",
            {
              onPointerDown: m,
              ref: f,
              position: k[1],
              geometry: u,
              material: p,
              renderOrder: 1e3,
              rotation: [0, 0, s / 50 * Math.PI - Math.PI / 4]
            }
          ),
          /* @__PURE__ */ fe(
            "threeLine",
            {
              position: k[1],
              geometry: d,
              material: D,
              renderOrder: 1e3,
              rotation: [0, 0, s / 50 * Math.PI - Math.PI / 4]
            }
          ),
          /* @__PURE__ */ fe(
            "threeLine",
            {
              geometry: new ut().setFromPoints(k),
              renderOrder: 1e3,
              children: /* @__PURE__ */ fe(
                "lineBasicMaterial",
                {
                  color: "#000",
                  depthTest: !1,
                  transparent: !0
                }
              )
            }
          )
        ] }, v))
      ]
    }
  );
});
function jF(g) {
  throw new Error('Could not dynamically require "' + g + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var uf = {}, YP = {
  get exports() {
    return uf;
  },
  set exports(g) {
    uf = g;
  }
};
(function(g, A) {
  (function(t, i) {
    g.exports = i();
  })(self, () => (
    /******/
    (() => {
      var e = {
        /***/
        76: (
          /***/
          (r, s, B) => {
            B(72);
            const { devDependencies: I } = B(681);
            r.exports = {
              corePath: `https://unpkg.com/@ffmpeg/core@${I["@ffmpeg/core"].substring(1)}/dist/ffmpeg-core.js`
            };
          }
        ),
        /***/
        339: (
          /***/
          (r, s, B) => {
            const I = B(72), E = (C) => new Promise((c, u) => {
              const d = new FileReader();
              d.onload = () => {
                c(d.result);
              }, d.onerror = ({ target: { error: { code: p } } }) => {
                u(Error(`File could not be read! Code=${p}`));
              }, d.readAsArrayBuffer(C);
            });
            r.exports = async (C) => {
              let c = C;
              return typeof C > "u" ? new Uint8Array() : (typeof C == "string" ? /data:_data\/([a-zA-Z]*);base64,([^"]*)/.test(C) ? c = atob(C.split(",")[1]).split("").map((u) => u.charCodeAt(0)) : c = await (await fetch(I(C))).arrayBuffer() : (C instanceof File || C instanceof Blob) && (c = await E(C)), new Uint8Array(c));
            };
          }
        ),
        /***/
        440: (
          /***/
          (r, s, B) => {
            const I = B(72), { log: E } = B(888), C = async (c, u) => {
              E("info", `fetch ${c}`);
              const d = await (await fetch(c)).arrayBuffer();
              E("info", `${c} file size = ${d.byteLength} bytes`);
              const p = new Blob([d], { type: u }), D = URL.createObjectURL(p);
              return E("info", `${c} blob URL = ${D}`), D;
            };
            r.exports = async ({ corePath: c }) => {
              if (typeof c != "string")
                throw Error("corePath should be a string!");
              const u = I(c), d = await C(
                u,
                "application/javascript"
              ), p = await C(
                u.replace("ffmpeg-core.js", "ffmpeg-core.wasm"),
                "application/wasm"
              ), D = await C(
                u.replace("ffmpeg-core.js", "ffmpeg-core.worker.js"),
                "application/javascript"
              );
              return typeof createFFmpegCore > "u" ? new Promise((f) => {
                const S = document.createElement("script"), y = () => {
                  S.removeEventListener("load", y), E("info", "ffmpeg-core.js script loaded"), f({
                    createFFmpegCore,
                    corePath: d,
                    wasmPath: p,
                    workerPath: D
                  });
                };
                S.src = d, S.type = "text/javascript", S.addEventListener("load", y), document.getElementsByTagName("head")[0].appendChild(S);
              }) : (E("info", "ffmpeg-core.js script is loaded already"), Promise.resolve({
                createFFmpegCore,
                corePath: d,
                wasmPath: p,
                workerPath: D
              }));
            };
          }
        ),
        /***/
        451: (
          /***/
          (r, s, B) => {
            const I = B(76), E = B(440), C = B(339);
            r.exports = {
              defaultOptions: I,
              getCreateFFmpegCore: E,
              fetchFile: C
            };
          }
        ),
        /***/
        617: (
          /***/
          (r) => {
            r.exports = {
              defaultArgs: [
                /* args[0] is always the binary path */
                "./ffmpeg",
                /* Disable interaction mode */
                "-nostdin",
                /* Force to override output file */
                "-y"
              ],
              baseOptions: {
                /* Flag to turn on/off log messages in console */
                log: !1,
                /*
                 * Custom logger to get ffmpeg.wasm output messages.
                 * a sample logger looks like this:
                 *
                 * ```
                 * logger = ({ type, message }) => {
                 *   console.log(type, message);
                 * }
                 * ```
                 *
                 * type can be one of following:
                 *
                 * info: internal workflow debug messages
                 * fferr: ffmpeg native stderr output
                 * ffout: ffmpeg native stdout output
                 */
                logger: () => {
                },
                /*
                 * Progress handler to get current progress of ffmpeg command.
                 * a sample progress handler looks like this:
                 *
                 * ```
                 * progress = ({ ratio }) => {
                 *   console.log(ratio);
                 * }
                 * ```
                 *
                 * ratio is a float number between 0 to 1.
                 */
                progress: () => {
                },
                /*
                 * Path to find/download ffmpeg.wasm-core,
                 * this value should be overwriten by `defaultOptions` in
                 * each environment.
                 */
                corePath: ""
              }
            };
          }
        ),
        /***/
        648: (
          /***/
          (r, s, B) => {
            const { defaultArgs: I, baseOptions: E } = B(617), { setLogging: C, setCustomLogger: c, log: u } = B(888), d = B(405), p = B(10), { defaultOptions: D, getCreateFFmpegCore: f } = B(451), { version: S } = B(681), y = Error("ffmpeg.wasm is not ready, make sure you have completed load().");
            r.exports = (m = {}) => {
              const {
                log: N,
                logger: F,
                progress: G,
                ...k
              } = {
                ...E,
                ...D,
                ...m
              };
              let v = null, x = null, H = null, _ = !1, j = G;
              const V = (QA) => {
                QA === "FFMPEG_END" && H !== null && (H(), H = null, _ = !1);
              }, iA = ({ type: QA, message: aA }) => {
                u(QA, aA), d(aA, j), V(aA);
              }, eA = async () => {
                if (u("info", "load ffmpeg-core"), v === null) {
                  u("info", "loading ffmpeg-core");
                  const {
                    createFFmpegCore: QA,
                    corePath: aA,
                    workerPath: MA,
                    wasmPath: hA
                  } = await f(k);
                  v = await QA({
                    /*
                     * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue
                     * as there is no document.currentScript in the context of content_scripts
                     */
                    mainScriptUrlOrBlob: aA,
                    printErr: (fA) => iA({ type: "fferr", message: fA }),
                    print: (fA) => iA({ type: "ffout", message: fA }),
                    /*
                     * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).
                     * It is critical for browser environment and we override both wasm and worker paths
                     * as we are using blob URL instead of original URL to avoid cross origin issues.
                     */
                    locateFile: (fA, wA) => {
                      if (typeof window < "u") {
                        if (typeof hA < "u" && fA.endsWith("ffmpeg-core.wasm"))
                          return hA;
                        if (typeof MA < "u" && fA.endsWith("ffmpeg-core.worker.js"))
                          return MA;
                      }
                      return wA + fA;
                    }
                  }), x = v.cwrap("proxy_main", "number", ["number", "number"]), u("info", "ffmpeg-core loaded");
                } else
                  throw Error("ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.");
              }, oA = () => v !== null, P = (...QA) => {
                if (u("info", `run ffmpeg command: ${QA.join(" ")}`), v === null)
                  throw y;
                if (_)
                  throw Error("ffmpeg.wasm can only run one command at a time");
                return _ = !0, new Promise((aA) => {
                  const MA = [...I, ...QA].filter((hA) => hA.length !== 0);
                  H = aA, x(...p(v, MA));
                });
              }, J = (QA, ...aA) => {
                if (u("info", `run FS.${QA} ${aA.map((MA) => typeof MA == "string" ? MA : `<${MA.length} bytes binary file>`).join(" ")}`), v === null)
                  throw y;
                {
                  let MA = null;
                  try {
                    MA = v.FS[QA](...aA);
                  } catch {
                    throw Error(QA === "readdir" ? `ffmpeg.FS('readdir', '${aA[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')` : QA === "readFile" ? `ffmpeg.FS('readFile', '${aA[0]}') error. Check if the path exists` : "Oops, something went wrong in FS operation.");
                  }
                  return MA;
                }
              }, tA = () => {
                if (v === null)
                  throw y;
                _ = !1, v.exit(1), v = null, x = null, H = null;
              }, Y = (QA) => {
                j = QA;
              }, rA = (QA) => {
                c(QA);
              };
              return C(N), c(F), u("info", `use ffmpeg.wasm v${S}`), {
                setProgress: Y,
                setLogger: rA,
                setLogging: C,
                load: eA,
                isLoaded: oA,
                run: P,
                exit: tA,
                FS: J
              };
            };
          }
        ),
        /***/
        888: (
          /***/
          (r) => {
            let s = !1, B = () => {
            };
            const I = (c) => {
              s = c;
            }, E = (c) => {
              B = c;
            }, C = (c, u) => {
              B({ type: c, message: u }), s && console.log(`[${c}] ${u}`);
            };
            r.exports = {
              logging: s,
              setLogging: I,
              setCustomLogger: E,
              log: C
            };
          }
        ),
        /***/
        10: (
          /***/
          (r) => {
            r.exports = (s, B) => {
              const I = s._malloc(B.length * Uint32Array.BYTES_PER_ELEMENT);
              return B.forEach((E, C) => {
                const c = s._malloc(E.length + 1);
                s.writeAsciiToMemory(E, c), s.setValue(I + Uint32Array.BYTES_PER_ELEMENT * C, c, "i32");
              }), [B.length, I];
            };
          }
        ),
        /***/
        405: (
          /***/
          (r) => {
            let s = 0, B = 0;
            const I = (E) => {
              const [C, c, u] = E.split(":");
              return parseFloat(C) * 60 * 60 + parseFloat(c) * 60 + parseFloat(u);
            };
            r.exports = (E, C) => {
              if (typeof E == "string")
                if (E.startsWith("  Duration")) {
                  const c = E.split(", ")[0].split(": ")[1], u = I(c);
                  C({ duration: u, ratio: B }), (s === 0 || s > u) && (s = u);
                } else if (E.startsWith("frame") || E.startsWith("size")) {
                  const c = E.split("time=")[1].split(" ")[0], u = I(c);
                  B = u / s, C({ ratio: B, time: u });
                } else
                  E.startsWith("video:") && (C({ ratio: 1 }), s = 0);
            };
          }
        ),
        /***/
        809: (
          /***/
          (r, s) => {
            Object.defineProperty(s, "__esModule", {
              value: !0
            }), s.changeDpiBlob = N, s.changeDpiDataUrl = F;
            function B(x) {
              if (Array.isArray(x)) {
                for (var H = 0, _ = Array(x.length); H < x.length; H++)
                  _[H] = x[H];
                return _;
              } else
                return Array.from(x);
            }
            function I() {
              for (var x = new Int32Array(256), H = 0; H < 256; H++) {
                for (var _ = H, j = 0; j < 8; j++)
                  _ = _ & 1 ? 3988292384 ^ _ >>> 1 : _ >>> 1;
                x[H] = _;
              }
              return x;
            }
            function E(x) {
              var H = -1;
              C || (C = I());
              for (var _ = 0; _ < x.length; _++)
                H = C[(H ^ x[_]) & 255] ^ H >>> 8;
              return H ^ -1;
            }
            var C = void 0, c = "image/png", u = "image/jpeg", d = "AAlwSFlz", p = "AAAJcEhZ", D = "AAAACXBI", f = "p".charCodeAt(0), S = "H".charCodeAt(0), y = "Y".charCodeAt(0), m = "s".charCodeAt(0);
            function N(x, H) {
              var _ = x.slice(0, 33);
              return new Promise(function(j, V) {
                var iA = new FileReader();
                iA.onload = function() {
                  var eA = new Uint8Array(iA.result), oA = x.slice(33), P = v(eA, H, x.type);
                  j(new Blob([P, oA], { type: x.type }));
                }, iA.readAsArrayBuffer(_);
              });
            }
            function F(x, H) {
              var _ = x.split(","), j = _[0], V = _[1], iA = void 0, eA = void 0, oA = !1;
              if (j.indexOf(c) !== -1) {
                iA = c;
                var P = G(V);
                P >= 0 ? (eA = Math.ceil((P + 28) / 3) * 4, oA = !0) : eA = 44;
              }
              j.indexOf(u) !== -1 && (iA = u, eA = 24);
              for (var J = V.substring(0, eA), tA = V.substring(eA), Y = atob(J), rA = new Uint8Array(Y.length), QA = 0; QA < rA.length; QA++)
                rA[QA] = Y.charCodeAt(QA);
              var aA = v(rA, H, iA, oA), MA = btoa(String.fromCharCode.apply(String, B(aA)));
              return [j, ",", MA, tA].join("");
            }
            function G(x) {
              var H = x.indexOf(d);
              return H === -1 && (H = x.indexOf(p)), H === -1 && (H = x.indexOf(D)), H;
            }
            function k(x) {
              for (var H = x.length - 1, _ = H; _ >= 4; _--)
                if (x[_ - 4] === 9 && x[_ - 3] === f && x[_ - 2] === S && x[_ - 1] === y && x[_] === m)
                  return _ - 3;
            }
            function v(x, H, _, j) {
              if (_ === u)
                return x[13] = 1, x[14] = H >> 8, x[15] = H & 255, x[16] = H >> 8, x[17] = H & 255, x;
              if (_ === c) {
                var V = new Uint8Array(13);
                H *= 39.3701, V[0] = f, V[1] = S, V[2] = y, V[3] = m, V[4] = H >>> 24, V[5] = H >>> 16, V[6] = H >>> 8, V[7] = H & 255, V[8] = V[4], V[9] = V[5], V[10] = V[6], V[11] = V[7], V[12] = 1;
                var iA = E(V), eA = new Uint8Array(4);
                if (eA[0] = iA >>> 24, eA[1] = iA >>> 16, eA[2] = iA >>> 8, eA[3] = iA & 255, j) {
                  var oA = k(x);
                  return x.set(V, oA), x.set(eA, oA + 13), x;
                } else {
                  var P = new Uint8Array(4);
                  P[0] = 0, P[1] = 0, P[2] = 0, P[3] = 9;
                  var J = new Uint8Array(54);
                  return J.set(x, 0), J.set(P, 33), J.set(V, 37), J.set(eA, 50), J;
                }
              }
            }
          }
        ),
        /***/
        162: (
          /***/
          function(r, s, B) {
            var I, E, C;
            (function(c, u) {
              E = [], I = u, C = typeof I == "function" ? I.apply(s, E) : I, C !== void 0 && (r.exports = C);
            })(this, function() {
              function c(y, m) {
                return typeof m > "u" ? m = { autoBom: !1 } : typeof m != "object" && (console.warn("Deprecated: Expected third argument to be a object"), m = { autoBom: !m }), m.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(y.type) ? new Blob(["\uFEFF", y], { type: y.type }) : y;
              }
              function u(y, m, N) {
                var F = new XMLHttpRequest();
                F.open("GET", y), F.responseType = "blob", F.onload = function() {
                  S(F.response, m, N);
                }, F.onerror = function() {
                  console.error("could not download file");
                }, F.send();
              }
              function d(y) {
                var m = new XMLHttpRequest();
                m.open("HEAD", y, !1);
                try {
                  m.send();
                } catch {
                }
                return 200 <= m.status && 299 >= m.status;
              }
              function p(y) {
                try {
                  y.dispatchEvent(new MouseEvent("click"));
                } catch {
                  var m = document.createEvent("MouseEvents");
                  m.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), y.dispatchEvent(m);
                }
              }
              var D = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof B.g == "object" && B.g.global === B.g ? B.g : void 0, f = D.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), S = D.saveAs || (typeof window != "object" || window !== D ? function() {
              } : "download" in HTMLAnchorElement.prototype && !f ? function(y, m, N) {
                var F = D.URL || D.webkitURL, G = document.createElement("a");
                m = m || y.name || "download", G.download = m, G.rel = "noopener", typeof y == "string" ? (G.href = y, G.origin === location.origin ? p(G) : d(G.href) ? u(y, m, N) : p(G, G.target = "_blank")) : (G.href = F.createObjectURL(y), setTimeout(function() {
                  F.revokeObjectURL(G.href);
                }, 4e4), setTimeout(function() {
                  p(G);
                }, 0));
              } : "msSaveOrOpenBlob" in navigator ? function(y, m, N) {
                if (m = m || y.name || "download", typeof y != "string")
                  navigator.msSaveOrOpenBlob(c(y, N), m);
                else if (d(y))
                  u(y, m, N);
                else {
                  var F = document.createElement("a");
                  F.href = y, F.target = "_blank", setTimeout(function() {
                    p(F);
                  });
                }
              } : function(y, m, N, F) {
                if (F = F || open("", "_blank"), F && (F.document.title = F.document.body.innerText = "downloading..."), typeof y == "string")
                  return u(y, m, N);
                var G = y.type === "application/octet-stream", k = /constructor/i.test(D.HTMLElement) || D.safari, v = /CriOS\/[\d]+/.test(navigator.userAgent);
                if ((v || G && k || f) && typeof FileReader < "u") {
                  var x = new FileReader();
                  x.onloadend = function() {
                    var j = x.result;
                    j = v ? j : j.replace(/^data:[^;]*;/, "data:attachment/file;"), F ? F.location.href = j : location = j, F = null;
                  }, x.readAsDataURL(y);
                } else {
                  var H = D.URL || D.webkitURL, _ = H.createObjectURL(y);
                  F ? F.location = _ : location.href = _, F = null, setTimeout(function() {
                    H.revokeObjectURL(_);
                  }, 4e4);
                }
              });
              D.saveAs = S.saveAs = S, r.exports = S;
            });
          }
        ),
        /***/
        733: (
          /***/
          (r, s, B) => {
            /*!
            
            	JSZip v3.7.1 - A JavaScript class for generating and reading zip files
            	<http://stuartk.com/jszip>
            
            	(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
            	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.
            
            	JSZip uses the library pako released under the MIT license :
            	https://github.com/nodeca/pako/blob/master/LICENSE
            	*/
            (function(I) {
              r.exports = I();
            })(function() {
              return function I(E, C, c) {
                function u(D, f) {
                  if (!C[D]) {
                    if (!E[D]) {
                      var S = void 0;
                      if (!f && S)
                        return jF(D);
                      if (d)
                        return d(D, !0);
                      var y = new Error("Cannot find module '" + D + "'");
                      throw y.code = "MODULE_NOT_FOUND", y;
                    }
                    var m = C[D] = { exports: {} };
                    E[D][0].call(m.exports, function(N) {
                      var F = E[D][1][N];
                      return u(F || N);
                    }, m, m.exports, I, E, C, c);
                  }
                  return C[D].exports;
                }
                for (var d = void 0, p = 0; p < c.length; p++)
                  u(c[p]);
                return u;
              }({ 1: [function(I, E, C) {
                var c = I("./utils"), u = I("./support"), d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                C.encode = function(p) {
                  for (var D, f, S, y, m, N, F, G = [], k = 0, v = p.length, x = v, H = c.getTypeOf(p) !== "string"; k < p.length; )
                    x = v - k, S = H ? (D = p[k++], f = k < v ? p[k++] : 0, k < v ? p[k++] : 0) : (D = p.charCodeAt(k++), f = k < v ? p.charCodeAt(k++) : 0, k < v ? p.charCodeAt(k++) : 0), y = D >> 2, m = (3 & D) << 4 | f >> 4, N = 1 < x ? (15 & f) << 2 | S >> 6 : 64, F = 2 < x ? 63 & S : 64, G.push(d.charAt(y) + d.charAt(m) + d.charAt(N) + d.charAt(F));
                  return G.join("");
                }, C.decode = function(p) {
                  var D, f, S, y, m, N, F = 0, G = 0, k = "data:";
                  if (p.substr(0, k.length) === k)
                    throw new Error("Invalid base64 input, it looks like a data url.");
                  var v, x = 3 * (p = p.replace(/[^A-Za-z0-9\+\/\=]/g, "")).length / 4;
                  if (p.charAt(p.length - 1) === d.charAt(64) && x--, p.charAt(p.length - 2) === d.charAt(64) && x--, x % 1 != 0)
                    throw new Error("Invalid base64 input, bad content length.");
                  for (v = u.uint8array ? new Uint8Array(0 | x) : new Array(0 | x); F < p.length; )
                    D = d.indexOf(p.charAt(F++)) << 2 | (y = d.indexOf(p.charAt(F++))) >> 4, f = (15 & y) << 4 | (m = d.indexOf(p.charAt(F++))) >> 2, S = (3 & m) << 6 | (N = d.indexOf(p.charAt(F++))), v[G++] = D, m !== 64 && (v[G++] = f), N !== 64 && (v[G++] = S);
                  return v;
                };
              }, { "./support": 30, "./utils": 32 }], 2: [function(I, E, C) {
                var c = I("./external"), u = I("./stream/DataWorker"), d = I("./stream/Crc32Probe"), p = I("./stream/DataLengthProbe");
                function D(f, S, y, m, N) {
                  this.compressedSize = f, this.uncompressedSize = S, this.crc32 = y, this.compression = m, this.compressedContent = N;
                }
                D.prototype = { getContentWorker: function() {
                  var f = new u(c.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new p("data_length")), S = this;
                  return f.on("end", function() {
                    if (this.streamInfo.data_length !== S.uncompressedSize)
                      throw new Error("Bug : uncompressed data size mismatch");
                  }), f;
                }, getCompressedWorker: function() {
                  return new u(c.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
                } }, D.createWorkerFrom = function(f, S, y) {
                  return f.pipe(new d()).pipe(new p("uncompressedSize")).pipe(S.compressWorker(y)).pipe(new p("compressedSize")).withStreamInfo("compression", S);
                }, E.exports = D;
              }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(I, E, C) {
                var c = I("./stream/GenericWorker");
                C.STORE = { magic: "\0\0", compressWorker: function(u) {
                  return new c("STORE compression");
                }, uncompressWorker: function() {
                  return new c("STORE decompression");
                } }, C.DEFLATE = I("./flate");
              }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(I, E, C) {
                var c = I("./utils"), u = function() {
                  for (var d, p = [], D = 0; D < 256; D++) {
                    d = D;
                    for (var f = 0; f < 8; f++)
                      d = 1 & d ? 3988292384 ^ d >>> 1 : d >>> 1;
                    p[D] = d;
                  }
                  return p;
                }();
                E.exports = function(d, p) {
                  return d !== void 0 && d.length ? c.getTypeOf(d) !== "string" ? function(D, f, S, y) {
                    var m = u, N = y + S;
                    D ^= -1;
                    for (var F = y; F < N; F++)
                      D = D >>> 8 ^ m[255 & (D ^ f[F])];
                    return -1 ^ D;
                  }(0 | p, d, d.length, 0) : function(D, f, S, y) {
                    var m = u, N = y + S;
                    D ^= -1;
                    for (var F = y; F < N; F++)
                      D = D >>> 8 ^ m[255 & (D ^ f.charCodeAt(F))];
                    return -1 ^ D;
                  }(0 | p, d, d.length, 0) : 0;
                };
              }, { "./utils": 32 }], 5: [function(I, E, C) {
                C.base64 = !1, C.binary = !1, C.dir = !1, C.createFolders = !0, C.date = null, C.compression = null, C.compressionOptions = null, C.comment = null, C.unixPermissions = null, C.dosPermissions = null;
              }, {}], 6: [function(I, E, C) {
                var c = null;
                c = typeof Promise < "u" ? Promise : I("lie"), E.exports = { Promise: c };
              }, { lie: 37 }], 7: [function(I, E, C) {
                var c = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", u = I("pako"), d = I("./utils"), p = I("./stream/GenericWorker"), D = c ? "uint8array" : "array";
                function f(S, y) {
                  p.call(this, "FlateWorker/" + S), this._pako = null, this._pakoAction = S, this._pakoOptions = y, this.meta = {};
                }
                C.magic = "\b\0", d.inherits(f, p), f.prototype.processChunk = function(S) {
                  this.meta = S.meta, this._pako === null && this._createPako(), this._pako.push(d.transformTo(D, S.data), !1);
                }, f.prototype.flush = function() {
                  p.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
                }, f.prototype.cleanUp = function() {
                  p.prototype.cleanUp.call(this), this._pako = null;
                }, f.prototype._createPako = function() {
                  this._pako = new u[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
                  var S = this;
                  this._pako.onData = function(y) {
                    S.push({ data: y, meta: S.meta });
                  };
                }, C.compressWorker = function(S) {
                  return new f("Deflate", S);
                }, C.uncompressWorker = function() {
                  return new f("Inflate", {});
                };
              }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(I, E, C) {
                function c(m, N) {
                  var F, G = "";
                  for (F = 0; F < N; F++)
                    G += String.fromCharCode(255 & m), m >>>= 8;
                  return G;
                }
                function u(m, N, F, G, k, v) {
                  var x, H, _ = m.file, j = m.compression, V = v !== D.utf8encode, iA = d.transformTo("string", v(_.name)), eA = d.transformTo("string", D.utf8encode(_.name)), oA = _.comment, P = d.transformTo("string", v(oA)), J = d.transformTo("string", D.utf8encode(oA)), tA = eA.length !== _.name.length, Y = J.length !== oA.length, rA = "", QA = "", aA = "", MA = _.dir, hA = _.date, fA = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
                  N && !F || (fA.crc32 = m.crc32, fA.compressedSize = m.compressedSize, fA.uncompressedSize = m.uncompressedSize);
                  var wA = 0;
                  N && (wA |= 8), V || !tA && !Y || (wA |= 2048);
                  var yA = 0, kA = 0;
                  MA && (yA |= 16), k === "UNIX" ? (kA = 798, yA |= function(dA, vA) {
                    var JA = dA;
                    return dA || (JA = vA ? 16893 : 33204), (65535 & JA) << 16;
                  }(_.unixPermissions, MA)) : (kA = 20, yA |= function(dA) {
                    return 63 & (dA || 0);
                  }(_.dosPermissions)), x = hA.getUTCHours(), x <<= 6, x |= hA.getUTCMinutes(), x <<= 5, x |= hA.getUTCSeconds() / 2, H = hA.getUTCFullYear() - 1980, H <<= 4, H |= hA.getUTCMonth() + 1, H <<= 5, H |= hA.getUTCDate(), tA && (QA = c(1, 1) + c(f(iA), 4) + eA, rA += "up" + c(QA.length, 2) + QA), Y && (aA = c(1, 1) + c(f(P), 4) + J, rA += "uc" + c(aA.length, 2) + aA);
                  var FA = "";
                  return FA += `
\0`, FA += c(wA, 2), FA += j.magic, FA += c(x, 2), FA += c(H, 2), FA += c(fA.crc32, 4), FA += c(fA.compressedSize, 4), FA += c(fA.uncompressedSize, 4), FA += c(iA.length, 2), FA += c(rA.length, 2), { fileRecord: S.LOCAL_FILE_HEADER + FA + iA + rA, dirRecord: S.CENTRAL_FILE_HEADER + c(kA, 2) + FA + c(P.length, 2) + "\0\0\0\0" + c(yA, 4) + c(G, 4) + iA + rA + P };
                }
                var d = I("../utils"), p = I("../stream/GenericWorker"), D = I("../utf8"), f = I("../crc32"), S = I("../signature");
                function y(m, N, F, G) {
                  p.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = N, this.zipPlatform = F, this.encodeFileName = G, this.streamFiles = m, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
                }
                d.inherits(y, p), y.prototype.push = function(m) {
                  var N = m.meta.percent || 0, F = this.entriesCount, G = this._sources.length;
                  this.accumulate ? this.contentBuffer.push(m) : (this.bytesWritten += m.data.length, p.prototype.push.call(this, { data: m.data, meta: { currentFile: this.currentFile, percent: F ? (N + 100 * (F - G - 1)) / F : 100 } }));
                }, y.prototype.openedSource = function(m) {
                  this.currentSourceOffset = this.bytesWritten, this.currentFile = m.file.name;
                  var N = this.streamFiles && !m.file.dir;
                  if (N) {
                    var F = u(m, N, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                    this.push({ data: F.fileRecord, meta: { percent: 0 } });
                  } else
                    this.accumulate = !0;
                }, y.prototype.closedSource = function(m) {
                  this.accumulate = !1;
                  var N = this.streamFiles && !m.file.dir, F = u(m, N, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                  if (this.dirRecords.push(F.dirRecord), N)
                    this.push({ data: function(G) {
                      return S.DATA_DESCRIPTOR + c(G.crc32, 4) + c(G.compressedSize, 4) + c(G.uncompressedSize, 4);
                    }(m), meta: { percent: 100 } });
                  else
                    for (this.push({ data: F.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
                      this.push(this.contentBuffer.shift());
                  this.currentFile = null;
                }, y.prototype.flush = function() {
                  for (var m = this.bytesWritten, N = 0; N < this.dirRecords.length; N++)
                    this.push({ data: this.dirRecords[N], meta: { percent: 100 } });
                  var F = this.bytesWritten - m, G = function(k, v, x, H, _) {
                    var j = d.transformTo("string", _(H));
                    return S.CENTRAL_DIRECTORY_END + "\0\0\0\0" + c(k, 2) + c(k, 2) + c(v, 4) + c(x, 4) + c(j.length, 2) + j;
                  }(this.dirRecords.length, F, m, this.zipComment, this.encodeFileName);
                  this.push({ data: G, meta: { percent: 100 } });
                }, y.prototype.prepareNextSource = function() {
                  this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
                }, y.prototype.registerPrevious = function(m) {
                  this._sources.push(m);
                  var N = this;
                  return m.on("data", function(F) {
                    N.processChunk(F);
                  }), m.on("end", function() {
                    N.closedSource(N.previous.streamInfo), N._sources.length ? N.prepareNextSource() : N.end();
                  }), m.on("error", function(F) {
                    N.error(F);
                  }), this;
                }, y.prototype.resume = function() {
                  return !!p.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
                }, y.prototype.error = function(m) {
                  var N = this._sources;
                  if (!p.prototype.error.call(this, m))
                    return !1;
                  for (var F = 0; F < N.length; F++)
                    try {
                      N[F].error(m);
                    } catch {
                    }
                  return !0;
                }, y.prototype.lock = function() {
                  p.prototype.lock.call(this);
                  for (var m = this._sources, N = 0; N < m.length; N++)
                    m[N].lock();
                }, E.exports = y;
              }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(I, E, C) {
                var c = I("../compressions"), u = I("./ZipFileWorker");
                C.generateWorker = function(d, p, D) {
                  var f = new u(p.streamFiles, D, p.platform, p.encodeFileName), S = 0;
                  try {
                    d.forEach(function(y, m) {
                      S++;
                      var N = function(v, x) {
                        var H = v || x, _ = c[H];
                        if (!_)
                          throw new Error(H + " is not a valid compression method !");
                        return _;
                      }(m.options.compression, p.compression), F = m.options.compressionOptions || p.compressionOptions || {}, G = m.dir, k = m.date;
                      m._compressWorker(N, F).withStreamInfo("file", { name: y, dir: G, date: k, comment: m.comment || "", unixPermissions: m.unixPermissions, dosPermissions: m.dosPermissions }).pipe(f);
                    }), f.entriesCount = S;
                  } catch (y) {
                    f.error(y);
                  }
                  return f;
                };
              }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(I, E, C) {
                function c() {
                  if (!(this instanceof c))
                    return new c();
                  if (arguments.length)
                    throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
                  this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
                    var u = new c();
                    for (var d in this)
                      typeof this[d] != "function" && (u[d] = this[d]);
                    return u;
                  };
                }
                (c.prototype = I("./object")).loadAsync = I("./load"), c.support = I("./support"), c.defaults = I("./defaults"), c.version = "3.7.1", c.loadAsync = function(u, d) {
                  return new c().loadAsync(u, d);
                }, c.external = I("./external"), E.exports = c;
              }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(I, E, C) {
                var c = I("./utils"), u = I("./external"), d = I("./utf8"), p = I("./zipEntries"), D = I("./stream/Crc32Probe"), f = I("./nodejsUtils");
                function S(y) {
                  return new u.Promise(function(m, N) {
                    var F = y.decompressed.getContentWorker().pipe(new D());
                    F.on("error", function(G) {
                      N(G);
                    }).on("end", function() {
                      F.streamInfo.crc32 !== y.decompressed.crc32 ? N(new Error("Corrupted zip : CRC32 mismatch")) : m();
                    }).resume();
                  });
                }
                E.exports = function(y, m) {
                  var N = this;
                  return m = c.extend(m || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: d.utf8decode }), f.isNode && f.isStream(y) ? u.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : c.prepareContent("the loaded zip file", y, !0, m.optimizedBinaryString, m.base64).then(function(F) {
                    var G = new p(m);
                    return G.load(F), G;
                  }).then(function(F) {
                    var G = [u.Promise.resolve(F)], k = F.files;
                    if (m.checkCRC32)
                      for (var v = 0; v < k.length; v++)
                        G.push(S(k[v]));
                    return u.Promise.all(G);
                  }).then(function(F) {
                    for (var G = F.shift(), k = G.files, v = 0; v < k.length; v++) {
                      var x = k[v];
                      N.file(x.fileNameStr, x.decompressed, { binary: !0, optimizedBinaryString: !0, date: x.date, dir: x.dir, comment: x.fileCommentStr.length ? x.fileCommentStr : null, unixPermissions: x.unixPermissions, dosPermissions: x.dosPermissions, createFolders: m.createFolders });
                    }
                    return G.zipComment.length && (N.comment = G.zipComment), N;
                  });
                };
              }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(I, E, C) {
                var c = I("../utils"), u = I("../stream/GenericWorker");
                function d(p, D) {
                  u.call(this, "Nodejs stream input adapter for " + p), this._upstreamEnded = !1, this._bindStream(D);
                }
                c.inherits(d, u), d.prototype._bindStream = function(p) {
                  var D = this;
                  (this._stream = p).pause(), p.on("data", function(f) {
                    D.push({ data: f, meta: { percent: 0 } });
                  }).on("error", function(f) {
                    D.isPaused ? this.generatedError = f : D.error(f);
                  }).on("end", function() {
                    D.isPaused ? D._upstreamEnded = !0 : D.end();
                  });
                }, d.prototype.pause = function() {
                  return !!u.prototype.pause.call(this) && (this._stream.pause(), !0);
                }, d.prototype.resume = function() {
                  return !!u.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
                }, E.exports = d;
              }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(I, E, C) {
                var c = I("readable-stream").Readable;
                function u(d, p, D) {
                  c.call(this, p), this._helper = d;
                  var f = this;
                  d.on("data", function(S, y) {
                    f.push(S) || f._helper.pause(), D && D(y);
                  }).on("error", function(S) {
                    f.emit("error", S);
                  }).on("end", function() {
                    f.push(null);
                  });
                }
                I("../utils").inherits(u, c), u.prototype._read = function() {
                  this._helper.resume();
                }, E.exports = u;
              }, { "../utils": 32, "readable-stream": 16 }], 14: [function(I, E, C) {
                E.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(c, u) {
                  if (Buffer.from && Buffer.from !== Uint8Array.from)
                    return Buffer.from(c, u);
                  if (typeof c == "number")
                    throw new Error('The "data" argument must not be a number');
                  return new Buffer(c, u);
                }, allocBuffer: function(c) {
                  if (Buffer.alloc)
                    return Buffer.alloc(c);
                  var u = new Buffer(c);
                  return u.fill(0), u;
                }, isBuffer: function(c) {
                  return Buffer.isBuffer(c);
                }, isStream: function(c) {
                  return c && typeof c.on == "function" && typeof c.pause == "function" && typeof c.resume == "function";
                } };
              }, {}], 15: [function(I, E, C) {
                function c(_, j, V) {
                  var iA, eA = d.getTypeOf(j), oA = d.extend(V || {}, f);
                  oA.date = oA.date || /* @__PURE__ */ new Date(), oA.compression !== null && (oA.compression = oA.compression.toUpperCase()), typeof oA.unixPermissions == "string" && (oA.unixPermissions = parseInt(oA.unixPermissions, 8)), oA.unixPermissions && 16384 & oA.unixPermissions && (oA.dir = !0), oA.dosPermissions && 16 & oA.dosPermissions && (oA.dir = !0), oA.dir && (_ = k(_)), oA.createFolders && (iA = G(_)) && v.call(this, iA, !0);
                  var P = eA === "string" && oA.binary === !1 && oA.base64 === !1;
                  V && V.binary !== void 0 || (oA.binary = !P), (j instanceof S && j.uncompressedSize === 0 || oA.dir || !j || j.length === 0) && (oA.base64 = !1, oA.binary = !0, j = "", oA.compression = "STORE", eA = "string");
                  var J = null;
                  J = j instanceof S || j instanceof p ? j : N.isNode && N.isStream(j) ? new F(_, j) : d.prepareContent(_, j, oA.binary, oA.optimizedBinaryString, oA.base64);
                  var tA = new y(_, J, oA);
                  this.files[_] = tA;
                }
                var u = I("./utf8"), d = I("./utils"), p = I("./stream/GenericWorker"), D = I("./stream/StreamHelper"), f = I("./defaults"), S = I("./compressedObject"), y = I("./zipObject"), m = I("./generate"), N = I("./nodejsUtils"), F = I("./nodejs/NodejsStreamInputAdapter"), G = function(_) {
                  _.slice(-1) === "/" && (_ = _.substring(0, _.length - 1));
                  var j = _.lastIndexOf("/");
                  return 0 < j ? _.substring(0, j) : "";
                }, k = function(_) {
                  return _.slice(-1) !== "/" && (_ += "/"), _;
                }, v = function(_, j) {
                  return j = j !== void 0 ? j : f.createFolders, _ = k(_), this.files[_] || c.call(this, _, null, { dir: !0, createFolders: j }), this.files[_];
                };
                function x(_) {
                  return Object.prototype.toString.call(_) === "[object RegExp]";
                }
                var H = { load: function() {
                  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                }, forEach: function(_) {
                  var j, V, iA;
                  for (j in this.files)
                    iA = this.files[j], (V = j.slice(this.root.length, j.length)) && j.slice(0, this.root.length) === this.root && _(V, iA);
                }, filter: function(_) {
                  var j = [];
                  return this.forEach(function(V, iA) {
                    _(V, iA) && j.push(iA);
                  }), j;
                }, file: function(_, j, V) {
                  if (arguments.length !== 1)
                    return _ = this.root + _, c.call(this, _, j, V), this;
                  if (x(_)) {
                    var iA = _;
                    return this.filter(function(oA, P) {
                      return !P.dir && iA.test(oA);
                    });
                  }
                  var eA = this.files[this.root + _];
                  return eA && !eA.dir ? eA : null;
                }, folder: function(_) {
                  if (!_)
                    return this;
                  if (x(_))
                    return this.filter(function(eA, oA) {
                      return oA.dir && _.test(eA);
                    });
                  var j = this.root + _, V = v.call(this, j), iA = this.clone();
                  return iA.root = V.name, iA;
                }, remove: function(_) {
                  _ = this.root + _;
                  var j = this.files[_];
                  if (j || (_.slice(-1) !== "/" && (_ += "/"), j = this.files[_]), j && !j.dir)
                    delete this.files[_];
                  else
                    for (var V = this.filter(function(eA, oA) {
                      return oA.name.slice(0, _.length) === _;
                    }), iA = 0; iA < V.length; iA++)
                      delete this.files[V[iA].name];
                  return this;
                }, generate: function(_) {
                  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                }, generateInternalStream: function(_) {
                  var j, V = {};
                  try {
                    if ((V = d.extend(_ || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: u.utf8encode })).type = V.type.toLowerCase(), V.compression = V.compression.toUpperCase(), V.type === "binarystring" && (V.type = "string"), !V.type)
                      throw new Error("No output type specified.");
                    d.checkSupport(V.type), V.platform !== "darwin" && V.platform !== "freebsd" && V.platform !== "linux" && V.platform !== "sunos" || (V.platform = "UNIX"), V.platform === "win32" && (V.platform = "DOS");
                    var iA = V.comment || this.comment || "";
                    j = m.generateWorker(this, V, iA);
                  } catch (eA) {
                    (j = new p("error")).error(eA);
                  }
                  return new D(j, V.type || "string", V.mimeType);
                }, generateAsync: function(_, j) {
                  return this.generateInternalStream(_).accumulate(j);
                }, generateNodeStream: function(_, j) {
                  return (_ = _ || {}).type || (_.type = "nodebuffer"), this.generateInternalStream(_).toNodejsStream(j);
                } };
                E.exports = H;
              }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(I, E, C) {
                E.exports = I("stream");
              }, { stream: void 0 }], 17: [function(I, E, C) {
                var c = I("./DataReader");
                function u(d) {
                  c.call(this, d);
                  for (var p = 0; p < this.data.length; p++)
                    d[p] = 255 & d[p];
                }
                I("../utils").inherits(u, c), u.prototype.byteAt = function(d) {
                  return this.data[this.zero + d];
                }, u.prototype.lastIndexOfSignature = function(d) {
                  for (var p = d.charCodeAt(0), D = d.charCodeAt(1), f = d.charCodeAt(2), S = d.charCodeAt(3), y = this.length - 4; 0 <= y; --y)
                    if (this.data[y] === p && this.data[y + 1] === D && this.data[y + 2] === f && this.data[y + 3] === S)
                      return y - this.zero;
                  return -1;
                }, u.prototype.readAndCheckSignature = function(d) {
                  var p = d.charCodeAt(0), D = d.charCodeAt(1), f = d.charCodeAt(2), S = d.charCodeAt(3), y = this.readData(4);
                  return p === y[0] && D === y[1] && f === y[2] && S === y[3];
                }, u.prototype.readData = function(d) {
                  if (this.checkOffset(d), d === 0)
                    return [];
                  var p = this.data.slice(this.zero + this.index, this.zero + this.index + d);
                  return this.index += d, p;
                }, E.exports = u;
              }, { "../utils": 32, "./DataReader": 18 }], 18: [function(I, E, C) {
                var c = I("../utils");
                function u(d) {
                  this.data = d, this.length = d.length, this.index = 0, this.zero = 0;
                }
                u.prototype = { checkOffset: function(d) {
                  this.checkIndex(this.index + d);
                }, checkIndex: function(d) {
                  if (this.length < this.zero + d || d < 0)
                    throw new Error("End of data reached (data length = " + this.length + ", asked index = " + d + "). Corrupted zip ?");
                }, setIndex: function(d) {
                  this.checkIndex(d), this.index = d;
                }, skip: function(d) {
                  this.setIndex(this.index + d);
                }, byteAt: function(d) {
                }, readInt: function(d) {
                  var p, D = 0;
                  for (this.checkOffset(d), p = this.index + d - 1; p >= this.index; p--)
                    D = (D << 8) + this.byteAt(p);
                  return this.index += d, D;
                }, readString: function(d) {
                  return c.transformTo("string", this.readData(d));
                }, readData: function(d) {
                }, lastIndexOfSignature: function(d) {
                }, readAndCheckSignature: function(d) {
                }, readDate: function() {
                  var d = this.readInt(4);
                  return new Date(Date.UTC(1980 + (d >> 25 & 127), (d >> 21 & 15) - 1, d >> 16 & 31, d >> 11 & 31, d >> 5 & 63, (31 & d) << 1));
                } }, E.exports = u;
              }, { "../utils": 32 }], 19: [function(I, E, C) {
                var c = I("./Uint8ArrayReader");
                function u(d) {
                  c.call(this, d);
                }
                I("../utils").inherits(u, c), u.prototype.readData = function(d) {
                  this.checkOffset(d);
                  var p = this.data.slice(this.zero + this.index, this.zero + this.index + d);
                  return this.index += d, p;
                }, E.exports = u;
              }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(I, E, C) {
                var c = I("./DataReader");
                function u(d) {
                  c.call(this, d);
                }
                I("../utils").inherits(u, c), u.prototype.byteAt = function(d) {
                  return this.data.charCodeAt(this.zero + d);
                }, u.prototype.lastIndexOfSignature = function(d) {
                  return this.data.lastIndexOf(d) - this.zero;
                }, u.prototype.readAndCheckSignature = function(d) {
                  return d === this.readData(4);
                }, u.prototype.readData = function(d) {
                  this.checkOffset(d);
                  var p = this.data.slice(this.zero + this.index, this.zero + this.index + d);
                  return this.index += d, p;
                }, E.exports = u;
              }, { "../utils": 32, "./DataReader": 18 }], 21: [function(I, E, C) {
                var c = I("./ArrayReader");
                function u(d) {
                  c.call(this, d);
                }
                I("../utils").inherits(u, c), u.prototype.readData = function(d) {
                  if (this.checkOffset(d), d === 0)
                    return new Uint8Array(0);
                  var p = this.data.subarray(this.zero + this.index, this.zero + this.index + d);
                  return this.index += d, p;
                }, E.exports = u;
              }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(I, E, C) {
                var c = I("../utils"), u = I("../support"), d = I("./ArrayReader"), p = I("./StringReader"), D = I("./NodeBufferReader"), f = I("./Uint8ArrayReader");
                E.exports = function(S) {
                  var y = c.getTypeOf(S);
                  return c.checkSupport(y), y !== "string" || u.uint8array ? y === "nodebuffer" ? new D(S) : u.uint8array ? new f(c.transformTo("uint8array", S)) : new d(c.transformTo("array", S)) : new p(S);
                };
              }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(I, E, C) {
                C.LOCAL_FILE_HEADER = "PK", C.CENTRAL_FILE_HEADER = "PK", C.CENTRAL_DIRECTORY_END = "PK", C.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", C.ZIP64_CENTRAL_DIRECTORY_END = "PK", C.DATA_DESCRIPTOR = "PK\x07\b";
              }, {}], 24: [function(I, E, C) {
                var c = I("./GenericWorker"), u = I("../utils");
                function d(p) {
                  c.call(this, "ConvertWorker to " + p), this.destType = p;
                }
                u.inherits(d, c), d.prototype.processChunk = function(p) {
                  this.push({ data: u.transformTo(this.destType, p.data), meta: p.meta });
                }, E.exports = d;
              }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(I, E, C) {
                var c = I("./GenericWorker"), u = I("../crc32");
                function d() {
                  c.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
                }
                I("../utils").inherits(d, c), d.prototype.processChunk = function(p) {
                  this.streamInfo.crc32 = u(p.data, this.streamInfo.crc32 || 0), this.push(p);
                }, E.exports = d;
              }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(I, E, C) {
                var c = I("../utils"), u = I("./GenericWorker");
                function d(p) {
                  u.call(this, "DataLengthProbe for " + p), this.propName = p, this.withStreamInfo(p, 0);
                }
                c.inherits(d, u), d.prototype.processChunk = function(p) {
                  if (p) {
                    var D = this.streamInfo[this.propName] || 0;
                    this.streamInfo[this.propName] = D + p.data.length;
                  }
                  u.prototype.processChunk.call(this, p);
                }, E.exports = d;
              }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(I, E, C) {
                var c = I("../utils"), u = I("./GenericWorker");
                function d(p) {
                  u.call(this, "DataWorker");
                  var D = this;
                  this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, p.then(function(f) {
                    D.dataIsReady = !0, D.data = f, D.max = f && f.length || 0, D.type = c.getTypeOf(f), D.isPaused || D._tickAndRepeat();
                  }, function(f) {
                    D.error(f);
                  });
                }
                c.inherits(d, u), d.prototype.cleanUp = function() {
                  u.prototype.cleanUp.call(this), this.data = null;
                }, d.prototype.resume = function() {
                  return !!u.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, c.delay(this._tickAndRepeat, [], this)), !0);
                }, d.prototype._tickAndRepeat = function() {
                  this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (c.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
                }, d.prototype._tick = function() {
                  if (this.isPaused || this.isFinished)
                    return !1;
                  var p = null, D = Math.min(this.max, this.index + 16384);
                  if (this.index >= this.max)
                    return this.end();
                  switch (this.type) {
                    case "string":
                      p = this.data.substring(this.index, D);
                      break;
                    case "uint8array":
                      p = this.data.subarray(this.index, D);
                      break;
                    case "array":
                    case "nodebuffer":
                      p = this.data.slice(this.index, D);
                  }
                  return this.index = D, this.push({ data: p, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
                }, E.exports = d;
              }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(I, E, C) {
                function c(u) {
                  this.name = u || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
                }
                c.prototype = { push: function(u) {
                  this.emit("data", u);
                }, end: function() {
                  if (this.isFinished)
                    return !1;
                  this.flush();
                  try {
                    this.emit("end"), this.cleanUp(), this.isFinished = !0;
                  } catch (u) {
                    this.emit("error", u);
                  }
                  return !0;
                }, error: function(u) {
                  return !this.isFinished && (this.isPaused ? this.generatedError = u : (this.isFinished = !0, this.emit("error", u), this.previous && this.previous.error(u), this.cleanUp()), !0);
                }, on: function(u, d) {
                  return this._listeners[u].push(d), this;
                }, cleanUp: function() {
                  this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
                }, emit: function(u, d) {
                  if (this._listeners[u])
                    for (var p = 0; p < this._listeners[u].length; p++)
                      this._listeners[u][p].call(this, d);
                }, pipe: function(u) {
                  return u.registerPrevious(this);
                }, registerPrevious: function(u) {
                  if (this.isLocked)
                    throw new Error("The stream '" + this + "' has already been used.");
                  this.streamInfo = u.streamInfo, this.mergeStreamInfo(), this.previous = u;
                  var d = this;
                  return u.on("data", function(p) {
                    d.processChunk(p);
                  }), u.on("end", function() {
                    d.end();
                  }), u.on("error", function(p) {
                    d.error(p);
                  }), this;
                }, pause: function() {
                  return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
                }, resume: function() {
                  if (!this.isPaused || this.isFinished)
                    return !1;
                  var u = this.isPaused = !1;
                  return this.generatedError && (this.error(this.generatedError), u = !0), this.previous && this.previous.resume(), !u;
                }, flush: function() {
                }, processChunk: function(u) {
                  this.push(u);
                }, withStreamInfo: function(u, d) {
                  return this.extraStreamInfo[u] = d, this.mergeStreamInfo(), this;
                }, mergeStreamInfo: function() {
                  for (var u in this.extraStreamInfo)
                    this.extraStreamInfo.hasOwnProperty(u) && (this.streamInfo[u] = this.extraStreamInfo[u]);
                }, lock: function() {
                  if (this.isLocked)
                    throw new Error("The stream '" + this + "' has already been used.");
                  this.isLocked = !0, this.previous && this.previous.lock();
                }, toString: function() {
                  var u = "Worker " + this.name;
                  return this.previous ? this.previous + " -> " + u : u;
                } }, E.exports = c;
              }, {}], 29: [function(I, E, C) {
                var c = I("../utils"), u = I("./ConvertWorker"), d = I("./GenericWorker"), p = I("../base64"), D = I("../support"), f = I("../external"), S = null;
                if (D.nodestream)
                  try {
                    S = I("../nodejs/NodejsStreamOutputAdapter");
                  } catch {
                  }
                function y(N, F) {
                  return new f.Promise(function(G, k) {
                    var v = [], x = N._internalType, H = N._outputType, _ = N._mimeType;
                    N.on("data", function(j, V) {
                      v.push(j), F && F(V);
                    }).on("error", function(j) {
                      v = [], k(j);
                    }).on("end", function() {
                      try {
                        var j = function(V, iA, eA) {
                          switch (V) {
                            case "blob":
                              return c.newBlob(c.transformTo("arraybuffer", iA), eA);
                            case "base64":
                              return p.encode(iA);
                            default:
                              return c.transformTo(V, iA);
                          }
                        }(H, function(V, iA) {
                          var eA, oA = 0, P = null, J = 0;
                          for (eA = 0; eA < iA.length; eA++)
                            J += iA[eA].length;
                          switch (V) {
                            case "string":
                              return iA.join("");
                            case "array":
                              return Array.prototype.concat.apply([], iA);
                            case "uint8array":
                              for (P = new Uint8Array(J), eA = 0; eA < iA.length; eA++)
                                P.set(iA[eA], oA), oA += iA[eA].length;
                              return P;
                            case "nodebuffer":
                              return Buffer.concat(iA);
                            default:
                              throw new Error("concat : unsupported type '" + V + "'");
                          }
                        }(x, v), _);
                        G(j);
                      } catch (V) {
                        k(V);
                      }
                      v = [];
                    }).resume();
                  });
                }
                function m(N, F, G) {
                  var k = F;
                  switch (F) {
                    case "blob":
                    case "arraybuffer":
                      k = "uint8array";
                      break;
                    case "base64":
                      k = "string";
                  }
                  try {
                    this._internalType = k, this._outputType = F, this._mimeType = G, c.checkSupport(k), this._worker = N.pipe(new u(k)), N.lock();
                  } catch (v) {
                    this._worker = new d("error"), this._worker.error(v);
                  }
                }
                m.prototype = { accumulate: function(N) {
                  return y(this, N);
                }, on: function(N, F) {
                  var G = this;
                  return N === "data" ? this._worker.on(N, function(k) {
                    F.call(G, k.data, k.meta);
                  }) : this._worker.on(N, function() {
                    c.delay(F, arguments, G);
                  }), this;
                }, resume: function() {
                  return c.delay(this._worker.resume, [], this._worker), this;
                }, pause: function() {
                  return this._worker.pause(), this;
                }, toNodejsStream: function(N) {
                  if (c.checkSupport("nodestream"), this._outputType !== "nodebuffer")
                    throw new Error(this._outputType + " is not supported by this method");
                  return new S(this, { objectMode: this._outputType !== "nodebuffer" }, N);
                } }, E.exports = m;
              }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(I, E, C) {
                if (C.base64 = !0, C.array = !0, C.string = !0, C.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", C.nodebuffer = typeof Buffer < "u", C.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
                  C.blob = !1;
                else {
                  var c = new ArrayBuffer(0);
                  try {
                    C.blob = new Blob([c], { type: "application/zip" }).size === 0;
                  } catch {
                    try {
                      var u = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                      u.append(c), C.blob = u.getBlob("application/zip").size === 0;
                    } catch {
                      C.blob = !1;
                    }
                  }
                }
                try {
                  C.nodestream = !!I("readable-stream").Readable;
                } catch {
                  C.nodestream = !1;
                }
              }, { "readable-stream": 16 }], 31: [function(I, E, C) {
                for (var c = I("./utils"), u = I("./support"), d = I("./nodejsUtils"), p = I("./stream/GenericWorker"), D = new Array(256), f = 0; f < 256; f++)
                  D[f] = 252 <= f ? 6 : 248 <= f ? 5 : 240 <= f ? 4 : 224 <= f ? 3 : 192 <= f ? 2 : 1;
                D[254] = D[254] = 1;
                function S() {
                  p.call(this, "utf-8 decode"), this.leftOver = null;
                }
                function y() {
                  p.call(this, "utf-8 encode");
                }
                C.utf8encode = function(m) {
                  return u.nodebuffer ? d.newBufferFrom(m, "utf-8") : function(N) {
                    var F, G, k, v, x, H = N.length, _ = 0;
                    for (v = 0; v < H; v++)
                      (64512 & (G = N.charCodeAt(v))) == 55296 && v + 1 < H && (64512 & (k = N.charCodeAt(v + 1))) == 56320 && (G = 65536 + (G - 55296 << 10) + (k - 56320), v++), _ += G < 128 ? 1 : G < 2048 ? 2 : G < 65536 ? 3 : 4;
                    for (F = u.uint8array ? new Uint8Array(_) : new Array(_), v = x = 0; x < _; v++)
                      (64512 & (G = N.charCodeAt(v))) == 55296 && v + 1 < H && (64512 & (k = N.charCodeAt(v + 1))) == 56320 && (G = 65536 + (G - 55296 << 10) + (k - 56320), v++), G < 128 ? F[x++] = G : (G < 2048 ? F[x++] = 192 | G >>> 6 : (G < 65536 ? F[x++] = 224 | G >>> 12 : (F[x++] = 240 | G >>> 18, F[x++] = 128 | G >>> 12 & 63), F[x++] = 128 | G >>> 6 & 63), F[x++] = 128 | 63 & G);
                    return F;
                  }(m);
                }, C.utf8decode = function(m) {
                  return u.nodebuffer ? c.transformTo("nodebuffer", m).toString("utf-8") : function(N) {
                    var F, G, k, v, x = N.length, H = new Array(2 * x);
                    for (F = G = 0; F < x; )
                      if ((k = N[F++]) < 128)
                        H[G++] = k;
                      else if (4 < (v = D[k]))
                        H[G++] = 65533, F += v - 1;
                      else {
                        for (k &= v === 2 ? 31 : v === 3 ? 15 : 7; 1 < v && F < x; )
                          k = k << 6 | 63 & N[F++], v--;
                        1 < v ? H[G++] = 65533 : k < 65536 ? H[G++] = k : (k -= 65536, H[G++] = 55296 | k >> 10 & 1023, H[G++] = 56320 | 1023 & k);
                      }
                    return H.length !== G && (H.subarray ? H = H.subarray(0, G) : H.length = G), c.applyFromCharCode(H);
                  }(m = c.transformTo(u.uint8array ? "uint8array" : "array", m));
                }, c.inherits(S, p), S.prototype.processChunk = function(m) {
                  var N = c.transformTo(u.uint8array ? "uint8array" : "array", m.data);
                  if (this.leftOver && this.leftOver.length) {
                    if (u.uint8array) {
                      var F = N;
                      (N = new Uint8Array(F.length + this.leftOver.length)).set(this.leftOver, 0), N.set(F, this.leftOver.length);
                    } else
                      N = this.leftOver.concat(N);
                    this.leftOver = null;
                  }
                  var G = function(v, x) {
                    var H;
                    for ((x = x || v.length) > v.length && (x = v.length), H = x - 1; 0 <= H && (192 & v[H]) == 128; )
                      H--;
                    return H < 0 || H === 0 ? x : H + D[v[H]] > x ? H : x;
                  }(N), k = N;
                  G !== N.length && (u.uint8array ? (k = N.subarray(0, G), this.leftOver = N.subarray(G, N.length)) : (k = N.slice(0, G), this.leftOver = N.slice(G, N.length))), this.push({ data: C.utf8decode(k), meta: m.meta });
                }, S.prototype.flush = function() {
                  this.leftOver && this.leftOver.length && (this.push({ data: C.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
                }, C.Utf8DecodeWorker = S, c.inherits(y, p), y.prototype.processChunk = function(m) {
                  this.push({ data: C.utf8encode(m.data), meta: m.meta });
                }, C.Utf8EncodeWorker = y;
              }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(I, E, C) {
                var c = I("./support"), u = I("./base64"), d = I("./nodejsUtils"), p = I("set-immediate-shim"), D = I("./external");
                function f(G) {
                  return G;
                }
                function S(G, k) {
                  for (var v = 0; v < G.length; ++v)
                    k[v] = 255 & G.charCodeAt(v);
                  return k;
                }
                C.newBlob = function(G, k) {
                  C.checkSupport("blob");
                  try {
                    return new Blob([G], { type: k });
                  } catch {
                    try {
                      var v = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                      return v.append(G), v.getBlob(k);
                    } catch {
                      throw new Error("Bug : can't construct the Blob.");
                    }
                  }
                };
                var y = { stringifyByChunk: function(G, k, v) {
                  var x = [], H = 0, _ = G.length;
                  if (_ <= v)
                    return String.fromCharCode.apply(null, G);
                  for (; H < _; )
                    k === "array" || k === "nodebuffer" ? x.push(String.fromCharCode.apply(null, G.slice(H, Math.min(H + v, _)))) : x.push(String.fromCharCode.apply(null, G.subarray(H, Math.min(H + v, _)))), H += v;
                  return x.join("");
                }, stringifyByChar: function(G) {
                  for (var k = "", v = 0; v < G.length; v++)
                    k += String.fromCharCode(G[v]);
                  return k;
                }, applyCanBeUsed: { uint8array: function() {
                  try {
                    return c.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
                  } catch {
                    return !1;
                  }
                }(), nodebuffer: function() {
                  try {
                    return c.nodebuffer && String.fromCharCode.apply(null, d.allocBuffer(1)).length === 1;
                  } catch {
                    return !1;
                  }
                }() } };
                function m(G) {
                  var k = 65536, v = C.getTypeOf(G), x = !0;
                  if (v === "uint8array" ? x = y.applyCanBeUsed.uint8array : v === "nodebuffer" && (x = y.applyCanBeUsed.nodebuffer), x)
                    for (; 1 < k; )
                      try {
                        return y.stringifyByChunk(G, v, k);
                      } catch {
                        k = Math.floor(k / 2);
                      }
                  return y.stringifyByChar(G);
                }
                function N(G, k) {
                  for (var v = 0; v < G.length; v++)
                    k[v] = G[v];
                  return k;
                }
                C.applyFromCharCode = m;
                var F = {};
                F.string = { string: f, array: function(G) {
                  return S(G, new Array(G.length));
                }, arraybuffer: function(G) {
                  return F.string.uint8array(G).buffer;
                }, uint8array: function(G) {
                  return S(G, new Uint8Array(G.length));
                }, nodebuffer: function(G) {
                  return S(G, d.allocBuffer(G.length));
                } }, F.array = { string: m, array: f, arraybuffer: function(G) {
                  return new Uint8Array(G).buffer;
                }, uint8array: function(G) {
                  return new Uint8Array(G);
                }, nodebuffer: function(G) {
                  return d.newBufferFrom(G);
                } }, F.arraybuffer = { string: function(G) {
                  return m(new Uint8Array(G));
                }, array: function(G) {
                  return N(new Uint8Array(G), new Array(G.byteLength));
                }, arraybuffer: f, uint8array: function(G) {
                  return new Uint8Array(G);
                }, nodebuffer: function(G) {
                  return d.newBufferFrom(new Uint8Array(G));
                } }, F.uint8array = { string: m, array: function(G) {
                  return N(G, new Array(G.length));
                }, arraybuffer: function(G) {
                  return G.buffer;
                }, uint8array: f, nodebuffer: function(G) {
                  return d.newBufferFrom(G);
                } }, F.nodebuffer = { string: m, array: function(G) {
                  return N(G, new Array(G.length));
                }, arraybuffer: function(G) {
                  return F.nodebuffer.uint8array(G).buffer;
                }, uint8array: function(G) {
                  return N(G, new Uint8Array(G.length));
                }, nodebuffer: f }, C.transformTo = function(G, k) {
                  if (k = k || "", !G)
                    return k;
                  C.checkSupport(G);
                  var v = C.getTypeOf(k);
                  return F[v][G](k);
                }, C.getTypeOf = function(G) {
                  return typeof G == "string" ? "string" : Object.prototype.toString.call(G) === "[object Array]" ? "array" : c.nodebuffer && d.isBuffer(G) ? "nodebuffer" : c.uint8array && G instanceof Uint8Array ? "uint8array" : c.arraybuffer && G instanceof ArrayBuffer ? "arraybuffer" : void 0;
                }, C.checkSupport = function(G) {
                  if (!c[G.toLowerCase()])
                    throw new Error(G + " is not supported by this platform");
                }, C.MAX_VALUE_16BITS = 65535, C.MAX_VALUE_32BITS = -1, C.pretty = function(G) {
                  var k, v, x = "";
                  for (v = 0; v < (G || "").length; v++)
                    x += "\\x" + ((k = G.charCodeAt(v)) < 16 ? "0" : "") + k.toString(16).toUpperCase();
                  return x;
                }, C.delay = function(G, k, v) {
                  p(function() {
                    G.apply(v || null, k || []);
                  });
                }, C.inherits = function(G, k) {
                  function v() {
                  }
                  v.prototype = k.prototype, G.prototype = new v();
                }, C.extend = function() {
                  var G, k, v = {};
                  for (G = 0; G < arguments.length; G++)
                    for (k in arguments[G])
                      arguments[G].hasOwnProperty(k) && v[k] === void 0 && (v[k] = arguments[G][k]);
                  return v;
                }, C.prepareContent = function(G, k, v, x, H) {
                  return D.Promise.resolve(k).then(function(_) {
                    return c.blob && (_ instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(_)) !== -1) && typeof FileReader < "u" ? new D.Promise(function(j, V) {
                      var iA = new FileReader();
                      iA.onload = function(eA) {
                        j(eA.target.result);
                      }, iA.onerror = function(eA) {
                        V(eA.target.error);
                      }, iA.readAsArrayBuffer(_);
                    }) : _;
                  }).then(function(_) {
                    var j = C.getTypeOf(_);
                    return j ? (j === "arraybuffer" ? _ = C.transformTo("uint8array", _) : j === "string" && (H ? _ = u.decode(_) : v && x !== !0 && (_ = function(V) {
                      return S(V, c.uint8array ? new Uint8Array(V.length) : new Array(V.length));
                    }(_))), _) : D.Promise.reject(new Error("Can't read the data of '" + G + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
                  });
                };
              }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, "set-immediate-shim": 54 }], 33: [function(I, E, C) {
                var c = I("./reader/readerFor"), u = I("./utils"), d = I("./signature"), p = I("./zipEntry"), D = (I("./utf8"), I("./support"));
                function f(S) {
                  this.files = [], this.loadOptions = S;
                }
                f.prototype = { checkSignature: function(S) {
                  if (!this.reader.readAndCheckSignature(S)) {
                    this.reader.index -= 4;
                    var y = this.reader.readString(4);
                    throw new Error("Corrupted zip or bug: unexpected signature (" + u.pretty(y) + ", expected " + u.pretty(S) + ")");
                  }
                }, isSignature: function(S, y) {
                  var m = this.reader.index;
                  this.reader.setIndex(S);
                  var N = this.reader.readString(4) === y;
                  return this.reader.setIndex(m), N;
                }, readBlockEndOfCentral: function() {
                  this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
                  var S = this.reader.readData(this.zipCommentLength), y = D.uint8array ? "uint8array" : "array", m = u.transformTo(y, S);
                  this.zipComment = this.loadOptions.decodeFileName(m);
                }, readBlockZip64EndOfCentral: function() {
                  this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
                  for (var S, y, m, N = this.zip64EndOfCentralSize - 44; 0 < N; )
                    S = this.reader.readInt(2), y = this.reader.readInt(4), m = this.reader.readData(y), this.zip64ExtensibleData[S] = { id: S, length: y, value: m };
                }, readBlockZip64EndOfCentralLocator: function() {
                  if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
                    throw new Error("Multi-volumes zip are not supported");
                }, readLocalFiles: function() {
                  var S, y;
                  for (S = 0; S < this.files.length; S++)
                    y = this.files[S], this.reader.setIndex(y.localHeaderOffset), this.checkSignature(d.LOCAL_FILE_HEADER), y.readLocalPart(this.reader), y.handleUTF8(), y.processAttributes();
                }, readCentralDir: function() {
                  var S;
                  for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(d.CENTRAL_FILE_HEADER); )
                    (S = new p({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(S);
                  if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
                    throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
                }, readEndOfCentral: function() {
                  var S = this.reader.lastIndexOfSignature(d.CENTRAL_DIRECTORY_END);
                  if (S < 0)
                    throw this.isSignature(0, d.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
                  this.reader.setIndex(S);
                  var y = S;
                  if (this.checkSignature(d.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === u.MAX_VALUE_16BITS || this.diskWithCentralDirStart === u.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === u.MAX_VALUE_16BITS || this.centralDirRecords === u.MAX_VALUE_16BITS || this.centralDirSize === u.MAX_VALUE_32BITS || this.centralDirOffset === u.MAX_VALUE_32BITS) {
                    if (this.zip64 = !0, (S = this.reader.lastIndexOfSignature(d.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
                      throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                    if (this.reader.setIndex(S), this.checkSignature(d.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, d.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(d.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
                      throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                    this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(d.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
                  }
                  var m = this.centralDirOffset + this.centralDirSize;
                  this.zip64 && (m += 20, m += 12 + this.zip64EndOfCentralSize);
                  var N = y - m;
                  if (0 < N)
                    this.isSignature(y, d.CENTRAL_FILE_HEADER) || (this.reader.zero = N);
                  else if (N < 0)
                    throw new Error("Corrupted zip: missing " + Math.abs(N) + " bytes.");
                }, prepareReader: function(S) {
                  this.reader = c(S);
                }, load: function(S) {
                  this.prepareReader(S), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
                } }, E.exports = f;
              }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utf8": 31, "./utils": 32, "./zipEntry": 34 }], 34: [function(I, E, C) {
                var c = I("./reader/readerFor"), u = I("./utils"), d = I("./compressedObject"), p = I("./crc32"), D = I("./utf8"), f = I("./compressions"), S = I("./support");
                function y(m, N) {
                  this.options = m, this.loadOptions = N;
                }
                y.prototype = { isEncrypted: function() {
                  return (1 & this.bitFlag) == 1;
                }, useUTF8: function() {
                  return (2048 & this.bitFlag) == 2048;
                }, readLocalPart: function(m) {
                  var N, F;
                  if (m.skip(22), this.fileNameLength = m.readInt(2), F = m.readInt(2), this.fileName = m.readData(this.fileNameLength), m.skip(F), this.compressedSize === -1 || this.uncompressedSize === -1)
                    throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
                  if ((N = function(G) {
                    for (var k in f)
                      if (f.hasOwnProperty(k) && f[k].magic === G)
                        return f[k];
                    return null;
                  }(this.compressionMethod)) === null)
                    throw new Error("Corrupted zip : compression " + u.pretty(this.compressionMethod) + " unknown (inner file : " + u.transformTo("string", this.fileName) + ")");
                  this.decompressed = new d(this.compressedSize, this.uncompressedSize, this.crc32, N, m.readData(this.compressedSize));
                }, readCentralPart: function(m) {
                  this.versionMadeBy = m.readInt(2), m.skip(2), this.bitFlag = m.readInt(2), this.compressionMethod = m.readString(2), this.date = m.readDate(), this.crc32 = m.readInt(4), this.compressedSize = m.readInt(4), this.uncompressedSize = m.readInt(4);
                  var N = m.readInt(2);
                  if (this.extraFieldsLength = m.readInt(2), this.fileCommentLength = m.readInt(2), this.diskNumberStart = m.readInt(2), this.internalFileAttributes = m.readInt(2), this.externalFileAttributes = m.readInt(4), this.localHeaderOffset = m.readInt(4), this.isEncrypted())
                    throw new Error("Encrypted zip are not supported");
                  m.skip(N), this.readExtraFields(m), this.parseZIP64ExtraField(m), this.fileComment = m.readData(this.fileCommentLength);
                }, processAttributes: function() {
                  this.unixPermissions = null, this.dosPermissions = null;
                  var m = this.versionMadeBy >> 8;
                  this.dir = !!(16 & this.externalFileAttributes), m == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), m == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
                }, parseZIP64ExtraField: function(m) {
                  if (this.extraFields[1]) {
                    var N = c(this.extraFields[1].value);
                    this.uncompressedSize === u.MAX_VALUE_32BITS && (this.uncompressedSize = N.readInt(8)), this.compressedSize === u.MAX_VALUE_32BITS && (this.compressedSize = N.readInt(8)), this.localHeaderOffset === u.MAX_VALUE_32BITS && (this.localHeaderOffset = N.readInt(8)), this.diskNumberStart === u.MAX_VALUE_32BITS && (this.diskNumberStart = N.readInt(4));
                  }
                }, readExtraFields: function(m) {
                  var N, F, G, k = m.index + this.extraFieldsLength;
                  for (this.extraFields || (this.extraFields = {}); m.index + 4 < k; )
                    N = m.readInt(2), F = m.readInt(2), G = m.readData(F), this.extraFields[N] = { id: N, length: F, value: G };
                  m.setIndex(k);
                }, handleUTF8: function() {
                  var m = S.uint8array ? "uint8array" : "array";
                  if (this.useUTF8())
                    this.fileNameStr = D.utf8decode(this.fileName), this.fileCommentStr = D.utf8decode(this.fileComment);
                  else {
                    var N = this.findExtraFieldUnicodePath();
                    if (N !== null)
                      this.fileNameStr = N;
                    else {
                      var F = u.transformTo(m, this.fileName);
                      this.fileNameStr = this.loadOptions.decodeFileName(F);
                    }
                    var G = this.findExtraFieldUnicodeComment();
                    if (G !== null)
                      this.fileCommentStr = G;
                    else {
                      var k = u.transformTo(m, this.fileComment);
                      this.fileCommentStr = this.loadOptions.decodeFileName(k);
                    }
                  }
                }, findExtraFieldUnicodePath: function() {
                  var m = this.extraFields[28789];
                  if (m) {
                    var N = c(m.value);
                    return N.readInt(1) !== 1 || p(this.fileName) !== N.readInt(4) ? null : D.utf8decode(N.readData(m.length - 5));
                  }
                  return null;
                }, findExtraFieldUnicodeComment: function() {
                  var m = this.extraFields[25461];
                  if (m) {
                    var N = c(m.value);
                    return N.readInt(1) !== 1 || p(this.fileComment) !== N.readInt(4) ? null : D.utf8decode(N.readData(m.length - 5));
                  }
                  return null;
                } }, E.exports = y;
              }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(I, E, C) {
                function c(N, F, G) {
                  this.name = N, this.dir = G.dir, this.date = G.date, this.comment = G.comment, this.unixPermissions = G.unixPermissions, this.dosPermissions = G.dosPermissions, this._data = F, this._dataBinary = G.binary, this.options = { compression: G.compression, compressionOptions: G.compressionOptions };
                }
                var u = I("./stream/StreamHelper"), d = I("./stream/DataWorker"), p = I("./utf8"), D = I("./compressedObject"), f = I("./stream/GenericWorker");
                c.prototype = { internalStream: function(N) {
                  var F = null, G = "string";
                  try {
                    if (!N)
                      throw new Error("No output type specified.");
                    var k = (G = N.toLowerCase()) === "string" || G === "text";
                    G !== "binarystring" && G !== "text" || (G = "string"), F = this._decompressWorker();
                    var v = !this._dataBinary;
                    v && !k && (F = F.pipe(new p.Utf8EncodeWorker())), !v && k && (F = F.pipe(new p.Utf8DecodeWorker()));
                  } catch (x) {
                    (F = new f("error")).error(x);
                  }
                  return new u(F, G, "");
                }, async: function(N, F) {
                  return this.internalStream(N).accumulate(F);
                }, nodeStream: function(N, F) {
                  return this.internalStream(N || "nodebuffer").toNodejsStream(F);
                }, _compressWorker: function(N, F) {
                  if (this._data instanceof D && this._data.compression.magic === N.magic)
                    return this._data.getCompressedWorker();
                  var G = this._decompressWorker();
                  return this._dataBinary || (G = G.pipe(new p.Utf8EncodeWorker())), D.createWorkerFrom(G, N, F);
                }, _decompressWorker: function() {
                  return this._data instanceof D ? this._data.getContentWorker() : this._data instanceof f ? this._data : new d(this._data);
                } };
                for (var S = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], y = function() {
                  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                }, m = 0; m < S.length; m++)
                  c.prototype[S[m]] = y;
                E.exports = c;
              }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(I, E, C) {
                (function(c) {
                  var u, d, p = c.MutationObserver || c.WebKitMutationObserver;
                  if (p) {
                    var D = 0, f = new p(N), S = c.document.createTextNode("");
                    f.observe(S, { characterData: !0 }), u = function() {
                      S.data = D = ++D % 2;
                    };
                  } else if (c.setImmediate || c.MessageChannel === void 0)
                    u = "document" in c && "onreadystatechange" in c.document.createElement("script") ? function() {
                      var F = c.document.createElement("script");
                      F.onreadystatechange = function() {
                        N(), F.onreadystatechange = null, F.parentNode.removeChild(F), F = null;
                      }, c.document.documentElement.appendChild(F);
                    } : function() {
                      setTimeout(N, 0);
                    };
                  else {
                    var y = new c.MessageChannel();
                    y.port1.onmessage = N, u = function() {
                      y.port2.postMessage(0);
                    };
                  }
                  var m = [];
                  function N() {
                    var F, G;
                    d = !0;
                    for (var k = m.length; k; ) {
                      for (G = m, m = [], F = -1; ++F < k; )
                        G[F]();
                      k = m.length;
                    }
                    d = !1;
                  }
                  E.exports = function(F) {
                    m.push(F) !== 1 || d || u();
                  };
                }).call(this, typeof B.g < "u" ? B.g : typeof self < "u" ? self : typeof window < "u" ? window : {});
              }, {}], 37: [function(I, E, C) {
                var c = I("immediate");
                function u() {
                }
                var d = {}, p = ["REJECTED"], D = ["FULFILLED"], f = ["PENDING"];
                function S(k) {
                  if (typeof k != "function")
                    throw new TypeError("resolver must be a function");
                  this.state = f, this.queue = [], this.outcome = void 0, k !== u && F(this, k);
                }
                function y(k, v, x) {
                  this.promise = k, typeof v == "function" && (this.onFulfilled = v, this.callFulfilled = this.otherCallFulfilled), typeof x == "function" && (this.onRejected = x, this.callRejected = this.otherCallRejected);
                }
                function m(k, v, x) {
                  c(function() {
                    var H;
                    try {
                      H = v(x);
                    } catch (_) {
                      return d.reject(k, _);
                    }
                    H === k ? d.reject(k, new TypeError("Cannot resolve promise with itself")) : d.resolve(k, H);
                  });
                }
                function N(k) {
                  var v = k && k.then;
                  if (k && (typeof k == "object" || typeof k == "function") && typeof v == "function")
                    return function() {
                      v.apply(k, arguments);
                    };
                }
                function F(k, v) {
                  var x = !1;
                  function H(V) {
                    x || (x = !0, d.reject(k, V));
                  }
                  function _(V) {
                    x || (x = !0, d.resolve(k, V));
                  }
                  var j = G(function() {
                    v(_, H);
                  });
                  j.status === "error" && H(j.value);
                }
                function G(k, v) {
                  var x = {};
                  try {
                    x.value = k(v), x.status = "success";
                  } catch (H) {
                    x.status = "error", x.value = H;
                  }
                  return x;
                }
                (E.exports = S).prototype.finally = function(k) {
                  if (typeof k != "function")
                    return this;
                  var v = this.constructor;
                  return this.then(function(x) {
                    return v.resolve(k()).then(function() {
                      return x;
                    });
                  }, function(x) {
                    return v.resolve(k()).then(function() {
                      throw x;
                    });
                  });
                }, S.prototype.catch = function(k) {
                  return this.then(null, k);
                }, S.prototype.then = function(k, v) {
                  if (typeof k != "function" && this.state === D || typeof v != "function" && this.state === p)
                    return this;
                  var x = new this.constructor(u);
                  return this.state !== f ? m(x, this.state === D ? k : v, this.outcome) : this.queue.push(new y(x, k, v)), x;
                }, y.prototype.callFulfilled = function(k) {
                  d.resolve(this.promise, k);
                }, y.prototype.otherCallFulfilled = function(k) {
                  m(this.promise, this.onFulfilled, k);
                }, y.prototype.callRejected = function(k) {
                  d.reject(this.promise, k);
                }, y.prototype.otherCallRejected = function(k) {
                  m(this.promise, this.onRejected, k);
                }, d.resolve = function(k, v) {
                  var x = G(N, v);
                  if (x.status === "error")
                    return d.reject(k, x.value);
                  var H = x.value;
                  if (H)
                    F(k, H);
                  else {
                    k.state = D, k.outcome = v;
                    for (var _ = -1, j = k.queue.length; ++_ < j; )
                      k.queue[_].callFulfilled(v);
                  }
                  return k;
                }, d.reject = function(k, v) {
                  k.state = p, k.outcome = v;
                  for (var x = -1, H = k.queue.length; ++x < H; )
                    k.queue[x].callRejected(v);
                  return k;
                }, S.resolve = function(k) {
                  return k instanceof this ? k : d.resolve(new this(u), k);
                }, S.reject = function(k) {
                  var v = new this(u);
                  return d.reject(v, k);
                }, S.all = function(k) {
                  var v = this;
                  if (Object.prototype.toString.call(k) !== "[object Array]")
                    return this.reject(new TypeError("must be an array"));
                  var x = k.length, H = !1;
                  if (!x)
                    return this.resolve([]);
                  for (var _ = new Array(x), j = 0, V = -1, iA = new this(u); ++V < x; )
                    eA(k[V], V);
                  return iA;
                  function eA(oA, P) {
                    v.resolve(oA).then(function(J) {
                      _[P] = J, ++j !== x || H || (H = !0, d.resolve(iA, _));
                    }, function(J) {
                      H || (H = !0, d.reject(iA, J));
                    });
                  }
                }, S.race = function(k) {
                  var v = this;
                  if (Object.prototype.toString.call(k) !== "[object Array]")
                    return this.reject(new TypeError("must be an array"));
                  var x = k.length, H = !1;
                  if (!x)
                    return this.resolve([]);
                  for (var _ = -1, j = new this(u); ++_ < x; )
                    V = k[_], v.resolve(V).then(function(iA) {
                      H || (H = !0, d.resolve(j, iA));
                    }, function(iA) {
                      H || (H = !0, d.reject(j, iA));
                    });
                  var V;
                  return j;
                };
              }, { immediate: 36 }], 38: [function(I, E, C) {
                var c = {};
                (0, I("./lib/utils/common").assign)(c, I("./lib/deflate"), I("./lib/inflate"), I("./lib/zlib/constants")), E.exports = c;
              }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(I, E, C) {
                var c = I("./zlib/deflate"), u = I("./utils/common"), d = I("./utils/strings"), p = I("./zlib/messages"), D = I("./zlib/zstream"), f = Object.prototype.toString, S = 0, y = -1, m = 0, N = 8;
                function F(k) {
                  if (!(this instanceof F))
                    return new F(k);
                  this.options = u.assign({ level: y, method: N, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: m, to: "" }, k || {});
                  var v = this.options;
                  v.raw && 0 < v.windowBits ? v.windowBits = -v.windowBits : v.gzip && 0 < v.windowBits && v.windowBits < 16 && (v.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new D(), this.strm.avail_out = 0;
                  var x = c.deflateInit2(this.strm, v.level, v.method, v.windowBits, v.memLevel, v.strategy);
                  if (x !== S)
                    throw new Error(p[x]);
                  if (v.header && c.deflateSetHeader(this.strm, v.header), v.dictionary) {
                    var H;
                    if (H = typeof v.dictionary == "string" ? d.string2buf(v.dictionary) : f.call(v.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(v.dictionary) : v.dictionary, (x = c.deflateSetDictionary(this.strm, H)) !== S)
                      throw new Error(p[x]);
                    this._dict_set = !0;
                  }
                }
                function G(k, v) {
                  var x = new F(v);
                  if (x.push(k, !0), x.err)
                    throw x.msg || p[x.err];
                  return x.result;
                }
                F.prototype.push = function(k, v) {
                  var x, H, _ = this.strm, j = this.options.chunkSize;
                  if (this.ended)
                    return !1;
                  H = v === ~~v ? v : v === !0 ? 4 : 0, typeof k == "string" ? _.input = d.string2buf(k) : f.call(k) === "[object ArrayBuffer]" ? _.input = new Uint8Array(k) : _.input = k, _.next_in = 0, _.avail_in = _.input.length;
                  do {
                    if (_.avail_out === 0 && (_.output = new u.Buf8(j), _.next_out = 0, _.avail_out = j), (x = c.deflate(_, H)) !== 1 && x !== S)
                      return this.onEnd(x), !(this.ended = !0);
                    _.avail_out !== 0 && (_.avail_in !== 0 || H !== 4 && H !== 2) || (this.options.to === "string" ? this.onData(d.buf2binstring(u.shrinkBuf(_.output, _.next_out))) : this.onData(u.shrinkBuf(_.output, _.next_out)));
                  } while ((0 < _.avail_in || _.avail_out === 0) && x !== 1);
                  return H === 4 ? (x = c.deflateEnd(this.strm), this.onEnd(x), this.ended = !0, x === S) : H !== 2 || (this.onEnd(S), !(_.avail_out = 0));
                }, F.prototype.onData = function(k) {
                  this.chunks.push(k);
                }, F.prototype.onEnd = function(k) {
                  k === S && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = u.flattenChunks(this.chunks)), this.chunks = [], this.err = k, this.msg = this.strm.msg;
                }, C.Deflate = F, C.deflate = G, C.deflateRaw = function(k, v) {
                  return (v = v || {}).raw = !0, G(k, v);
                }, C.gzip = function(k, v) {
                  return (v = v || {}).gzip = !0, G(k, v);
                };
              }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(I, E, C) {
                var c = I("./zlib/inflate"), u = I("./utils/common"), d = I("./utils/strings"), p = I("./zlib/constants"), D = I("./zlib/messages"), f = I("./zlib/zstream"), S = I("./zlib/gzheader"), y = Object.prototype.toString;
                function m(F) {
                  if (!(this instanceof m))
                    return new m(F);
                  this.options = u.assign({ chunkSize: 16384, windowBits: 0, to: "" }, F || {});
                  var G = this.options;
                  G.raw && 0 <= G.windowBits && G.windowBits < 16 && (G.windowBits = -G.windowBits, G.windowBits === 0 && (G.windowBits = -15)), !(0 <= G.windowBits && G.windowBits < 16) || F && F.windowBits || (G.windowBits += 32), 15 < G.windowBits && G.windowBits < 48 && !(15 & G.windowBits) && (G.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new f(), this.strm.avail_out = 0;
                  var k = c.inflateInit2(this.strm, G.windowBits);
                  if (k !== p.Z_OK)
                    throw new Error(D[k]);
                  this.header = new S(), c.inflateGetHeader(this.strm, this.header);
                }
                function N(F, G) {
                  var k = new m(G);
                  if (k.push(F, !0), k.err)
                    throw k.msg || D[k.err];
                  return k.result;
                }
                m.prototype.push = function(F, G) {
                  var k, v, x, H, _, j, V = this.strm, iA = this.options.chunkSize, eA = this.options.dictionary, oA = !1;
                  if (this.ended)
                    return !1;
                  v = G === ~~G ? G : G === !0 ? p.Z_FINISH : p.Z_NO_FLUSH, typeof F == "string" ? V.input = d.binstring2buf(F) : y.call(F) === "[object ArrayBuffer]" ? V.input = new Uint8Array(F) : V.input = F, V.next_in = 0, V.avail_in = V.input.length;
                  do {
                    if (V.avail_out === 0 && (V.output = new u.Buf8(iA), V.next_out = 0, V.avail_out = iA), (k = c.inflate(V, p.Z_NO_FLUSH)) === p.Z_NEED_DICT && eA && (j = typeof eA == "string" ? d.string2buf(eA) : y.call(eA) === "[object ArrayBuffer]" ? new Uint8Array(eA) : eA, k = c.inflateSetDictionary(this.strm, j)), k === p.Z_BUF_ERROR && oA === !0 && (k = p.Z_OK, oA = !1), k !== p.Z_STREAM_END && k !== p.Z_OK)
                      return this.onEnd(k), !(this.ended = !0);
                    V.next_out && (V.avail_out !== 0 && k !== p.Z_STREAM_END && (V.avail_in !== 0 || v !== p.Z_FINISH && v !== p.Z_SYNC_FLUSH) || (this.options.to === "string" ? (x = d.utf8border(V.output, V.next_out), H = V.next_out - x, _ = d.buf2string(V.output, x), V.next_out = H, V.avail_out = iA - H, H && u.arraySet(V.output, V.output, x, H, 0), this.onData(_)) : this.onData(u.shrinkBuf(V.output, V.next_out)))), V.avail_in === 0 && V.avail_out === 0 && (oA = !0);
                  } while ((0 < V.avail_in || V.avail_out === 0) && k !== p.Z_STREAM_END);
                  return k === p.Z_STREAM_END && (v = p.Z_FINISH), v === p.Z_FINISH ? (k = c.inflateEnd(this.strm), this.onEnd(k), this.ended = !0, k === p.Z_OK) : v !== p.Z_SYNC_FLUSH || (this.onEnd(p.Z_OK), !(V.avail_out = 0));
                }, m.prototype.onData = function(F) {
                  this.chunks.push(F);
                }, m.prototype.onEnd = function(F) {
                  F === p.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = u.flattenChunks(this.chunks)), this.chunks = [], this.err = F, this.msg = this.strm.msg;
                }, C.Inflate = m, C.inflate = N, C.inflateRaw = function(F, G) {
                  return (G = G || {}).raw = !0, N(F, G);
                }, C.ungzip = N;
              }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(I, E, C) {
                var c = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
                C.assign = function(p) {
                  for (var D = Array.prototype.slice.call(arguments, 1); D.length; ) {
                    var f = D.shift();
                    if (f) {
                      if (typeof f != "object")
                        throw new TypeError(f + "must be non-object");
                      for (var S in f)
                        f.hasOwnProperty(S) && (p[S] = f[S]);
                    }
                  }
                  return p;
                }, C.shrinkBuf = function(p, D) {
                  return p.length === D ? p : p.subarray ? p.subarray(0, D) : (p.length = D, p);
                };
                var u = { arraySet: function(p, D, f, S, y) {
                  if (D.subarray && p.subarray)
                    p.set(D.subarray(f, f + S), y);
                  else
                    for (var m = 0; m < S; m++)
                      p[y + m] = D[f + m];
                }, flattenChunks: function(p) {
                  var D, f, S, y, m, N;
                  for (D = S = 0, f = p.length; D < f; D++)
                    S += p[D].length;
                  for (N = new Uint8Array(S), D = y = 0, f = p.length; D < f; D++)
                    m = p[D], N.set(m, y), y += m.length;
                  return N;
                } }, d = { arraySet: function(p, D, f, S, y) {
                  for (var m = 0; m < S; m++)
                    p[y + m] = D[f + m];
                }, flattenChunks: function(p) {
                  return [].concat.apply([], p);
                } };
                C.setTyped = function(p) {
                  p ? (C.Buf8 = Uint8Array, C.Buf16 = Uint16Array, C.Buf32 = Int32Array, C.assign(C, u)) : (C.Buf8 = Array, C.Buf16 = Array, C.Buf32 = Array, C.assign(C, d));
                }, C.setTyped(c);
              }, {}], 42: [function(I, E, C) {
                var c = I("./common"), u = !0, d = !0;
                try {
                  String.fromCharCode.apply(null, [0]);
                } catch {
                  u = !1;
                }
                try {
                  String.fromCharCode.apply(null, new Uint8Array(1));
                } catch {
                  d = !1;
                }
                for (var p = new c.Buf8(256), D = 0; D < 256; D++)
                  p[D] = 252 <= D ? 6 : 248 <= D ? 5 : 240 <= D ? 4 : 224 <= D ? 3 : 192 <= D ? 2 : 1;
                function f(S, y) {
                  if (y < 65537 && (S.subarray && d || !S.subarray && u))
                    return String.fromCharCode.apply(null, c.shrinkBuf(S, y));
                  for (var m = "", N = 0; N < y; N++)
                    m += String.fromCharCode(S[N]);
                  return m;
                }
                p[254] = p[254] = 1, C.string2buf = function(S) {
                  var y, m, N, F, G, k = S.length, v = 0;
                  for (F = 0; F < k; F++)
                    (64512 & (m = S.charCodeAt(F))) == 55296 && F + 1 < k && (64512 & (N = S.charCodeAt(F + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (N - 56320), F++), v += m < 128 ? 1 : m < 2048 ? 2 : m < 65536 ? 3 : 4;
                  for (y = new c.Buf8(v), F = G = 0; G < v; F++)
                    (64512 & (m = S.charCodeAt(F))) == 55296 && F + 1 < k && (64512 & (N = S.charCodeAt(F + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (N - 56320), F++), m < 128 ? y[G++] = m : (m < 2048 ? y[G++] = 192 | m >>> 6 : (m < 65536 ? y[G++] = 224 | m >>> 12 : (y[G++] = 240 | m >>> 18, y[G++] = 128 | m >>> 12 & 63), y[G++] = 128 | m >>> 6 & 63), y[G++] = 128 | 63 & m);
                  return y;
                }, C.buf2binstring = function(S) {
                  return f(S, S.length);
                }, C.binstring2buf = function(S) {
                  for (var y = new c.Buf8(S.length), m = 0, N = y.length; m < N; m++)
                    y[m] = S.charCodeAt(m);
                  return y;
                }, C.buf2string = function(S, y) {
                  var m, N, F, G, k = y || S.length, v = new Array(2 * k);
                  for (m = N = 0; m < k; )
                    if ((F = S[m++]) < 128)
                      v[N++] = F;
                    else if (4 < (G = p[F]))
                      v[N++] = 65533, m += G - 1;
                    else {
                      for (F &= G === 2 ? 31 : G === 3 ? 15 : 7; 1 < G && m < k; )
                        F = F << 6 | 63 & S[m++], G--;
                      1 < G ? v[N++] = 65533 : F < 65536 ? v[N++] = F : (F -= 65536, v[N++] = 55296 | F >> 10 & 1023, v[N++] = 56320 | 1023 & F);
                    }
                  return f(v, N);
                }, C.utf8border = function(S, y) {
                  var m;
                  for ((y = y || S.length) > S.length && (y = S.length), m = y - 1; 0 <= m && (192 & S[m]) == 128; )
                    m--;
                  return m < 0 || m === 0 ? y : m + p[S[m]] > y ? m : y;
                };
              }, { "./common": 41 }], 43: [function(I, E, C) {
                E.exports = function(c, u, d, p) {
                  for (var D = 65535 & c | 0, f = c >>> 16 & 65535 | 0, S = 0; d !== 0; ) {
                    for (d -= S = 2e3 < d ? 2e3 : d; f = f + (D = D + u[p++] | 0) | 0, --S; )
                      ;
                    D %= 65521, f %= 65521;
                  }
                  return D | f << 16 | 0;
                };
              }, {}], 44: [function(I, E, C) {
                E.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
              }, {}], 45: [function(I, E, C) {
                var c = function() {
                  for (var u, d = [], p = 0; p < 256; p++) {
                    u = p;
                    for (var D = 0; D < 8; D++)
                      u = 1 & u ? 3988292384 ^ u >>> 1 : u >>> 1;
                    d[p] = u;
                  }
                  return d;
                }();
                E.exports = function(u, d, p, D) {
                  var f = c, S = D + p;
                  u ^= -1;
                  for (var y = D; y < S; y++)
                    u = u >>> 8 ^ f[255 & (u ^ d[y])];
                  return -1 ^ u;
                };
              }, {}], 46: [function(I, E, C) {
                var c, u = I("../utils/common"), d = I("./trees"), p = I("./adler32"), D = I("./crc32"), f = I("./messages"), S = 0, y = 4, m = 0, N = -2, F = -1, G = 4, k = 2, v = 8, x = 9, H = 286, _ = 30, j = 19, V = 2 * H + 1, iA = 15, eA = 3, oA = 258, P = oA + eA + 1, J = 42, tA = 113, Y = 1, rA = 2, QA = 3, aA = 4;
                function MA(O, AA) {
                  return O.msg = f[AA], AA;
                }
                function hA(O) {
                  return (O << 1) - (4 < O ? 9 : 0);
                }
                function fA(O) {
                  for (var AA = O.length; 0 <= --AA; )
                    O[AA] = 0;
                }
                function wA(O) {
                  var AA = O.state, q = AA.pending;
                  q > O.avail_out && (q = O.avail_out), q !== 0 && (u.arraySet(O.output, AA.pending_buf, AA.pending_out, q, O.next_out), O.next_out += q, AA.pending_out += q, O.total_out += q, O.avail_out -= q, AA.pending -= q, AA.pending === 0 && (AA.pending_out = 0));
                }
                function yA(O, AA) {
                  d._tr_flush_block(O, 0 <= O.block_start ? O.block_start : -1, O.strstart - O.block_start, AA), O.block_start = O.strstart, wA(O.strm);
                }
                function kA(O, AA) {
                  O.pending_buf[O.pending++] = AA;
                }
                function FA(O, AA) {
                  O.pending_buf[O.pending++] = AA >>> 8 & 255, O.pending_buf[O.pending++] = 255 & AA;
                }
                function dA(O, AA) {
                  var q, Z, $ = O.max_chain_length, BA = O.strstart, GA = O.prev_length, bA = O.nice_match, DA = O.strstart > O.w_size - P ? O.strstart - (O.w_size - P) : 0, SA = O.window, EA = O.w_mask, mA = O.prev, YA = O.strstart + oA, ZA = SA[BA + GA - 1], _A = SA[BA + GA];
                  O.prev_length >= O.good_match && ($ >>= 2), bA > O.lookahead && (bA = O.lookahead);
                  do
                    if (SA[(q = AA) + GA] === _A && SA[q + GA - 1] === ZA && SA[q] === SA[BA] && SA[++q] === SA[BA + 1]) {
                      BA += 2, q++;
                      do
                        ;
                      while (SA[++BA] === SA[++q] && SA[++BA] === SA[++q] && SA[++BA] === SA[++q] && SA[++BA] === SA[++q] && SA[++BA] === SA[++q] && SA[++BA] === SA[++q] && SA[++BA] === SA[++q] && SA[++BA] === SA[++q] && BA < YA);
                      if (Z = oA - (YA - BA), BA = YA - oA, GA < Z) {
                        if (O.match_start = AA, bA <= (GA = Z))
                          break;
                        ZA = SA[BA + GA - 1], _A = SA[BA + GA];
                      }
                    }
                  while ((AA = mA[AA & EA]) > DA && --$ != 0);
                  return GA <= O.lookahead ? GA : O.lookahead;
                }
                function vA(O) {
                  var AA, q, Z, $, BA, GA, bA, DA, SA, EA, mA = O.w_size;
                  do {
                    if ($ = O.window_size - O.lookahead - O.strstart, O.strstart >= mA + (mA - P)) {
                      for (u.arraySet(O.window, O.window, mA, mA, 0), O.match_start -= mA, O.strstart -= mA, O.block_start -= mA, AA = q = O.hash_size; Z = O.head[--AA], O.head[AA] = mA <= Z ? Z - mA : 0, --q; )
                        ;
                      for (AA = q = mA; Z = O.prev[--AA], O.prev[AA] = mA <= Z ? Z - mA : 0, --q; )
                        ;
                      $ += mA;
                    }
                    if (O.strm.avail_in === 0)
                      break;
                    if (GA = O.strm, bA = O.window, DA = O.strstart + O.lookahead, SA = $, EA = void 0, EA = GA.avail_in, SA < EA && (EA = SA), q = EA === 0 ? 0 : (GA.avail_in -= EA, u.arraySet(bA, GA.input, GA.next_in, EA, DA), GA.state.wrap === 1 ? GA.adler = p(GA.adler, bA, EA, DA) : GA.state.wrap === 2 && (GA.adler = D(GA.adler, bA, EA, DA)), GA.next_in += EA, GA.total_in += EA, EA), O.lookahead += q, O.lookahead + O.insert >= eA)
                      for (BA = O.strstart - O.insert, O.ins_h = O.window[BA], O.ins_h = (O.ins_h << O.hash_shift ^ O.window[BA + 1]) & O.hash_mask; O.insert && (O.ins_h = (O.ins_h << O.hash_shift ^ O.window[BA + eA - 1]) & O.hash_mask, O.prev[BA & O.w_mask] = O.head[O.ins_h], O.head[O.ins_h] = BA, BA++, O.insert--, !(O.lookahead + O.insert < eA)); )
                        ;
                  } while (O.lookahead < P && O.strm.avail_in !== 0);
                }
                function JA(O, AA) {
                  for (var q, Z; ; ) {
                    if (O.lookahead < P) {
                      if (vA(O), O.lookahead < P && AA === S)
                        return Y;
                      if (O.lookahead === 0)
                        break;
                    }
                    if (q = 0, O.lookahead >= eA && (O.ins_h = (O.ins_h << O.hash_shift ^ O.window[O.strstart + eA - 1]) & O.hash_mask, q = O.prev[O.strstart & O.w_mask] = O.head[O.ins_h], O.head[O.ins_h] = O.strstart), q !== 0 && O.strstart - q <= O.w_size - P && (O.match_length = dA(O, q)), O.match_length >= eA)
                      if (Z = d._tr_tally(O, O.strstart - O.match_start, O.match_length - eA), O.lookahead -= O.match_length, O.match_length <= O.max_lazy_match && O.lookahead >= eA) {
                        for (O.match_length--; O.strstart++, O.ins_h = (O.ins_h << O.hash_shift ^ O.window[O.strstart + eA - 1]) & O.hash_mask, q = O.prev[O.strstart & O.w_mask] = O.head[O.ins_h], O.head[O.ins_h] = O.strstart, --O.match_length != 0; )
                          ;
                        O.strstart++;
                      } else
                        O.strstart += O.match_length, O.match_length = 0, O.ins_h = O.window[O.strstart], O.ins_h = (O.ins_h << O.hash_shift ^ O.window[O.strstart + 1]) & O.hash_mask;
                    else
                      Z = d._tr_tally(O, 0, O.window[O.strstart]), O.lookahead--, O.strstart++;
                    if (Z && (yA(O, !1), O.strm.avail_out === 0))
                      return Y;
                  }
                  return O.insert = O.strstart < eA - 1 ? O.strstart : eA - 1, AA === y ? (yA(O, !0), O.strm.avail_out === 0 ? QA : aA) : O.last_lit && (yA(O, !1), O.strm.avail_out === 0) ? Y : rA;
                }
                function ne(O, AA) {
                  for (var q, Z, $; ; ) {
                    if (O.lookahead < P) {
                      if (vA(O), O.lookahead < P && AA === S)
                        return Y;
                      if (O.lookahead === 0)
                        break;
                    }
                    if (q = 0, O.lookahead >= eA && (O.ins_h = (O.ins_h << O.hash_shift ^ O.window[O.strstart + eA - 1]) & O.hash_mask, q = O.prev[O.strstart & O.w_mask] = O.head[O.ins_h], O.head[O.ins_h] = O.strstart), O.prev_length = O.match_length, O.prev_match = O.match_start, O.match_length = eA - 1, q !== 0 && O.prev_length < O.max_lazy_match && O.strstart - q <= O.w_size - P && (O.match_length = dA(O, q), O.match_length <= 5 && (O.strategy === 1 || O.match_length === eA && 4096 < O.strstart - O.match_start) && (O.match_length = eA - 1)), O.prev_length >= eA && O.match_length <= O.prev_length) {
                      for ($ = O.strstart + O.lookahead - eA, Z = d._tr_tally(O, O.strstart - 1 - O.prev_match, O.prev_length - eA), O.lookahead -= O.prev_length - 1, O.prev_length -= 2; ++O.strstart <= $ && (O.ins_h = (O.ins_h << O.hash_shift ^ O.window[O.strstart + eA - 1]) & O.hash_mask, q = O.prev[O.strstart & O.w_mask] = O.head[O.ins_h], O.head[O.ins_h] = O.strstart), --O.prev_length != 0; )
                        ;
                      if (O.match_available = 0, O.match_length = eA - 1, O.strstart++, Z && (yA(O, !1), O.strm.avail_out === 0))
                        return Y;
                    } else if (O.match_available) {
                      if ((Z = d._tr_tally(O, 0, O.window[O.strstart - 1])) && yA(O, !1), O.strstart++, O.lookahead--, O.strm.avail_out === 0)
                        return Y;
                    } else
                      O.match_available = 1, O.strstart++, O.lookahead--;
                  }
                  return O.match_available && (Z = d._tr_tally(O, 0, O.window[O.strstart - 1]), O.match_available = 0), O.insert = O.strstart < eA - 1 ? O.strstart : eA - 1, AA === y ? (yA(O, !0), O.strm.avail_out === 0 ? QA : aA) : O.last_lit && (yA(O, !1), O.strm.avail_out === 0) ? Y : rA;
                }
                function ee(O, AA, q, Z, $) {
                  this.good_length = O, this.max_lazy = AA, this.nice_length = q, this.max_chain = Z, this.func = $;
                }
                function pe() {
                  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new u.Buf16(2 * V), this.dyn_dtree = new u.Buf16(2 * (2 * _ + 1)), this.bl_tree = new u.Buf16(2 * (2 * j + 1)), fA(this.dyn_ltree), fA(this.dyn_dtree), fA(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new u.Buf16(iA + 1), this.heap = new u.Buf16(2 * H + 1), fA(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new u.Buf16(2 * H + 1), fA(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
                }
                function Ae(O) {
                  var AA;
                  return O && O.state ? (O.total_in = O.total_out = 0, O.data_type = k, (AA = O.state).pending = 0, AA.pending_out = 0, AA.wrap < 0 && (AA.wrap = -AA.wrap), AA.status = AA.wrap ? J : tA, O.adler = AA.wrap === 2 ? 0 : 1, AA.last_flush = S, d._tr_init(AA), m) : MA(O, N);
                }
                function ie(O) {
                  var AA = Ae(O);
                  return AA === m && function(q) {
                    q.window_size = 2 * q.w_size, fA(q.head), q.max_lazy_match = c[q.level].max_lazy, q.good_match = c[q.level].good_length, q.nice_match = c[q.level].nice_length, q.max_chain_length = c[q.level].max_chain, q.strstart = 0, q.block_start = 0, q.lookahead = 0, q.insert = 0, q.match_length = q.prev_length = eA - 1, q.match_available = 0, q.ins_h = 0;
                  }(O.state), AA;
                }
                function de(O, AA, q, Z, $, BA) {
                  if (!O)
                    return N;
                  var GA = 1;
                  if (AA === F && (AA = 6), Z < 0 ? (GA = 0, Z = -Z) : 15 < Z && (GA = 2, Z -= 16), $ < 1 || x < $ || q !== v || Z < 8 || 15 < Z || AA < 0 || 9 < AA || BA < 0 || G < BA)
                    return MA(O, N);
                  Z === 8 && (Z = 9);
                  var bA = new pe();
                  return (O.state = bA).strm = O, bA.wrap = GA, bA.gzhead = null, bA.w_bits = Z, bA.w_size = 1 << bA.w_bits, bA.w_mask = bA.w_size - 1, bA.hash_bits = $ + 7, bA.hash_size = 1 << bA.hash_bits, bA.hash_mask = bA.hash_size - 1, bA.hash_shift = ~~((bA.hash_bits + eA - 1) / eA), bA.window = new u.Buf8(2 * bA.w_size), bA.head = new u.Buf16(bA.hash_size), bA.prev = new u.Buf16(bA.w_size), bA.lit_bufsize = 1 << $ + 6, bA.pending_buf_size = 4 * bA.lit_bufsize, bA.pending_buf = new u.Buf8(bA.pending_buf_size), bA.d_buf = 1 * bA.lit_bufsize, bA.l_buf = 3 * bA.lit_bufsize, bA.level = AA, bA.strategy = BA, bA.method = q, ie(O);
                }
                c = [new ee(0, 0, 0, 0, function(O, AA) {
                  var q = 65535;
                  for (q > O.pending_buf_size - 5 && (q = O.pending_buf_size - 5); ; ) {
                    if (O.lookahead <= 1) {
                      if (vA(O), O.lookahead === 0 && AA === S)
                        return Y;
                      if (O.lookahead === 0)
                        break;
                    }
                    O.strstart += O.lookahead, O.lookahead = 0;
                    var Z = O.block_start + q;
                    if ((O.strstart === 0 || O.strstart >= Z) && (O.lookahead = O.strstart - Z, O.strstart = Z, yA(O, !1), O.strm.avail_out === 0) || O.strstart - O.block_start >= O.w_size - P && (yA(O, !1), O.strm.avail_out === 0))
                      return Y;
                  }
                  return O.insert = 0, AA === y ? (yA(O, !0), O.strm.avail_out === 0 ? QA : aA) : (O.strstart > O.block_start && (yA(O, !1), O.strm.avail_out), Y);
                }), new ee(4, 4, 8, 4, JA), new ee(4, 5, 16, 8, JA), new ee(4, 6, 32, 32, JA), new ee(4, 4, 16, 16, ne), new ee(8, 16, 32, 32, ne), new ee(8, 16, 128, 128, ne), new ee(8, 32, 128, 256, ne), new ee(32, 128, 258, 1024, ne), new ee(32, 258, 258, 4096, ne)], C.deflateInit = function(O, AA) {
                  return de(O, AA, v, 15, 8, 0);
                }, C.deflateInit2 = de, C.deflateReset = ie, C.deflateResetKeep = Ae, C.deflateSetHeader = function(O, AA) {
                  return O && O.state ? O.state.wrap !== 2 ? N : (O.state.gzhead = AA, m) : N;
                }, C.deflate = function(O, AA) {
                  var q, Z, $, BA;
                  if (!O || !O.state || 5 < AA || AA < 0)
                    return O ? MA(O, N) : N;
                  if (Z = O.state, !O.output || !O.input && O.avail_in !== 0 || Z.status === 666 && AA !== y)
                    return MA(O, O.avail_out === 0 ? -5 : N);
                  if (Z.strm = O, q = Z.last_flush, Z.last_flush = AA, Z.status === J)
                    if (Z.wrap === 2)
                      O.adler = 0, kA(Z, 31), kA(Z, 139), kA(Z, 8), Z.gzhead ? (kA(Z, (Z.gzhead.text ? 1 : 0) + (Z.gzhead.hcrc ? 2 : 0) + (Z.gzhead.extra ? 4 : 0) + (Z.gzhead.name ? 8 : 0) + (Z.gzhead.comment ? 16 : 0)), kA(Z, 255 & Z.gzhead.time), kA(Z, Z.gzhead.time >> 8 & 255), kA(Z, Z.gzhead.time >> 16 & 255), kA(Z, Z.gzhead.time >> 24 & 255), kA(Z, Z.level === 9 ? 2 : 2 <= Z.strategy || Z.level < 2 ? 4 : 0), kA(Z, 255 & Z.gzhead.os), Z.gzhead.extra && Z.gzhead.extra.length && (kA(Z, 255 & Z.gzhead.extra.length), kA(Z, Z.gzhead.extra.length >> 8 & 255)), Z.gzhead.hcrc && (O.adler = D(O.adler, Z.pending_buf, Z.pending, 0)), Z.gzindex = 0, Z.status = 69) : (kA(Z, 0), kA(Z, 0), kA(Z, 0), kA(Z, 0), kA(Z, 0), kA(Z, Z.level === 9 ? 2 : 2 <= Z.strategy || Z.level < 2 ? 4 : 0), kA(Z, 3), Z.status = tA);
                    else {
                      var GA = v + (Z.w_bits - 8 << 4) << 8;
                      GA |= (2 <= Z.strategy || Z.level < 2 ? 0 : Z.level < 6 ? 1 : Z.level === 6 ? 2 : 3) << 6, Z.strstart !== 0 && (GA |= 32), GA += 31 - GA % 31, Z.status = tA, FA(Z, GA), Z.strstart !== 0 && (FA(Z, O.adler >>> 16), FA(Z, 65535 & O.adler)), O.adler = 1;
                    }
                  if (Z.status === 69)
                    if (Z.gzhead.extra) {
                      for ($ = Z.pending; Z.gzindex < (65535 & Z.gzhead.extra.length) && (Z.pending !== Z.pending_buf_size || (Z.gzhead.hcrc && Z.pending > $ && (O.adler = D(O.adler, Z.pending_buf, Z.pending - $, $)), wA(O), $ = Z.pending, Z.pending !== Z.pending_buf_size)); )
                        kA(Z, 255 & Z.gzhead.extra[Z.gzindex]), Z.gzindex++;
                      Z.gzhead.hcrc && Z.pending > $ && (O.adler = D(O.adler, Z.pending_buf, Z.pending - $, $)), Z.gzindex === Z.gzhead.extra.length && (Z.gzindex = 0, Z.status = 73);
                    } else
                      Z.status = 73;
                  if (Z.status === 73)
                    if (Z.gzhead.name) {
                      $ = Z.pending;
                      do {
                        if (Z.pending === Z.pending_buf_size && (Z.gzhead.hcrc && Z.pending > $ && (O.adler = D(O.adler, Z.pending_buf, Z.pending - $, $)), wA(O), $ = Z.pending, Z.pending === Z.pending_buf_size)) {
                          BA = 1;
                          break;
                        }
                        BA = Z.gzindex < Z.gzhead.name.length ? 255 & Z.gzhead.name.charCodeAt(Z.gzindex++) : 0, kA(Z, BA);
                      } while (BA !== 0);
                      Z.gzhead.hcrc && Z.pending > $ && (O.adler = D(O.adler, Z.pending_buf, Z.pending - $, $)), BA === 0 && (Z.gzindex = 0, Z.status = 91);
                    } else
                      Z.status = 91;
                  if (Z.status === 91)
                    if (Z.gzhead.comment) {
                      $ = Z.pending;
                      do {
                        if (Z.pending === Z.pending_buf_size && (Z.gzhead.hcrc && Z.pending > $ && (O.adler = D(O.adler, Z.pending_buf, Z.pending - $, $)), wA(O), $ = Z.pending, Z.pending === Z.pending_buf_size)) {
                          BA = 1;
                          break;
                        }
                        BA = Z.gzindex < Z.gzhead.comment.length ? 255 & Z.gzhead.comment.charCodeAt(Z.gzindex++) : 0, kA(Z, BA);
                      } while (BA !== 0);
                      Z.gzhead.hcrc && Z.pending > $ && (O.adler = D(O.adler, Z.pending_buf, Z.pending - $, $)), BA === 0 && (Z.status = 103);
                    } else
                      Z.status = 103;
                  if (Z.status === 103 && (Z.gzhead.hcrc ? (Z.pending + 2 > Z.pending_buf_size && wA(O), Z.pending + 2 <= Z.pending_buf_size && (kA(Z, 255 & O.adler), kA(Z, O.adler >> 8 & 255), O.adler = 0, Z.status = tA)) : Z.status = tA), Z.pending !== 0) {
                    if (wA(O), O.avail_out === 0)
                      return Z.last_flush = -1, m;
                  } else if (O.avail_in === 0 && hA(AA) <= hA(q) && AA !== y)
                    return MA(O, -5);
                  if (Z.status === 666 && O.avail_in !== 0)
                    return MA(O, -5);
                  if (O.avail_in !== 0 || Z.lookahead !== 0 || AA !== S && Z.status !== 666) {
                    var bA = Z.strategy === 2 ? function(DA, SA) {
                      for (var EA; ; ) {
                        if (DA.lookahead === 0 && (vA(DA), DA.lookahead === 0)) {
                          if (SA === S)
                            return Y;
                          break;
                        }
                        if (DA.match_length = 0, EA = d._tr_tally(DA, 0, DA.window[DA.strstart]), DA.lookahead--, DA.strstart++, EA && (yA(DA, !1), DA.strm.avail_out === 0))
                          return Y;
                      }
                      return DA.insert = 0, SA === y ? (yA(DA, !0), DA.strm.avail_out === 0 ? QA : aA) : DA.last_lit && (yA(DA, !1), DA.strm.avail_out === 0) ? Y : rA;
                    }(Z, AA) : Z.strategy === 3 ? function(DA, SA) {
                      for (var EA, mA, YA, ZA, _A = DA.window; ; ) {
                        if (DA.lookahead <= oA) {
                          if (vA(DA), DA.lookahead <= oA && SA === S)
                            return Y;
                          if (DA.lookahead === 0)
                            break;
                        }
                        if (DA.match_length = 0, DA.lookahead >= eA && 0 < DA.strstart && (mA = _A[YA = DA.strstart - 1]) === _A[++YA] && mA === _A[++YA] && mA === _A[++YA]) {
                          ZA = DA.strstart + oA;
                          do
                            ;
                          while (mA === _A[++YA] && mA === _A[++YA] && mA === _A[++YA] && mA === _A[++YA] && mA === _A[++YA] && mA === _A[++YA] && mA === _A[++YA] && mA === _A[++YA] && YA < ZA);
                          DA.match_length = oA - (ZA - YA), DA.match_length > DA.lookahead && (DA.match_length = DA.lookahead);
                        }
                        if (DA.match_length >= eA ? (EA = d._tr_tally(DA, 1, DA.match_length - eA), DA.lookahead -= DA.match_length, DA.strstart += DA.match_length, DA.match_length = 0) : (EA = d._tr_tally(DA, 0, DA.window[DA.strstart]), DA.lookahead--, DA.strstart++), EA && (yA(DA, !1), DA.strm.avail_out === 0))
                          return Y;
                      }
                      return DA.insert = 0, SA === y ? (yA(DA, !0), DA.strm.avail_out === 0 ? QA : aA) : DA.last_lit && (yA(DA, !1), DA.strm.avail_out === 0) ? Y : rA;
                    }(Z, AA) : c[Z.level].func(Z, AA);
                    if (bA !== QA && bA !== aA || (Z.status = 666), bA === Y || bA === QA)
                      return O.avail_out === 0 && (Z.last_flush = -1), m;
                    if (bA === rA && (AA === 1 ? d._tr_align(Z) : AA !== 5 && (d._tr_stored_block(Z, 0, 0, !1), AA === 3 && (fA(Z.head), Z.lookahead === 0 && (Z.strstart = 0, Z.block_start = 0, Z.insert = 0))), wA(O), O.avail_out === 0))
                      return Z.last_flush = -1, m;
                  }
                  return AA !== y ? m : Z.wrap <= 0 ? 1 : (Z.wrap === 2 ? (kA(Z, 255 & O.adler), kA(Z, O.adler >> 8 & 255), kA(Z, O.adler >> 16 & 255), kA(Z, O.adler >> 24 & 255), kA(Z, 255 & O.total_in), kA(Z, O.total_in >> 8 & 255), kA(Z, O.total_in >> 16 & 255), kA(Z, O.total_in >> 24 & 255)) : (FA(Z, O.adler >>> 16), FA(Z, 65535 & O.adler)), wA(O), 0 < Z.wrap && (Z.wrap = -Z.wrap), Z.pending !== 0 ? m : 1);
                }, C.deflateEnd = function(O) {
                  var AA;
                  return O && O.state ? (AA = O.state.status) !== J && AA !== 69 && AA !== 73 && AA !== 91 && AA !== 103 && AA !== tA && AA !== 666 ? MA(O, N) : (O.state = null, AA === tA ? MA(O, -3) : m) : N;
                }, C.deflateSetDictionary = function(O, AA) {
                  var q, Z, $, BA, GA, bA, DA, SA, EA = AA.length;
                  if (!O || !O.state || (BA = (q = O.state).wrap) === 2 || BA === 1 && q.status !== J || q.lookahead)
                    return N;
                  for (BA === 1 && (O.adler = p(O.adler, AA, EA, 0)), q.wrap = 0, EA >= q.w_size && (BA === 0 && (fA(q.head), q.strstart = 0, q.block_start = 0, q.insert = 0), SA = new u.Buf8(q.w_size), u.arraySet(SA, AA, EA - q.w_size, q.w_size, 0), AA = SA, EA = q.w_size), GA = O.avail_in, bA = O.next_in, DA = O.input, O.avail_in = EA, O.next_in = 0, O.input = AA, vA(q); q.lookahead >= eA; ) {
                    for (Z = q.strstart, $ = q.lookahead - (eA - 1); q.ins_h = (q.ins_h << q.hash_shift ^ q.window[Z + eA - 1]) & q.hash_mask, q.prev[Z & q.w_mask] = q.head[q.ins_h], q.head[q.ins_h] = Z, Z++, --$; )
                      ;
                    q.strstart = Z, q.lookahead = eA - 1, vA(q);
                  }
                  return q.strstart += q.lookahead, q.block_start = q.strstart, q.insert = q.lookahead, q.lookahead = 0, q.match_length = q.prev_length = eA - 1, q.match_available = 0, O.next_in = bA, O.input = DA, O.avail_in = GA, q.wrap = BA, m;
                }, C.deflateInfo = "pako deflate (from Nodeca project)";
              }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(I, E, C) {
                E.exports = function() {
                  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
                };
              }, {}], 48: [function(I, E, C) {
                E.exports = function(c, u) {
                  var d, p, D, f, S, y, m, N, F, G, k, v, x, H, _, j, V, iA, eA, oA, P, J, tA, Y, rA;
                  d = c.state, p = c.next_in, Y = c.input, D = p + (c.avail_in - 5), f = c.next_out, rA = c.output, S = f - (u - c.avail_out), y = f + (c.avail_out - 257), m = d.dmax, N = d.wsize, F = d.whave, G = d.wnext, k = d.window, v = d.hold, x = d.bits, H = d.lencode, _ = d.distcode, j = (1 << d.lenbits) - 1, V = (1 << d.distbits) - 1;
                  A:
                    do {
                      x < 15 && (v += Y[p++] << x, x += 8, v += Y[p++] << x, x += 8), iA = H[v & j];
                      e:
                        for (; ; ) {
                          if (v >>>= eA = iA >>> 24, x -= eA, (eA = iA >>> 16 & 255) === 0)
                            rA[f++] = 65535 & iA;
                          else {
                            if (!(16 & eA)) {
                              if (!(64 & eA)) {
                                iA = H[(65535 & iA) + (v & (1 << eA) - 1)];
                                continue e;
                              }
                              if (32 & eA) {
                                d.mode = 12;
                                break A;
                              }
                              c.msg = "invalid literal/length code", d.mode = 30;
                              break A;
                            }
                            oA = 65535 & iA, (eA &= 15) && (x < eA && (v += Y[p++] << x, x += 8), oA += v & (1 << eA) - 1, v >>>= eA, x -= eA), x < 15 && (v += Y[p++] << x, x += 8, v += Y[p++] << x, x += 8), iA = _[v & V];
                            t:
                              for (; ; ) {
                                if (v >>>= eA = iA >>> 24, x -= eA, !(16 & (eA = iA >>> 16 & 255))) {
                                  if (!(64 & eA)) {
                                    iA = _[(65535 & iA) + (v & (1 << eA) - 1)];
                                    continue t;
                                  }
                                  c.msg = "invalid distance code", d.mode = 30;
                                  break A;
                                }
                                if (P = 65535 & iA, x < (eA &= 15) && (v += Y[p++] << x, (x += 8) < eA && (v += Y[p++] << x, x += 8)), m < (P += v & (1 << eA) - 1)) {
                                  c.msg = "invalid distance too far back", d.mode = 30;
                                  break A;
                                }
                                if (v >>>= eA, x -= eA, (eA = f - S) < P) {
                                  if (F < (eA = P - eA) && d.sane) {
                                    c.msg = "invalid distance too far back", d.mode = 30;
                                    break A;
                                  }
                                  if (tA = k, (J = 0) === G) {
                                    if (J += N - eA, eA < oA) {
                                      for (oA -= eA; rA[f++] = k[J++], --eA; )
                                        ;
                                      J = f - P, tA = rA;
                                    }
                                  } else if (G < eA) {
                                    if (J += N + G - eA, (eA -= G) < oA) {
                                      for (oA -= eA; rA[f++] = k[J++], --eA; )
                                        ;
                                      if (J = 0, G < oA) {
                                        for (oA -= eA = G; rA[f++] = k[J++], --eA; )
                                          ;
                                        J = f - P, tA = rA;
                                      }
                                    }
                                  } else if (J += G - eA, eA < oA) {
                                    for (oA -= eA; rA[f++] = k[J++], --eA; )
                                      ;
                                    J = f - P, tA = rA;
                                  }
                                  for (; 2 < oA; )
                                    rA[f++] = tA[J++], rA[f++] = tA[J++], rA[f++] = tA[J++], oA -= 3;
                                  oA && (rA[f++] = tA[J++], 1 < oA && (rA[f++] = tA[J++]));
                                } else {
                                  for (J = f - P; rA[f++] = rA[J++], rA[f++] = rA[J++], rA[f++] = rA[J++], 2 < (oA -= 3); )
                                    ;
                                  oA && (rA[f++] = rA[J++], 1 < oA && (rA[f++] = rA[J++]));
                                }
                                break;
                              }
                          }
                          break;
                        }
                    } while (p < D && f < y);
                  p -= oA = x >> 3, v &= (1 << (x -= oA << 3)) - 1, c.next_in = p, c.next_out = f, c.avail_in = p < D ? D - p + 5 : 5 - (p - D), c.avail_out = f < y ? y - f + 257 : 257 - (f - y), d.hold = v, d.bits = x;
                };
              }, {}], 49: [function(I, E, C) {
                var c = I("../utils/common"), u = I("./adler32"), d = I("./crc32"), p = I("./inffast"), D = I("./inftrees"), f = 1, S = 2, y = 0, m = -2, N = 1, F = 852, G = 592;
                function k(J) {
                  return (J >>> 24 & 255) + (J >>> 8 & 65280) + ((65280 & J) << 8) + ((255 & J) << 24);
                }
                function v() {
                  this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new c.Buf16(320), this.work = new c.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
                }
                function x(J) {
                  var tA;
                  return J && J.state ? (tA = J.state, J.total_in = J.total_out = tA.total = 0, J.msg = "", tA.wrap && (J.adler = 1 & tA.wrap), tA.mode = N, tA.last = 0, tA.havedict = 0, tA.dmax = 32768, tA.head = null, tA.hold = 0, tA.bits = 0, tA.lencode = tA.lendyn = new c.Buf32(F), tA.distcode = tA.distdyn = new c.Buf32(G), tA.sane = 1, tA.back = -1, y) : m;
                }
                function H(J) {
                  var tA;
                  return J && J.state ? ((tA = J.state).wsize = 0, tA.whave = 0, tA.wnext = 0, x(J)) : m;
                }
                function _(J, tA) {
                  var Y, rA;
                  return J && J.state ? (rA = J.state, tA < 0 ? (Y = 0, tA = -tA) : (Y = 1 + (tA >> 4), tA < 48 && (tA &= 15)), tA && (tA < 8 || 15 < tA) ? m : (rA.window !== null && rA.wbits !== tA && (rA.window = null), rA.wrap = Y, rA.wbits = tA, H(J))) : m;
                }
                function j(J, tA) {
                  var Y, rA;
                  return J ? (rA = new v(), (J.state = rA).window = null, (Y = _(J, tA)) !== y && (J.state = null), Y) : m;
                }
                var V, iA, eA = !0;
                function oA(J) {
                  if (eA) {
                    var tA;
                    for (V = new c.Buf32(512), iA = new c.Buf32(32), tA = 0; tA < 144; )
                      J.lens[tA++] = 8;
                    for (; tA < 256; )
                      J.lens[tA++] = 9;
                    for (; tA < 280; )
                      J.lens[tA++] = 7;
                    for (; tA < 288; )
                      J.lens[tA++] = 8;
                    for (D(f, J.lens, 0, 288, V, 0, J.work, { bits: 9 }), tA = 0; tA < 32; )
                      J.lens[tA++] = 5;
                    D(S, J.lens, 0, 32, iA, 0, J.work, { bits: 5 }), eA = !1;
                  }
                  J.lencode = V, J.lenbits = 9, J.distcode = iA, J.distbits = 5;
                }
                function P(J, tA, Y, rA) {
                  var QA, aA = J.state;
                  return aA.window === null && (aA.wsize = 1 << aA.wbits, aA.wnext = 0, aA.whave = 0, aA.window = new c.Buf8(aA.wsize)), rA >= aA.wsize ? (c.arraySet(aA.window, tA, Y - aA.wsize, aA.wsize, 0), aA.wnext = 0, aA.whave = aA.wsize) : (rA < (QA = aA.wsize - aA.wnext) && (QA = rA), c.arraySet(aA.window, tA, Y - rA, QA, aA.wnext), (rA -= QA) ? (c.arraySet(aA.window, tA, Y - rA, rA, 0), aA.wnext = rA, aA.whave = aA.wsize) : (aA.wnext += QA, aA.wnext === aA.wsize && (aA.wnext = 0), aA.whave < aA.wsize && (aA.whave += QA))), 0;
                }
                C.inflateReset = H, C.inflateReset2 = _, C.inflateResetKeep = x, C.inflateInit = function(J) {
                  return j(J, 15);
                }, C.inflateInit2 = j, C.inflate = function(J, tA) {
                  var Y, rA, QA, aA, MA, hA, fA, wA, yA, kA, FA, dA, vA, JA, ne, ee, pe, Ae, ie, de, O, AA, q, Z, $ = 0, BA = new c.Buf8(4), GA = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                  if (!J || !J.state || !J.output || !J.input && J.avail_in !== 0)
                    return m;
                  (Y = J.state).mode === 12 && (Y.mode = 13), MA = J.next_out, QA = J.output, fA = J.avail_out, aA = J.next_in, rA = J.input, hA = J.avail_in, wA = Y.hold, yA = Y.bits, kA = hA, FA = fA, AA = y;
                  A:
                    for (; ; )
                      switch (Y.mode) {
                        case N:
                          if (Y.wrap === 0) {
                            Y.mode = 13;
                            break;
                          }
                          for (; yA < 16; ) {
                            if (hA === 0)
                              break A;
                            hA--, wA += rA[aA++] << yA, yA += 8;
                          }
                          if (2 & Y.wrap && wA === 35615) {
                            BA[Y.check = 0] = 255 & wA, BA[1] = wA >>> 8 & 255, Y.check = d(Y.check, BA, 2, 0), yA = wA = 0, Y.mode = 2;
                            break;
                          }
                          if (Y.flags = 0, Y.head && (Y.head.done = !1), !(1 & Y.wrap) || (((255 & wA) << 8) + (wA >> 8)) % 31) {
                            J.msg = "incorrect header check", Y.mode = 30;
                            break;
                          }
                          if ((15 & wA) != 8) {
                            J.msg = "unknown compression method", Y.mode = 30;
                            break;
                          }
                          if (yA -= 4, O = 8 + (15 & (wA >>>= 4)), Y.wbits === 0)
                            Y.wbits = O;
                          else if (O > Y.wbits) {
                            J.msg = "invalid window size", Y.mode = 30;
                            break;
                          }
                          Y.dmax = 1 << O, J.adler = Y.check = 1, Y.mode = 512 & wA ? 10 : 12, yA = wA = 0;
                          break;
                        case 2:
                          for (; yA < 16; ) {
                            if (hA === 0)
                              break A;
                            hA--, wA += rA[aA++] << yA, yA += 8;
                          }
                          if (Y.flags = wA, (255 & Y.flags) != 8) {
                            J.msg = "unknown compression method", Y.mode = 30;
                            break;
                          }
                          if (57344 & Y.flags) {
                            J.msg = "unknown header flags set", Y.mode = 30;
                            break;
                          }
                          Y.head && (Y.head.text = wA >> 8 & 1), 512 & Y.flags && (BA[0] = 255 & wA, BA[1] = wA >>> 8 & 255, Y.check = d(Y.check, BA, 2, 0)), yA = wA = 0, Y.mode = 3;
                        case 3:
                          for (; yA < 32; ) {
                            if (hA === 0)
                              break A;
                            hA--, wA += rA[aA++] << yA, yA += 8;
                          }
                          Y.head && (Y.head.time = wA), 512 & Y.flags && (BA[0] = 255 & wA, BA[1] = wA >>> 8 & 255, BA[2] = wA >>> 16 & 255, BA[3] = wA >>> 24 & 255, Y.check = d(Y.check, BA, 4, 0)), yA = wA = 0, Y.mode = 4;
                        case 4:
                          for (; yA < 16; ) {
                            if (hA === 0)
                              break A;
                            hA--, wA += rA[aA++] << yA, yA += 8;
                          }
                          Y.head && (Y.head.xflags = 255 & wA, Y.head.os = wA >> 8), 512 & Y.flags && (BA[0] = 255 & wA, BA[1] = wA >>> 8 & 255, Y.check = d(Y.check, BA, 2, 0)), yA = wA = 0, Y.mode = 5;
                        case 5:
                          if (1024 & Y.flags) {
                            for (; yA < 16; ) {
                              if (hA === 0)
                                break A;
                              hA--, wA += rA[aA++] << yA, yA += 8;
                            }
                            Y.length = wA, Y.head && (Y.head.extra_len = wA), 512 & Y.flags && (BA[0] = 255 & wA, BA[1] = wA >>> 8 & 255, Y.check = d(Y.check, BA, 2, 0)), yA = wA = 0;
                          } else
                            Y.head && (Y.head.extra = null);
                          Y.mode = 6;
                        case 6:
                          if (1024 & Y.flags && (hA < (dA = Y.length) && (dA = hA), dA && (Y.head && (O = Y.head.extra_len - Y.length, Y.head.extra || (Y.head.extra = new Array(Y.head.extra_len)), c.arraySet(Y.head.extra, rA, aA, dA, O)), 512 & Y.flags && (Y.check = d(Y.check, rA, dA, aA)), hA -= dA, aA += dA, Y.length -= dA), Y.length))
                            break A;
                          Y.length = 0, Y.mode = 7;
                        case 7:
                          if (2048 & Y.flags) {
                            if (hA === 0)
                              break A;
                            for (dA = 0; O = rA[aA + dA++], Y.head && O && Y.length < 65536 && (Y.head.name += String.fromCharCode(O)), O && dA < hA; )
                              ;
                            if (512 & Y.flags && (Y.check = d(Y.check, rA, dA, aA)), hA -= dA, aA += dA, O)
                              break A;
                          } else
                            Y.head && (Y.head.name = null);
                          Y.length = 0, Y.mode = 8;
                        case 8:
                          if (4096 & Y.flags) {
                            if (hA === 0)
                              break A;
                            for (dA = 0; O = rA[aA + dA++], Y.head && O && Y.length < 65536 && (Y.head.comment += String.fromCharCode(O)), O && dA < hA; )
                              ;
                            if (512 & Y.flags && (Y.check = d(Y.check, rA, dA, aA)), hA -= dA, aA += dA, O)
                              break A;
                          } else
                            Y.head && (Y.head.comment = null);
                          Y.mode = 9;
                        case 9:
                          if (512 & Y.flags) {
                            for (; yA < 16; ) {
                              if (hA === 0)
                                break A;
                              hA--, wA += rA[aA++] << yA, yA += 8;
                            }
                            if (wA !== (65535 & Y.check)) {
                              J.msg = "header crc mismatch", Y.mode = 30;
                              break;
                            }
                            yA = wA = 0;
                          }
                          Y.head && (Y.head.hcrc = Y.flags >> 9 & 1, Y.head.done = !0), J.adler = Y.check = 0, Y.mode = 12;
                          break;
                        case 10:
                          for (; yA < 32; ) {
                            if (hA === 0)
                              break A;
                            hA--, wA += rA[aA++] << yA, yA += 8;
                          }
                          J.adler = Y.check = k(wA), yA = wA = 0, Y.mode = 11;
                        case 11:
                          if (Y.havedict === 0)
                            return J.next_out = MA, J.avail_out = fA, J.next_in = aA, J.avail_in = hA, Y.hold = wA, Y.bits = yA, 2;
                          J.adler = Y.check = 1, Y.mode = 12;
                        case 12:
                          if (tA === 5 || tA === 6)
                            break A;
                        case 13:
                          if (Y.last) {
                            wA >>>= 7 & yA, yA -= 7 & yA, Y.mode = 27;
                            break;
                          }
                          for (; yA < 3; ) {
                            if (hA === 0)
                              break A;
                            hA--, wA += rA[aA++] << yA, yA += 8;
                          }
                          switch (Y.last = 1 & wA, yA -= 1, 3 & (wA >>>= 1)) {
                            case 0:
                              Y.mode = 14;
                              break;
                            case 1:
                              if (oA(Y), Y.mode = 20, tA !== 6)
                                break;
                              wA >>>= 2, yA -= 2;
                              break A;
                            case 2:
                              Y.mode = 17;
                              break;
                            case 3:
                              J.msg = "invalid block type", Y.mode = 30;
                          }
                          wA >>>= 2, yA -= 2;
                          break;
                        case 14:
                          for (wA >>>= 7 & yA, yA -= 7 & yA; yA < 32; ) {
                            if (hA === 0)
                              break A;
                            hA--, wA += rA[aA++] << yA, yA += 8;
                          }
                          if ((65535 & wA) != (wA >>> 16 ^ 65535)) {
                            J.msg = "invalid stored block lengths", Y.mode = 30;
                            break;
                          }
                          if (Y.length = 65535 & wA, yA = wA = 0, Y.mode = 15, tA === 6)
                            break A;
                        case 15:
                          Y.mode = 16;
                        case 16:
                          if (dA = Y.length) {
                            if (hA < dA && (dA = hA), fA < dA && (dA = fA), dA === 0)
                              break A;
                            c.arraySet(QA, rA, aA, dA, MA), hA -= dA, aA += dA, fA -= dA, MA += dA, Y.length -= dA;
                            break;
                          }
                          Y.mode = 12;
                          break;
                        case 17:
                          for (; yA < 14; ) {
                            if (hA === 0)
                              break A;
                            hA--, wA += rA[aA++] << yA, yA += 8;
                          }
                          if (Y.nlen = 257 + (31 & wA), wA >>>= 5, yA -= 5, Y.ndist = 1 + (31 & wA), wA >>>= 5, yA -= 5, Y.ncode = 4 + (15 & wA), wA >>>= 4, yA -= 4, 286 < Y.nlen || 30 < Y.ndist) {
                            J.msg = "too many length or distance symbols", Y.mode = 30;
                            break;
                          }
                          Y.have = 0, Y.mode = 18;
                        case 18:
                          for (; Y.have < Y.ncode; ) {
                            for (; yA < 3; ) {
                              if (hA === 0)
                                break A;
                              hA--, wA += rA[aA++] << yA, yA += 8;
                            }
                            Y.lens[GA[Y.have++]] = 7 & wA, wA >>>= 3, yA -= 3;
                          }
                          for (; Y.have < 19; )
                            Y.lens[GA[Y.have++]] = 0;
                          if (Y.lencode = Y.lendyn, Y.lenbits = 7, q = { bits: Y.lenbits }, AA = D(0, Y.lens, 0, 19, Y.lencode, 0, Y.work, q), Y.lenbits = q.bits, AA) {
                            J.msg = "invalid code lengths set", Y.mode = 30;
                            break;
                          }
                          Y.have = 0, Y.mode = 19;
                        case 19:
                          for (; Y.have < Y.nlen + Y.ndist; ) {
                            for (; ee = ($ = Y.lencode[wA & (1 << Y.lenbits) - 1]) >>> 16 & 255, pe = 65535 & $, !((ne = $ >>> 24) <= yA); ) {
                              if (hA === 0)
                                break A;
                              hA--, wA += rA[aA++] << yA, yA += 8;
                            }
                            if (pe < 16)
                              wA >>>= ne, yA -= ne, Y.lens[Y.have++] = pe;
                            else {
                              if (pe === 16) {
                                for (Z = ne + 2; yA < Z; ) {
                                  if (hA === 0)
                                    break A;
                                  hA--, wA += rA[aA++] << yA, yA += 8;
                                }
                                if (wA >>>= ne, yA -= ne, Y.have === 0) {
                                  J.msg = "invalid bit length repeat", Y.mode = 30;
                                  break;
                                }
                                O = Y.lens[Y.have - 1], dA = 3 + (3 & wA), wA >>>= 2, yA -= 2;
                              } else if (pe === 17) {
                                for (Z = ne + 3; yA < Z; ) {
                                  if (hA === 0)
                                    break A;
                                  hA--, wA += rA[aA++] << yA, yA += 8;
                                }
                                yA -= ne, O = 0, dA = 3 + (7 & (wA >>>= ne)), wA >>>= 3, yA -= 3;
                              } else {
                                for (Z = ne + 7; yA < Z; ) {
                                  if (hA === 0)
                                    break A;
                                  hA--, wA += rA[aA++] << yA, yA += 8;
                                }
                                yA -= ne, O = 0, dA = 11 + (127 & (wA >>>= ne)), wA >>>= 7, yA -= 7;
                              }
                              if (Y.have + dA > Y.nlen + Y.ndist) {
                                J.msg = "invalid bit length repeat", Y.mode = 30;
                                break;
                              }
                              for (; dA--; )
                                Y.lens[Y.have++] = O;
                            }
                          }
                          if (Y.mode === 30)
                            break;
                          if (Y.lens[256] === 0) {
                            J.msg = "invalid code -- missing end-of-block", Y.mode = 30;
                            break;
                          }
                          if (Y.lenbits = 9, q = { bits: Y.lenbits }, AA = D(f, Y.lens, 0, Y.nlen, Y.lencode, 0, Y.work, q), Y.lenbits = q.bits, AA) {
                            J.msg = "invalid literal/lengths set", Y.mode = 30;
                            break;
                          }
                          if (Y.distbits = 6, Y.distcode = Y.distdyn, q = { bits: Y.distbits }, AA = D(S, Y.lens, Y.nlen, Y.ndist, Y.distcode, 0, Y.work, q), Y.distbits = q.bits, AA) {
                            J.msg = "invalid distances set", Y.mode = 30;
                            break;
                          }
                          if (Y.mode = 20, tA === 6)
                            break A;
                        case 20:
                          Y.mode = 21;
                        case 21:
                          if (6 <= hA && 258 <= fA) {
                            J.next_out = MA, J.avail_out = fA, J.next_in = aA, J.avail_in = hA, Y.hold = wA, Y.bits = yA, p(J, FA), MA = J.next_out, QA = J.output, fA = J.avail_out, aA = J.next_in, rA = J.input, hA = J.avail_in, wA = Y.hold, yA = Y.bits, Y.mode === 12 && (Y.back = -1);
                            break;
                          }
                          for (Y.back = 0; ee = ($ = Y.lencode[wA & (1 << Y.lenbits) - 1]) >>> 16 & 255, pe = 65535 & $, !((ne = $ >>> 24) <= yA); ) {
                            if (hA === 0)
                              break A;
                            hA--, wA += rA[aA++] << yA, yA += 8;
                          }
                          if (ee && !(240 & ee)) {
                            for (Ae = ne, ie = ee, de = pe; ee = ($ = Y.lencode[de + ((wA & (1 << Ae + ie) - 1) >> Ae)]) >>> 16 & 255, pe = 65535 & $, !(Ae + (ne = $ >>> 24) <= yA); ) {
                              if (hA === 0)
                                break A;
                              hA--, wA += rA[aA++] << yA, yA += 8;
                            }
                            wA >>>= Ae, yA -= Ae, Y.back += Ae;
                          }
                          if (wA >>>= ne, yA -= ne, Y.back += ne, Y.length = pe, ee === 0) {
                            Y.mode = 26;
                            break;
                          }
                          if (32 & ee) {
                            Y.back = -1, Y.mode = 12;
                            break;
                          }
                          if (64 & ee) {
                            J.msg = "invalid literal/length code", Y.mode = 30;
                            break;
                          }
                          Y.extra = 15 & ee, Y.mode = 22;
                        case 22:
                          if (Y.extra) {
                            for (Z = Y.extra; yA < Z; ) {
                              if (hA === 0)
                                break A;
                              hA--, wA += rA[aA++] << yA, yA += 8;
                            }
                            Y.length += wA & (1 << Y.extra) - 1, wA >>>= Y.extra, yA -= Y.extra, Y.back += Y.extra;
                          }
                          Y.was = Y.length, Y.mode = 23;
                        case 23:
                          for (; ee = ($ = Y.distcode[wA & (1 << Y.distbits) - 1]) >>> 16 & 255, pe = 65535 & $, !((ne = $ >>> 24) <= yA); ) {
                            if (hA === 0)
                              break A;
                            hA--, wA += rA[aA++] << yA, yA += 8;
                          }
                          if (!(240 & ee)) {
                            for (Ae = ne, ie = ee, de = pe; ee = ($ = Y.distcode[de + ((wA & (1 << Ae + ie) - 1) >> Ae)]) >>> 16 & 255, pe = 65535 & $, !(Ae + (ne = $ >>> 24) <= yA); ) {
                              if (hA === 0)
                                break A;
                              hA--, wA += rA[aA++] << yA, yA += 8;
                            }
                            wA >>>= Ae, yA -= Ae, Y.back += Ae;
                          }
                          if (wA >>>= ne, yA -= ne, Y.back += ne, 64 & ee) {
                            J.msg = "invalid distance code", Y.mode = 30;
                            break;
                          }
                          Y.offset = pe, Y.extra = 15 & ee, Y.mode = 24;
                        case 24:
                          if (Y.extra) {
                            for (Z = Y.extra; yA < Z; ) {
                              if (hA === 0)
                                break A;
                              hA--, wA += rA[aA++] << yA, yA += 8;
                            }
                            Y.offset += wA & (1 << Y.extra) - 1, wA >>>= Y.extra, yA -= Y.extra, Y.back += Y.extra;
                          }
                          if (Y.offset > Y.dmax) {
                            J.msg = "invalid distance too far back", Y.mode = 30;
                            break;
                          }
                          Y.mode = 25;
                        case 25:
                          if (fA === 0)
                            break A;
                          if (dA = FA - fA, Y.offset > dA) {
                            if ((dA = Y.offset - dA) > Y.whave && Y.sane) {
                              J.msg = "invalid distance too far back", Y.mode = 30;
                              break;
                            }
                            vA = dA > Y.wnext ? (dA -= Y.wnext, Y.wsize - dA) : Y.wnext - dA, dA > Y.length && (dA = Y.length), JA = Y.window;
                          } else
                            JA = QA, vA = MA - Y.offset, dA = Y.length;
                          for (fA < dA && (dA = fA), fA -= dA, Y.length -= dA; QA[MA++] = JA[vA++], --dA; )
                            ;
                          Y.length === 0 && (Y.mode = 21);
                          break;
                        case 26:
                          if (fA === 0)
                            break A;
                          QA[MA++] = Y.length, fA--, Y.mode = 21;
                          break;
                        case 27:
                          if (Y.wrap) {
                            for (; yA < 32; ) {
                              if (hA === 0)
                                break A;
                              hA--, wA |= rA[aA++] << yA, yA += 8;
                            }
                            if (FA -= fA, J.total_out += FA, Y.total += FA, FA && (J.adler = Y.check = Y.flags ? d(Y.check, QA, FA, MA - FA) : u(Y.check, QA, FA, MA - FA)), FA = fA, (Y.flags ? wA : k(wA)) !== Y.check) {
                              J.msg = "incorrect data check", Y.mode = 30;
                              break;
                            }
                            yA = wA = 0;
                          }
                          Y.mode = 28;
                        case 28:
                          if (Y.wrap && Y.flags) {
                            for (; yA < 32; ) {
                              if (hA === 0)
                                break A;
                              hA--, wA += rA[aA++] << yA, yA += 8;
                            }
                            if (wA !== (4294967295 & Y.total)) {
                              J.msg = "incorrect length check", Y.mode = 30;
                              break;
                            }
                            yA = wA = 0;
                          }
                          Y.mode = 29;
                        case 29:
                          AA = 1;
                          break A;
                        case 30:
                          AA = -3;
                          break A;
                        case 31:
                          return -4;
                        case 32:
                        default:
                          return m;
                      }
                  return J.next_out = MA, J.avail_out = fA, J.next_in = aA, J.avail_in = hA, Y.hold = wA, Y.bits = yA, (Y.wsize || FA !== J.avail_out && Y.mode < 30 && (Y.mode < 27 || tA !== 4)) && P(J, J.output, J.next_out, FA - J.avail_out) ? (Y.mode = 31, -4) : (kA -= J.avail_in, FA -= J.avail_out, J.total_in += kA, J.total_out += FA, Y.total += FA, Y.wrap && FA && (J.adler = Y.check = Y.flags ? d(Y.check, QA, FA, J.next_out - FA) : u(Y.check, QA, FA, J.next_out - FA)), J.data_type = Y.bits + (Y.last ? 64 : 0) + (Y.mode === 12 ? 128 : 0) + (Y.mode === 20 || Y.mode === 15 ? 256 : 0), (kA == 0 && FA === 0 || tA === 4) && AA === y && (AA = -5), AA);
                }, C.inflateEnd = function(J) {
                  if (!J || !J.state)
                    return m;
                  var tA = J.state;
                  return tA.window && (tA.window = null), J.state = null, y;
                }, C.inflateGetHeader = function(J, tA) {
                  var Y;
                  return J && J.state && 2 & (Y = J.state).wrap ? ((Y.head = tA).done = !1, y) : m;
                }, C.inflateSetDictionary = function(J, tA) {
                  var Y, rA = tA.length;
                  return J && J.state ? (Y = J.state).wrap !== 0 && Y.mode !== 11 ? m : Y.mode === 11 && u(1, tA, rA, 0) !== Y.check ? -3 : P(J, tA, rA, rA) ? (Y.mode = 31, -4) : (Y.havedict = 1, y) : m;
                }, C.inflateInfo = "pako inflate (from Nodeca project)";
              }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(I, E, C) {
                var c = I("../utils/common"), u = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], d = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], p = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], D = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
                E.exports = function(f, S, y, m, N, F, G, k) {
                  var v, x, H, _, j, V, iA, eA, oA, P = k.bits, J = 0, tA = 0, Y = 0, rA = 0, QA = 0, aA = 0, MA = 0, hA = 0, fA = 0, wA = 0, yA = null, kA = 0, FA = new c.Buf16(16), dA = new c.Buf16(16), vA = null, JA = 0;
                  for (J = 0; J <= 15; J++)
                    FA[J] = 0;
                  for (tA = 0; tA < m; tA++)
                    FA[S[y + tA]]++;
                  for (QA = P, rA = 15; 1 <= rA && FA[rA] === 0; rA--)
                    ;
                  if (rA < QA && (QA = rA), rA === 0)
                    return N[F++] = 20971520, N[F++] = 20971520, k.bits = 1, 0;
                  for (Y = 1; Y < rA && FA[Y] === 0; Y++)
                    ;
                  for (QA < Y && (QA = Y), J = hA = 1; J <= 15; J++)
                    if (hA <<= 1, (hA -= FA[J]) < 0)
                      return -1;
                  if (0 < hA && (f === 0 || rA !== 1))
                    return -1;
                  for (dA[1] = 0, J = 1; J < 15; J++)
                    dA[J + 1] = dA[J] + FA[J];
                  for (tA = 0; tA < m; tA++)
                    S[y + tA] !== 0 && (G[dA[S[y + tA]]++] = tA);
                  if (V = f === 0 ? (yA = vA = G, 19) : f === 1 ? (yA = u, kA -= 257, vA = d, JA -= 257, 256) : (yA = p, vA = D, -1), J = Y, j = F, MA = tA = wA = 0, H = -1, _ = (fA = 1 << (aA = QA)) - 1, f === 1 && 852 < fA || f === 2 && 592 < fA)
                    return 1;
                  for (; ; ) {
                    for (iA = J - MA, oA = G[tA] < V ? (eA = 0, G[tA]) : G[tA] > V ? (eA = vA[JA + G[tA]], yA[kA + G[tA]]) : (eA = 96, 0), v = 1 << J - MA, Y = x = 1 << aA; N[j + (wA >> MA) + (x -= v)] = iA << 24 | eA << 16 | oA | 0, x !== 0; )
                      ;
                    for (v = 1 << J - 1; wA & v; )
                      v >>= 1;
                    if (v !== 0 ? (wA &= v - 1, wA += v) : wA = 0, tA++, --FA[J] == 0) {
                      if (J === rA)
                        break;
                      J = S[y + G[tA]];
                    }
                    if (QA < J && (wA & _) !== H) {
                      for (MA === 0 && (MA = QA), j += Y, hA = 1 << (aA = J - MA); aA + MA < rA && !((hA -= FA[aA + MA]) <= 0); )
                        aA++, hA <<= 1;
                      if (fA += 1 << aA, f === 1 && 852 < fA || f === 2 && 592 < fA)
                        return 1;
                      N[H = wA & _] = QA << 24 | aA << 16 | j - F | 0;
                    }
                  }
                  return wA !== 0 && (N[j + wA] = J - MA << 24 | 4194304 | 0), k.bits = QA, 0;
                };
              }, { "../utils/common": 41 }], 51: [function(I, E, C) {
                E.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
              }, {}], 52: [function(I, E, C) {
                var c = I("../utils/common"), u = 0, d = 1;
                function p($) {
                  for (var BA = $.length; 0 <= --BA; )
                    $[BA] = 0;
                }
                var D = 0, f = 29, S = 256, y = S + 1 + f, m = 30, N = 19, F = 2 * y + 1, G = 15, k = 16, v = 7, x = 256, H = 16, _ = 17, j = 18, V = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], iA = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], eA = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], oA = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], P = new Array(2 * (y + 2));
                p(P);
                var J = new Array(2 * m);
                p(J);
                var tA = new Array(512);
                p(tA);
                var Y = new Array(256);
                p(Y);
                var rA = new Array(f);
                p(rA);
                var QA, aA, MA, hA = new Array(m);
                function fA($, BA, GA, bA, DA) {
                  this.static_tree = $, this.extra_bits = BA, this.extra_base = GA, this.elems = bA, this.max_length = DA, this.has_stree = $ && $.length;
                }
                function wA($, BA) {
                  this.dyn_tree = $, this.max_code = 0, this.stat_desc = BA;
                }
                function yA($) {
                  return $ < 256 ? tA[$] : tA[256 + ($ >>> 7)];
                }
                function kA($, BA) {
                  $.pending_buf[$.pending++] = 255 & BA, $.pending_buf[$.pending++] = BA >>> 8 & 255;
                }
                function FA($, BA, GA) {
                  $.bi_valid > k - GA ? ($.bi_buf |= BA << $.bi_valid & 65535, kA($, $.bi_buf), $.bi_buf = BA >> k - $.bi_valid, $.bi_valid += GA - k) : ($.bi_buf |= BA << $.bi_valid & 65535, $.bi_valid += GA);
                }
                function dA($, BA, GA) {
                  FA($, GA[2 * BA], GA[2 * BA + 1]);
                }
                function vA($, BA) {
                  for (var GA = 0; GA |= 1 & $, $ >>>= 1, GA <<= 1, 0 < --BA; )
                    ;
                  return GA >>> 1;
                }
                function JA($, BA, GA) {
                  var bA, DA, SA = new Array(G + 1), EA = 0;
                  for (bA = 1; bA <= G; bA++)
                    SA[bA] = EA = EA + GA[bA - 1] << 1;
                  for (DA = 0; DA <= BA; DA++) {
                    var mA = $[2 * DA + 1];
                    mA !== 0 && ($[2 * DA] = vA(SA[mA]++, mA));
                  }
                }
                function ne($) {
                  var BA;
                  for (BA = 0; BA < y; BA++)
                    $.dyn_ltree[2 * BA] = 0;
                  for (BA = 0; BA < m; BA++)
                    $.dyn_dtree[2 * BA] = 0;
                  for (BA = 0; BA < N; BA++)
                    $.bl_tree[2 * BA] = 0;
                  $.dyn_ltree[2 * x] = 1, $.opt_len = $.static_len = 0, $.last_lit = $.matches = 0;
                }
                function ee($) {
                  8 < $.bi_valid ? kA($, $.bi_buf) : 0 < $.bi_valid && ($.pending_buf[$.pending++] = $.bi_buf), $.bi_buf = 0, $.bi_valid = 0;
                }
                function pe($, BA, GA, bA) {
                  var DA = 2 * BA, SA = 2 * GA;
                  return $[DA] < $[SA] || $[DA] === $[SA] && bA[BA] <= bA[GA];
                }
                function Ae($, BA, GA) {
                  for (var bA = $.heap[GA], DA = GA << 1; DA <= $.heap_len && (DA < $.heap_len && pe(BA, $.heap[DA + 1], $.heap[DA], $.depth) && DA++, !pe(BA, bA, $.heap[DA], $.depth)); )
                    $.heap[GA] = $.heap[DA], GA = DA, DA <<= 1;
                  $.heap[GA] = bA;
                }
                function ie($, BA, GA) {
                  var bA, DA, SA, EA, mA = 0;
                  if ($.last_lit !== 0)
                    for (; bA = $.pending_buf[$.d_buf + 2 * mA] << 8 | $.pending_buf[$.d_buf + 2 * mA + 1], DA = $.pending_buf[$.l_buf + mA], mA++, bA === 0 ? dA($, DA, BA) : (dA($, (SA = Y[DA]) + S + 1, BA), (EA = V[SA]) !== 0 && FA($, DA -= rA[SA], EA), dA($, SA = yA(--bA), GA), (EA = iA[SA]) !== 0 && FA($, bA -= hA[SA], EA)), mA < $.last_lit; )
                      ;
                  dA($, x, BA);
                }
                function de($, BA) {
                  var GA, bA, DA, SA = BA.dyn_tree, EA = BA.stat_desc.static_tree, mA = BA.stat_desc.has_stree, YA = BA.stat_desc.elems, ZA = -1;
                  for ($.heap_len = 0, $.heap_max = F, GA = 0; GA < YA; GA++)
                    SA[2 * GA] !== 0 ? ($.heap[++$.heap_len] = ZA = GA, $.depth[GA] = 0) : SA[2 * GA + 1] = 0;
                  for (; $.heap_len < 2; )
                    SA[2 * (DA = $.heap[++$.heap_len] = ZA < 2 ? ++ZA : 0)] = 1, $.depth[DA] = 0, $.opt_len--, mA && ($.static_len -= EA[2 * DA + 1]);
                  for (BA.max_code = ZA, GA = $.heap_len >> 1; 1 <= GA; GA--)
                    Ae($, SA, GA);
                  for (DA = YA; GA = $.heap[1], $.heap[1] = $.heap[$.heap_len--], Ae($, SA, 1), bA = $.heap[1], $.heap[--$.heap_max] = GA, $.heap[--$.heap_max] = bA, SA[2 * DA] = SA[2 * GA] + SA[2 * bA], $.depth[DA] = ($.depth[GA] >= $.depth[bA] ? $.depth[GA] : $.depth[bA]) + 1, SA[2 * GA + 1] = SA[2 * bA + 1] = DA, $.heap[1] = DA++, Ae($, SA, 1), 2 <= $.heap_len; )
                    ;
                  $.heap[--$.heap_max] = $.heap[1], function(_A, Se) {
                    var cA, xA, gA, RA, UA, TA, ge = Se.dyn_tree, Me = Se.max_code, xe = Se.stat_desc.static_tree, we = Se.stat_desc.has_stree, Ee = Se.stat_desc.extra_bits, he = Se.stat_desc.extra_base, _e = Se.stat_desc.max_length, Pe = 0;
                    for (RA = 0; RA <= G; RA++)
                      _A.bl_count[RA] = 0;
                    for (ge[2 * _A.heap[_A.heap_max] + 1] = 0, cA = _A.heap_max + 1; cA < F; cA++)
                      _e < (RA = ge[2 * ge[2 * (xA = _A.heap[cA]) + 1] + 1] + 1) && (RA = _e, Pe++), ge[2 * xA + 1] = RA, Me < xA || (_A.bl_count[RA]++, UA = 0, he <= xA && (UA = Ee[xA - he]), TA = ge[2 * xA], _A.opt_len += TA * (RA + UA), we && (_A.static_len += TA * (xe[2 * xA + 1] + UA)));
                    if (Pe !== 0) {
                      do {
                        for (RA = _e - 1; _A.bl_count[RA] === 0; )
                          RA--;
                        _A.bl_count[RA]--, _A.bl_count[RA + 1] += 2, _A.bl_count[_e]--, Pe -= 2;
                      } while (0 < Pe);
                      for (RA = _e; RA !== 0; RA--)
                        for (xA = _A.bl_count[RA]; xA !== 0; )
                          Me < (gA = _A.heap[--cA]) || (ge[2 * gA + 1] !== RA && (_A.opt_len += (RA - ge[2 * gA + 1]) * ge[2 * gA], ge[2 * gA + 1] = RA), xA--);
                    }
                  }($, BA), JA(SA, ZA, $.bl_count);
                }
                function O($, BA, GA) {
                  var bA, DA, SA = -1, EA = BA[1], mA = 0, YA = 7, ZA = 4;
                  for (EA === 0 && (YA = 138, ZA = 3), BA[2 * (GA + 1) + 1] = 65535, bA = 0; bA <= GA; bA++)
                    DA = EA, EA = BA[2 * (bA + 1) + 1], ++mA < YA && DA === EA || (mA < ZA ? $.bl_tree[2 * DA] += mA : DA !== 0 ? (DA !== SA && $.bl_tree[2 * DA]++, $.bl_tree[2 * H]++) : mA <= 10 ? $.bl_tree[2 * _]++ : $.bl_tree[2 * j]++, SA = DA, ZA = (mA = 0) === EA ? (YA = 138, 3) : DA === EA ? (YA = 6, 3) : (YA = 7, 4));
                }
                function AA($, BA, GA) {
                  var bA, DA, SA = -1, EA = BA[1], mA = 0, YA = 7, ZA = 4;
                  for (EA === 0 && (YA = 138, ZA = 3), bA = 0; bA <= GA; bA++)
                    if (DA = EA, EA = BA[2 * (bA + 1) + 1], !(++mA < YA && DA === EA)) {
                      if (mA < ZA)
                        for (; dA($, DA, $.bl_tree), --mA != 0; )
                          ;
                      else
                        DA !== 0 ? (DA !== SA && (dA($, DA, $.bl_tree), mA--), dA($, H, $.bl_tree), FA($, mA - 3, 2)) : mA <= 10 ? (dA($, _, $.bl_tree), FA($, mA - 3, 3)) : (dA($, j, $.bl_tree), FA($, mA - 11, 7));
                      SA = DA, ZA = (mA = 0) === EA ? (YA = 138, 3) : DA === EA ? (YA = 6, 3) : (YA = 7, 4);
                    }
                }
                p(hA);
                var q = !1;
                function Z($, BA, GA, bA) {
                  FA($, (D << 1) + (bA ? 1 : 0), 3), function(DA, SA, EA, mA) {
                    ee(DA), mA && (kA(DA, EA), kA(DA, ~EA)), c.arraySet(DA.pending_buf, DA.window, SA, EA, DA.pending), DA.pending += EA;
                  }($, BA, GA, !0);
                }
                C._tr_init = function($) {
                  q || (function() {
                    var BA, GA, bA, DA, SA, EA = new Array(G + 1);
                    for (DA = bA = 0; DA < f - 1; DA++)
                      for (rA[DA] = bA, BA = 0; BA < 1 << V[DA]; BA++)
                        Y[bA++] = DA;
                    for (Y[bA - 1] = DA, DA = SA = 0; DA < 16; DA++)
                      for (hA[DA] = SA, BA = 0; BA < 1 << iA[DA]; BA++)
                        tA[SA++] = DA;
                    for (SA >>= 7; DA < m; DA++)
                      for (hA[DA] = SA << 7, BA = 0; BA < 1 << iA[DA] - 7; BA++)
                        tA[256 + SA++] = DA;
                    for (GA = 0; GA <= G; GA++)
                      EA[GA] = 0;
                    for (BA = 0; BA <= 143; )
                      P[2 * BA + 1] = 8, BA++, EA[8]++;
                    for (; BA <= 255; )
                      P[2 * BA + 1] = 9, BA++, EA[9]++;
                    for (; BA <= 279; )
                      P[2 * BA + 1] = 7, BA++, EA[7]++;
                    for (; BA <= 287; )
                      P[2 * BA + 1] = 8, BA++, EA[8]++;
                    for (JA(P, y + 1, EA), BA = 0; BA < m; BA++)
                      J[2 * BA + 1] = 5, J[2 * BA] = vA(BA, 5);
                    QA = new fA(P, V, S + 1, y, G), aA = new fA(J, iA, 0, m, G), MA = new fA(new Array(0), eA, 0, N, v);
                  }(), q = !0), $.l_desc = new wA($.dyn_ltree, QA), $.d_desc = new wA($.dyn_dtree, aA), $.bl_desc = new wA($.bl_tree, MA), $.bi_buf = 0, $.bi_valid = 0, ne($);
                }, C._tr_stored_block = Z, C._tr_flush_block = function($, BA, GA, bA) {
                  var DA, SA, EA = 0;
                  0 < $.level ? ($.strm.data_type === 2 && ($.strm.data_type = function(mA) {
                    var YA, ZA = 4093624447;
                    for (YA = 0; YA <= 31; YA++, ZA >>>= 1)
                      if (1 & ZA && mA.dyn_ltree[2 * YA] !== 0)
                        return u;
                    if (mA.dyn_ltree[18] !== 0 || mA.dyn_ltree[20] !== 0 || mA.dyn_ltree[26] !== 0)
                      return d;
                    for (YA = 32; YA < S; YA++)
                      if (mA.dyn_ltree[2 * YA] !== 0)
                        return d;
                    return u;
                  }($)), de($, $.l_desc), de($, $.d_desc), EA = function(mA) {
                    var YA;
                    for (O(mA, mA.dyn_ltree, mA.l_desc.max_code), O(mA, mA.dyn_dtree, mA.d_desc.max_code), de(mA, mA.bl_desc), YA = N - 1; 3 <= YA && mA.bl_tree[2 * oA[YA] + 1] === 0; YA--)
                      ;
                    return mA.opt_len += 3 * (YA + 1) + 5 + 5 + 4, YA;
                  }($), DA = $.opt_len + 3 + 7 >>> 3, (SA = $.static_len + 3 + 7 >>> 3) <= DA && (DA = SA)) : DA = SA = GA + 5, GA + 4 <= DA && BA !== -1 ? Z($, BA, GA, bA) : $.strategy === 4 || SA === DA ? (FA($, 2 + (bA ? 1 : 0), 3), ie($, P, J)) : (FA($, 4 + (bA ? 1 : 0), 3), function(mA, YA, ZA, _A) {
                    var Se;
                    for (FA(mA, YA - 257, 5), FA(mA, ZA - 1, 5), FA(mA, _A - 4, 4), Se = 0; Se < _A; Se++)
                      FA(mA, mA.bl_tree[2 * oA[Se] + 1], 3);
                    AA(mA, mA.dyn_ltree, YA - 1), AA(mA, mA.dyn_dtree, ZA - 1);
                  }($, $.l_desc.max_code + 1, $.d_desc.max_code + 1, EA + 1), ie($, $.dyn_ltree, $.dyn_dtree)), ne($), bA && ee($);
                }, C._tr_tally = function($, BA, GA) {
                  return $.pending_buf[$.d_buf + 2 * $.last_lit] = BA >>> 8 & 255, $.pending_buf[$.d_buf + 2 * $.last_lit + 1] = 255 & BA, $.pending_buf[$.l_buf + $.last_lit] = 255 & GA, $.last_lit++, BA === 0 ? $.dyn_ltree[2 * GA]++ : ($.matches++, BA--, $.dyn_ltree[2 * (Y[GA] + S + 1)]++, $.dyn_dtree[2 * yA(BA)]++), $.last_lit === $.lit_bufsize - 1;
                }, C._tr_align = function($) {
                  FA($, 2, 3), dA($, x, P), function(BA) {
                    BA.bi_valid === 16 ? (kA(BA, BA.bi_buf), BA.bi_buf = 0, BA.bi_valid = 0) : 8 <= BA.bi_valid && (BA.pending_buf[BA.pending++] = 255 & BA.bi_buf, BA.bi_buf >>= 8, BA.bi_valid -= 8);
                  }($);
                };
              }, { "../utils/common": 41 }], 53: [function(I, E, C) {
                E.exports = function() {
                  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
                };
              }, {}], 54: [function(I, E, C) {
                E.exports = typeof setImmediate == "function" ? setImmediate : function() {
                  var c = [].slice.apply(arguments);
                  c.splice(1, 0, 0), setTimeout.apply(null, c);
                };
              }, {}] }, {}, [10])(10);
            });
          }
        ),
        /***/
        560: (
          /***/
          () => {
            HTMLCanvasElement.prototype.toBlob || (HTMLCanvasElement.prototype.toBlob = function(r, s, B) {
              var I = this.toDataURL(s, B).split(",")[1];
              setTimeout(function() {
                for (var E = atob(I), C = E.length, c = new Uint8Array(C), u = 0; u < C; u++)
                  c[u] = E.charCodeAt(u);
                r(new Blob([c], { type: s || "image/png" }));
              });
            });
          }
        ),
        /***/
        650: (
          /***/
          (r, s, B) => {
            B.r(s), B.d(s, {
              /* harmony export */
              default: () => y
              /* harmony export */
            });
            function I(m, N) {
              if (!(m instanceof N))
                throw new TypeError("Cannot call a class as a function");
            }
            function E(m, N) {
              for (var F = 0; F < N.length; F++) {
                var G = N[F];
                G.enumerable = G.enumerable || !1, G.configurable = !0, "value" in G && (G.writable = !0), Object.defineProperty(m, G.key, G);
              }
            }
            function C(m, N, F) {
              return N && E(m.prototype, N), F && E(m, F), m;
            }
            function c(m) {
              return u(m) || d(m) || p(m) || f();
            }
            function u(m) {
              if (Array.isArray(m))
                return D(m);
            }
            function d(m) {
              if (typeof Symbol < "u" && Symbol.iterator in Object(m))
                return Array.from(m);
            }
            function p(m, N) {
              if (m) {
                if (typeof m == "string")
                  return D(m, N);
                var F = Object.prototype.toString.call(m).slice(8, -1);
                if (F === "Object" && m.constructor && (F = m.constructor.name), F === "Map" || F === "Set")
                  return Array.from(F);
                if (F === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(F))
                  return D(m, N);
              }
            }
            function D(m, N) {
              (N == null || N > m.length) && (N = m.length);
              for (var F = 0, G = new Array(N); F < N; F++)
                G[F] = m[F];
              return G;
            }
            function f() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            var S = function() {
              var m = ["a[href]", "area[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "button:not([disabled]):not([aria-hidden])", "iframe", "object", "embed", "[contenteditable]", '[tabindex]:not([tabindex^="-"])'], N = /* @__PURE__ */ function() {
                function V(iA) {
                  var eA = iA.targetModal, oA = iA.triggers, P = oA === void 0 ? [] : oA, J = iA.onShow, tA = J === void 0 ? function() {
                  } : J, Y = iA.onClose, rA = Y === void 0 ? function() {
                  } : Y, QA = iA.openTrigger, aA = QA === void 0 ? "data-micromodal-trigger" : QA, MA = iA.closeTrigger, hA = MA === void 0 ? "data-micromodal-close" : MA, fA = iA.openClass, wA = fA === void 0 ? "is-open" : fA, yA = iA.disableScroll, kA = yA === void 0 ? !1 : yA, FA = iA.disableFocus, dA = FA === void 0 ? !1 : FA, vA = iA.awaitCloseAnimation, JA = vA === void 0 ? !1 : vA, ne = iA.awaitOpenAnimation, ee = ne === void 0 ? !1 : ne, pe = iA.debugMode, Ae = pe === void 0 ? !1 : pe;
                  I(this, V), this.modal = document.getElementById(eA), this.config = {
                    debugMode: Ae,
                    disableScroll: kA,
                    openTrigger: aA,
                    closeTrigger: hA,
                    openClass: wA,
                    onShow: tA,
                    onClose: rA,
                    awaitCloseAnimation: JA,
                    awaitOpenAnimation: ee,
                    disableFocus: dA
                  }, P.length > 0 && this.registerTriggers.apply(this, c(P)), this.onClick = this.onClick.bind(this), this.onKeydown = this.onKeydown.bind(this);
                }
                return C(V, [{
                  key: "registerTriggers",
                  value: function() {
                    for (var eA = this, oA = arguments.length, P = new Array(oA), J = 0; J < oA; J++)
                      P[J] = arguments[J];
                    P.filter(Boolean).forEach(function(tA) {
                      tA.addEventListener("click", function(Y) {
                        return eA.showModal(Y);
                      });
                    });
                  }
                }, {
                  key: "showModal",
                  value: function() {
                    var eA = this, oA = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                    if (this.activeElement = document.activeElement, this.modal.setAttribute("aria-hidden", "false"), this.modal.classList.add(this.config.openClass), this.scrollBehaviour("disable"), this.addEventListeners(), this.config.awaitOpenAnimation) {
                      var P = function J() {
                        eA.modal.removeEventListener("animationend", J, !1), eA.setFocusToFirstNode();
                      };
                      this.modal.addEventListener("animationend", P, !1);
                    } else
                      this.setFocusToFirstNode();
                    this.config.onShow(this.modal, this.activeElement, oA);
                  }
                }, {
                  key: "closeModal",
                  value: function() {
                    var eA = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, oA = this.modal;
                    if (this.modal.setAttribute("aria-hidden", "true"), this.removeEventListeners(), this.scrollBehaviour("enable"), this.activeElement && this.activeElement.focus && this.activeElement.focus(), this.config.onClose(this.modal, this.activeElement, eA), this.config.awaitCloseAnimation) {
                      var P = this.config.openClass;
                      this.modal.addEventListener("animationend", function J() {
                        oA.classList.remove(P), oA.removeEventListener("animationend", J, !1);
                      }, !1);
                    } else
                      oA.classList.remove(this.config.openClass);
                  }
                }, {
                  key: "closeModalById",
                  value: function(eA) {
                    this.modal = document.getElementById(eA), this.modal && this.closeModal();
                  }
                }, {
                  key: "scrollBehaviour",
                  value: function(eA) {
                    if (this.config.disableScroll) {
                      var oA = document.querySelector("body");
                      switch (eA) {
                        case "enable":
                          Object.assign(oA.style, {
                            overflow: ""
                          });
                          break;
                        case "disable":
                          Object.assign(oA.style, {
                            overflow: "hidden"
                          });
                          break;
                      }
                    }
                  }
                }, {
                  key: "addEventListeners",
                  value: function() {
                    this.modal.addEventListener("touchstart", this.onClick), this.modal.addEventListener("click", this.onClick), document.addEventListener("keydown", this.onKeydown);
                  }
                }, {
                  key: "removeEventListeners",
                  value: function() {
                    this.modal.removeEventListener("touchstart", this.onClick), this.modal.removeEventListener("click", this.onClick), document.removeEventListener("keydown", this.onKeydown);
                  }
                }, {
                  key: "onClick",
                  value: function(eA) {
                    eA.target.hasAttribute(this.config.closeTrigger) && this.closeModal(eA);
                  }
                }, {
                  key: "onKeydown",
                  value: function(eA) {
                    eA.keyCode === 27 && this.closeModal(eA), eA.keyCode === 9 && this.retainFocus(eA);
                  }
                }, {
                  key: "getFocusableNodes",
                  value: function() {
                    var eA = this.modal.querySelectorAll(m);
                    return Array.apply(void 0, c(eA));
                  }
                  /**
                   * Tries to set focus on a node which is not a close trigger
                   * if no other nodes exist then focuses on first close trigger
                   */
                }, {
                  key: "setFocusToFirstNode",
                  value: function() {
                    var eA = this;
                    if (!this.config.disableFocus) {
                      var oA = this.getFocusableNodes();
                      if (oA.length !== 0) {
                        var P = oA.filter(function(J) {
                          return !J.hasAttribute(eA.config.closeTrigger);
                        });
                        P.length > 0 && P[0].focus(), P.length === 0 && oA[0].focus();
                      }
                    }
                  }
                }, {
                  key: "retainFocus",
                  value: function(eA) {
                    var oA = this.getFocusableNodes();
                    if (oA.length !== 0)
                      if (oA = oA.filter(function(J) {
                        return J.offsetParent !== null;
                      }), !this.modal.contains(document.activeElement))
                        oA[0].focus();
                      else {
                        var P = oA.indexOf(document.activeElement);
                        eA.shiftKey && P === 0 && (oA[oA.length - 1].focus(), eA.preventDefault()), !eA.shiftKey && oA.length > 0 && P === oA.length - 1 && (oA[0].focus(), eA.preventDefault());
                      }
                  }
                }]), V;
              }(), F = null, G = function(iA, eA) {
                var oA = [];
                return iA.forEach(function(P) {
                  var J = P.attributes[eA].value;
                  oA[J] === void 0 && (oA[J] = []), oA[J].push(P);
                }), oA;
              }, k = function(iA) {
                if (!document.getElementById(iA))
                  return console.warn("MicroModal: Seems like you have missed %c'".concat(iA, "'"), "background-color: #f8f9fa;color: #50596c;font-weight: bold;", "ID somewhere in your code. Refer example below to resolve it."), console.warn("%cExample:", "background-color: #f8f9fa;color: #50596c;font-weight: bold;", '<div class="modal" id="'.concat(iA, '"></div>')), !1;
              }, v = function(iA) {
                if (iA.length <= 0)
                  return console.warn("MicroModal: Please specify at least one %c'micromodal-trigger'", "background-color: #f8f9fa;color: #50596c;font-weight: bold;", "data attribute."), console.warn("%cExample:", "background-color: #f8f9fa;color: #50596c;font-weight: bold;", '<a href="#" data-micromodal-trigger="my-modal"></a>'), !1;
              }, x = function(iA, eA) {
                if (v(iA), !eA)
                  return !0;
                for (var oA in eA)
                  k(oA);
                return !0;
              }, H = function(iA) {
                var eA = Object.assign({}, {
                  openTrigger: "data-micromodal-trigger"
                }, iA), oA = c(document.querySelectorAll("[".concat(eA.openTrigger, "]"))), P = G(oA, eA.openTrigger);
                if (!(eA.debugMode === !0 && x(oA, P) === !1))
                  for (var J in P) {
                    var tA = P[J];
                    eA.targetModal = J, eA.triggers = c(tA), F = new N(eA);
                  }
              }, _ = function(iA, eA) {
                var oA = eA || {};
                oA.targetModal = iA, !(oA.debugMode === !0 && k(iA) === !1) && (F && F.removeEventListeners(), F = new N(oA), F.showModal());
              }, j = function(iA) {
                iA ? F.closeModalById(iA) : F.closeModal();
              };
              return {
                init: H,
                show: _,
                close: j
              };
            }();
            window.MicroModal = S;
            const y = S;
          }
        ),
        /***/
        57: (
          /***/
          (r, s, B) => {
            B.r(s), B.d(s, {
              /* harmony export */
              default: () => I
              /* harmony export */
            });
            const I = `(function(b){function a(b,d){if({}.hasOwnProperty.call(a.cache,b))return a.cache[b];var e=a.resolve(b);if(!e)throw new Error('Failed to resolve module '+b);var c={id:b,require:a,filename:b,exports:{},loaded:!1,parent:d,children:[]};d&&d.children.push(c);var f=b.slice(0,b.lastIndexOf('/')+1);return a.cache[b]=c.exports,e.call(c.exports,c,c.exports,f,b),c.loaded=!0,a.cache[b]=c.exports}a.modules={},a.cache={},a.resolve=function(b){return{}.hasOwnProperty.call(a.modules,b)?a.modules[b]:void 0},a.define=function(b,c){a.modules[b]=c},a.define('/gif.worker.coffee',function(d,e,f,g){var b,c;b=a('/GIFEncoder.js',d),c=function(a){var c,e,d,f;return c=new b(a.width,a.height),a.index===0?c.writeHeader():c.firstFrame=!1,c.setTransparent(a.transparent),c.setRepeat(a.repeat),c.setDelay(a.delay),c.setQuality(a.quality),c.addFrame(a.data),a.last&&c.finish(),d=c.stream(),a.data=d.pages,a.cursor=d.cursor,a.pageSize=d.constructor.pageSize,a.canTransfer?(f=function(c){for(var b=0,d=a.data.length;b<d;++b)e=a.data[b],c.push(e.buffer);return c}.call(this,[]),self.postMessage(a,f)):self.postMessage(a)},self.onmessage=function(a){return c(a.data)}}),a.define('/GIFEncoder.js',function(e,h,i,j){function c(){this.page=-1,this.pages=[],this.newPage()}function b(a,b){this.width=~~a,this.height=~~b,this.transparent=null,this.transIndex=0,this.repeat=-1,this.delay=0,this.image=null,this.pixels=null,this.indexedPixels=null,this.colorDepth=null,this.colorTab=null,this.usedEntry=new Array,this.palSize=7,this.dispose=-1,this.firstFrame=!0,this.sample=10,this.out=new c}var f=a('/TypedNeuQuant.js',e),g=a('/LZWEncoder.js',e);c.pageSize=4096,c.charMap={};for(var d=0;d<256;d++)c.charMap[d]=String.fromCharCode(d);c.prototype.newPage=function(){this.pages[++this.page]=new Uint8Array(c.pageSize),this.cursor=0},c.prototype.getData=function(){var d='';for(var a=0;a<this.pages.length;a++)for(var b=0;b<c.pageSize;b++)d+=c.charMap[this.pages[a][b]];return d},c.prototype.writeByte=function(a){this.cursor>=c.pageSize&&this.newPage(),this.pages[this.page][this.cursor++]=a},c.prototype.writeUTFBytes=function(b){for(var c=b.length,a=0;a<c;a++)this.writeByte(b.charCodeAt(a))},c.prototype.writeBytes=function(b,d,e){for(var c=e||b.length,a=d||0;a<c;a++)this.writeByte(b[a])},b.prototype.setDelay=function(a){this.delay=Math.round(a/10)},b.prototype.setFrameRate=function(a){this.delay=Math.round(100/a)},b.prototype.setDispose=function(a){a>=0&&(this.dispose=a)},b.prototype.setRepeat=function(a){this.repeat=a},b.prototype.setTransparent=function(a){this.transparent=a},b.prototype.addFrame=function(a){this.image=a,this.getImagePixels(),this.analyzePixels(),this.firstFrame&&(this.writeLSD(),this.writePalette(),this.repeat>=0&&this.writeNetscapeExt()),this.writeGraphicCtrlExt(),this.writeImageDesc(),this.firstFrame||this.writePalette(),this.writePixels(),this.firstFrame=!1},b.prototype.finish=function(){this.out.writeByte(59)},b.prototype.setQuality=function(a){a<1&&(a=1),this.sample=a},b.prototype.writeHeader=function(){this.out.writeUTFBytes('GIF89a')},b.prototype.analyzePixels=function(){var g=this.pixels.length,d=g/3;this.indexedPixels=new Uint8Array(d);var a=new f(this.pixels,this.sample);a.buildColormap(),this.colorTab=a.getColormap();var b=0;for(var c=0;c<d;c++){var e=a.lookupRGB(this.pixels[b++]&255,this.pixels[b++]&255,this.pixels[b++]&255);this.usedEntry[e]=!0,this.indexedPixels[c]=e}this.pixels=null,this.colorDepth=8,this.palSize=7,this.transparent!==null&&(this.transIndex=this.findClosest(this.transparent))},b.prototype.findClosest=function(e){if(this.colorTab===null)return-1;var k=(e&16711680)>>16,l=(e&65280)>>8,m=e&255,c=0,d=16777216,j=this.colorTab.length;for(var a=0;a<j;){var f=k-(this.colorTab[a++]&255),g=l-(this.colorTab[a++]&255),h=m-(this.colorTab[a]&255),i=f*f+g*g+h*h,b=parseInt(a/3);this.usedEntry[b]&&i<d&&(d=i,c=b),a++}return c},b.prototype.getImagePixels=function(){var a=this.width,g=this.height;this.pixels=new Uint8Array(a*g*3);var b=this.image,c=0;for(var d=0;d<g;d++)for(var e=0;e<a;e++){var f=d*a*4+e*4;this.pixels[c++]=b[f],this.pixels[c++]=b[f+1],this.pixels[c++]=b[f+2]}},b.prototype.writeGraphicCtrlExt=function(){this.out.writeByte(33),this.out.writeByte(249),this.out.writeByte(4);var b,a;this.transparent===null?(b=0,a=0):(b=1,a=2),this.dispose>=0&&(a=dispose&7),a<<=2,this.out.writeByte(0|a|0|b),this.writeShort(this.delay),this.out.writeByte(this.transIndex),this.out.writeByte(0)},b.prototype.writeImageDesc=function(){this.out.writeByte(44),this.writeShort(0),this.writeShort(0),this.writeShort(this.width),this.writeShort(this.height),this.firstFrame?this.out.writeByte(0):this.out.writeByte(128|this.palSize)},b.prototype.writeLSD=function(){this.writeShort(this.width),this.writeShort(this.height),this.out.writeByte(240|this.palSize),this.out.writeByte(0),this.out.writeByte(0)},b.prototype.writeNetscapeExt=function(){this.out.writeByte(33),this.out.writeByte(255),this.out.writeByte(11),this.out.writeUTFBytes('NETSCAPE2.0'),this.out.writeByte(3),this.out.writeByte(1),this.writeShort(this.repeat),this.out.writeByte(0)},b.prototype.writePalette=function(){this.out.writeBytes(this.colorTab);var b=768-this.colorTab.length;for(var a=0;a<b;a++)this.out.writeByte(0)},b.prototype.writeShort=function(a){this.out.writeByte(a&255),this.out.writeByte(a>>8&255)},b.prototype.writePixels=function(){var a=new g(this.width,this.height,this.indexedPixels,this.colorDepth);a.encode(this.out)},b.prototype.stream=function(){return this.out},e.exports=b}),a.define('/LZWEncoder.js',function(e,g,h,i){function f(y,D,C,B){function w(a,b){r[f++]=a,f>=254&&t(b)}function x(b){u(a),k=i+2,j=!0,l(i,b)}function u(b){for(var a=0;a<b;++a)h[a]=-1}function A(z,r){var g,t,d,e,y,w,s;for(q=z,j=!1,n_bits=q,m=p(n_bits),i=1<<z-1,o=i+1,k=i+2,f=0,e=v(),s=0,g=a;g<65536;g*=2)++s;s=8-s,w=a,u(w),l(i,r);a:while((t=v())!=c){if(g=(t<<b)+e,d=t<<s^e,h[d]===g){e=n[d];continue}if(h[d]>=0){y=w-d,d===0&&(y=1);do if((d-=y)<0&&(d+=w),h[d]===g){e=n[d];continue a}while(h[d]>=0)}l(e,r),e=t,k<1<<b?(n[d]=k++,h[d]=g):x(r)}l(e,r),l(o,r)}function z(a){a.writeByte(s),remaining=y*D,curPixel=0,A(s+1,a),a.writeByte(0)}function t(a){f>0&&(a.writeByte(f),a.writeBytes(r,0,f),f=0)}function p(a){return(1<<a)-1}function v(){if(remaining===0)return c;--remaining;var a=C[curPixel++];return a&255}function l(a,c){g&=d[e],e>0?g|=a<<e:g=a,e+=n_bits;while(e>=8)w(g&255,c),g>>=8,e-=8;if((k>m||j)&&(j?(m=p(n_bits=q),j=!1):(++n_bits,n_bits==b?m=1<<b:m=p(n_bits))),a==o){while(e>0)w(g&255,c),g>>=8,e-=8;t(c)}}var s=Math.max(2,B),r=new Uint8Array(256),h=new Int32Array(a),n=new Int32Array(a),g,e=0,f,k=0,m,j=!1,q,i,o;this.encode=z}var c=-1,b=12,a=5003,d=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535];e.exports=f}),a.define('/TypedNeuQuant.js',function(A,F,E,D){function C(A,B){function I(){o=[],q=new Int32Array(256),t=new Int32Array(a),y=new Int32Array(a),z=new Int32Array(a>>3);var c,d;for(c=0;c<a;c++)d=(c<<b+8)/a,o[c]=new Float64Array([d,d,d,0]),y[c]=e/a,t[c]=0}function J(){for(var c=0;c<a;c++)o[c][0]>>=b,o[c][1]>>=b,o[c][2]>>=b,o[c][3]=c}function K(b,a,c,e,f){o[a][0]-=b*(o[a][0]-c)/d,o[a][1]-=b*(o[a][1]-e)/d,o[a][2]-=b*(o[a][2]-f)/d}function L(j,e,n,l,k){var h=Math.abs(e-j),i=Math.min(e+j,a),g=e+1,f=e-1,m=1,b,d;while(g<i||f>h)d=z[m++],g<i&&(b=o[g++],b[0]-=d*(b[0]-n)/c,b[1]-=d*(b[1]-l)/c,b[2]-=d*(b[2]-k)/c),f>h&&(b=o[f--],b[0]-=d*(b[0]-n)/c,b[1]-=d*(b[1]-l)/c,b[2]-=d*(b[2]-k)/c)}function C(p,s,q){var h=2147483647,k=h,d=-1,m=d,c,j,e,n,l;for(c=0;c<a;c++)j=o[c],e=Math.abs(j[0]-p)+Math.abs(j[1]-s)+Math.abs(j[2]-q),e<h&&(h=e,d=c),n=e-(t[c]>>i-b),n<k&&(k=n,m=c),l=y[c]>>g,y[c]-=l,t[c]+=l<<f;return y[d]+=x,t[d]-=r,m}function D(){var d,b,e,c,h,g,f=0,i=0;for(d=0;d<a;d++){for(e=o[d],h=d,g=e[1],b=d+1;b<a;b++)c=o[b],c[1]<g&&(h=b,g=c[1]);if(c=o[h],d!=h&&(b=c[0],c[0]=e[0],e[0]=b,b=c[1],c[1]=e[1],e[1]=b,b=c[2],c[2]=e[2],e[2]=b,b=c[3],c[3]=e[3],e[3]=b),g!=f){for(q[f]=i+d>>1,b=f+1;b<g;b++)q[b]=d;f=g,i=d}}for(q[f]=i+n>>1,b=f+1;b<256;b++)q[b]=n}function E(j,i,k){var b,d,c,e=1e3,h=-1,f=q[i],g=f-1;while(f<a||g>=0)f<a&&(d=o[f],c=d[1]-i,c>=e?f=a:(f++,c<0&&(c=-c),b=d[0]-j,b<0&&(b=-b),c+=b,c<e&&(b=d[2]-k,b<0&&(b=-b),c+=b,c<e&&(e=c,h=d[3])))),g>=0&&(d=o[g],c=i-d[1],c>=e?g=-1:(g--,c<0&&(c=-c),b=d[0]-j,b<0&&(b=-b),c+=b,c<e&&(b=d[2]-k,b<0&&(b=-b),c+=b,c<e&&(e=c,h=d[3]))));return h}function F(){var c,f=A.length,D=30+(B-1)/3,y=f/(3*B),q=~~(y/w),n=d,o=u,a=o>>h;for(a<=1&&(a=0),c=0;c<a;c++)z[c]=n*((a*a-c*c)*m/(a*a));var i;f<s?(B=1,i=3):f%l!==0?i=3*l:f%k!==0?i=3*k:f%p!==0?i=3*p:i=3*j;var r,t,x,e,g=0;c=0;while(c<y)if(r=(A[g]&255)<<b,t=(A[g+1]&255)<<b,x=(A[g+2]&255)<<b,e=C(r,t,x),K(n,e,r,t,x),a!==0&&L(a,e,r,t,x),g+=i,g>=f&&(g-=f),c++,q===0&&(q=1),c%q===0)for(n-=n/D,o-=o/v,a=o>>h,a<=1&&(a=0),e=0;e<a;e++)z[e]=n*((a*a-e*e)*m/(a*a))}function G(){I(),F(),J(),D()}function H(){var b=[],g=[];for(var c=0;c<a;c++)g[o[c][3]]=c;var d=0;for(var e=0;e<a;e++){var f=g[e];b[d++]=o[f][0],b[d++]=o[f][1],b[d++]=o[f][2]}return b}var o,q,t,y,z;this.buildColormap=G,this.getColormap=H,this.lookupRGB=E}var w=100,a=256,n=a-1,b=4,i=16,e=1<<i,f=10,B=1<<f,g=10,x=e>>g,r=e<<f-g,z=a>>3,h=6,t=1<<h,u=z*t,v=30,o=10,d=1<<o,q=8,m=1<<q,y=o+q,c=1<<y,l=499,k=491,p=487,j=503,s=3*j;A.exports=C}),a('/gif.worker.coffee')}.call(this,this))\r
//# sourceMappingURL=gif.worker.js.map\r
// gif.worker.js 0.1.6 - https://github.com/jnordberg/gif.js`;
          }
        ),
        /***/
        72: (
          /***/
          function(r, s, B) {
            var I, E;
            (function(C, c) {
              I = c, E = typeof I == "function" ? I.call(s, B, s, r) : I, E !== void 0 && (r.exports = E);
            })(this, function() {
              function C() {
                var c = arguments.length;
                if (c === 0)
                  throw new Error("resolveUrl requires at least one argument; got none.");
                var u = document.createElement("base");
                if (u.href = arguments[0], c === 1)
                  return u.href;
                var d = document.getElementsByTagName("head")[0];
                d.insertBefore(u, d.firstChild);
                for (var p = document.createElement("a"), D, f = 1; f < c; f++)
                  p.href = arguments[f], D = p.href, u.href = D;
                return d.removeChild(u), D;
              }
              return C;
            });
          }
        ),
        /***/
        914: (
          /***/
          function(r, s, B) {
            var I = this && this.__assign || function() {
              return I = Object.assign || function(cA) {
                for (var xA, gA = 1, RA = arguments.length; gA < RA; gA++) {
                  xA = arguments[gA];
                  for (var UA in xA)
                    Object.prototype.hasOwnProperty.call(xA, UA) && (cA[UA] = xA[UA]);
                }
                return cA;
              }, I.apply(this, arguments);
            }, E = this && this.__awaiter || function(cA, xA, gA, RA) {
              function UA(TA) {
                return TA instanceof gA ? TA : new gA(function(ge) {
                  ge(TA);
                });
              }
              return new (gA || (gA = Promise))(function(TA, ge) {
                function Me(Ee) {
                  try {
                    we(RA.next(Ee));
                  } catch (he) {
                    ge(he);
                  }
                }
                function xe(Ee) {
                  try {
                    we(RA.throw(Ee));
                  } catch (he) {
                    ge(he);
                  }
                }
                function we(Ee) {
                  Ee.done ? TA(Ee.value) : UA(Ee.value).then(Me, xe);
                }
                we((RA = RA.apply(cA, xA || [])).next());
              });
            }, C = this && this.__generator || function(cA, xA) {
              var gA = { label: 0, sent: function() {
                if (TA[0] & 1)
                  throw TA[1];
                return TA[1];
              }, trys: [], ops: [] }, RA, UA, TA, ge;
              return ge = { next: Me(0), throw: Me(1), return: Me(2) }, typeof Symbol == "function" && (ge[Symbol.iterator] = function() {
                return this;
              }), ge;
              function Me(we) {
                return function(Ee) {
                  return xe([we, Ee]);
                };
              }
              function xe(we) {
                if (RA)
                  throw new TypeError("Generator is already executing.");
                for (; gA; )
                  try {
                    if (RA = 1, UA && (TA = we[0] & 2 ? UA.return : we[0] ? UA.throw || ((TA = UA.return) && TA.call(UA), 0) : UA.next) && !(TA = TA.call(UA, we[1])).done)
                      return TA;
                    switch (UA = 0, TA && (we = [we[0] & 2, TA.value]), we[0]) {
                      case 0:
                      case 1:
                        TA = we;
                        break;
                      case 4:
                        return gA.label++, { value: we[1], done: !1 };
                      case 5:
                        gA.label++, UA = we[1], we = [0];
                        continue;
                      case 7:
                        we = gA.ops.pop(), gA.trys.pop();
                        continue;
                      default:
                        if (TA = gA.trys, !(TA = TA.length > 0 && TA[TA.length - 1]) && (we[0] === 6 || we[0] === 2)) {
                          gA = 0;
                          continue;
                        }
                        if (we[0] === 3 && (!TA || we[1] > TA[0] && we[1] < TA[3])) {
                          gA.label = we[1];
                          break;
                        }
                        if (we[0] === 6 && gA.label < TA[1]) {
                          gA.label = TA[1], TA = we;
                          break;
                        }
                        if (TA && gA.label < TA[2]) {
                          gA.label = TA[2], gA.ops.push(we);
                          break;
                        }
                        TA[2] && gA.ops.pop(), gA.trys.pop();
                        continue;
                    }
                    we = xA.call(cA, gA);
                  } catch (Ee) {
                    we = [6, Ee], UA = 0;
                  } finally {
                    RA = TA = 0;
                  }
                if (we[0] & 5)
                  throw we[1];
                return { value: we[0] ? we[1] : void 0, done: !0 };
              }
            }, c = this && this.__spreadArray || function(cA, xA, gA) {
              if (gA || arguments.length === 2)
                for (var RA = 0, UA = xA.length, TA; RA < UA; RA++)
                  (TA || !(RA in xA)) && (TA || (TA = Array.prototype.slice.call(xA, 0, RA)), TA[RA] = xA[RA]);
              return cA.concat(TA || Array.prototype.slice.call(xA));
            };
            Object.defineProperty(s, "__esModule", { value: !0 }), s.browserSupportsGIF = s.browserSupportsMP4 = s.browserSupportsWEBM = s.checkHotkeys = s.isRecording = s.stopRecord = s.recordFrame = s.takeJPEGSnapshot = s.takePNGSnapshot = s.beginJPEGFramesRecord = s.beginPNGFramesRecord = s.beginGIFRecord = s.beginVideoRecord = s.bindKeyToJPEGSnapshot = s.bindKeyToPNGSnapshot = s.bindKeyToJPEGFramesRecord = s.bindKeyToPNGFramesRecord = s.bindKeyToGIFRecord = s.bindKeyToVideoRecord = s.setVerbose = s.dispose = s.init = s.MP4 = s.WEBM = s.showDialog = void 0;
            var u = B(886), d = B(162);
            B(560);
            var p = B(809), D = B(848), f = B(330), S = B(57), y = B(733), m = URL.createObjectURL(new Blob([S.default])), N, F = void 0, G = B(330);
            Object.defineProperty(s, "showDialog", { enumerable: !0, get: function() {
              return G.showDialog;
            } });
            var k = "gif";
            s.WEBM = "webm", s.MP4 = "mp4";
            var v = "jpegzip", x = "pngzip", H = "jpeg", _ = "png", j = [];
            u.default;
            var V = [], iA = {}, eA = {}, oA = null;
            function P(cA, xA) {
              oA = cA, N = xA?.ffmpegCorePath || "https://unpkg.com/@ffmpeg/core@0.10.0/dist/ffmpeg-core.js", xA && xA.verbose !== void 0 && rA(xA.verbose), xA && xA.showAlerts !== void 0 && (D.PARAMS.SHOW_ALERTS = xA.showAlerts), xA && xA.showDialogs !== void 0 && (D.PARAMS.SHOW_DIALOGS = xA.showDialogs), xA && xA.showRecDot !== void 0 && (D.PARAMS.SHOW_REC_DOT = xA.showRecDot), D.PARAMS.SHOW_REC_DOT && (0, f.initDotWithCSS)(xA?.recDotCSS), oA.addEventListener("resize", tA), window.addEventListener("keydown", J);
            }
            s.init = P;
            function J(cA) {
              V.push({
                key: cA.key
              }), D.PARAMS.IS_MANUALLY_CHECKING_HOTKEYS || FA();
            }
            function tA() {
              if (j.length) {
                var cA = "Don't resize while recording canvas!";
                (0, f.showWarning)(cA);
              }
            }
            function Y() {
              oA?.removeEventListener("resize", tA), oA = null, window.removeEventListener("keydown", J);
            }
            s.dispose = Y;
            function rA(cA) {
              D.PARAMS.VERBOSE = !!cA, F && F.setLogging(D.PARAMS.VERBOSE);
            }
            s.setVerbose = rA;
            function QA() {
              if (oA === null)
                throw new Error("No canvas supplied, please call CanvasCapture.init() and pass in canvas element.");
            }
            function aA(cA, xA) {
              Object.keys(eA).forEach(function(gA) {
                eA[gA] === cA && delete eA[gA];
              }), eA[xA] = cA;
            }
            function MA(cA, xA) {
              xA?.format === s.WEBM ? (iA.webm = xA, aA(cA, s.WEBM)) : (iA.mp4 = xA, aA(cA, s.MP4));
            }
            s.bindKeyToVideoRecord = MA;
            function hA(cA, xA) {
              iA.gif = xA, aA(cA, k);
            }
            s.bindKeyToGIFRecord = hA;
            function fA(cA, xA) {
              iA.pngzip = xA, aA(cA, x);
            }
            s.bindKeyToPNGFramesRecord = fA;
            function wA(cA, xA) {
              iA.jpegzip = xA, aA(cA, v);
            }
            s.bindKeyToJPEGFramesRecord = wA;
            function yA(cA, xA) {
              iA.png = xA, aA(cA, _);
            }
            s.bindKeyToPNGSnapshot = yA;
            function kA(cA, xA) {
              iA.jpeg = xA, aA(cA, H);
            }
            s.bindKeyToJPEGSnapshot = kA;
            function FA() {
              for (var cA, xA, gA = 0; gA < V.length; gA++) {
                var RA = V[gA].key;
                if (eA.mp4 && RA === eA[s.MP4]) {
                  var UA = $(s.MP4);
                  if (UA.length)
                    Z(UA);
                  else {
                    if (!_A()) {
                      var TA = "This browser does not support MP4 video recording, please try again in Chrome.", ge = (cA = iA[s.MP4]) === null || cA === void 0 ? void 0 : cA.onError;
                      ge && ge(new Error(TA)), (0, f.showWarning)(TA);
                    }
                    vA(iA[s.MP4]);
                  }
                }
                if (eA.webm && RA === eA[s.WEBM]) {
                  var Me = $(s.WEBM);
                  if (Me.length)
                    Z(Me);
                  else {
                    if (!ZA()) {
                      var TA = "This browser does not support WEBM video recording, please try again in Chrome.", ge = (xA = iA[s.WEBM]) === null || xA === void 0 ? void 0 : xA.onError;
                      ge && ge(new Error(TA)), (0, f.showWarning)(TA);
                    }
                    vA(iA[s.WEBM]);
                  }
                }
                if (eA.gif && RA === eA[k]) {
                  var xe = $(k);
                  xe.length ? Z(xe) : JA(iA[k]);
                }
                if (eA.pngzip && RA === eA[x]) {
                  var we = $(x);
                  we.length ? Z(we) : ne(iA[x]);
                }
                if (eA.jpegzip && RA === eA[v]) {
                  var Ee = $(v);
                  Ee.length ? Z(Ee) : ee(iA[v]);
                }
                eA.png && RA === eA[_] && ie(iA[_]), eA.jpeg && RA === eA[H] && de(iA[H]);
              }
              V.length = 0;
            }
            function dA(cA) {
              j.push(cA), cA.type !== x && cA.type !== v && cA.capturer.start(), (0, f.showDot)(GA());
            }
            function vA(cA) {
              try {
                var xA = cA?.format || s.MP4;
                if (xA === s.MP4) {
                  if (!_A()) {
                    var gA = "This browser does not support MP4 video recording, please try again in Chrome.";
                    throw (0, f.showWarning)(gA), new Error(gA);
                  }
                } else if (xA === s.WEBM) {
                  if (!ZA()) {
                    var gA = "This browser does not support WEBM video recording, please try again in Chrome.";
                    throw (0, f.showWarning)(gA), new Error(gA);
                  }
                } else
                  throw new Error("invalid video format ".concat(xA, "."));
                if (BA().length) {
                  var gA = "CCapture.js only supports one video/gif capture at a time.";
                  throw (0, f.showWarning)(gA), new Error(gA);
                }
                var RA = 1;
                cA && cA.quality && (RA = cA.quality);
                var UA = cA?.name || "Video_Capture", TA = new window.CCapture({
                  format: s.WEBM,
                  name: UA,
                  framerate: cA?.fps || 60,
                  quality: RA * 100,
                  verbose: D.PARAMS.VERBOSE
                }), ge = {
                  name: UA,
                  capturer: TA,
                  numFrames: 0,
                  type: xA,
                  ffmpegOptions: cA?.ffmpegOptions,
                  onExportProgress: cA?.onExportProgress,
                  onExport: cA?.onExport,
                  onExportFinish: cA?.onExportFinish,
                  onError: cA?.onError
                };
                return dA(ge), ge;
              } catch (Me) {
                if (cA?.onError)
                  cA.onError(Me);
                else
                  throw Me;
              }
            }
            s.beginVideoRecord = vA;
            function JA(cA) {
              try {
                if (BA().length) {
                  var xA = "CCapture.js only supports one video/gif capture at a time.";
                  throw (0, f.showWarning)(xA), new Error(xA);
                }
                var gA = 100;
                cA && cA.quality && (gA = cA.quality * 100);
                var RA = cA?.name || "GIF_Capture", UA = new window.CCapture({
                  format: k,
                  name: RA,
                  framerate: cA?.fps || 60,
                  workersPath: m,
                  quality: gA,
                  verbose: D.PARAMS.VERBOSE,
                  onProgress: cA?.onExportProgress
                }), TA = {
                  name: RA,
                  capturer: UA,
                  numFrames: 0,
                  type: k,
                  onExport: cA?.onExport,
                  onExportFinish: cA?.onExportFinish,
                  onError: cA?.onError
                };
                return dA(TA), TA;
              } catch (ge) {
                if (cA?.onError)
                  cA.onError(ge);
                else
                  throw ge;
              }
            }
            s.beginGIFRecord = JA;
            function ne(cA) {
              try {
                var xA = cA?.name || "PNG_Frames_Capture", gA = { dpi: cA?.dpi }, RA = {
                  name: xA,
                  zipOptions: gA,
                  zipPromises: [],
                  capturer: new y(),
                  numFrames: 0,
                  type: x,
                  onExportProgress: cA?.onExportProgress,
                  onExport: cA?.onExport,
                  onExportFinish: cA?.onExportFinish,
                  onError: cA?.onError
                };
                return dA(RA), RA;
              } catch (UA) {
                if (cA?.onError)
                  cA.onError(UA);
                else
                  throw UA;
              }
            }
            s.beginPNGFramesRecord = ne;
            function ee(cA) {
              try {
                var xA = cA?.name || "JPEG_Frames_Capture", gA = { dpi: cA?.dpi, quality: cA?.quality }, RA = {
                  name: xA,
                  zipOptions: gA,
                  zipPromises: [],
                  capturer: new y(),
                  numFrames: 0,
                  type: v,
                  onExportProgress: cA?.onExportProgress,
                  onExport: cA?.onExport,
                  onExportFinish: cA?.onExportFinish,
                  onError: cA?.onError
                };
                return dA(RA), RA;
              } catch (UA) {
                if (cA?.onError)
                  cA.onError(UA);
                else
                  throw UA;
              }
            }
            s.beginJPEGFramesRecord = ee;
            function pe(cA, xA, gA) {
              return E(this, void 0, void 0, function() {
                return C(this, function(RA) {
                  return [2, new Promise(function(UA) {
                    cA.toBlob(function(TA) {
                      UA(TA);
                    }, "image/".concat(xA), gA);
                  })];
                });
              });
            }
            function Ae(cA, xA, gA, RA) {
              return E(this, void 0, void 0, function() {
                var UA, TA, ge, Me;
                return C(this, function(xe) {
                  switch (xe.label) {
                    case 0:
                      return QA(), UA = RA?.onExportFinish, [4, pe(oA, xA, gA)];
                    case 1:
                      if (TA = xe.sent(), !TA)
                        throw ge = "Problem saving ".concat(xA.toUpperCase(), ", please try again!"), (0, f.showWarning)(ge), new Error(ge);
                      return Me = RA?.onExport || d.saveAs, RA?.dpi ? [4, (0, p.changeDpiBlob)(TA, RA?.dpi).then(function(we) {
                        Me(we, cA), UA && UA();
                      })] : [3, 3];
                    case 2:
                      return xe.sent(), [3, 4];
                    case 3:
                      Me(TA, cA), UA && UA(), xe.label = 4;
                    case 4:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }
            function ie(cA) {
              return E(this, void 0, void 0, function() {
                var xA, gA, RA;
                return C(this, function(UA) {
                  switch (UA.label) {
                    case 0:
                      return UA.trys.push([0, 2, , 3]), xA = cA?.name || "PNG_Capture", gA = "".concat(xA, ".png"), [4, Ae(gA, _, void 0, cA)];
                    case 1:
                      return UA.sent(), [3, 3];
                    case 2:
                      if (RA = UA.sent(), cA?.onError)
                        cA.onError(RA);
                      else
                        throw RA;
                      return [3, 3];
                    case 3:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }
            s.takePNGSnapshot = ie;
            function de(cA) {
              return E(this, void 0, void 0, function() {
                var xA, gA, RA;
                return C(this, function(UA) {
                  switch (UA.label) {
                    case 0:
                      return UA.trys.push([0, 2, , 3]), xA = cA?.name || "JPEG_Capture", gA = "".concat(xA, ".jpg"), [4, Ae(gA, H, cA?.quality || 1, cA)];
                    case 1:
                      return UA.sent(), [3, 3];
                    case 2:
                      if (RA = UA.sent(), cA?.onError)
                        cA.onError(RA);
                      else
                        throw RA;
                      return [3, 3];
                    case 3:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }
            s.takeJPEGSnapshot = de;
            function O(cA) {
              var xA = j;
              cA && (Array.isArray(cA) ? xA = cA : xA = [cA]);
              try {
                if (QA(), xA.length === 0) {
                  var gA = "No valid capturer inited, please call CanvasCapture.beginVideoRecord(), CanvasCapture.beginGIFRecord(), CanvasCapture.beginPNGFramesRecord(), or CanvasCapture.beginJPEGFramesRecord() first.";
                  throw (0, f.showWarning)(gA), new Error(gA);
                }
                for (var RA = function(Me) {
                  var xe = xA[Me], we = xe.capturer, Ee = xe.type, he = xe.zipOptions, _e = xe.zipPromises, Pe = xe.numFrames;
                  if (Ee === v || Ee === x) {
                    var Nt = "frame_".concat(Pe + 1), Jt = new Promise(function(vi, je) {
                      var Ri = {
                        dpi: he?.dpi,
                        quality: he.quality,
                        name: Nt,
                        onExport: function(lA, jA) {
                          we.file(jA, lA);
                        },
                        onExportFinish: vi,
                        onError: je
                      };
                      Ee === v ? de(Ri) : ie(Ri);
                    });
                    _e.push(Jt);
                  } else
                    we.capture(oA);
                  xA[Me].numFrames = Pe + 1;
                }, UA = 0; UA < xA.length; UA++)
                  RA(UA);
              } catch (Me) {
                for (var TA = !0, UA = 0; UA < xA.length; UA++) {
                  var ge = xA[UA];
                  ge.onError ? ge.onError(Me) : TA = !1;
                }
                if (!xA.length || !TA)
                  throw Me;
              }
            }
            s.recordFrame = O;
            function AA(cA) {
              return E(this, void 0, void 0, function() {
                return C(this, function(xA) {
                  return [2, new Promise(function(gA) {
                    cA.save(function(RA) {
                      gA(RA);
                    });
                  })];
                });
              });
            }
            function q(cA) {
              return E(this, void 0, void 0, function() {
                var xA, gA, RA, UA, TA, ge, Me, xe, we, Ee, he, _e, Pe, Pe, Nt, Pe, Nt;
                return C(this, function(Jt) {
                  switch (Jt.label) {
                    case 0:
                      if (xA = j[cA], gA = xA.name, RA = xA.capturer, UA = xA.numFrames, TA = xA.type, ge = xA.zipPromises, Me = xA.onExportProgress, xe = xA.onExport, we = xA.onExportFinish, xA.onError, Ee = xA.ffmpegOptions, j.splice(cA, 1), TA !== x && TA !== v && RA.stop(), UA === 0)
                        throw he = "No frames recorded, call CanvasCapture.recordFrame().", (0, f.showWarning)(he), new Error(he);
                      switch (_e = TA, _e) {
                        case s.MP4:
                          return [3, 1];
                        case s.WEBM:
                          return [3, 4];
                        case k:
                          return [3, 6];
                        case x:
                          return [3, 8];
                        case v:
                          return [3, 8];
                      }
                      return [3, 11];
                    case 1:
                      return [4, AA(RA)];
                    case 2:
                      return Pe = Jt.sent(), (0, f.showDialog)("Processing...", "MP4 is processing and may take a minute to save.  You can close this dialog in the meantime.", { autoCloseDelay: 7e3 }), [4, SA({
                        name: gA,
                        blob: Pe,
                        onExportProgress: Me,
                        onExport: xe,
                        onExportFinish: we,
                        ffmpegOptions: Ee
                      })];
                    case 3:
                      return Jt.sent(), [3, 12];
                    case 4:
                      return Me && Me(0), [4, AA(RA)];
                    case 5:
                      return Pe = Jt.sent(), Me && Me(1), Nt = "".concat(gA, ".webm"), xe ? xe(Pe, Nt) : (0, d.saveAs)(Pe, Nt), we && we(), [3, 12];
                    case 6:
                      return (0, f.showDialog)("Processing...", "GIF is processing and may take a minute to save.  You can close this dialog in the meantime.", { autoCloseDelay: 7e3 }), [4, AA(RA)];
                    case 7:
                      return Pe = Jt.sent(), Nt = "".concat(gA, ".gif"), xe ? xe(Pe, Nt) : (0, d.saveAs)(Pe, Nt), we && we(), [3, 12];
                    case 8:
                      return [4, Promise.all(ge)];
                    case 9:
                      return Jt.sent(), (0, f.showDialog)("Processing...", "Frames are being zipped and may take a minute to save.  You can close this dialog in the meantime.", { autoCloseDelay: 7e3 }), [4, RA.generateAsync({ type: "blob" }, function(vi) {
                        Me && Me(vi.percent / 100);
                      }).then(function(vi) {
                        var je = "".concat(gA, ".zip");
                        xe ? xe(vi, je) : (0, d.saveAs)(vi, je), we && we();
                      })];
                    case 10:
                      return Jt.sent(), [3, 12];
                    case 11:
                      throw new Error("Need to handle saving type ".concat(TA, "."));
                    case 12:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }
            function Z(cA) {
              return E(this, void 0, void 0, function() {
                var xA, gA, RA, Me, UA, TA, ge, Me, xe;
                return C(this, function(we) {
                  switch (we.label) {
                    case 0:
                      cA && !Array.isArray(cA) && (cA = [cA]), xA = cA || j, we.label = 1;
                    case 1:
                      if (we.trys.push([1, 3, , 4]), j.length === 0)
                        throw gA = "No valid capturer inited, please call CanvasCapture.beginVideoRecord(), CanvasCapture.beginGIFRecord(), CanvasCapture.beginPNGFramesRecord(), or CanvasCapture.beginJPEGFramesRecord() first.", (0, f.showWarning)(gA), new Error(gA);
                      for (RA = [], Me = 0; Me < xA.length; Me++) {
                        if (UA = j.indexOf(xA[Me]), UA < 0)
                          throw new Error("Invalid capture ".concat(xA[Me], "  may have already been stopped."));
                        RA.push(q(UA));
                      }
                      return (0, f.showDot)(GA()), [4, Promise.all(RA)];
                    case 2:
                      return we.sent(), [3, 4];
                    case 3:
                      for (TA = we.sent(), ge = !0, Me = 0; Me < xA.length; Me++)
                        xe = xA[Me], xe.onError ? xe.onError(TA) : ge = !1;
                      if (!xA.length || !ge)
                        throw TA;
                      return [3, 4];
                    case 4:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }
            s.stopRecord = Z;
            function $(cA) {
              for (var xA = [], gA = 0; gA < j.length; gA++)
                j[gA].type === cA && xA.push(j[gA]);
              return xA;
            }
            function BA() {
              return $(s.WEBM).concat($(s.MP4)).concat($(k));
            }
            function GA() {
              return j.length > 0;
            }
            s.isRecording = GA;
            function bA() {
              D.PARAMS.IS_MANUALLY_CHECKING_HOTKEYS = !0, FA();
            }
            s.checkHotkeys = bA;
            var DA = !1;
            function SA(cA) {
              return E(this, void 0, void 0, function() {
                var xA, gA, RA, UA, TA, ge, Me, xe, we, Ee, he, _e, Pe, Nt, Jt, vi;
                return C(this, function(je) {
                  switch (je.label) {
                    case 0:
                      return F || (xA = B(648), F = xA({
                        corePath: N
                      })), DA ? [3, 2] : [4, F.load().catch(function() {
                        var Ri = "MP4 export not supported in this browser, try again in the latest version of Chrome.";
                        throw (0, f.showWarning)(Ri), new Error(Ri);
                      })];
                    case 1:
                      je.sent(), DA = !0, je.label = 2;
                    case 2:
                      return gA = cA.name, RA = cA.blob, UA = cA.onExportProgress, TA = cA.onExport, ge = cA.onExportFinish, Me = cA.ffmpegOptions, [4, RA.arrayBuffer()];
                    case 3:
                      return xe = je.sent(), we = new Uint8Array(xe), F.FS("writeFile", "".concat(gA, ".webm"), we), UA && F.setProgress(function(Ri) {
                        UA(Math.max(0, Math.min(Ri.ratio, 1)));
                      }), Ee = {
                        "-c:v": "libx264",
                        "-preset": "slow",
                        "-crf": "22",
                        "-pix_fmt": "yuv420p"
                      }, he = I(I({}, Ee), Me || {}), _e = [], Object.keys(he).forEach(function(Ri) {
                        _e.push(Ri, he[Ri]);
                      }), Pe = "".concat(gA, ".mp4"), [4, (vi = F).run.apply(vi, c(c(["-i", "".concat(gA, ".webm")], _e, !1), [
                        "-vf",
                        "crop=trunc(iw/2)*2:trunc(ih/2)*2",
                        "-an",
                        Pe
                      ], !1))];
                    case 4:
                      return je.sent(), [4, F.FS("readFile", Pe)];
                    case 5:
                      return Nt = je.sent(), Jt = new Blob([Nt], { type: "video/mp4" }), TA ? TA(Jt, Pe) : (0, d.saveAs)(Jt, Pe), F.FS("unlink", "".concat(gA, ".webm")), F.FS("unlink", Pe), ge && ge(), [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }
            function EA() {
              var cA = document.createElement("canvas"), xA = cA.toDataURL("image/webp", { quality: 1 });
              return !(typeof xA != "string" || !xA.match(/^data:image\/webp;base64,/i));
            }
            function mA() {
              try {
                var cA = new SharedArrayBuffer(1024);
              } catch {
                return !1;
              }
              return !0;
            }
            function YA() {
              return !!window.Worker;
            }
            function ZA() {
              return EA();
            }
            s.browserSupportsWEBM = ZA;
            function _A() {
              return EA() && mA();
            }
            s.browserSupportsMP4 = _A;
            function Se() {
              return YA();
            }
            s.browserSupportsGIF = Se;
          }
        ),
        /***/
        713: (
          /***/
          (r, s) => {
            Object.defineProperty(s, "__esModule", { value: !0 }), s.css = void 0, s.css = `
/**************************  Basic Modal Styles
**************************/

.modal {
  font-family: -apple-system,BlinkMacSystemFont,avenir next,avenir,helvetica neue,helvetica,ubuntu,roboto,noto,segoe ui,arial,sans-serif;
}

.modal__overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.6);
  display: flex;
  justify-content: center;
  align-items: center;
}

.modal__container {
  background-color: #fff;
  padding: 30px;
  max-width: 500px;
  max-height: 100vh;
  overflow-y: auto;
  box-sizing: border-box;
}

.modal__header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal__title {
  margin-top: 0;
  margin-bottom: 0;
  font-weight: 600;
  font-size: 1.25rem;
  line-height: 1.25;
  color: #222;
  box-sizing: border-box;
}

.modal__footer {
  text-align: right;
}

.modal__footer>.modal__btn {
  margin-right: 8px;
}

.modal__close {
  background: transparent;
  border: 0;
}

.modal__header .modal__close:before { content: ""; }

.modal__content {
  margin-top: 2rem;
  margin-bottom: 2rem;
  line-height: 1.5;
  color: rgba(0,0,0,.8);
}

.modal__btn {
  font-size: .875rem;
  padding-left: 1rem;
  padding-right: 1rem;
  padding-top: .5rem;
  padding-bottom: .5rem;
  background-color: #e6e6e6;
  color: rgba(0,0,0,.8);
  border-radius: .25rem;
  border-style: none;
  border-width: 0;
  cursor: pointer;
  -webkit-appearance: button;
  text-transform: none;
  overflow: visible;
  line-height: 1.15;
  margin: 0;
  will-change: transform;
  -moz-osx-font-smoothing: grayscale;
  -webkit-backface-visibility: hidden;
  backface-visibility: hidden;
  -webkit-transform: translateZ(0);
  transform: translateZ(0);
  transition: -webkit-transform .25s ease-out;
  transition: transform .25s ease-out;
  transition: transform .25s ease-out,-webkit-transform .25s ease-out;
}

.modal__btn:focus, .modal__btn:hover {
  -webkit-transform: scale(1.05);
  transform: scale(1.05);
}

.modal__btn-primary {
  background-color: #333;
  color: #fff;
}



/**************************  Demo Animation Style
**************************/
@keyframes mmfadeIn {
    from { opacity: 0; }
      to { opacity: 1; }
}

@keyframes mmfadeOut {
    from { opacity: 1; }
      to { opacity: 0; }
}

@keyframes mmslideIn {
  from { transform: translateY(15%); }
    to { transform: translateY(0); }
}

@keyframes mmslideOut {
    from { transform: translateY(0); }
    to { transform: translateY(-10%); }
}

.micromodal-slide {
  display: none;
}

.micromodal-slide.is-open {
  display: block;
}

.micromodal-slide[aria-hidden="false"] .modal__overlay {
  animation: mmfadeIn .3s cubic-bezier(0.0, 0.0, 0.2, 1);
}

.micromodal-slide[aria-hidden="false"] .modal__container {
  animation: mmslideIn .3s cubic-bezier(0, 0, .2, 1);
}

.micromodal-slide[aria-hidden="true"] .modal__overlay {
  animation: mmfadeOut .3s cubic-bezier(0.0, 0.0, 0.2, 1);
}

.micromodal-slide[aria-hidden="true"] .modal__container {
  animation: mmslideOut .3s cubic-bezier(0, 0, .2, 1);
}

.micromodal-slide .modal__container,
.micromodal-slide .modal__overlay {
  will-change: transform;
}
`;
          }
        ),
        /***/
        330: (
          /***/
          function(r, s, B) {
            var I = this && this.__assign || function() {
              return I = Object.assign || function(x) {
                for (var H, _ = 1, j = arguments.length; _ < j; _++) {
                  H = arguments[_];
                  for (var V in H)
                    Object.prototype.hasOwnProperty.call(H, V) && (x[V] = H[V]);
                }
                return x;
              }, I.apply(this, arguments);
            };
            Object.defineProperty(s, "__esModule", { value: !0 }), s.showDot = s.initDotWithCSS = s.showDialog = s.showWarning = void 0;
            var E = B(650), C = B(713), c = B(848), u = document.createElement("style");
            u.textContent = C.css, document.head.append(u);
            function d(x, H, _) {
              _ === void 0 && (_ = "");
              var j = '<div class="modal micromodal-slide" id="modal-'.concat(x, `" aria-hidden="true">
		<div class="modal__overlay" tabindex="-1" data-micromodal-close>
		<div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="modal-`).concat(x, `-title">
			<header class="modal__header">
				<h2 class="modal__title" id="modal-`).concat(x, `-title">
					`).concat(H, `
				</h2>
				<button class="modal__close" aria-label="Close modal" data-micromodal-close></button>
			</header>
			<main class="modal__content">
				<p id="modal-`).concat(x, `-content">
					`).concat(_, `
				</p>
			</main>
		</div>
		</div>
	</div>`), V = document.createElement("div");
              return V.innerHTML = j, V.firstChild;
            }
            var p = !1, D = !1, f = "alert", S = d(f, "Warning"), y = "dialog", m = d(y, "Saving...");
            function N(x) {
              console.warn(x), c.PARAMS.SHOW_ALERTS && (p || (p = !0, document.getElementsByTagName("body")[0].appendChild(S)), document.getElementById("modal-".concat(f, "-content")).innerHTML = x, E.default.show("modal-".concat(f)));
            }
            s.showWarning = N;
            function F(x, H, _) {
              if (c.PARAMS.VERBOSE && console.log(x, H), !!c.PARAMS.SHOW_DIALOGS) {
                D || (D = !0, document.getElementsByTagName("body")[0].appendChild(m)), document.getElementById("modal-".concat(y, "-title")).innerHTML = x, document.getElementById("modal-".concat(y, "-content")).innerHTML = H, E.default.show("modal-".concat(y));
                var j = _?.autoCloseDelay !== void 0 ? _.autoCloseDelay : -1;
                j > 0 && setTimeout(function() {
                  E.default.close("modal-".concat(y));
                }, j);
              }
            }
            s.showDialog = F;
            var G = document.createElement("div");
            function k(x) {
              G.id = "recordingDot";
              var H = I({ background: "red", width: "20px", height: "20px", "border-radius": "50%", display: "none", position: "absolute", top: "0", right: "0", "z-index": "10", margin: "20px" }, x);
              Object.assign(G.style, H), document.getElementsByTagName("body")[0].appendChild(G);
            }
            s.initDotWithCSS = k;
            function v(x) {
              c.PARAMS.SHOW_REC_DOT && (x ? G.style.display = "inline-block" : G.style.display = "none");
            }
            s.showDot = v;
          }
        ),
        /***/
        848: (
          /***/
          (r, s) => {
            Object.defineProperty(s, "__esModule", { value: !0 }), s.PARAMS = void 0, s.PARAMS = {
              VERBOSE: !1,
              SHOW_ALERTS: !1,
              SHOW_DIALOGS: !1,
              SHOW_REC_DOT: !1,
              IS_MANUALLY_CHECKING_HOTKEYS: !1
            };
          }
        ),
        /***/
        886: (
          /***/
          (r, s, B) => {
            r = B.nmd(r);
            var I;
            (function() {
              if (typeof r.exports < "u")
                var E = B(846), C = B(173), c = B(769), u = B(166);
              var d = {
                function: !0,
                object: !0
              };
              function p(P) {
                return P && P.Object === Object ? P : null;
              }
              var D = d[typeof s] && s && !s.nodeType ? s : void 0, f = r && !r.nodeType ? r : void 0;
              f && f.exports;
              var S = p(D && f && typeof B.g == "object" && B.g), y = p(d[typeof self] && self), m = p(d[typeof window] && window), N = p(d[typeof this] && this);
              S || m !== (N && N.window) && m || y || N || Function("return this")(), "gc" in window || (window.gc = function() {
              }), HTMLCanvasElement.prototype.toBlob || Object.defineProperty(HTMLCanvasElement.prototype, "toBlob", {
                value: function(P, J, tA) {
                  for (var Y = atob(this.toDataURL(J, tA).split(",")[1]), rA = Y.length, QA = new Uint8Array(rA), aA = 0; aA < rA; aA++)
                    QA[aA] = Y.charCodeAt(aA);
                  P(new Blob([QA], { type: J || "image/png" }));
                }
              });
              // @license http://opensource.org/licenses/MIT
              (function() {
                if ("performance" in window || (window.performance = {}), Date.now = Date.now || function() {
                  return (/* @__PURE__ */ new Date()).getTime();
                }, !("now" in window.performance)) {
                  var P = Date.now();
                  performance.timing && performance.timing.navigationStart && (P = performance.timing.navigationStart), window.performance.now = function() {
                    return Date.now() - P;
                  };
                }
              })();
              function F(P) {
                return ("0000000" + P).slice(-7);
              }
              var G = window.Date.now();
              function k() {
                function P() {
                  return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
                }
                return P() + P() + "-" + P() + "-" + P() + "-" + P() + "-" + P() + P() + P();
              }
              function v(P) {
                var J = {};
                this.settings = P, this.on = function(tA, Y) {
                  J[tA] = Y;
                }, this.emit = function(tA) {
                  var Y = J[tA];
                  Y && Y.apply(null, Array.prototype.slice.call(arguments, 1));
                }, this.filename = P.name || k(), this.extension = "", this.mimeType = "";
              }
              v.prototype.start = function() {
              }, v.prototype.stop = function() {
              }, v.prototype.add = function() {
              }, v.prototype.save = function() {
              }, v.prototype.dispose = function() {
              }, v.prototype.safeToProceed = function() {
                return !0;
              }, v.prototype.step = function() {
                console.log("Step not set!");
              };
              function x(P) {
                v.call(this, P), this.extension = ".tar", this.mimeType = "application/x-tar", this.fileExtension = "", this.tape = null, this.count = 0;
              }
              x.prototype = Object.create(v.prototype), x.prototype.start = function() {
                this.dispose();
              }, x.prototype.add = function(P) {
                var J = new FileReader();
                J.onload = function() {
                  this.tape.append(F(this.count) + this.fileExtension, new Uint8Array(J.result)), this.count++, this.step();
                }.bind(this), J.readAsArrayBuffer(P);
              }, x.prototype.save = function(P) {
                P(this.tape.save());
              }, x.prototype.dispose = function() {
                this.tape = new E(), this.count = 0;
              };
              function H(P) {
                x.call(this, P), this.type = "image/png", this.fileExtension = ".png";
              }
              H.prototype = Object.create(x.prototype), H.prototype.add = function(P) {
                P.toBlob(function(J) {
                  x.prototype.add.call(this, J);
                }.bind(this), this.type);
              };
              function _(P) {
                x.call(this, P), this.type = "image/jpeg", this.fileExtension = ".jpg", this.quality = P.quality / 100 || 0.8;
              }
              _.prototype = Object.create(x.prototype), _.prototype.add = function(P) {
                P.toBlob(function(J) {
                  x.prototype.add.call(this, J);
                }.bind(this), this.type, this.quality);
              };
              function j(P) {
                var J = document.createElement("canvas");
                J.toDataURL("image/webp").substr(5, 10) !== "image/webp" && console.log("WebP not supported - try another export format"), v.call(this, P), this.quality = P.quality / 100 || 0.8, this.extension = ".webm", this.mimeType = "video/webm", this.baseFilename = this.filename, this.frames = [], this.part = 1, this.videoWriter = new u({
                  quality: this.quality,
                  fileWriter: null,
                  fd: null,
                  frameRate: P.framerate
                });
              }
              j.prototype = Object.create(v.prototype), j.prototype.start = function(P) {
                this.dispose();
              }, j.prototype.add = function(P) {
                this.videoWriter.addFrame(P), this.settings.autoSaveTime > 0 && this.frames.length / this.settings.framerate >= this.settings.autoSaveTime ? this.save(function(J) {
                  this.filename = this.baseFilename + "-part-" + F(this.part), C(J, this.filename + this.extension, this.mimeType), this.dispose(), this.part++, this.filename = this.baseFilename + "-part-" + F(this.part), this.step();
                }.bind(this)) : this.step();
              }, j.prototype.save = function(P) {
                this.videoWriter.complete().then(P);
              }, j.prototype.dispose = function(P) {
                this.frames = [];
              };
              function V(P) {
                v.call(this, P), P.quality = P.quality / 100 || 0.8, this.encoder = new FFMpegServer.Video(P), this.encoder.on("process", function() {
                  this.emit("process");
                }.bind(this)), this.encoder.on("finished", function(J, tA) {
                  var Y = this.callback;
                  Y && (this.callback = void 0, Y(J, tA));
                }.bind(this)), this.encoder.on("progress", function(J) {
                  this.settings.onProgress && this.settings.onProgress(J);
                }.bind(this)), this.encoder.on("error", function(J) {
                  alert(JSON.stringify(J, null, 2));
                }.bind(this));
              }
              V.prototype = Object.create(v.prototype), V.prototype.start = function() {
                this.encoder.start(this.settings);
              }, V.prototype.add = function(P) {
                this.encoder.add(P);
              }, V.prototype.save = function(P) {
                this.callback = P, this.encoder.end();
              }, V.prototype.safeToProceed = function() {
                return this.encoder.safeToProceed();
              };
              function iA(P) {
                v.call(this, P), this.framerate = this.settings.framerate, this.type = "video/webm", this.extension = ".webm", this.stream = null, this.mediaRecorder = null, this.chunks = [];
              }
              iA.prototype = Object.create(v.prototype), iA.prototype.add = function(P) {
                this.stream || (this.stream = P.captureStream(this.framerate), this.mediaRecorder = new MediaRecorder(this.stream), this.mediaRecorder.start(), this.mediaRecorder.ondataavailable = function(J) {
                  this.chunks.push(J.data);
                }.bind(this)), this.step();
              }, iA.prototype.save = function(P) {
                this.mediaRecorder.onstop = function(J) {
                  var tA = new Blob(this.chunks, { type: "video/webm" });
                  this.chunks = [], P(tA);
                }.bind(this), this.mediaRecorder.stop();
              };
              function eA(P) {
                v.call(this, P), P.quality = 31 - (P.quality * 30 / 100 || 10), P.workers = P.workers || 4, this.extension = ".gif", this.mimeType = "image/gif", this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d"), this.sizeSet = !1, this.encoder = new c({
                  workers: P.workers,
                  quality: P.quality,
                  workerScript: P.workersPath
                }), this.encoder.on("progress", function(J) {
                  this.settings.onProgress && this.settings.onProgress(J);
                }.bind(this)), this.encoder.on("finished", function(J) {
                  var tA = this.callback;
                  tA && (this.callback = void 0, tA(J));
                }.bind(this));
              }
              eA.prototype = Object.create(v.prototype), eA.prototype.add = function(P) {
                this.sizeSet || (this.encoder.setOption("width", P.width), this.encoder.setOption("height", P.height), this.sizeSet = !0), this.canvas.width = P.width, this.canvas.height = P.height, this.ctx.drawImage(P, 0, 0), this.encoder.addFrame(this.ctx, { copy: !0, delay: this.settings.step }), this.step();
              }, eA.prototype.save = function(P) {
                this.callback = P, this.encoder.render();
              };
              function oA(P) {
                var J = P || {}, tA, Y, rA, QA, aA, ZA, MA, hA = [], fA = [], wA = 0, yA = 0, kA = [], FA = !1, dA = {};
                J.framerate = J.framerate || 60, J.motionBlurFrames = 2 * (J.motionBlurFrames || 1), tA = J.verbose || !1, J.display, J.step = 1e3 / J.framerate, J.timeLimit = J.timeLimit || 0, J.frameLimit = J.frameLimit || 0, J.startTime = J.startTime || 0;
                var vA = document.createElement("div");
                vA.style.position = "absolute", vA.style.left = vA.style.top = 0, vA.style.backgroundColor = "black", vA.style.fontFamily = "monospace", vA.style.fontSize = "11px", vA.style.padding = "5px", vA.style.color = "red", vA.style.zIndex = 1e5, J.display && document.body.appendChild(vA);
                var JA = document.createElement("canvas"), ne = JA.getContext("2d"), ee, pe;
                ge("Step is set to " + J.step + "ms");
                var Ae = {
                  gif: eA,
                  webm: j,
                  ffmpegserver: V,
                  png: H,
                  jpg: _,
                  "webm-mediarecorder": iA
                }, ie = Ae[J.format];
                if (!ie)
                  throw "Error: Incorrect or missing format: Valid formats are " + Object.keys(Ae).join(", ");
                if (MA = new ie(J), MA.step = ZA, MA.on("process", UA), MA.on("progress", we), "performance" in window || (window.performance = {}), Date.now = Date.now || function() {
                  return (/* @__PURE__ */ new Date()).getTime();
                }, !("now" in window.performance)) {
                  var de = Date.now();
                  performance.timing && performance.timing.navigationStart && (de = performance.timing.navigationStart), window.performance.now = function() {
                    return Date.now() - de;
                  };
                }
                var O = window.setTimeout, AA = window.setInterval, q = window.clearInterval, Z = window.clearTimeout, $ = window.requestAnimationFrame, BA = window.Date.now, GA = window.performance.now, bA = window.Date.prototype.getTime, DA = [];
                function SA() {
                  ge("Capturer start"), rA = window.Date.now(), Y = rA + J.startTime, aA = window.performance.now(), QA = aA + J.startTime, window.Date.prototype.getTime = function() {
                    return Y;
                  }, window.Date.now = function() {
                    return Y;
                  }, window.setTimeout = function(he, _e) {
                    var Pe = {
                      callback: he,
                      time: _e,
                      triggerTime: Y + _e
                    };
                    return hA.push(Pe), ge("Timeout set to " + Pe.time), Pe;
                  }, window.clearTimeout = function(he) {
                    for (var _e = 0; _e < hA.length; _e++)
                      if (hA[_e] == he) {
                        hA.splice(_e, 1), ge("Timeout cleared");
                        continue;
                      }
                  }, window.setInterval = function(he, _e) {
                    var Pe = {
                      callback: he,
                      time: _e,
                      triggerTime: Y + _e
                    };
                    return fA.push(Pe), ge("Interval set to " + Pe.time), Pe;
                  }, window.clearInterval = function(he) {
                    return ge("clear Interval"), null;
                  }, window.requestAnimationFrame = function(he) {
                    kA.push(he);
                  }, window.performance.now = function() {
                    return QA;
                  };
                  function Ee() {
                    return this._hooked || (this._hooked = !0, this._hookedTime = this.currentTime || 0, this.pause(), DA.push(this)), this._hookedTime + J.startTime;
                  }
                  try {
                    Object.defineProperty(HTMLVideoElement.prototype, "currentTime", { get: Ee }), Object.defineProperty(HTMLAudioElement.prototype, "currentTime", { get: Ee });
                  } catch (he) {
                    ge(he);
                  }
                }
                function EA() {
                  SA(), MA.start(), FA = !0;
                }
                function mA() {
                  FA = !1, MA.stop(), _A();
                }
                function YA(Ee, he) {
                  O(Ee, 0, he);
                }
                function ZA() {
                  YA(UA);
                }
                function _A() {
                  ge("Capturer stop"), window.setTimeout = O, window.setInterval = AA, window.clearInterval = q, window.clearTimeout = Z, window.requestAnimationFrame = $, window.Date.prototype.getTime = bA, window.Date.now = BA, window.performance.now = GA;
                }
                function Se() {
                  var Ee = wA / J.framerate;
                  (J.frameLimit && wA >= J.frameLimit || J.timeLimit && Ee >= J.timeLimit) && (mA(), TA());
                  var he = /* @__PURE__ */ new Date(null);
                  he.setSeconds(Ee), J.motionBlurFrames > 2 ? vA.textContent = "CCapture " + J.format + " | " + wA + " frames (" + yA + " inter) | " + he.toISOString().substr(11, 8) : vA.textContent = "CCapture " + J.format + " | " + wA + " frames | " + he.toISOString().substr(11, 8);
                }
                function cA(Ee) {
                  (JA.width !== Ee.width || JA.height !== Ee.height) && (JA.width = Ee.width, JA.height = Ee.height, ee = new Uint16Array(JA.height * JA.width * 4), ne.fillStyle = "#0", ne.fillRect(0, 0, JA.width, JA.height));
                }
                function xA(Ee) {
                  ne.drawImage(Ee, 0, 0), pe = ne.getImageData(0, 0, JA.width, JA.height);
                  for (var he = 0; he < ee.length; he += 4)
                    ee[he] += pe.data[he], ee[he + 1] += pe.data[he + 1], ee[he + 2] += pe.data[he + 2];
                  yA++;
                }
                function gA() {
                  for (var Ee = pe.data, he = 0; he < ee.length; he += 4)
                    Ee[he] = ee[he] * 2 / J.motionBlurFrames, Ee[he + 1] = ee[he + 1] * 2 / J.motionBlurFrames, Ee[he + 2] = ee[he + 2] * 2 / J.motionBlurFrames;
                  ne.putImageData(pe, 0, 0), MA.add(JA), wA++, yA = 0, ge("Full MB Frame! " + wA + " " + Y);
                  for (var he = 0; he < ee.length; he += 4)
                    ee[he] = 0, ee[he + 1] = 0, ee[he + 2] = 0;
                  gc();
                }
                function RA(Ee) {
                  FA && (J.motionBlurFrames > 2 ? (cA(Ee), xA(Ee), yA >= 0.5 * J.motionBlurFrames ? gA() : ZA()) : (MA.add(Ee), wA++, ge("Full Frame! " + wA)));
                }
                function UA() {
                  var Ee = 1e3 / J.framerate, he = (wA + yA / J.motionBlurFrames) * Ee;
                  Y = rA + he, QA = aA + he, DA.forEach(function(Pe) {
                    Pe._hookedTime = he / 1e3;
                  }), Se(), ge("Frame: " + wA + " " + yA);
                  for (var _e = 0; _e < hA.length; _e++)
                    if (Y >= hA[_e].triggerTime) {
                      YA(hA[_e].callback), hA.splice(_e, 1);
                      continue;
                    }
                  for (var _e = 0; _e < fA.length; _e++)
                    if (Y >= fA[_e].triggerTime) {
                      YA(fA[_e].callback), fA[_e].triggerTime += fA[_e].time;
                      continue;
                    }
                  kA.forEach(function(Pe) {
                    YA(Pe, Y - G);
                  }), kA = [];
                }
                function TA(Ee) {
                  Ee || (Ee = function(he) {
                    return C(he, MA.filename + MA.extension, MA.mimeType), !1;
                  }), MA.save(Ee);
                }
                function ge(Ee) {
                  tA && console.log(Ee);
                }
                function Me(Ee, he) {
                  dA[Ee] = he;
                }
                function xe(Ee) {
                  var he = dA[Ee];
                  he && he.apply(null, Array.prototype.slice.call(arguments, 1));
                }
                function we(Ee) {
                  xe("progress", Ee);
                }
                return {
                  start: EA,
                  capture: RA,
                  stop: mA,
                  save: TA,
                  on: Me
                };
              }
              (m || y || {}).CCapture = oA, I = function() {
                return oA;
              }.call(s, B, s, r), I !== void 0 && (r.exports = I);
            })();
          }
        ),
        /***/
        173: (
          /***/
          (r) => {
            function s(B, I, E) {
              var C = window, c = "application/octet-stream", u = E || c, d = B, p = document, D = p.createElement("a"), f = function(x) {
                return String(x);
              }, S = C.Blob || C.MozBlob || C.WebKitBlob || f, y = C.MSBlobBuilder || C.WebKitBlobBuilder || C.BlobBuilder, m = I || "download", N, F, G;
              if (String(this) === "true" && (d = [d, u], u = d[0], d = d[1]), String(d).match(/^data\:[\w+\-]+\/[\w+\-]+[,;]/))
                return navigator.msSaveBlob ? (
                  // IE10 can't do a[download], only Blobs:
                  navigator.msSaveBlob(k(d), m)
                ) : v(d);
              try {
                N = d instanceof S ? d : new S([d], { type: u });
              } catch {
                y && (F = new y(), F.append([d]), N = F.getBlob(u));
              }
              function k(x) {
                var H = x.split(/[:;,]/), _ = H[1], j = H[2] == "base64" ? atob : decodeURIComponent, V = j(H.pop()), iA = V.length, eA = 0, oA = new Uint8Array(iA);
                for (eA; eA < iA; ++eA)
                  oA[eA] = V.charCodeAt(eA);
                return new S([oA], { type: _ });
              }
              function v(x, H) {
                if ("download" in D)
                  return D.href = x, D.setAttribute("download", m), D.innerHTML = "downloading...", D.style.display = "none", p.body.appendChild(D), setTimeout(function() {
                    D.click(), p.body.removeChild(D), H === !0 && setTimeout(function() {
                      C.URL.revokeObjectURL(D.href);
                    }, 250);
                  }, 66), !0;
                var _ = p.createElement("iframe");
                p.body.appendChild(_), H || (x = "data:" + x.replace(/^data:([\w\/\-\+]+)/, c)), _.src = x, setTimeout(function() {
                  p.body.removeChild(_);
                }, 333);
              }
              if (navigator.msSaveBlob)
                return navigator.msSaveBlob(N, m);
              if (C.URL)
                v(C.URL.createObjectURL(N), !0);
              else {
                if (typeof N == "string" || N.constructor === f)
                  try {
                    return v("data:" + u + ";base64," + C.btoa(N));
                  } catch {
                    return v("data:" + u + "," + encodeURIComponent(N));
                  }
                G = new FileReader(), G.onload = function(x) {
                  v(this.result);
                }, G.readAsDataURL(N);
              }
              return !0;
            }
            typeof r.exports < "u" && (r.exports = s);
          }
        ),
        /***/
        769: (
          /***/
          (r) => {
            (function(s) {
              r.exports = s();
            })(function() {
              return function() {
                function s(B, I, E) {
                  function C(u, d) {
                    if (!I[u]) {
                      if (!B[u]) {
                        var p = void 0;
                        if (!d && p)
                          return jF(u);
                        var D = new Error("Cannot find module '" + u + "'");
                        throw D.code = "MODULE_NOT_FOUND", D;
                      }
                      var f = I[u] = { exports: {} };
                      B[u][0].call(f.exports, function(S) {
                        var y = B[u][1][S];
                        return C(y || S);
                      }, f, f.exports, s, B, I, E);
                    }
                    return I[u].exports;
                  }
                  for (var c = 0; c < E.length; c++)
                    C(E[c]);
                  return C;
                }
                return s;
              }()({ 1: [function(s, B, I) {
                function E() {
                  this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
                }
                B.exports = E, E.EventEmitter = E, E.prototype._events = void 0, E.prototype._maxListeners = void 0, E.defaultMaxListeners = 10, E.prototype.setMaxListeners = function(p) {
                  if (!c(p) || p < 0 || isNaN(p))
                    throw TypeError("n must be a positive number");
                  return this._maxListeners = p, this;
                }, E.prototype.emit = function(p) {
                  var D, f, S, y, m, N;
                  if (this._events || (this._events = {}), p === "error" && (!this._events.error || u(this._events.error) && !this._events.error.length)) {
                    if (D = arguments[1], D instanceof Error)
                      throw D;
                    var F = new Error('Uncaught, unspecified "error" event. (' + D + ")");
                    throw F.context = D, F;
                  }
                  if (f = this._events[p], d(f))
                    return !1;
                  if (C(f))
                    switch (arguments.length) {
                      case 1:
                        f.call(this);
                        break;
                      case 2:
                        f.call(this, arguments[1]);
                        break;
                      case 3:
                        f.call(this, arguments[1], arguments[2]);
                        break;
                      default:
                        y = Array.prototype.slice.call(arguments, 1), f.apply(this, y);
                    }
                  else if (u(f))
                    for (y = Array.prototype.slice.call(arguments, 1), N = f.slice(), S = N.length, m = 0; m < S; m++)
                      N[m].apply(this, y);
                  return !0;
                }, E.prototype.addListener = function(p, D) {
                  var f;
                  if (!C(D))
                    throw TypeError("listener must be a function");
                  return this._events || (this._events = {}), this._events.newListener && this.emit("newListener", p, C(D.listener) ? D.listener : D), this._events[p] ? u(this._events[p]) ? this._events[p].push(D) : this._events[p] = [this._events[p], D] : this._events[p] = D, u(this._events[p]) && !this._events[p].warned && (d(this._maxListeners) ? f = E.defaultMaxListeners : f = this._maxListeners, f && f > 0 && this._events[p].length > f && (this._events[p].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[p].length), typeof console.trace == "function" && console.trace())), this;
                }, E.prototype.on = E.prototype.addListener, E.prototype.once = function(p, D) {
                  if (!C(D))
                    throw TypeError("listener must be a function");
                  var f = !1;
                  function S() {
                    this.removeListener(p, S), f || (f = !0, D.apply(this, arguments));
                  }
                  return S.listener = D, this.on(p, S), this;
                }, E.prototype.removeListener = function(p, D) {
                  var f, S, y, m;
                  if (!C(D))
                    throw TypeError("listener must be a function");
                  if (!this._events || !this._events[p])
                    return this;
                  if (f = this._events[p], y = f.length, S = -1, f === D || C(f.listener) && f.listener === D)
                    delete this._events[p], this._events.removeListener && this.emit("removeListener", p, D);
                  else if (u(f)) {
                    for (m = y; m-- > 0; )
                      if (f[m] === D || f[m].listener && f[m].listener === D) {
                        S = m;
                        break;
                      }
                    if (S < 0)
                      return this;
                    f.length === 1 ? (f.length = 0, delete this._events[p]) : f.splice(S, 1), this._events.removeListener && this.emit("removeListener", p, D);
                  }
                  return this;
                }, E.prototype.removeAllListeners = function(p) {
                  var D, f;
                  if (!this._events)
                    return this;
                  if (!this._events.removeListener)
                    return arguments.length === 0 ? this._events = {} : this._events[p] && delete this._events[p], this;
                  if (arguments.length === 0) {
                    for (D in this._events)
                      D !== "removeListener" && this.removeAllListeners(D);
                    return this.removeAllListeners("removeListener"), this._events = {}, this;
                  }
                  if (f = this._events[p], C(f))
                    this.removeListener(p, f);
                  else if (f)
                    for (; f.length; )
                      this.removeListener(p, f[f.length - 1]);
                  return delete this._events[p], this;
                }, E.prototype.listeners = function(p) {
                  var D;
                  return !this._events || !this._events[p] ? D = [] : C(this._events[p]) ? D = [this._events[p]] : D = this._events[p].slice(), D;
                }, E.prototype.listenerCount = function(p) {
                  if (this._events) {
                    var D = this._events[p];
                    if (C(D))
                      return 1;
                    if (D)
                      return D.length;
                  }
                  return 0;
                }, E.listenerCount = function(p, D) {
                  return p.listenerCount(D);
                };
                function C(p) {
                  return typeof p == "function";
                }
                function c(p) {
                  return typeof p == "number";
                }
                function u(p) {
                  return typeof p == "object" && p !== null;
                }
                function d(p) {
                  return p === void 0;
                }
              }, {}], 2: [function(s, B, I) {
                var E = s("./TypedNeuQuant.js"), C = s("./LZWEncoder.js");
                function c() {
                  this.page = -1, this.pages = [], this.newPage();
                }
                c.pageSize = 4096, c.charMap = {};
                for (var u = 0; u < 256; u++)
                  c.charMap[u] = String.fromCharCode(u);
                c.prototype.newPage = function() {
                  this.pages[++this.page] = new Uint8Array(c.pageSize), this.cursor = 0;
                }, c.prototype.getData = function() {
                  for (var p = "", D = 0; D < this.pages.length; D++)
                    for (var f = 0; f < c.pageSize; f++)
                      p += c.charMap[this.pages[D][f]];
                  return p;
                }, c.prototype.writeByte = function(p) {
                  this.cursor >= c.pageSize && this.newPage(), this.pages[this.page][this.cursor++] = p;
                }, c.prototype.writeUTFBytes = function(p) {
                  for (var D = p.length, f = 0; f < D; f++)
                    this.writeByte(p.charCodeAt(f));
                }, c.prototype.writeBytes = function(p, D, f) {
                  for (var S = f || p.length, y = D || 0; y < S; y++)
                    this.writeByte(p[y]);
                };
                function d(p, D) {
                  this.width = ~~p, this.height = ~~D, this.transparent = null, this.transIndex = 0, this.repeat = -1, this.delay = 0, this.image = null, this.pixels = null, this.indexedPixels = null, this.colorDepth = null, this.colorTab = null, this.neuQuant = null, this.usedEntry = new Array(), this.palSize = 7, this.dispose = -1, this.firstFrame = !0, this.sample = 10, this.dither = !1, this.globalPalette = !1, this.out = new c();
                }
                d.prototype.setDelay = function(p) {
                  this.delay = Math.round(p / 10);
                }, d.prototype.setFrameRate = function(p) {
                  this.delay = Math.round(100 / p);
                }, d.prototype.setDispose = function(p) {
                  p >= 0 && (this.dispose = p);
                }, d.prototype.setRepeat = function(p) {
                  this.repeat = p;
                }, d.prototype.setTransparent = function(p) {
                  this.transparent = p;
                }, d.prototype.addFrame = function(p) {
                  this.image = p, this.colorTab = this.globalPalette && this.globalPalette.slice ? this.globalPalette : null, this.getImagePixels(), this.analyzePixels(), this.globalPalette === !0 && (this.globalPalette = this.colorTab), this.firstFrame && (this.writeLSD(), this.writePalette(), this.repeat >= 0 && this.writeNetscapeExt()), this.writeGraphicCtrlExt(), this.writeImageDesc(), !this.firstFrame && !this.globalPalette && this.writePalette(), this.writePixels(), this.firstFrame = !1;
                }, d.prototype.finish = function() {
                  this.out.writeByte(59);
                }, d.prototype.setQuality = function(p) {
                  p < 1 && (p = 1), this.sample = p;
                }, d.prototype.setDither = function(p) {
                  p === !0 && (p = "FloydSteinberg"), this.dither = p;
                }, d.prototype.setGlobalPalette = function(p) {
                  this.globalPalette = p;
                }, d.prototype.getGlobalPalette = function() {
                  return this.globalPalette && this.globalPalette.slice && this.globalPalette.slice(0) || this.globalPalette;
                }, d.prototype.writeHeader = function() {
                  this.out.writeUTFBytes("GIF89a");
                }, d.prototype.analyzePixels = function() {
                  this.colorTab || (this.neuQuant = new E(this.pixels, this.sample), this.neuQuant.buildColormap(), this.colorTab = this.neuQuant.getColormap()), this.dither ? this.ditherPixels(this.dither.replace("-serpentine", ""), this.dither.match(/-serpentine/) !== null) : this.indexPixels(), this.pixels = null, this.colorDepth = 8, this.palSize = 7, this.transparent !== null && (this.transIndex = this.findClosest(this.transparent, !0));
                }, d.prototype.indexPixels = function(p) {
                  var D = this.pixels.length / 3;
                  this.indexedPixels = new Uint8Array(D);
                  for (var f = 0, S = 0; S < D; S++) {
                    var y = this.findClosestRGB(this.pixels[f++] & 255, this.pixels[f++] & 255, this.pixels[f++] & 255);
                    this.usedEntry[y] = !0, this.indexedPixels[S] = y;
                  }
                }, d.prototype.ditherPixels = function(p, D) {
                  var f = { FalseFloydSteinberg: [[0.375, 1, 0], [0.375, 0, 1], [0.25, 1, 1]], FloydSteinberg: [[0.4375, 1, 0], [0.1875, -1, 1], [0.3125, 0, 1], [0.0625, 1, 1]], Stucki: [[0.19047619047619047, 1, 0], [0.09523809523809523, 2, 0], [0.047619047619047616, -2, 1], [0.09523809523809523, -1, 1], [0.19047619047619047, 0, 1], [0.09523809523809523, 1, 1], [0.047619047619047616, 2, 1], [0.023809523809523808, -2, 2], [0.047619047619047616, -1, 2], [0.09523809523809523, 0, 2], [0.047619047619047616, 1, 2], [0.023809523809523808, 2, 2]], Atkinson: [[0.125, 1, 0], [0.125, 2, 0], [0.125, -1, 1], [0.125, 0, 1], [0.125, 1, 1], [0.125, 0, 2]] };
                  if (!p || !f[p])
                    throw "Unknown dithering kernel: " + p;
                  var S = f[p], y = 0, m = this.height, N = this.width, F = this.pixels, G = D ? -1 : 1;
                  this.indexedPixels = new Uint8Array(this.pixels.length / 3);
                  for (var k = 0; k < m; k++) {
                    D && (G = G * -1);
                    for (var v = G == 1 ? 0 : N - 1, x = G == 1 ? N : 0; v !== x; v += G) {
                      y = k * N + v;
                      var H = y * 3, _ = F[H], j = F[H + 1], V = F[H + 2];
                      H = this.findClosestRGB(_, j, V), this.usedEntry[H] = !0, this.indexedPixels[y] = H, H *= 3;
                      for (var iA = this.colorTab[H], eA = this.colorTab[H + 1], oA = this.colorTab[H + 2], P = _ - iA, J = j - eA, tA = V - oA, Y = G == 1 ? 0 : S.length - 1, rA = G == 1 ? S.length : 0; Y !== rA; Y += G) {
                        var QA = S[Y][1], aA = S[Y][2];
                        if (QA + v >= 0 && QA + v < N && aA + k >= 0 && aA + k < m) {
                          var MA = S[Y][0];
                          H = y + QA + aA * N, H *= 3, F[H] = Math.max(0, Math.min(255, F[H] + P * MA)), F[H + 1] = Math.max(0, Math.min(255, F[H + 1] + J * MA)), F[H + 2] = Math.max(0, Math.min(255, F[H + 2] + tA * MA));
                        }
                      }
                    }
                  }
                }, d.prototype.findClosest = function(p, D) {
                  return this.findClosestRGB((p & 16711680) >> 16, (p & 65280) >> 8, p & 255, D);
                }, d.prototype.findClosestRGB = function(p, D, f, S) {
                  if (this.colorTab === null)
                    return -1;
                  if (this.neuQuant && !S)
                    return this.neuQuant.lookupRGB(p, D, f);
                  for (var y = 0, m = 256 * 256 * 256, N = this.colorTab.length, F = 0, G = 0; F < N; G++) {
                    var k = p - (this.colorTab[F++] & 255), v = D - (this.colorTab[F++] & 255), x = f - (this.colorTab[F++] & 255), H = k * k + v * v + x * x;
                    (!S || this.usedEntry[G]) && H < m && (m = H, y = G);
                  }
                  return y;
                }, d.prototype.getImagePixels = function() {
                  var p = this.width, D = this.height;
                  this.pixels = new Uint8Array(p * D * 3);
                  for (var f = this.image, S = 0, y = 0, m = 0; m < D; m++)
                    for (var N = 0; N < p; N++)
                      this.pixels[y++] = f[S++], this.pixels[y++] = f[S++], this.pixels[y++] = f[S++], S++;
                }, d.prototype.writeGraphicCtrlExt = function() {
                  this.out.writeByte(33), this.out.writeByte(249), this.out.writeByte(4);
                  var p, D;
                  this.transparent === null ? (p = 0, D = 0) : (p = 1, D = 2), this.dispose >= 0 && (D = this.dispose & 7), D <<= 2, this.out.writeByte(0 | D | 0 | p), this.writeShort(this.delay), this.out.writeByte(this.transIndex), this.out.writeByte(0);
                }, d.prototype.writeImageDesc = function() {
                  this.out.writeByte(44), this.writeShort(0), this.writeShort(0), this.writeShort(this.width), this.writeShort(this.height), this.firstFrame || this.globalPalette ? this.out.writeByte(0) : this.out.writeByte(128 | this.palSize);
                }, d.prototype.writeLSD = function() {
                  this.writeShort(this.width), this.writeShort(this.height), this.out.writeByte(240 | this.palSize), this.out.writeByte(0), this.out.writeByte(0);
                }, d.prototype.writeNetscapeExt = function() {
                  this.out.writeByte(33), this.out.writeByte(255), this.out.writeByte(11), this.out.writeUTFBytes("NETSCAPE2.0"), this.out.writeByte(3), this.out.writeByte(1), this.writeShort(this.repeat), this.out.writeByte(0);
                }, d.prototype.writePalette = function() {
                  this.out.writeBytes(this.colorTab);
                  for (var p = 3 * 256 - this.colorTab.length, D = 0; D < p; D++)
                    this.out.writeByte(0);
                }, d.prototype.writeShort = function(p) {
                  this.out.writeByte(p & 255), this.out.writeByte(p >> 8 & 255);
                }, d.prototype.writePixels = function() {
                  var p = new C(this.width, this.height, this.indexedPixels, this.colorDepth);
                  p.encode(this.out);
                }, d.prototype.stream = function() {
                  return this.out;
                }, B.exports = d;
              }, { "./LZWEncoder.js": 3, "./TypedNeuQuant.js": 4 }], 3: [function(s, B, I) {
                var E = -1, C = 12, c = 5003, u = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535];
                function d(p, D, f, S) {
                  var y = Math.max(2, S), m = new Uint8Array(256), N = new Int32Array(c), F = new Int32Array(c), G, k = 0, v, x = 0, H, _ = !1, j, V, iA;
                  function eA(MA, hA) {
                    m[v++] = MA, v >= 254 && Y(hA);
                  }
                  function oA(MA) {
                    P(c), x = V + 2, _ = !0, aA(V, MA);
                  }
                  function P(MA) {
                    for (var hA = 0; hA < MA; ++hA)
                      N[hA] = -1;
                  }
                  function J(MA, hA) {
                    var fA, wA, yA, kA, FA, dA, vA;
                    for (j = MA, _ = !1, n_bits = j, H = rA(n_bits), V = 1 << MA - 1, iA = V + 1, x = V + 2, v = 0, kA = QA(), vA = 0, fA = c; fA < 65536; fA *= 2)
                      ++vA;
                    vA = 8 - vA, dA = c, P(dA), aA(V, hA);
                    A:
                      for (; (wA = QA()) != E; ) {
                        if (fA = (wA << C) + kA, yA = wA << vA ^ kA, N[yA] === fA) {
                          kA = F[yA];
                          continue;
                        } else if (N[yA] >= 0) {
                          FA = dA - yA, yA === 0 && (FA = 1);
                          do
                            if ((yA -= FA) < 0 && (yA += dA), N[yA] === fA) {
                              kA = F[yA];
                              continue A;
                            }
                          while (N[yA] >= 0);
                        }
                        aA(kA, hA), kA = wA, x < 1 << C ? (F[yA] = x++, N[yA] = fA) : oA(hA);
                      }
                    aA(kA, hA), aA(iA, hA);
                  }
                  function tA(MA) {
                    MA.writeByte(y), remaining = p * D, curPixel = 0, J(y + 1, MA), MA.writeByte(0);
                  }
                  function Y(MA) {
                    v > 0 && (MA.writeByte(v), MA.writeBytes(m, 0, v), v = 0);
                  }
                  function rA(MA) {
                    return (1 << MA) - 1;
                  }
                  function QA() {
                    if (remaining === 0)
                      return E;
                    --remaining;
                    var MA = f[curPixel++];
                    return MA & 255;
                  }
                  function aA(MA, hA) {
                    for (G &= u[k], k > 0 ? G |= MA << k : G = MA, k += n_bits; k >= 8; )
                      eA(G & 255, hA), G >>= 8, k -= 8;
                    if ((x > H || _) && (_ ? (H = rA(n_bits = j), _ = !1) : (++n_bits, n_bits == C ? H = 1 << C : H = rA(n_bits))), MA == iA) {
                      for (; k > 0; )
                        eA(G & 255, hA), G >>= 8, k -= 8;
                      Y(hA);
                    }
                  }
                  this.encode = tA;
                }
                B.exports = d;
              }, {}], 4: [function(s, B, I) {
                var E = 100, C = 256, c = C - 1, u = 4, d = 16, p = 1 << d, D = 10, f = 10, S = p >> f, y = p << D - f, m = C >> 3, N = 6, F = 1 << N, G = m * F, k = 30, v = 10, x = 1 << v, H = 8, _ = 1 << H, j = v + H, V = 1 << j, iA = 499, eA = 491, oA = 487, P = 503, J = 3 * P;
                function tA(Y, rA) {
                  var QA, aA, MA, hA, fA;
                  function wA() {
                    QA = [], aA = new Int32Array(256), MA = new Int32Array(C), hA = new Int32Array(C), fA = new Int32Array(C >> 3);
                    var Ae, ie;
                    for (Ae = 0; Ae < C; Ae++)
                      ie = (Ae << u + 8) / C, QA[Ae] = new Float64Array([ie, ie, ie, 0]), hA[Ae] = p / C, MA[Ae] = 0;
                  }
                  function yA() {
                    for (var Ae = 0; Ae < C; Ae++)
                      QA[Ae][0] >>= u, QA[Ae][1] >>= u, QA[Ae][2] >>= u, QA[Ae][3] = Ae;
                  }
                  function kA(Ae, ie, de, O, AA) {
                    QA[ie][0] -= Ae * (QA[ie][0] - de) / x, QA[ie][1] -= Ae * (QA[ie][1] - O) / x, QA[ie][2] -= Ae * (QA[ie][2] - AA) / x;
                  }
                  function FA(Ae, ie, de, O, AA) {
                    for (var q = Math.abs(ie - Ae), Z = Math.min(ie + Ae, C), $ = ie + 1, BA = ie - 1, GA = 1, bA, DA; $ < Z || BA > q; )
                      DA = fA[GA++], $ < Z && (bA = QA[$++], bA[0] -= DA * (bA[0] - de) / V, bA[1] -= DA * (bA[1] - O) / V, bA[2] -= DA * (bA[2] - AA) / V), BA > q && (bA = QA[BA--], bA[0] -= DA * (bA[0] - de) / V, bA[1] -= DA * (bA[1] - O) / V, bA[2] -= DA * (bA[2] - AA) / V);
                  }
                  function dA(Ae, ie, de) {
                    var O = 2147483647, AA = O, q = -1, Z = q, $, BA, GA, bA, DA;
                    for ($ = 0; $ < C; $++)
                      BA = QA[$], GA = Math.abs(BA[0] - Ae) + Math.abs(BA[1] - ie) + Math.abs(BA[2] - de), GA < O && (O = GA, q = $), bA = GA - (MA[$] >> d - u), bA < AA && (AA = bA, Z = $), DA = hA[$] >> f, hA[$] -= DA, MA[$] += DA << D;
                    return hA[q] += S, MA[q] -= y, Z;
                  }
                  function vA() {
                    var Ae, ie, de, O, AA, q, Z = 0, $ = 0;
                    for (Ae = 0; Ae < C; Ae++) {
                      for (de = QA[Ae], AA = Ae, q = de[1], ie = Ae + 1; ie < C; ie++)
                        O = QA[ie], O[1] < q && (AA = ie, q = O[1]);
                      if (O = QA[AA], Ae != AA && (ie = O[0], O[0] = de[0], de[0] = ie, ie = O[1], O[1] = de[1], de[1] = ie, ie = O[2], O[2] = de[2], de[2] = ie, ie = O[3], O[3] = de[3], de[3] = ie), q != Z) {
                        for (aA[Z] = $ + Ae >> 1, ie = Z + 1; ie < q; ie++)
                          aA[ie] = Ae;
                        Z = q, $ = Ae;
                      }
                    }
                    for (aA[Z] = $ + c >> 1, ie = Z + 1; ie < 256; ie++)
                      aA[ie] = c;
                  }
                  function JA(Ae, ie, de) {
                    for (var O, AA, q, Z = 1e3, $ = -1, BA = aA[ie], GA = BA - 1; BA < C || GA >= 0; )
                      BA < C && (AA = QA[BA], q = AA[1] - ie, q >= Z ? BA = C : (BA++, q < 0 && (q = -q), O = AA[0] - Ae, O < 0 && (O = -O), q += O, q < Z && (O = AA[2] - de, O < 0 && (O = -O), q += O, q < Z && (Z = q, $ = AA[3])))), GA >= 0 && (AA = QA[GA], q = ie - AA[1], q >= Z ? GA = -1 : (GA--, q < 0 && (q = -q), O = AA[0] - Ae, O < 0 && (O = -O), q += O, q < Z && (O = AA[2] - de, O < 0 && (O = -O), q += O, q < Z && (Z = q, $ = AA[3]))));
                    return $;
                  }
                  function ne() {
                    var Ae, ie = Y.length, de = 30 + (rA - 1) / 3, O = ie / (3 * rA), AA = ~~(O / E), q = x, Z = G, $ = Z >> N;
                    for ($ <= 1 && ($ = 0), Ae = 0; Ae < $; Ae++)
                      fA[Ae] = q * (($ * $ - Ae * Ae) * _ / ($ * $));
                    var BA;
                    ie < J ? (rA = 1, BA = 3) : ie % iA !== 0 ? BA = 3 * iA : ie % eA !== 0 ? BA = 3 * eA : ie % oA !== 0 ? BA = 3 * oA : BA = 3 * P;
                    var GA, bA, DA, SA, EA = 0;
                    for (Ae = 0; Ae < O; )
                      if (GA = (Y[EA] & 255) << u, bA = (Y[EA + 1] & 255) << u, DA = (Y[EA + 2] & 255) << u, SA = dA(GA, bA, DA), kA(q, SA, GA, bA, DA), $ !== 0 && FA($, SA, GA, bA, DA), EA += BA, EA >= ie && (EA -= ie), Ae++, AA === 0 && (AA = 1), Ae % AA === 0)
                        for (q -= q / de, Z -= Z / k, $ = Z >> N, $ <= 1 && ($ = 0), SA = 0; SA < $; SA++)
                          fA[SA] = q * (($ * $ - SA * SA) * _ / ($ * $));
                  }
                  function ee() {
                    wA(), ne(), yA(), vA();
                  }
                  this.buildColormap = ee;
                  function pe() {
                    for (var Ae = [], ie = [], de = 0; de < C; de++)
                      ie[QA[de][3]] = de;
                    for (var O = 0, AA = 0; AA < C; AA++) {
                      var q = ie[AA];
                      Ae[O++] = QA[q][0], Ae[O++] = QA[q][1], Ae[O++] = QA[q][2];
                    }
                    return Ae;
                  }
                  this.getColormap = pe, this.lookupRGB = JA;
                }
                B.exports = tA;
              }, {}], 5: [function(s, B, I) {
                var E, C, c, u, d;
                d = navigator.userAgent.toLowerCase(), u = navigator.platform.toLowerCase(), E = d.match(/(opera|ie|firefox|chrome|version)[\s\/:]([\w\d\.]+)?.*?(safari|version[\s\/:]([\w\d\.]+)|$)/) || [null, "unknown", 0], c = E[1] === "ie" && document.documentMode, C = { name: E[1] === "version" ? E[3] : E[1], version: c || parseFloat(E[1] === "opera" && E[4] ? E[4] : E[2]), platform: { name: d.match(/ip(?:ad|od|hone)/) ? "ios" : (d.match(/(?:webos|android)/) || u.match(/mac|win|linux/) || ["other"])[0] } }, C[C.name] = !0, C[C.name + parseInt(C.version, 10)] = !0, C.platform[C.platform.name] = !0, B.exports = C;
              }, {}], 6: [function(s, B, I) {
                var E, C, c = function(D, f) {
                  for (var S in f)
                    u.call(f, S) && (D[S] = f[S]);
                  function y() {
                    this.constructor = D;
                  }
                  return y.prototype = f.prototype, D.prototype = new y(), D.__super__ = f.prototype, D;
                }, u = {}.hasOwnProperty, d = [].indexOf || function(D) {
                  for (var f = 0, S = this.length; f < S; f++)
                    if (f in this && this[f] === D)
                      return f;
                  return -1;
                }, p = [].slice;
                E = s("events").EventEmitter, C = s("./browser.coffee"), s("./GIFEncoder.js"), s("./gif.worker.coffee"), B.exports = function(D) {
                  var f, S;
                  c(y, D), f = { workerScript: "gif.worker.js", workers: 2, repeat: 0, background: "#fff", quality: 10, width: null, height: null, transparent: null, debug: !1, dither: !1 }, S = { delay: 500, copy: !1, dispose: -1 };
                  function y(m) {
                    var N, F, G;
                    this.running = !1, this.options = {}, this.frames = [], this.freeWorkers = [], this.activeWorkers = [], this.setOptions(m);
                    for (F in f)
                      G = f[F], (N = this.options)[F] == null && (N[F] = G);
                  }
                  return y.prototype.setOption = function(m, N) {
                    if (this.options[m] = N, this._canvas != null && (m === "width" || m === "height"))
                      return this._canvas[m] = N;
                  }, y.prototype.setOptions = function(m) {
                    var N, F, G;
                    F = [];
                    for (N in m)
                      u.call(m, N) && (G = m[N], F.push(this.setOption(N, G)));
                    return F;
                  }, y.prototype.addFrame = function(m, N) {
                    var F, G;
                    N == null && (N = {}), F = {}, F.transparent = this.options.transparent;
                    for (G in S)
                      F[G] = N[G] || S[G];
                    if (this.options.width == null && this.setOption("width", m.width), this.options.height == null && this.setOption("height", m.height), typeof ImageData < "u" && ImageData !== null && m instanceof ImageData)
                      F.data = m.data;
                    else if (typeof CanvasRenderingContext2D < "u" && CanvasRenderingContext2D !== null && m instanceof CanvasRenderingContext2D || typeof WebGLRenderingContext < "u" && WebGLRenderingContext !== null && m instanceof WebGLRenderingContext)
                      N.copy ? F.data = this.getContextData(m) : F.context = m;
                    else if (m.childNodes != null)
                      N.copy ? F.data = this.getImageData(m) : F.image = m;
                    else
                      throw new Error("Invalid image");
                    return this.frames.push(F);
                  }, y.prototype.render = function() {
                    var m, N, F;
                    if (this.running)
                      throw new Error("Already running");
                    if (this.options.width == null || this.options.height == null)
                      throw new Error("Width and height must be set prior to rendering");
                    if (this.running = !0, this.nextFrame = 0, this.finishedFrames = 0, this.imageParts = function() {
                      var G, k, v;
                      for (v = [], G = 0, k = this.frames.length; 0 <= k ? G < k : G > k; 0 <= k ? ++G : --G)
                        v.push(null);
                      return v;
                    }.call(this), N = this.spawnWorkers(), this.options.globalPalette === !0)
                      this.renderNextFrame();
                    else
                      for (m = 0, F = N; 0 <= F ? m < F : m > F; 0 <= F ? ++m : --m)
                        this.renderNextFrame();
                    return this.emit("start"), this.emit("progress", 0);
                  }, y.prototype.abort = function() {
                    for (var m; m = this.activeWorkers.shift(), m != null; )
                      this.log("killing active worker"), m.terminate();
                    return this.running = !1, this.emit("abort");
                  }, y.prototype.spawnWorkers = function() {
                    var m, N, F;
                    return m = Math.min(this.options.workers, this.frames.length), function() {
                      F = [];
                      for (var G = N = this.freeWorkers.length; N <= m ? G < m : G > m; N <= m ? G++ : G--)
                        F.push(G);
                      return F;
                    }.apply(this).forEach(function(G) {
                      return function(k) {
                        var v;
                        return G.log("spawning worker " + k), v = new Worker(G.options.workerScript), v.onmessage = function(x) {
                          return G.activeWorkers.splice(G.activeWorkers.indexOf(v), 1), G.freeWorkers.push(v), G.frameFinished(x.data);
                        }, G.freeWorkers.push(v);
                      };
                    }(this)), m;
                  }, y.prototype.frameFinished = function(m) {
                    var N, F;
                    if (this.log("frame " + m.index + " finished - " + this.activeWorkers.length + " active"), this.finishedFrames++, this.emit("progress", this.finishedFrames / this.frames.length), this.imageParts[m.index] = m, this.options.globalPalette === !0 && (this.options.globalPalette = m.globalPalette, this.log("global palette analyzed"), this.frames.length > 2))
                      for (N = 1, F = this.freeWorkers.length; 1 <= F ? N < F : N > F; 1 <= F ? ++N : --N)
                        this.renderNextFrame();
                    return d.call(this.imageParts, null) >= 0 ? this.renderNextFrame() : this.finishRendering();
                  }, y.prototype.finishRendering = function() {
                    var m, N, F, G, k, v, x, H, _, j, V, iA, eA, oA, P, J;
                    for (H = 0, oA = this.imageParts, k = 0, _ = oA.length; k < _; k++)
                      N = oA[k], H += (N.data.length - 1) * N.pageSize + N.cursor;
                    for (H += N.pageSize - N.cursor, this.log("rendering finished - filesize " + Math.round(H / 1e3) + "kb"), m = new Uint8Array(H), iA = 0, P = this.imageParts, v = 0, j = P.length; v < j; v++)
                      for (N = P[v], J = N.data, F = x = 0, V = J.length; x < V; F = ++x)
                        eA = J[F], m.set(eA, iA), F === N.data.length - 1 ? iA += N.cursor : iA += N.pageSize;
                    return G = new Blob([m], { type: "image/gif" }), this.emit("finished", G, m);
                  }, y.prototype.renderNextFrame = function() {
                    var m, N, F;
                    if (this.freeWorkers.length === 0)
                      throw new Error("No free workers");
                    if (!(this.nextFrame >= this.frames.length))
                      return m = this.frames[this.nextFrame++], F = this.freeWorkers.shift(), N = this.getTask(m), this.log("starting frame " + (N.index + 1) + " of " + this.frames.length), this.activeWorkers.push(F), F.postMessage(N);
                  }, y.prototype.getContextData = function(m) {
                    return m.getImageData(0, 0, this.options.width, this.options.height).data;
                  }, y.prototype.getImageData = function(m) {
                    var N;
                    return this._canvas == null && (this._canvas = document.createElement("canvas"), this._canvas.width = this.options.width, this._canvas.height = this.options.height), N = this._canvas.getContext("2d"), N.setFill = this.options.background, N.fillRect(0, 0, this.options.width, this.options.height), N.drawImage(m, 0, 0), this.getContextData(N);
                  }, y.prototype.getTask = function(m) {
                    var N, F;
                    if (N = this.frames.indexOf(m), F = { index: N, last: N === this.frames.length - 1, delay: m.delay, dispose: m.dispose, transparent: m.transparent, width: this.options.width, height: this.options.height, quality: this.options.quality, dither: this.options.dither, globalPalette: this.options.globalPalette, repeat: this.options.repeat, canTransfer: C.name === "chrome" }, m.data != null)
                      F.data = m.data;
                    else if (m.context != null)
                      F.data = this.getContextData(m.context);
                    else if (m.image != null)
                      F.data = this.getImageData(m.image);
                    else
                      throw new Error("Invalid frame");
                    return F;
                  }, y.prototype.log = function() {
                    var m;
                    if (m = 1 <= arguments.length ? p.call(arguments, 0) : [], !!this.options.debug)
                      return console.log.apply(console, m);
                  }, y;
                }(E);
              }, { "./GIFEncoder.js": 2, "./browser.coffee": 5, "./gif.worker.coffee": 7, events: 1 }], 7: [function(s, B, I) {
                var E, C;
                E = s("./GIFEncoder.js"), C = function(c) {
                  var u, d, p, D;
                  return u = new E(c.width, c.height), c.index === 0 ? u.writeHeader() : u.firstFrame = !1, u.setTransparent(c.transparent), u.setDispose(c.dispose), u.setRepeat(c.repeat), u.setDelay(c.delay), u.setQuality(c.quality), u.setDither(c.dither), u.setGlobalPalette(c.globalPalette), u.addFrame(c.data), c.last && u.finish(), c.globalPalette === !0 && (c.globalPalette = u.getGlobalPalette()), p = u.stream(), c.data = p.pages, c.cursor = p.cursor, c.pageSize = p.constructor.pageSize, c.canTransfer ? (D = function() {
                    var f, S, y, m;
                    for (y = c.data, m = [], f = 0, S = y.length; f < S; f++)
                      d = y[f], m.push(d.buffer);
                    return m;
                  }(), self.postMessage(c, D)) : self.postMessage(c);
                }, self.onmessage = function(c) {
                  return C(c.data);
                };
              }, { "./GIFEncoder.js": 2 }] }, {}, [6])(6);
            });
          }
        ),
        /***/
        846: (
          /***/
          (r) => {
            (function() {
              var s = [
                "A",
                "B",
                "C",
                "D",
                "E",
                "F",
                "G",
                "H",
                "I",
                "J",
                "K",
                "L",
                "M",
                "N",
                "O",
                "P",
                "Q",
                "R",
                "S",
                "T",
                "U",
                "V",
                "W",
                "X",
                "Y",
                "Z",
                "a",
                "b",
                "c",
                "d",
                "e",
                "f",
                "g",
                "h",
                "i",
                "j",
                "k",
                "l",
                "m",
                "n",
                "o",
                "p",
                "q",
                "r",
                "s",
                "t",
                "u",
                "v",
                "w",
                "x",
                "y",
                "z",
                "0",
                "1",
                "2",
                "3",
                "4",
                "5",
                "6",
                "7",
                "8",
                "9",
                "+",
                "/"
              ];
              function B(u) {
                var d, p = new Uint8Array(u);
                for (d = 0; d < u; d += 1)
                  p[d] = 0;
                return p;
              }
              function I(u, d, p, D) {
                var f = d + p, S = B((parseInt(f / D) + 1) * D);
                return S.set(u), S;
              }
              function E(u, d, p) {
                return u = u.toString(p || 8), "000000000000".substr(u.length + 12 - d) + u;
              }
              function C(u, d, p) {
                var D, f;
                for (d = d || B(u.length), p = p || 0, D = 0, f = u.length; D < f; D += 1)
                  d[p] = u.charCodeAt(D), p += 1;
                return d;
              }
              function c(u) {
                var d, p = u.length % 3, D = "", f, S;
                function y(m) {
                  return s[m >> 18 & 63] + s[m >> 12 & 63] + s[m >> 6 & 63] + s[m & 63];
                }
                for (d = 0, S = u.length - p; d < S; d += 3)
                  f = (u[d] << 16) + (u[d + 1] << 8) + u[d + 2], D += y(f);
                switch (D.length % 4) {
                  case 1:
                    D += "=";
                    break;
                  case 2:
                    D += "==";
                    break;
                }
                return D;
              }
              window.utils = {}, window.utils.clean = B, window.utils.pad = E, window.utils.extend = I, window.utils.stringToUint8 = C, window.utils.uint8ToBase64 = c;
            })(), function() {
              var s = window.utils, B;
              B = [
                {
                  field: "fileName",
                  length: 100
                },
                {
                  field: "fileMode",
                  length: 8
                },
                {
                  field: "uid",
                  length: 8
                },
                {
                  field: "gid",
                  length: 8
                },
                {
                  field: "fileSize",
                  length: 12
                },
                {
                  field: "mtime",
                  length: 12
                },
                {
                  field: "checksum",
                  length: 8
                },
                {
                  field: "type",
                  length: 1
                },
                {
                  field: "linkName",
                  length: 100
                },
                {
                  field: "ustar",
                  length: 8
                },
                {
                  field: "owner",
                  length: 32
                },
                {
                  field: "group",
                  length: 32
                },
                {
                  field: "majorNumber",
                  length: 8
                },
                {
                  field: "minorNumber",
                  length: 8
                },
                {
                  field: "filenamePrefix",
                  length: 155
                },
                {
                  field: "padding",
                  length: 12
                }
              ];
              function I(E, C) {
                var c = s.clean(512), u = 0;
                return B.forEach(function(d) {
                  var p = E[d.field] || "", D, f;
                  for (D = 0, f = p.length; D < f; D += 1)
                    c[u] = p.charCodeAt(D), u += 1;
                  u += d.length - D;
                }), typeof C == "function" ? C(c, u) : c;
              }
              window.header = {}, window.header.structure = B, window.header.format = I;
            }(), function() {
              var s = window.header, B = window.utils, I = 512, E;
              function C(c) {
                this.written = 0, E = (c || 20) * I, this.out = B.clean(E), this.blocks = [], this.length = 0;
              }
              C.prototype.append = function(c, u, d, p) {
                var D, f, S, y, m, N, F;
                if (typeof u == "string")
                  u = B.stringToUint8(u);
                else if (u.constructor !== Uint8Array.prototype.constructor)
                  throw "Invalid input type. You gave me: " + u.constructor.toString().match(/function\s*([$A-Za-z_][0-9A-Za-z_]*)\s*\(/)[1];
                typeof d == "function" && (d = {}), d = d || {}, S = d.mode || parseInt("777", 8) & 4095, y = d.mtime || Math.floor(+/* @__PURE__ */ new Date() / 1e3), m = d.uid || 0, N = d.gid || 0, D = {
                  fileName: c,
                  fileMode: B.pad(S, 7),
                  uid: B.pad(m, 7),
                  gid: B.pad(N, 7),
                  fileSize: B.pad(u.length, 11),
                  mtime: B.pad(y, 11),
                  checksum: "        ",
                  type: "0",
                  // just a file
                  ustar: "ustar  ",
                  owner: d.owner || "",
                  group: d.group || ""
                }, f = 0, Object.keys(D).forEach(function(v) {
                  var x, H = D[v], _;
                  for (x = 0, _ = H.length; x < _; x += 1)
                    f += H.charCodeAt(x);
                }), D.checksum = B.pad(f, 6) + "\0 ", F = s.format(D);
                var G = Math.ceil(F.length / I) * I, k = Math.ceil(u.length / I) * I;
                this.blocks.push({ header: F, input: u, headerLength: G, inputLength: k });
              }, C.prototype.save = function() {
                var c = [], u = [], d = 0, p = Math.pow(2, 20), D = [];
                return this.blocks.forEach(function(f) {
                  d + f.headerLength + f.inputLength > p && (u.push({ blocks: D, length: d }), D = [], d = 0), D.push(f), d += f.headerLength + f.inputLength;
                }), u.push({ blocks: D, length: d }), u.forEach(function(f) {
                  var S = new Uint8Array(f.length), y = 0;
                  f.blocks.forEach(function(m) {
                    S.set(m.header, y), y += m.headerLength, S.set(m.input, y), y += m.inputLength;
                  }), c.push(S);
                }), c.push(new Uint8Array(2 * I)), new Blob(c, { type: "octet/stream" });
              }, C.prototype.clear = function() {
                this.written = 0, this.out = B.clean(E);
              }, typeof r.exports < "u" ? r.exports = C : window.Tar = C;
            }();
          }
        ),
        /***/
        166: (
          /***/
          (r) => {
            var s = function(I) {
              this.data = new Uint8Array(I), this.pos = 0;
            };
            s.prototype.seek = function(I) {
              this.pos = I;
            }, s.prototype.writeBytes = function(I) {
              for (var E = 0; E < I.length; E++)
                this.data[this.pos++] = I[E];
            }, s.prototype.writeByte = function(I) {
              this.data[this.pos++] = I;
            }, s.prototype.writeU8 = s.prototype.writeByte, s.prototype.writeU16BE = function(I) {
              this.data[this.pos++] = I >> 8, this.data[this.pos++] = I;
            }, s.prototype.writeDoubleBE = function(I) {
              for (var E = new Uint8Array(new Float64Array([I]).buffer), C = E.length - 1; C >= 0; C--)
                this.writeByte(E[C]);
            }, s.prototype.writeFloatBE = function(I) {
              for (var E = new Uint8Array(new Float32Array([I]).buffer), C = E.length - 1; C >= 0; C--)
                this.writeByte(E[C]);
            }, s.prototype.writeString = function(I) {
              for (var E = 0; E < I.length; E++)
                this.data[this.pos++] = I.charCodeAt(E);
            }, s.prototype.writeEBMLVarIntWidth = function(I, E) {
              switch (E) {
                case 1:
                  this.writeU8(128 | I);
                  break;
                case 2:
                  this.writeU8(64 | I >> 8), this.writeU8(I);
                  break;
                case 3:
                  this.writeU8(32 | I >> 16), this.writeU8(I >> 8), this.writeU8(I);
                  break;
                case 4:
                  this.writeU8(16 | I >> 24), this.writeU8(I >> 16), this.writeU8(I >> 8), this.writeU8(I);
                  break;
                case 5:
                  this.writeU8(8 | I / 4294967296 & 7), this.writeU8(I >> 24), this.writeU8(I >> 16), this.writeU8(I >> 8), this.writeU8(I);
                  break;
                default:
                  throw new RuntimeException("Bad EBML VINT size " + E);
              }
            }, s.prototype.measureEBMLVarInt = function(I) {
              if (I < 127)
                return 1;
              if (I < 16383)
                return 2;
              if (I < 2097151)
                return 3;
              if (I < 268435455)
                return 4;
              if (I < 34359738367)
                return 5;
              throw new RuntimeException("EBML VINT size not supported " + I);
            }, s.prototype.writeEBMLVarInt = function(I) {
              this.writeEBMLVarIntWidth(I, this.measureEBMLVarInt(I));
            }, s.prototype.writeUnsignedIntBE = function(I, E) {
              switch (E === void 0 && (E = this.measureUnsignedInt(I)), E) {
                case 5:
                  this.writeU8(Math.floor(I / 4294967296));
                case 4:
                  this.writeU8(I >> 24);
                case 3:
                  this.writeU8(I >> 16);
                case 2:
                  this.writeU8(I >> 8);
                case 1:
                  this.writeU8(I);
                  break;
                default:
                  throw new RuntimeException("Bad UINT size " + E);
              }
            }, s.prototype.measureUnsignedInt = function(I) {
              return I < 256 ? 1 : I < 65536 ? 2 : I < 16777216 ? 3 : I < 4294967296 ? 4 : 5;
            }, s.prototype.getAsDataArray = function() {
              if (this.pos < this.data.byteLength)
                return this.data.subarray(0, this.pos);
              if (this.pos == this.data.byteLength)
                return this.data;
              throw "ArrayBufferDataStream's pos lies beyond end of buffer";
            };
            var B = function(I) {
              return function(E) {
                var C = [], c = Promise.resolve(), u = null, d = null;
                typeof FileWriter < "u" && E instanceof FileWriter ? u = E : I && E && (d = E), this.pos = 0, this.length = 0;
                function p(S) {
                  return new Promise(function(y, m) {
                    var N = new FileReader();
                    N.addEventListener("loadend", function() {
                      y(N.result);
                    }), N.readAsArrayBuffer(S);
                  });
                }
                function D(S) {
                  return new Promise(function(y, m) {
                    S instanceof Uint8Array ? y(S) : S instanceof ArrayBuffer || ArrayBuffer.isView(S) ? y(new Uint8Array(S)) : S instanceof Blob ? y(p(S).then(function(N) {
                      return new Uint8Array(N);
                    })) : y(p(new Blob([S])).then(function(N) {
                      return new Uint8Array(N);
                    }));
                  });
                }
                function f(S) {
                  var y = S.byteLength || S.length || S.size;
                  if (!Number.isInteger(y))
                    throw "Failed to determine size of element";
                  return y;
                }
                this.seek = function(S) {
                  if (S < 0)
                    throw "Offset may not be negative";
                  if (isNaN(S))
                    throw "Offset may not be NaN";
                  if (S > this.length)
                    throw "Seeking beyond the end of file is not allowed";
                  this.pos = S;
                }, this.write = function(S) {
                  var y = {
                    offset: this.pos,
                    data: S,
                    length: f(S)
                  }, m = y.offset >= this.length;
                  this.pos += y.length, this.length = Math.max(this.length, this.pos), c = c.then(function() {
                    if (d)
                      return new Promise(function(G, k) {
                        D(y.data).then(function(v) {
                          var x = 0, H = Buffer.from(v.buffer), _ = function(j, V, iA) {
                            x += V, x >= iA.length ? G() : I.write(d, iA, x, iA.length - x, y.offset + x, _);
                          };
                          I.write(d, H, 0, H.length, y.offset, _);
                        });
                      });
                    if (u)
                      return new Promise(function(G, k) {
                        u.onwriteend = G, u.seek(y.offset), u.write(new Blob([y.data]));
                      });
                    if (!m)
                      for (var N = 0; N < C.length; N++) {
                        var F = C[N];
                        if (!(y.offset + y.length <= F.offset || y.offset >= F.offset + F.length)) {
                          if (y.offset < F.offset || y.offset + y.length > F.offset + F.length)
                            throw new Error("Overwrite crosses blob boundaries");
                          if (y.offset == F.offset && y.length == F.length) {
                            F.data = y.data;
                            return;
                          } else
                            return D(F.data).then(function(G) {
                              return F.data = G, D(y.data);
                            }).then(function(G) {
                              y.data = G, F.data.set(y.data, y.offset - F.offset);
                            });
                        }
                      }
                    C.push(y);
                  });
                }, this.complete = function(S) {
                  return d || u ? c = c.then(function() {
                    return null;
                  }) : c = c.then(function() {
                    for (var y = [], m = 0; m < C.length; m++)
                      y.push(C[m].data);
                    return new Blob(y, { mimeType: S });
                  }), c;
                };
              };
            }(null);
            (function() {
              var I = function(E, C) {
                function c(y, m) {
                  var N = {};
                  return [y, m].forEach(function(F) {
                    for (var G in F)
                      Object.prototype.hasOwnProperty.call(F, G) && (N[G] = F[G]);
                  }), N;
                }
                function u(y) {
                  return typeof y != "string" || !y.match(/^data:image\/webp;base64,/i) ? !1 : window.atob(y.substring(23));
                }
                function d(y, m) {
                  var N = y.toDataURL("image/webp", { quality: m });
                  return u(N);
                }
                function p(y) {
                  var m = y.indexOf("VP8 ");
                  if (m == -1)
                    throw "Failed to identify beginning of keyframe in WebP image";
                  return m += 8, y.substring(m);
                }
                function D(y) {
                  this.value = y;
                }
                function f(y) {
                  this.value = y;
                }
                function S(y, m, N) {
                  if (Array.isArray(N))
                    for (var F = 0; F < N.length; F++)
                      S(y, m, N[F]);
                  else if (typeof N == "string")
                    y.writeString(N);
                  else if (N instanceof Uint8Array)
                    y.writeBytes(N);
                  else if (N.id)
                    if (N.offset = y.pos + m, y.writeUnsignedIntBE(N.id), Array.isArray(N.data)) {
                      var G, k, v;
                      N.size === -1 ? y.writeByte(255) : (G = y.pos, y.writeBytes([0, 0, 0, 0])), k = y.pos, N.dataOffset = k + m, S(y, m, N.data), N.size !== -1 && (v = y.pos, N.size = v - k, y.seek(G), y.writeEBMLVarIntWidth(N.size, 4), y.seek(v));
                    } else if (typeof N.data == "string")
                      y.writeEBMLVarInt(N.data.length), N.dataOffset = y.pos + m, y.writeString(N.data);
                    else if (typeof N.data == "number")
                      N.size || (N.size = y.measureUnsignedInt(N.data)), y.writeEBMLVarInt(N.size), N.dataOffset = y.pos + m, y.writeUnsignedIntBE(N.data, N.size);
                    else if (N.data instanceof f)
                      y.writeEBMLVarInt(8), N.dataOffset = y.pos + m, y.writeDoubleBE(N.data.value);
                    else if (N.data instanceof D)
                      y.writeEBMLVarInt(4), N.dataOffset = y.pos + m, y.writeFloatBE(N.data.value);
                    else if (N.data instanceof Uint8Array)
                      y.writeEBMLVarInt(N.data.byteLength), N.dataOffset = y.pos + m, y.writeBytes(N.data);
                    else
                      throw "Bad EBML datatype " + typeof N.data;
                  else
                    throw "Bad EBML datatype " + typeof N.data;
                }
                return function(y) {
                  var m = 5e3, N = 1, F = !1, G, k, v = [], x = 0, H = 0, _ = {
                    quality: 0.95,
                    // WebM image quality from 0.0 (worst) to 1.0 (best)
                    fileWriter: null,
                    // Chrome FileWriter in order to stream to a file instead of buffering to memory (optional)
                    fd: null,
                    // Node.JS file descriptor to write to instead of buffering (optional)
                    // You must supply one of:
                    frameDuration: null,
                    // Duration of frames in milliseconds
                    frameRate: null
                    // Number of frames per second
                  }, j = {
                    Cues: { id: new Uint8Array([28, 83, 187, 107]), positionEBML: null },
                    SegmentInfo: { id: new Uint8Array([21, 73, 169, 102]), positionEBML: null },
                    Tracks: { id: new Uint8Array([22, 84, 174, 107]), positionEBML: null }
                  }, V, iA = {
                    id: 17545,
                    // Duration
                    data: new f(0)
                  }, eA, oA = [], P = new C(y.fileWriter || y.fd);
                  function J(FA) {
                    return FA - V.dataOffset;
                  }
                  function tA() {
                    var FA = {
                      id: 21420,
                      // SeekPosition
                      size: 5,
                      // Allows for 32GB video files
                      data: 0
                      // We'll overwrite this when the file is complete
                    }, dA = {
                      id: 290298740,
                      // SeekHead
                      data: []
                    };
                    for (var vA in j) {
                      var JA = j[vA];
                      JA.positionEBML = Object.create(FA), dA.data.push({
                        id: 19899,
                        // Seek
                        data: [
                          {
                            id: 21419,
                            // SeekID
                            data: JA.id
                          },
                          JA.positionEBML
                        ]
                      });
                    }
                    return dA;
                  }
                  function Y() {
                    eA = tA();
                    var FA = {
                      id: 440786851,
                      // EBML
                      data: [
                        {
                          id: 17030,
                          // EBMLVersion
                          data: 1
                        },
                        {
                          id: 17143,
                          // EBMLReadVersion
                          data: 1
                        },
                        {
                          id: 17138,
                          // EBMLMaxIDLength
                          data: 4
                        },
                        {
                          id: 17139,
                          // EBMLMaxSizeLength
                          data: 8
                        },
                        {
                          id: 17026,
                          // DocType
                          data: "webm"
                        },
                        {
                          id: 17031,
                          // DocTypeVersion
                          data: 2
                        },
                        {
                          id: 17029,
                          // DocTypeReadVersion
                          data: 2
                        }
                      ]
                    }, dA = {
                      id: 357149030,
                      // Info
                      data: [
                        {
                          id: 2807729,
                          // TimecodeScale
                          data: 1e6
                          // Times will be in miliseconds (1e6 nanoseconds per step = 1ms)
                        },
                        {
                          id: 19840,
                          // MuxingApp
                          data: "webm-writer-js"
                        },
                        {
                          id: 22337,
                          // WritingApp
                          data: "webm-writer-js"
                        },
                        iA
                        // To be filled in later
                      ]
                    }, vA = {
                      id: 374648427,
                      // Tracks
                      data: [
                        {
                          id: 174,
                          // TrackEntry
                          data: [
                            {
                              id: 215,
                              // TrackNumber
                              data: N
                            },
                            {
                              id: 29637,
                              // TrackUID
                              data: N
                            },
                            {
                              id: 156,
                              // FlagLacing
                              data: 0
                            },
                            {
                              id: 2274716,
                              // Language
                              data: "und"
                            },
                            {
                              id: 134,
                              // CodecID
                              data: "V_VP8"
                            },
                            {
                              id: 2459272,
                              // CodecName
                              data: "VP8"
                            },
                            {
                              id: 131,
                              // TrackType
                              data: 1
                            },
                            {
                              id: 224,
                              // Video
                              data: [
                                {
                                  id: 176,
                                  // PixelWidth
                                  data: G
                                },
                                {
                                  id: 186,
                                  // PixelHeight
                                  data: k
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    };
                    V = {
                      id: 408125543,
                      // Segment
                      size: -1,
                      // Unbounded size
                      data: [
                        eA,
                        dA,
                        vA
                      ]
                    };
                    var JA = new E(256);
                    S(JA, P.pos, [FA, V]), P.write(JA.getAsDataArray()), j.SegmentInfo.positionEBML.data = J(dA.offset), j.Tracks.positionEBML.data = J(vA.offset);
                  }
                  function rA(FA) {
                    var dA = new E(4);
                    if (!(FA.trackNumber > 0 && FA.trackNumber < 127))
                      throw "TrackNumber must be > 0 and < 127";
                    return dA.writeEBMLVarInt(FA.trackNumber), dA.writeU16BE(FA.timecode), dA.writeByte(
                      128
                      // Keyframe
                    ), {
                      id: 163,
                      // SimpleBlock
                      data: [
                        dA.getAsDataArray(),
                        FA.frame
                      ]
                    };
                  }
                  function QA(FA) {
                    return {
                      id: 524531317,
                      data: [
                        {
                          id: 231,
                          // Timecode
                          data: Math.round(FA.timecode)
                        }
                      ]
                    };
                  }
                  function aA(FA, dA, vA) {
                    oA.push({
                      id: 187,
                      // Cue
                      data: [
                        {
                          id: 179,
                          // CueTime
                          data: dA
                        },
                        {
                          id: 183,
                          // CueTrackPositions
                          data: [
                            {
                              id: 247,
                              // CueTrack
                              data: FA
                            },
                            {
                              id: 241,
                              // CueClusterPosition
                              data: J(vA)
                            }
                          ]
                        }
                      ]
                    });
                  }
                  function MA() {
                    var FA = {
                      id: 475249515,
                      data: oA
                    }, dA = new E(16 + oA.length * 32);
                    S(dA, P.pos, FA), P.write(dA.getAsDataArray()), j.Cues.positionEBML.data = J(FA.offset);
                  }
                  function hA() {
                    if (v.length != 0) {
                      for (var FA = 0, dA = 0; dA < v.length; dA++)
                        FA += v[dA].frame.length;
                      for (var vA = new E(FA + v.length * 32), JA = QA({
                        timecode: Math.round(x)
                      }), dA = 0; dA < v.length; dA++)
                        JA.data.push(rA(v[dA]));
                      S(vA, P.pos, JA), P.write(vA.getAsDataArray()), aA(N, Math.round(x), JA.offset), v = [], x += H, H = 0;
                    }
                  }
                  function fA() {
                    if (!y.frameDuration)
                      if (y.frameRate)
                        y.frameDuration = 1e3 / y.frameRate;
                      else
                        throw "Missing required frameDuration or frameRate setting";
                  }
                  function wA(FA) {
                    FA.trackNumber = N, FA.timecode = Math.round(H), v.push(FA), H += FA.duration, H >= m && hA();
                  }
                  function yA() {
                    var FA = new E(eA.size), dA = P.pos;
                    S(FA, eA.dataOffset, eA.data), P.seek(eA.dataOffset), P.write(FA.getAsDataArray()), P.seek(dA);
                  }
                  function kA() {
                    var FA = new E(8), dA = P.pos;
                    FA.writeDoubleBE(x), P.seek(iA.dataOffset), P.write(FA.getAsDataArray()), P.seek(dA);
                  }
                  this.addFrame = function(FA) {
                    if (F) {
                      if (FA.width != G || FA.height != k)
                        throw "Frame size differs from previous frames";
                    } else
                      G = FA.width, k = FA.height, Y(), F = !0;
                    var dA = d(FA, { quality: y.quality });
                    if (!dA)
                      throw "Couldn't decode WebP frame, does the browser support WebP?";
                    wA({
                      frame: p(dA),
                      duration: y.frameDuration
                    });
                  }, this.complete = function() {
                    return hA(), MA(), yA(), kA(), P.complete("video/webm");
                  }, this.getWrittenSize = function() {
                    return P.length;
                  }, y = c(_, y || {}), fA();
                };
              };
              typeof r.exports < "u" ? r.exports = I(s, B) : window.WebMWriter = I(s, B);
            })();
          }
        ),
        /***/
        681: (
          /***/
          (r) => {
            r.exports = JSON.parse('{"_from":"@ffmpeg/ffmpeg","_id":"@ffmpeg/ffmpeg@0.10.1","_inBundle":false,"_integrity":"sha512-ChQkH7Rh57hmVo1LhfQFibWX/xqneolJKSwItwZdKPcLZuKigtYAYDIvB55pDfP17VtR1R77SxgkB2/UApB+Og==","_location":"/@ffmpeg/ffmpeg","_phantomChildren":{},"_requested":{"type":"tag","registry":true,"raw":"@ffmpeg/ffmpeg","name":"@ffmpeg/ffmpeg","escapedName":"@ffmpeg%2fffmpeg","scope":"@ffmpeg","rawSpec":"","saveSpec":null,"fetchSpec":"latest"},"_requiredBy":["#USER","/"],"_resolved":"https://registry.npmjs.org/@ffmpeg/ffmpeg/-/ffmpeg-0.10.1.tgz","_shasum":"3dacf3985de9c83a95fbf79fe709920cc009b00a","_spec":"@ffmpeg/ffmpeg","_where":"/Users/amandaghassaei/Projects/canvas-capture","author":{"name":"Jerome Wu","email":"jeromewus@gmail.com"},"browser":{"./src/node/index.js":"./src/browser/index.js"},"bugs":{"url":"https://github.com/ffmpegwasm/ffmpeg.wasm/issues"},"bundleDependencies":false,"dependencies":{"is-url":"^1.2.4","node-fetch":"^2.6.1","regenerator-runtime":"^0.13.7","resolve-url":"^0.2.1"},"deprecated":false,"description":"FFmpeg WebAssembly version","devDependencies":{"@babel/core":"^7.12.3","@babel/preset-env":"^7.12.1","@ffmpeg/core":"^0.10.0","@types/emscripten":"^1.39.4","babel-loader":"^8.1.0","chai":"^4.2.0","cors":"^2.8.5","eslint":"^7.12.1","eslint-config-airbnb-base":"^14.1.0","eslint-plugin-import":"^2.22.1","express":"^4.17.1","mocha":"^8.2.1","mocha-headless-chrome":"^2.0.3","npm-run-all":"^4.1.5","wait-on":"^5.3.0","webpack":"^5.3.2","webpack-cli":"^4.1.0","webpack-dev-middleware":"^4.0.0"},"directories":{"example":"examples"},"engines":{"node":">=12.16.1"},"homepage":"https://github.com/ffmpegwasm/ffmpeg.wasm#readme","keywords":["ffmpeg","WebAssembly","video"],"license":"MIT","main":"src/index.js","name":"@ffmpeg/ffmpeg","repository":{"type":"git","url":"git+https://github.com/ffmpegwasm/ffmpeg.wasm.git"},"scripts":{"build":"rimraf dist && webpack --config scripts/webpack.config.prod.js","lint":"eslint src","prepublishOnly":"npm run build","start":"node scripts/server.js","test":"npm-run-all -p -r start test:all","test:all":"npm-run-all wait test:browser:ffmpeg test:node:all","test:browser":"mocha-headless-chrome -a allow-file-access-from-files -a incognito -a no-sandbox -a disable-setuid-sandbox -a disable-logging -t 300000","test:browser:ffmpeg":"npm run test:browser -- -f ./tests/ffmpeg.test.html","test:node":"node --experimental-wasm-threads --experimental-wasm-bulk-memory node_modules/.bin/_mocha --exit --bail --require ./scripts/test-helper.js","test:node:all":"npm run test:node -- ./tests/*.test.js","wait":"rimraf dist && wait-on http://localhost:3000/dist/ffmpeg.dev.js"},"types":"src/index.d.ts","version":"0.10.1"}');
          }
        )
        /******/
      }, t = {};
      function i(r) {
        var s = t[r];
        if (s !== void 0)
          return s.exports;
        var B = t[r] = {
          /******/
          id: r,
          /******/
          loaded: !1,
          /******/
          exports: {}
          /******/
        };
        return e[r].call(B.exports, B, B.exports, i), B.loaded = !0, B.exports;
      }
      i.d = (r, s) => {
        for (var B in s)
          i.o(s, B) && !i.o(r, B) && Object.defineProperty(r, B, { enumerable: !0, get: s[B] });
      }, i.g = function() {
        if (typeof globalThis == "object")
          return globalThis;
        try {
          return this || new Function("return this")();
        } catch {
          if (typeof window == "object")
            return window;
        }
      }(), i.o = (r, s) => Object.prototype.hasOwnProperty.call(r, s), i.r = (r) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(r, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(r, "__esModule", { value: !0 });
      }, i.nmd = (r) => (r.paths = [], r.children || (r.children = []), r);
      var n = {};
      return (() => {
        var r = n;
        Object.defineProperty(r, "__esModule", { value: !0 }), r.CanvasCapture = void 0;
        var s = i(914);
        r.CanvasCapture = s, r.default = s;
      })(), n;
    })()
  ));
})(YP);
const of = /* @__PURE__ */ mU(uf), HP = () => {
  const g = xP(), {
    modelMesh: A,
    mousePosition: e,
    raycastIntersectionRef: t,
    gizmoRef: i,
    cameraControls: n,
    mouseHelper: r
  } = Vc(), {
    pastedStickers: s,
    setPastedStickers: B,
    selectedSticker: I,
    setSelectedSticker: E,
    scale: C,
    setScale: c,
    rotation: u,
    setRotation: d,
    modelPosition: p,
    isDragging: D,
    isRotating: f,
    modelScaleFactor: S
  } = dB(), { scene: y, camera: m } = mr(), N = Dt(0);
  cy(() => {
    r.current = new Xi(
      new Xa(1, 1, 10),
      new Oy()
    ), y.add(r.current), r.current.visible = !1;
  }, [r, y]);
  const F = (k, v) => {
    const x = s.findIndex((_) => _.id === k);
    if (x < 0 || D || f)
      return;
    const H = new nm();
    B((_) => {
      if (!t.current || !A.current)
        return _;
      const j = [..._], V = j[x];
      V.mh = r.current.clone(), V.mh.clone().rotateOnAxis(new IA(0, 0, 1), V.rotationAngle), V.geometry.calculateUV(v, new ue(0, 0), -1, !0), H.setFromCamera(e.current, m);
      const eA = y.getObjectByName(`STICKER_${k}`), oA = H.intersectObjects([eA]);
      if (oA.length > 0 && oA[0].uv) {
        const J = oA[0].uv;
        V.translateFactor = J;
      }
      V.geometry.calculateUV(v, V.translateFactor, V.scale).setRotation(V.rotationAngle);
      const P = eA.material;
      return V.position = t.current.point.clone(), V.face = v, P.needsUpdate = !0, j;
    }), G();
  }, G = dg(() => {
    const k = s.find(
      (_) => _.id === I
    );
    if (i.current.visible = !!k, !k || !i.current)
      return;
    const v = k.mh.rotation.clone();
    i.current.rotation.copy(v);
    const x = new IA();
    i.current?.getWorldDirection(x);
    const H = k.position.clone();
    i.current?.position.copy(H.add(x.multiplyScalar(0.03)));
  }, [i, s, I]);
  return qE(({ camera: k, raycaster: v }, x) => {
    const H = e.current;
    if (n.current && (of.isRecording() ? (n.current.azimuthAngle += 2.8 * (x !== 0 ? x : 1), of.recordFrame(), n.current.azimuthAngle - N.current >= Math.PI * 2 && (of.stopRecord(), y.traverse((_) => {
      _.userData.hideOnExport && (_.visible = !0);
    }))) : N.current = n.current.azimuthAngle), A.current && H) {
      v.setFromCamera(H, k);
      const _ = v.intersectObjects([A.current]);
      if (_.length > 0) {
        t.current = _[0];
        const j = _[0].point.clone();
        r.current?.position.copy(j);
        const V = _[0].face?.normal.clone();
        V?.transformDirection(A.current.matrixWorld), V?.multiplyScalar(2), V?.add(_[0].point), r.current?.lookAt(V), t.current.point = j;
        return;
      }
      t.current = void 0;
    }
  }), gi(() => {
    B((k) => {
      const v = k.findIndex((eA) => eA.id === I);
      if (v < 0)
        return k;
      const x = [...k], H = x[v], _ = H.mh.clone(), j = u / 50 * Math.PI;
      H.rotationAngle = j, _.rotateOnAxis(new IA(0, 0, 1), j), H.geometry = H.geometry.calculateUV(H.face, H.translateFactor, C).setRotation(j), H.scale = C, H.rotationAngle = j;
      const iA = y.getObjectByName(`STICKER_${H.id}`).material;
      return iA.needsUpdate = !0, x;
    });
  }, [u, C, I, y, B]), gi(() => {
    G();
  }, [I, G]), /* @__PURE__ */ Wi(Df, { children: [
    /* @__PURE__ */ Wi("group", { name: "MODEL_GROUP", scale: 0.01, position: p, children: [
      s.map((k, v) => /* @__PURE__ */ fe(
        LP,
        {
          id: k.id,
          selected: k.id === I,
          mesh: { geometry: k.geometry.getGeometry() },
          index: v,
          image: k.image,
          texture: k.texture,
          onClick: (x) => {
            const H = x.uv;
            H.x >= 0 && H.x < 1 && H.y >= 0 && H.y < 1 && (x.stopPropagation(), d(k.rotationAngle * 50 / Math.PI), c(k.scale), E(k.id));
          },
          onDrag: (x) => {
            const H = x.event.face.a;
            F(k.id, H);
          }
        },
        k.id
      )),
      /* @__PURE__ */ Wi("group", { name: "MODEL_MESH", children: [
        /* @__PURE__ */ fe("mesh", { ref: A, geometry: oy(g)?.geometry, children: /* @__PURE__ */ fe("meshStandardMaterial", {}) }),
        g.children.filter((k) => k.uuid !== oy(g)?.uuid).map((k) => k instanceof Xi ? /* @__PURE__ */ fe(
          "mesh",
          {
            geometry: k.geometry,
            scale: S,
            children: /* @__PURE__ */ fe("meshStandardMaterial", {})
          },
          k.uuid
        ) : k instanceof eo ? /* @__PURE__ */ fe(
          "group",
          {
            name: k.name,
            position: new IA().copy(k.position),
            rotation: new Nr().copy(k.rotation),
            scale: new IA().copy(k.scale),
            children: k.children.map((v) => /* @__PURE__ */ fe(
              "mesh",
              {
                geometry: v.geometry,
                material: v.material
              },
              v.uuid
            ))
          },
          k.uuid
        ) : null)
      ] })
    ] }),
    /* @__PURE__ */ fe(bP, { ref: i })
  ] });
}, _P = ({
  modelMesh: g,
  intersectionRef: A,
  mousePosition: e
}) => (qE(({ camera: t, raycaster: i }) => {
  if (!e.current || (i.setFromCamera(e.current, t), !g.current))
    return;
  const n = i.intersectObject(g.current);
  n.length !== 0 && (A.current = n[0]);
}), null), sy = ({ value: g, min: A, max: e, onChange: t, step: i }) => /* @__PURE__ */ fe(
  "input",
  {
    type: "range",
    value: g,
    min: A,
    max: e,
    className: "ms-h-2 ms-w-full ms-cursor-pointer ms-appearance-none ms-rounded-lg ms-bg-gray-500",
    onChange: t,
    step: i || 1
  }
), ZF = () => /* @__PURE__ */ fe(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    className: "text-white",
    children: /* @__PURE__ */ Wi("g", { color: "white", children: [
      /* @__PURE__ */ fe("circle", { cx: "12", cy: "2.5", r: "1.5", fill: "currentColor", opacity: ".14" }),
      /* @__PURE__ */ fe(
        "circle",
        {
          cx: "16.75",
          cy: "3.77",
          r: "1.5",
          fill: "currentColor",
          opacity: ".29"
        }
      ),
      /* @__PURE__ */ fe(
        "circle",
        {
          cx: "20.23",
          cy: "7.25",
          r: "1.5",
          fill: "currentColor",
          opacity: ".43"
        }
      ),
      /* @__PURE__ */ fe(
        "circle",
        {
          cx: "21.50",
          cy: "12.00",
          r: "1.5",
          fill: "currentColor",
          opacity: ".57"
        }
      ),
      /* @__PURE__ */ fe(
        "circle",
        {
          cx: "20.23",
          cy: "16.75",
          r: "1.5",
          fill: "currentColor",
          opacity: ".71"
        }
      ),
      /* @__PURE__ */ fe(
        "circle",
        {
          cx: "16.75",
          cy: "20.23",
          r: "1.5",
          fill: "currentColor",
          opacity: ".86"
        }
      ),
      /* @__PURE__ */ fe("circle", { cx: "12", cy: "21.5", r: "1.5", fill: "currentColor" }),
      /* @__PURE__ */ fe(
        "animateTransform",
        {
          attributeName: "transform",
          type: "rotate",
          calcMode: "discrete",
          dur: "0.75s",
          values: "0 12 12;30 12 12;60 12 12;90 12 12;120 12 12;150 12 12;180 12 12;210 12 12;240 12 12;270 12 12;300 12 12;330 12 12;360 12 12",
          repeatCount: "indefinite"
        }
      )
    ] })
  }
);
function JP() {
  for (var g = arguments.length, A = new Array(g), e = 0; e < g; e++)
    A[e] = arguments[e];
  return ni(
    () => (t) => {
      A.forEach((i) => i(t));
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    A
  );
}
const Jf = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
function PE(g) {
  const A = Object.prototype.toString.call(g);
  return A === "[object Window]" || // In Electron context the Window object serializes to [object global]
  A === "[object global]";
}
function Cm(g) {
  return "nodeType" in g;
}
function Fr(g) {
  var A, e;
  return g ? PE(g) ? g : Cm(g) && (A = (e = g.ownerDocument) == null ? void 0 : e.defaultView) != null ? A : window : window;
}
function Qm(g) {
  const {
    Document: A
  } = Fr(g);
  return g instanceof A;
}
function pu(g) {
  return PE(g) ? !1 : g instanceof Fr(g).HTMLElement;
}
function OP(g) {
  return g instanceof Fr(g).SVGElement;
}
function WE(g) {
  return g ? PE(g) ? g.document : Cm(g) ? Qm(g) ? g : pu(g) ? g.ownerDocument : document : document : document;
}
const Es = Jf ? cy : gi;
function Em(g) {
  const A = Dt(g);
  return Es(() => {
    A.current = g;
  }), dg(function() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return A.current == null ? void 0 : A.current(...t);
  }, []);
}
function qP() {
  const g = Dt(null), A = dg((t, i) => {
    g.current = setInterval(t, i);
  }, []), e = dg(() => {
    g.current !== null && (clearInterval(g.current), g.current = null);
  }, []);
  return [A, e];
}
function qc(g, A) {
  A === void 0 && (A = [g]);
  const e = Dt(g);
  return Es(() => {
    e.current !== g && (e.current = g);
  }, A), e;
}
function Du(g, A) {
  const e = Dt();
  return ni(
    () => {
      const t = g(e.current);
      return e.current = t, t;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [...A]
  );
}
function hf(g) {
  const A = Em(g), e = Dt(null), t = dg(
    (i) => {
      i !== e.current && A?.(i, e.current), e.current = i;
    },
    //eslint-disable-next-line
    []
  );
  return [e, t];
}
function ay(g) {
  const A = Dt();
  return gi(() => {
    A.current = g;
  }, [g]), A.current;
}
let tw = {};
function wu(g, A) {
  return ni(() => {
    if (A)
      return A;
    const e = tw[g] == null ? 0 : tw[g] + 1;
    return tw[g] = e, g + "-" + e;
  }, [g, A]);
}
function ck(g) {
  return function(A) {
    for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)
      t[i - 1] = arguments[i];
    return t.reduce((n, r) => {
      const s = Object.entries(r);
      for (const [B, I] of s) {
        const E = n[B];
        E != null && (n[B] = E + g * I);
      }
      return n;
    }, {
      ...A
    });
  };
}
const SE = /* @__PURE__ */ ck(1), Pc = /* @__PURE__ */ ck(-1);
function PP(g) {
  return "clientX" in g && "clientY" in g;
}
function lm(g) {
  if (!g)
    return !1;
  const {
    KeyboardEvent: A
  } = Fr(g.target);
  return A && g instanceof A;
}
function WP(g) {
  if (!g)
    return !1;
  const {
    TouchEvent: A
  } = Fr(g.target);
  return A && g instanceof A;
}
function Iy(g) {
  if (WP(g)) {
    if (g.touches && g.touches.length) {
      const {
        clientX: A,
        clientY: e
      } = g.touches[0];
      return {
        x: A,
        y: e
      };
    } else if (g.changedTouches && g.changedTouches.length) {
      const {
        clientX: A,
        clientY: e
      } = g.changedTouches[0];
      return {
        x: A,
        y: e
      };
    }
  }
  return PP(g) ? {
    x: g.clientX,
    y: g.clientY
  } : null;
}
const Wc = /* @__PURE__ */ Object.freeze({
  Translate: {
    toString(g) {
      if (!g)
        return;
      const {
        x: A,
        y: e
      } = g;
      return "translate3d(" + (A ? Math.round(A) : 0) + "px, " + (e ? Math.round(e) : 0) + "px, 0)";
    }
  },
  Scale: {
    toString(g) {
      if (!g)
        return;
      const {
        scaleX: A,
        scaleY: e
      } = g;
      return "scaleX(" + A + ") scaleY(" + e + ")";
    }
  },
  Transform: {
    toString(g) {
      if (g)
        return [Wc.Translate.toString(g), Wc.Scale.toString(g)].join(" ");
    }
  },
  Transition: {
    toString(g) {
      let {
        property: A,
        duration: e,
        easing: t
      } = g;
      return A + " " + e + "ms " + t;
    }
  }
}), XF = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]";
function zP(g) {
  return g.matches(XF) ? g : g.querySelector(XF);
}
const VP = {
  display: "none"
};
function jP(g) {
  let {
    id: A,
    value: e
  } = g;
  return qi.createElement("div", {
    id: A,
    style: VP
  }, e);
}
const ZP = {
  position: "fixed",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0 0 0 0)",
  clipPath: "inset(100%)",
  whiteSpace: "nowrap"
};
function XP(g) {
  let {
    id: A,
    announcement: e
  } = g;
  return qi.createElement("div", {
    id: A,
    style: ZP,
    role: "status",
    "aria-live": "assertive",
    "aria-atomic": !0
  }, e);
}
function $P() {
  const [g, A] = cn("");
  return {
    announce: dg((t) => {
      t != null && A(t);
    }, []),
    announcement: g
  };
}
const uk = /* @__PURE__ */ qC(null);
function A8(g) {
  const A = za(uk);
  gi(() => {
    if (!A)
      throw new Error("useDndMonitor must be used within a children of <DndContext>");
    return A(g);
  }, [g, A]);
}
function e8() {
  const [g] = cn(() => /* @__PURE__ */ new Set()), A = dg((t) => (g.add(t), () => g.delete(t)), [g]);
  return [dg((t) => {
    let {
      type: i,
      event: n
    } = t;
    g.forEach((r) => {
      var s;
      return (s = r[i]) == null ? void 0 : s.call(r, n);
    });
  }, [g]), A];
}
const t8 = {
  draggable: `
    To pick up a draggable item, press the space bar.
    While dragging, use the arrow keys to move the item.
    Press space again to drop the item in its new position, or press escape to cancel.
  `
}, i8 = {
  onDragStart(g) {
    let {
      active: A
    } = g;
    return "Picked up draggable item " + A.id + ".";
  },
  onDragOver(g) {
    let {
      active: A,
      over: e
    } = g;
    return e ? "Draggable item " + A.id + " was moved over droppable area " + e.id + "." : "Draggable item " + A.id + " is no longer over a droppable area.";
  },
  onDragEnd(g) {
    let {
      active: A,
      over: e
    } = g;
    return e ? "Draggable item " + A.id + " was dropped over droppable area " + e.id : "Draggable item " + A.id + " was dropped.";
  },
  onDragCancel(g) {
    let {
      active: A
    } = g;
    return "Dragging was cancelled. Draggable item " + A.id + " was dropped.";
  }
};
function n8(g) {
  let {
    announcements: A = i8,
    container: e,
    hiddenTextDescribedById: t,
    screenReaderInstructions: i = t8
  } = g;
  const {
    announce: n,
    announcement: r
  } = $P(), s = wu("DndLiveRegion"), [B, I] = cn(!1);
  if (gi(() => {
    I(!0);
  }, []), A8(ni(() => ({
    onDragStart(C) {
      let {
        active: c
      } = C;
      n(A.onDragStart({
        active: c
      }));
    },
    onDragMove(C) {
      let {
        active: c,
        over: u
      } = C;
      A.onDragMove && n(A.onDragMove({
        active: c,
        over: u
      }));
    },
    onDragOver(C) {
      let {
        active: c,
        over: u
      } = C;
      n(A.onDragOver({
        active: c,
        over: u
      }));
    },
    onDragEnd(C) {
      let {
        active: c,
        over: u
      } = C;
      n(A.onDragEnd({
        active: c,
        over: u
      }));
    },
    onDragCancel(C) {
      let {
        active: c,
        over: u
      } = C;
      n(A.onDragCancel({
        active: c,
        over: u
      }));
    }
  }), [n, A])), !B)
    return null;
  const E = qi.createElement(qi.Fragment, null, qi.createElement(jP, {
    id: t,
    value: i.draggable
  }), qi.createElement(XP, {
    id: s,
    announcement: r
  }));
  return e ? wK(E, e) : E;
}
var $n;
(function(g) {
  g.DragStart = "dragStart", g.DragMove = "dragMove", g.DragEnd = "dragEnd", g.DragCancel = "dragCancel", g.DragOver = "dragOver", g.RegisterDroppable = "registerDroppable", g.SetDroppableDisabled = "setDroppableDisabled", g.UnregisterDroppable = "unregisterDroppable";
})($n || ($n = {}));
function df() {
}
function $F(g, A) {
  return ni(
    () => ({
      sensor: g,
      options: A ?? {}
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [g, A]
  );
}
function g8() {
  for (var g = arguments.length, A = new Array(g), e = 0; e < g; e++)
    A[e] = arguments[e];
  return ni(
    () => [...A].filter((t) => t != null),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [...A]
  );
}
const ls = /* @__PURE__ */ Object.freeze({
  x: 0,
  y: 0
});
function hk(g, A) {
  return Math.sqrt(Math.pow(g.x - A.x, 2) + Math.pow(g.y - A.y, 2));
}
function dk(g, A) {
  let {
    data: {
      value: e
    }
  } = g, {
    data: {
      value: t
    }
  } = A;
  return e - t;
}
function r8(g, A) {
  let {
    data: {
      value: e
    }
  } = g, {
    data: {
      value: t
    }
  } = A;
  return t - e;
}
function AG(g) {
  let {
    left: A,
    top: e,
    height: t,
    width: i
  } = g;
  return [{
    x: A,
    y: e
  }, {
    x: A + i,
    y: e
  }, {
    x: A,
    y: e + t
  }, {
    x: A + i,
    y: e + t
  }];
}
function fk(g, A) {
  if (!g || g.length === 0)
    return null;
  const [e] = g;
  return A ? e[A] : e;
}
function eG(g, A, e) {
  return A === void 0 && (A = g.left), e === void 0 && (e = g.top), {
    x: A + g.width * 0.5,
    y: e + g.height * 0.5
  };
}
const o8 = (g) => {
  let {
    collisionRect: A,
    droppableRects: e,
    droppableContainers: t
  } = g;
  const i = eG(A, A.left, A.top), n = [];
  for (const r of t) {
    const {
      id: s
    } = r, B = e.get(s);
    if (B) {
      const I = hk(eG(B), i);
      n.push({
        id: s,
        data: {
          droppableContainer: r,
          value: I
        }
      });
    }
  }
  return n.sort(dk);
}, s8 = (g) => {
  let {
    collisionRect: A,
    droppableRects: e,
    droppableContainers: t
  } = g;
  const i = AG(A), n = [];
  for (const r of t) {
    const {
      id: s
    } = r, B = e.get(s);
    if (B) {
      const I = AG(B), E = i.reduce((c, u, d) => c + hk(I[d], u), 0), C = Number((E / 4).toFixed(4));
      n.push({
        id: s,
        data: {
          droppableContainer: r,
          value: C
        }
      });
    }
  }
  return n.sort(dk);
};
function a8(g, A) {
  const e = Math.max(A.top, g.top), t = Math.max(A.left, g.left), i = Math.min(A.left + A.width, g.left + g.width), n = Math.min(A.top + A.height, g.top + g.height), r = i - t, s = n - e;
  if (t < i && e < n) {
    const B = A.width * A.height, I = g.width * g.height, E = r * s, C = E / (B + I - E);
    return Number(C.toFixed(4));
  }
  return 0;
}
const I8 = (g) => {
  let {
    collisionRect: A,
    droppableRects: e,
    droppableContainers: t
  } = g;
  const i = [];
  for (const n of t) {
    const {
      id: r
    } = n, s = e.get(r);
    if (s) {
      const B = a8(s, A);
      B > 0 && i.push({
        id: r,
        data: {
          droppableContainer: n,
          value: B
        }
      });
    }
  }
  return i.sort(r8);
};
function B8(g, A, e) {
  return {
    ...g,
    scaleX: A && e ? A.width / e.width : 1,
    scaleY: A && e ? A.height / e.height : 1
  };
}
function pk(g, A) {
  return g && A ? {
    x: g.left - A.left,
    y: g.top - A.top
  } : ls;
}
function C8(g) {
  return function(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
      i[n - 1] = arguments[n];
    return i.reduce((r, s) => ({
      ...r,
      top: r.top + g * s.y,
      bottom: r.bottom + g * s.y,
      left: r.left + g * s.x,
      right: r.right + g * s.x
    }), {
      ...e
    });
  };
}
const Q8 = /* @__PURE__ */ C8(1);
function E8(g) {
  if (g.startsWith("matrix3d(")) {
    const A = g.slice(9, -1).split(/, /);
    return {
      x: +A[12],
      y: +A[13],
      scaleX: +A[0],
      scaleY: +A[5]
    };
  } else if (g.startsWith("matrix(")) {
    const A = g.slice(7, -1).split(/, /);
    return {
      x: +A[4],
      y: +A[5],
      scaleX: +A[0],
      scaleY: +A[3]
    };
  }
  return null;
}
function l8(g, A, e) {
  const t = E8(A);
  if (!t)
    return g;
  const {
    scaleX: i,
    scaleY: n,
    x: r,
    y: s
  } = t, B = g.left - r - (1 - i) * parseFloat(e), I = g.top - s - (1 - n) * parseFloat(e.slice(e.indexOf(" ") + 1)), E = i ? g.width / i : g.width, C = n ? g.height / n : g.height;
  return {
    width: E,
    height: C,
    top: I,
    right: B + E,
    bottom: I + C,
    left: B
  };
}
const c8 = {
  ignoreTransform: !1
};
function zE(g, A) {
  A === void 0 && (A = c8);
  let e = g.getBoundingClientRect();
  if (A.ignoreTransform) {
    const {
      transform: I,
      transformOrigin: E
    } = Fr(g).getComputedStyle(g);
    I && (e = l8(e, I, E));
  }
  const {
    top: t,
    left: i,
    width: n,
    height: r,
    bottom: s,
    right: B
  } = e;
  return {
    top: t,
    left: i,
    width: n,
    height: r,
    bottom: s,
    right: B
  };
}
function tG(g) {
  return zE(g, {
    ignoreTransform: !0
  });
}
function u8(g) {
  const A = g.innerWidth, e = g.innerHeight;
  return {
    top: 0,
    left: 0,
    right: A,
    bottom: e,
    width: A,
    height: e
  };
}
function h8(g, A) {
  return A === void 0 && (A = Fr(g).getComputedStyle(g)), A.position === "fixed";
}
function d8(g, A) {
  A === void 0 && (A = Fr(g).getComputedStyle(g));
  const e = /(auto|scroll|overlay)/;
  return ["overflow", "overflowX", "overflowY"].some((i) => {
    const n = A[i];
    return typeof n == "string" ? e.test(n) : !1;
  });
}
function Of(g, A) {
  const e = [];
  function t(i) {
    if (A != null && e.length >= A || !i)
      return e;
    if (Qm(i) && i.scrollingElement != null && !e.includes(i.scrollingElement))
      return e.push(i.scrollingElement), e;
    if (!pu(i) || OP(i) || e.includes(i))
      return e;
    const n = Fr(g).getComputedStyle(i);
    return i !== g && d8(i, n) && e.push(i), h8(i, n) ? e : t(i.parentNode);
  }
  return g ? t(g) : e;
}
function Dk(g) {
  const [A] = Of(g, 1);
  return A ?? null;
}
function iw(g) {
  return !Jf || !g ? null : PE(g) ? g : Cm(g) ? Qm(g) || g === WE(g).scrollingElement ? window : pu(g) ? g : null : null;
}
function wk(g) {
  return PE(g) ? g.scrollX : g.scrollLeft;
}
function yk(g) {
  return PE(g) ? g.scrollY : g.scrollTop;
}
function By(g) {
  return {
    x: wk(g),
    y: yk(g)
  };
}
var og;
(function(g) {
  g[g.Forward = 1] = "Forward", g[g.Backward = -1] = "Backward";
})(og || (og = {}));
function mk(g) {
  return !Jf || !g ? !1 : g === document.scrollingElement;
}
function Sk(g) {
  const A = {
    x: 0,
    y: 0
  }, e = mk(g) ? {
    height: window.innerHeight,
    width: window.innerWidth
  } : {
    height: g.clientHeight,
    width: g.clientWidth
  }, t = {
    x: g.scrollWidth - e.width,
    y: g.scrollHeight - e.height
  }, i = g.scrollTop <= A.y, n = g.scrollLeft <= A.x, r = g.scrollTop >= t.y, s = g.scrollLeft >= t.x;
  return {
    isTop: i,
    isLeft: n,
    isBottom: r,
    isRight: s,
    maxScroll: t,
    minScroll: A
  };
}
const f8 = {
  x: 0.2,
  y: 0.2
};
function p8(g, A, e, t, i) {
  let {
    top: n,
    left: r,
    right: s,
    bottom: B
  } = e;
  t === void 0 && (t = 10), i === void 0 && (i = f8);
  const {
    isTop: I,
    isBottom: E,
    isLeft: C,
    isRight: c
  } = Sk(g), u = {
    x: 0,
    y: 0
  }, d = {
    x: 0,
    y: 0
  }, p = {
    height: A.height * i.y,
    width: A.width * i.x
  };
  return !I && n <= A.top + p.height ? (u.y = og.Backward, d.y = t * Math.abs((A.top + p.height - n) / p.height)) : !E && B >= A.bottom - p.height && (u.y = og.Forward, d.y = t * Math.abs((A.bottom - p.height - B) / p.height)), !c && s >= A.right - p.width ? (u.x = og.Forward, d.x = t * Math.abs((A.right - p.width - s) / p.width)) : !C && r <= A.left + p.width && (u.x = og.Backward, d.x = t * Math.abs((A.left + p.width - r) / p.width)), {
    direction: u,
    speed: d
  };
}
function D8(g) {
  if (g === document.scrollingElement) {
    const {
      innerWidth: n,
      innerHeight: r
    } = window;
    return {
      top: 0,
      left: 0,
      right: n,
      bottom: r,
      width: n,
      height: r
    };
  }
  const {
    top: A,
    left: e,
    right: t,
    bottom: i
  } = g.getBoundingClientRect();
  return {
    top: A,
    left: e,
    right: t,
    bottom: i,
    width: g.clientWidth,
    height: g.clientHeight
  };
}
function Mk(g) {
  return g.reduce((A, e) => SE(A, By(e)), ls);
}
function w8(g) {
  return g.reduce((A, e) => A + wk(e), 0);
}
function y8(g) {
  return g.reduce((A, e) => A + yk(e), 0);
}
function m8(g, A) {
  if (A === void 0 && (A = zE), !g)
    return;
  const {
    top: e,
    left: t,
    bottom: i,
    right: n
  } = A(g);
  Dk(g) && (i <= 0 || n <= 0 || e >= window.innerHeight || t >= window.innerWidth) && g.scrollIntoView({
    block: "center",
    inline: "center"
  });
}
const S8 = [["x", ["left", "right"], w8], ["y", ["top", "bottom"], y8]];
class cm {
  constructor(A, e) {
    this.rect = void 0, this.width = void 0, this.height = void 0, this.top = void 0, this.bottom = void 0, this.right = void 0, this.left = void 0;
    const t = Of(e), i = Mk(t);
    this.rect = {
      ...A
    }, this.width = A.width, this.height = A.height;
    for (const [n, r, s] of S8)
      for (const B of r)
        Object.defineProperty(this, B, {
          get: () => {
            const I = s(t), E = i[n] - I;
            return this.rect[B] + E;
          },
          enumerable: !0
        });
    Object.defineProperty(this, "rect", {
      enumerable: !1
    });
  }
}
class Gc {
  constructor(A) {
    this.target = void 0, this.listeners = [], this.removeAll = () => {
      this.listeners.forEach((e) => {
        var t;
        return (t = this.target) == null ? void 0 : t.removeEventListener(...e);
      });
    }, this.target = A;
  }
  add(A, e, t) {
    var i;
    (i = this.target) == null || i.addEventListener(A, e, t), this.listeners.push([A, e, t]);
  }
}
function M8(g) {
  const {
    EventTarget: A
  } = Fr(g);
  return g instanceof A ? g : WE(g);
}
function nw(g, A) {
  const e = Math.abs(g.x), t = Math.abs(g.y);
  return typeof A == "number" ? Math.sqrt(e ** 2 + t ** 2) > A : "x" in A && "y" in A ? e > A.x && t > A.y : "x" in A ? e > A.x : "y" in A ? t > A.y : !1;
}
var Fo;
(function(g) {
  g.Click = "click", g.DragStart = "dragstart", g.Keydown = "keydown", g.ContextMenu = "contextmenu", g.Resize = "resize", g.SelectionChange = "selectionchange", g.VisibilityChange = "visibilitychange";
})(Fo || (Fo = {}));
function iG(g) {
  g.preventDefault();
}
function R8(g) {
  g.stopPropagation();
}
var ri;
(function(g) {
  g.Space = "Space", g.Down = "ArrowDown", g.Right = "ArrowRight", g.Left = "ArrowLeft", g.Up = "ArrowUp", g.Esc = "Escape", g.Enter = "Enter";
})(ri || (ri = {}));
const Rk = {
  start: [ri.Space, ri.Enter],
  cancel: [ri.Esc],
  end: [ri.Space, ri.Enter]
}, N8 = (g, A) => {
  let {
    currentCoordinates: e
  } = A;
  switch (g.code) {
    case ri.Right:
      return {
        ...e,
        x: e.x + 25
      };
    case ri.Left:
      return {
        ...e,
        x: e.x - 25
      };
    case ri.Down:
      return {
        ...e,
        y: e.y + 25
      };
    case ri.Up:
      return {
        ...e,
        y: e.y - 25
      };
  }
};
class um {
  constructor(A) {
    this.props = void 0, this.autoScrollEnabled = !1, this.referenceCoordinates = void 0, this.listeners = void 0, this.windowListeners = void 0, this.props = A;
    const {
      event: {
        target: e
      }
    } = A;
    this.props = A, this.listeners = new Gc(WE(e)), this.windowListeners = new Gc(Fr(e)), this.handleKeyDown = this.handleKeyDown.bind(this), this.handleCancel = this.handleCancel.bind(this), this.attach();
  }
  attach() {
    this.handleStart(), this.windowListeners.add(Fo.Resize, this.handleCancel), this.windowListeners.add(Fo.VisibilityChange, this.handleCancel), setTimeout(() => this.listeners.add(Fo.Keydown, this.handleKeyDown));
  }
  handleStart() {
    const {
      activeNode: A,
      onStart: e
    } = this.props, t = A.node.current;
    t && m8(t), e(ls);
  }
  handleKeyDown(A) {
    if (lm(A)) {
      const {
        active: e,
        context: t,
        options: i
      } = this.props, {
        keyboardCodes: n = Rk,
        coordinateGetter: r = N8,
        scrollBehavior: s = "smooth"
      } = i, {
        code: B
      } = A;
      if (n.end.includes(B)) {
        this.handleEnd(A);
        return;
      }
      if (n.cancel.includes(B)) {
        this.handleCancel(A);
        return;
      }
      const {
        collisionRect: I
      } = t.current, E = I ? {
        x: I.left,
        y: I.top
      } : ls;
      this.referenceCoordinates || (this.referenceCoordinates = E);
      const C = r(A, {
        active: e,
        context: t.current,
        currentCoordinates: E
      });
      if (C) {
        const c = Pc(C, E), u = {
          x: 0,
          y: 0
        }, {
          scrollableAncestors: d
        } = t.current;
        for (const p of d) {
          const D = A.code, {
            isTop: f,
            isRight: S,
            isLeft: y,
            isBottom: m,
            maxScroll: N,
            minScroll: F
          } = Sk(p), G = D8(p), k = {
            x: Math.min(D === ri.Right ? G.right - G.width / 2 : G.right, Math.max(D === ri.Right ? G.left : G.left + G.width / 2, C.x)),
            y: Math.min(D === ri.Down ? G.bottom - G.height / 2 : G.bottom, Math.max(D === ri.Down ? G.top : G.top + G.height / 2, C.y))
          }, v = D === ri.Right && !S || D === ri.Left && !y, x = D === ri.Down && !m || D === ri.Up && !f;
          if (v && k.x !== C.x) {
            const H = p.scrollLeft + c.x, _ = D === ri.Right && H <= N.x || D === ri.Left && H >= F.x;
            if (_ && !c.y) {
              p.scrollTo({
                left: H,
                behavior: s
              });
              return;
            }
            _ ? u.x = p.scrollLeft - H : u.x = D === ri.Right ? p.scrollLeft - N.x : p.scrollLeft - F.x, u.x && p.scrollBy({
              left: -u.x,
              behavior: s
            });
            break;
          } else if (x && k.y !== C.y) {
            const H = p.scrollTop + c.y, _ = D === ri.Down && H <= N.y || D === ri.Up && H >= F.y;
            if (_ && !c.x) {
              p.scrollTo({
                top: H,
                behavior: s
              });
              return;
            }
            _ ? u.y = p.scrollTop - H : u.y = D === ri.Down ? p.scrollTop - N.y : p.scrollTop - F.y, u.y && p.scrollBy({
              top: -u.y,
              behavior: s
            });
            break;
          }
        }
        this.handleMove(A, SE(Pc(C, this.referenceCoordinates), u));
      }
    }
  }
  handleMove(A, e) {
    const {
      onMove: t
    } = this.props;
    A.preventDefault(), t(e);
  }
  handleEnd(A) {
    const {
      onEnd: e
    } = this.props;
    A.preventDefault(), this.detach(), e();
  }
  handleCancel(A) {
    const {
      onCancel: e
    } = this.props;
    A.preventDefault(), this.detach(), e();
  }
  detach() {
    this.listeners.removeAll(), this.windowListeners.removeAll();
  }
}
um.activators = [{
  eventName: "onKeyDown",
  handler: (g, A, e) => {
    let {
      keyboardCodes: t = Rk,
      onActivation: i
    } = A, {
      active: n
    } = e;
    const {
      code: r
    } = g.nativeEvent;
    if (t.start.includes(r)) {
      const s = n.activatorNode.current;
      return s && g.target !== s ? !1 : (g.preventDefault(), i?.({
        event: g.nativeEvent
      }), !0);
    }
    return !1;
  }
}];
function nG(g) {
  return !!(g && "distance" in g);
}
function gG(g) {
  return !!(g && "delay" in g);
}
class hm {
  constructor(A, e, t) {
    var i;
    t === void 0 && (t = M8(A.event.target)), this.props = void 0, this.events = void 0, this.autoScrollEnabled = !0, this.document = void 0, this.activated = !1, this.initialCoordinates = void 0, this.timeoutId = null, this.listeners = void 0, this.documentListeners = void 0, this.windowListeners = void 0, this.props = A, this.events = e;
    const {
      event: n
    } = A, {
      target: r
    } = n;
    this.props = A, this.events = e, this.document = WE(r), this.documentListeners = new Gc(this.document), this.listeners = new Gc(t), this.windowListeners = new Gc(Fr(r)), this.initialCoordinates = (i = Iy(n)) != null ? i : ls, this.handleStart = this.handleStart.bind(this), this.handleMove = this.handleMove.bind(this), this.handleEnd = this.handleEnd.bind(this), this.handleCancel = this.handleCancel.bind(this), this.handleKeydown = this.handleKeydown.bind(this), this.removeTextSelection = this.removeTextSelection.bind(this), this.attach();
  }
  attach() {
    const {
      events: A,
      props: {
        options: {
          activationConstraint: e
        }
      }
    } = this;
    if (this.listeners.add(A.move.name, this.handleMove, {
      passive: !1
    }), this.listeners.add(A.end.name, this.handleEnd), this.windowListeners.add(Fo.Resize, this.handleCancel), this.windowListeners.add(Fo.DragStart, iG), this.windowListeners.add(Fo.VisibilityChange, this.handleCancel), this.windowListeners.add(Fo.ContextMenu, iG), this.documentListeners.add(Fo.Keydown, this.handleKeydown), e) {
      if (nG(e))
        return;
      if (gG(e)) {
        this.timeoutId = setTimeout(this.handleStart, e.delay);
        return;
      }
    }
    this.handleStart();
  }
  detach() {
    this.listeners.removeAll(), this.windowListeners.removeAll(), setTimeout(this.documentListeners.removeAll, 50), this.timeoutId !== null && (clearTimeout(this.timeoutId), this.timeoutId = null);
  }
  handleStart() {
    const {
      initialCoordinates: A
    } = this, {
      onStart: e
    } = this.props;
    A && (this.activated = !0, this.documentListeners.add(Fo.Click, R8, {
      capture: !0
    }), this.removeTextSelection(), this.documentListeners.add(Fo.SelectionChange, this.removeTextSelection), e(A));
  }
  handleMove(A) {
    var e;
    const {
      activated: t,
      initialCoordinates: i,
      props: n
    } = this, {
      onMove: r,
      options: {
        activationConstraint: s
      }
    } = n;
    if (!i)
      return;
    const B = (e = Iy(A)) != null ? e : ls, I = Pc(i, B);
    if (!t && s) {
      if (gG(s))
        return nw(I, s.tolerance) ? this.handleCancel() : void 0;
      if (nG(s))
        return s.tolerance != null && nw(I, s.tolerance) ? this.handleCancel() : nw(I, s.distance) ? this.handleStart() : void 0;
    }
    A.cancelable && A.preventDefault(), r(B);
  }
  handleEnd() {
    const {
      onEnd: A
    } = this.props;
    this.detach(), A();
  }
  handleCancel() {
    const {
      onCancel: A
    } = this.props;
    this.detach(), A();
  }
  handleKeydown(A) {
    A.code === ri.Esc && this.handleCancel();
  }
  removeTextSelection() {
    var A;
    (A = this.document.getSelection()) == null || A.removeAllRanges();
  }
}
const F8 = {
  move: {
    name: "pointermove"
  },
  end: {
    name: "pointerup"
  }
};
class dm extends hm {
  constructor(A) {
    const {
      event: e
    } = A, t = WE(e.target);
    super(A, F8, t);
  }
}
dm.activators = [{
  eventName: "onPointerDown",
  handler: (g, A) => {
    let {
      nativeEvent: e
    } = g, {
      onActivation: t
    } = A;
    return !e.isPrimary || e.button !== 0 ? !1 : (t?.({
      event: e
    }), !0);
  }
}];
const G8 = {
  move: {
    name: "mousemove"
  },
  end: {
    name: "mouseup"
  }
};
var Cy;
(function(g) {
  g[g.RightClick = 2] = "RightClick";
})(Cy || (Cy = {}));
class v8 extends hm {
  constructor(A) {
    super(A, G8, WE(A.event.target));
  }
}
v8.activators = [{
  eventName: "onMouseDown",
  handler: (g, A) => {
    let {
      nativeEvent: e
    } = g, {
      onActivation: t
    } = A;
    return e.button === Cy.RightClick ? !1 : (t?.({
      event: e
    }), !0);
  }
}];
const gw = {
  move: {
    name: "touchmove"
  },
  end: {
    name: "touchend"
  }
};
class U8 extends hm {
  constructor(A) {
    super(A, gw);
  }
  static setup() {
    return window.addEventListener(gw.move.name, A, {
      capture: !1,
      passive: !1
    }), function() {
      window.removeEventListener(gw.move.name, A);
    };
    function A() {
    }
  }
}
U8.activators = [{
  eventName: "onTouchStart",
  handler: (g, A) => {
    let {
      nativeEvent: e
    } = g, {
      onActivation: t
    } = A;
    const {
      touches: i
    } = e;
    return i.length > 1 ? !1 : (t?.({
      event: e
    }), !0);
  }
}];
var vc;
(function(g) {
  g[g.Pointer = 0] = "Pointer", g[g.DraggableRect = 1] = "DraggableRect";
})(vc || (vc = {}));
var ff;
(function(g) {
  g[g.TreeOrder = 0] = "TreeOrder", g[g.ReversedTreeOrder = 1] = "ReversedTreeOrder";
})(ff || (ff = {}));
function k8(g) {
  let {
    acceleration: A,
    activator: e = vc.Pointer,
    canScroll: t,
    draggingRect: i,
    enabled: n,
    interval: r = 5,
    order: s = ff.TreeOrder,
    pointerCoordinates: B,
    scrollableAncestors: I,
    scrollableAncestorRects: E,
    delta: C,
    threshold: c
  } = g;
  const u = L8({
    delta: C,
    disabled: !n
  }), [d, p] = qP(), D = Dt({
    x: 0,
    y: 0
  }), f = Dt({
    x: 0,
    y: 0
  }), S = ni(() => {
    switch (e) {
      case vc.Pointer:
        return B ? {
          top: B.y,
          bottom: B.y,
          left: B.x,
          right: B.x
        } : null;
      case vc.DraggableRect:
        return i;
    }
  }, [e, i, B]), y = Dt(null), m = dg(() => {
    const F = y.current;
    if (!F)
      return;
    const G = D.current.x * f.current.x, k = D.current.y * f.current.y;
    F.scrollBy(G, k);
  }, []), N = ni(() => s === ff.TreeOrder ? [...I].reverse() : I, [s, I]);
  gi(
    () => {
      if (!n || !I.length || !S) {
        p();
        return;
      }
      for (const F of N) {
        if (t?.(F) === !1)
          continue;
        const G = I.indexOf(F), k = E[G];
        if (!k)
          continue;
        const {
          direction: v,
          speed: x
        } = p8(F, k, S, A, c);
        for (const H of ["x", "y"])
          u[H][v[H]] || (x[H] = 0, v[H] = 0);
        if (x.x > 0 || x.y > 0) {
          p(), y.current = F, d(m, r), D.current = x, f.current = v;
          return;
        }
      }
      D.current = {
        x: 0,
        y: 0
      }, f.current = {
        x: 0,
        y: 0
      }, p();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      A,
      m,
      t,
      p,
      n,
      r,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(S),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(u),
      d,
      I,
      N,
      E,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(c)
    ]
  );
}
const x8 = {
  x: {
    [og.Backward]: !1,
    [og.Forward]: !1
  },
  y: {
    [og.Backward]: !1,
    [og.Forward]: !1
  }
};
function L8(g) {
  let {
    delta: A,
    disabled: e
  } = g;
  const t = ay(A);
  return Du((i) => {
    if (e || !t || !i)
      return x8;
    const n = {
      x: Math.sign(A.x - t.x),
      y: Math.sign(A.y - t.y)
    };
    return {
      x: {
        [og.Backward]: i.x[og.Backward] || n.x === -1,
        [og.Forward]: i.x[og.Forward] || n.x === 1
      },
      y: {
        [og.Backward]: i.y[og.Backward] || n.y === -1,
        [og.Forward]: i.y[og.Forward] || n.y === 1
      }
    };
  }, [e, A, t]);
}
function T8(g, A) {
  const e = A !== null ? g.get(A) : void 0, t = e ? e.node.current : null;
  return Du((i) => {
    var n;
    return A === null ? null : (n = t ?? i) != null ? n : null;
  }, [t, A]);
}
function K8(g, A) {
  return ni(() => g.reduce((e, t) => {
    const {
      sensor: i
    } = t, n = i.activators.map((r) => ({
      eventName: r.eventName,
      handler: A(r.handler, t)
    }));
    return [...e, ...n];
  }, []), [g, A]);
}
var TE;
(function(g) {
  g[g.Always = 0] = "Always", g[g.BeforeDragging = 1] = "BeforeDragging", g[g.WhileDragging = 2] = "WhileDragging";
})(TE || (TE = {}));
var Qy;
(function(g) {
  g.Optimized = "optimized";
})(Qy || (Qy = {}));
const rG = /* @__PURE__ */ new Map();
function b8(g, A) {
  let {
    dragging: e,
    dependencies: t,
    config: i
  } = A;
  const [n, r] = cn(null), {
    frequency: s,
    measure: B,
    strategy: I
  } = i, E = Dt(g), C = D(), c = qc(C), u = dg(function(f) {
    f === void 0 && (f = []), !c.current && r((S) => S === null ? f : S.concat(f.filter((y) => !S.includes(y))));
  }, [c]), d = Dt(null), p = Du((f) => {
    if (C && !e)
      return rG;
    if (!f || f === rG || E.current !== g || n != null) {
      const S = /* @__PURE__ */ new Map();
      for (let y of g) {
        if (!y)
          continue;
        if (n && n.length > 0 && !n.includes(y.id) && y.rect.current) {
          S.set(y.id, y.rect.current);
          continue;
        }
        const m = y.node.current, N = m ? new cm(B(m), m) : null;
        y.rect.current = N, N && S.set(y.id, N);
      }
      return S;
    }
    return f;
  }, [g, n, e, C, B]);
  return gi(() => {
    E.current = g;
  }, [g]), gi(
    () => {
      C || u();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [e, C]
  ), gi(
    () => {
      n && n.length > 0 && r(null);
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [JSON.stringify(n)]
  ), gi(
    () => {
      C || typeof s != "number" || d.current !== null || (d.current = setTimeout(() => {
        u(), d.current = null;
      }, s));
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [s, C, u, ...t]
  ), {
    droppableRects: p,
    measureDroppableContainers: u,
    measuringScheduled: n != null
  };
  function D() {
    switch (I) {
      case TE.Always:
        return !1;
      case TE.BeforeDragging:
        return e;
      default:
        return !e;
    }
  }
}
function Nk(g, A) {
  return Du((e) => g ? e || (typeof A == "function" ? A(g) : g) : null, [A, g]);
}
function Y8(g, A) {
  return Nk(g, A);
}
function H8(g) {
  let {
    callback: A,
    disabled: e
  } = g;
  const t = Em(A), i = ni(() => {
    if (e || typeof window > "u" || typeof window.MutationObserver > "u")
      return;
    const {
      MutationObserver: n
    } = window;
    return new n(t);
  }, [t, e]);
  return gi(() => () => i?.disconnect(), [i]), i;
}
function qf(g) {
  let {
    callback: A,
    disabled: e
  } = g;
  const t = Em(A), i = ni(
    () => {
      if (e || typeof window > "u" || typeof window.ResizeObserver > "u")
        return;
      const {
        ResizeObserver: n
      } = window;
      return new n(t);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [e]
  );
  return gi(() => () => i?.disconnect(), [i]), i;
}
function _8(g) {
  return new cm(zE(g), g);
}
function oG(g, A, e) {
  A === void 0 && (A = _8);
  const [t, i] = wf(s, null), n = H8({
    callback(B) {
      if (g)
        for (const I of B) {
          const {
            type: E,
            target: C
          } = I;
          if (E === "childList" && C instanceof HTMLElement && C.contains(g)) {
            i();
            break;
          }
        }
    }
  }), r = qf({
    callback: i
  });
  return Es(() => {
    i(), g ? (r?.observe(g), n?.observe(document.body, {
      childList: !0,
      subtree: !0
    })) : (r?.disconnect(), n?.disconnect());
  }, [g]), t;
  function s(B) {
    if (!g)
      return null;
    if (g.isConnected === !1) {
      var I;
      return (I = B ?? e) != null ? I : null;
    }
    const E = A(g);
    return JSON.stringify(B) === JSON.stringify(E) ? B : E;
  }
}
function J8(g) {
  const A = Nk(g);
  return pk(g, A);
}
const sG = [];
function O8(g) {
  const A = Dt(g), e = Du((t) => g ? t && t !== sG && g && A.current && g.parentNode === A.current.parentNode ? t : Of(g) : sG, [g]);
  return gi(() => {
    A.current = g;
  }, [g]), e;
}
function q8(g) {
  const [A, e] = cn(null), t = Dt(g), i = dg((n) => {
    const r = iw(n.target);
    r && e((s) => s ? (s.set(r, By(r)), new Map(s)) : null);
  }, []);
  return gi(() => {
    const n = t.current;
    if (g !== n) {
      r(n);
      const s = g.map((B) => {
        const I = iw(B);
        return I ? (I.addEventListener("scroll", i, {
          passive: !0
        }), [I, By(I)]) : null;
      }).filter((B) => B != null);
      e(s.length ? new Map(s) : null), t.current = g;
    }
    return () => {
      r(g), r(n);
    };
    function r(s) {
      s.forEach((B) => {
        const I = iw(B);
        I?.removeEventListener("scroll", i);
      });
    }
  }, [i, g]), ni(() => g.length ? A ? Array.from(A.values()).reduce((n, r) => SE(n, r), ls) : Mk(g) : ls, [g, A]);
}
function aG(g, A) {
  A === void 0 && (A = []);
  const e = Dt(null);
  return gi(
    () => {
      e.current = null;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    A
  ), gi(() => {
    const t = g !== ls;
    t && !e.current && (e.current = g), !t && e.current && (e.current = null);
  }, [g]), e.current ? Pc(g, e.current) : ls;
}
function P8(g) {
  gi(
    () => {
      if (!Jf)
        return;
      const A = g.map((e) => {
        let {
          sensor: t
        } = e;
        return t.setup == null ? void 0 : t.setup();
      });
      return () => {
        for (const e of A)
          e?.();
      };
    },
    // TO-DO: Sensors length could theoretically change which would not be a valid dependency
    // eslint-disable-next-line react-hooks/exhaustive-deps
    g.map((A) => {
      let {
        sensor: e
      } = A;
      return e;
    })
  );
}
function W8(g, A) {
  return ni(() => g.reduce((e, t) => {
    let {
      eventName: i,
      handler: n
    } = t;
    return e[i] = (r) => {
      n(r, A);
    }, e;
  }, {}), [g, A]);
}
function Fk(g) {
  return ni(() => g ? u8(g) : null, [g]);
}
const rw = [];
function z8(g, A) {
  A === void 0 && (A = zE);
  const [e] = g, t = Fk(e ? Fr(e) : null), [i, n] = wf(s, rw), r = qf({
    callback: n
  });
  return g.length > 0 && i === rw && n(), Es(() => {
    g.length ? g.forEach((B) => r?.observe(B)) : (r?.disconnect(), n());
  }, [g]), i;
  function s() {
    return g.length ? g.map((B) => mk(B) ? t : new cm(A(B), B)) : rw;
  }
}
function V8(g) {
  if (!g)
    return null;
  if (g.children.length > 1)
    return g;
  const A = g.children[0];
  return pu(A) ? A : g;
}
function j8(g) {
  let {
    measure: A
  } = g;
  const [e, t] = cn(null), i = dg((I) => {
    for (const {
      target: E
    } of I)
      if (pu(E)) {
        t((C) => {
          const c = A(E);
          return C ? {
            ...C,
            width: c.width,
            height: c.height
          } : c;
        });
        break;
      }
  }, [A]), n = qf({
    callback: i
  }), r = dg((I) => {
    const E = V8(I);
    n?.disconnect(), E && n?.observe(E), t(E ? A(E) : null);
  }, [A, n]), [s, B] = hf(r);
  return ni(() => ({
    nodeRef: s,
    rect: e,
    setRef: B
  }), [e, s, B]);
}
const Z8 = [{
  sensor: dm,
  options: {}
}, {
  sensor: um,
  options: {}
}], X8 = {
  current: {}
}, sf = {
  draggable: {
    measure: tG
  },
  droppable: {
    measure: tG,
    strategy: TE.WhileDragging,
    frequency: Qy.Optimized
  },
  dragOverlay: {
    measure: zE
  }
};
class Uc extends Map {
  get(A) {
    var e;
    return A != null && (e = super.get(A)) != null ? e : void 0;
  }
  toArray() {
    return Array.from(this.values());
  }
  getEnabled() {
    return this.toArray().filter((A) => {
      let {
        disabled: e
      } = A;
      return !e;
    });
  }
  getNodeFor(A) {
    var e, t;
    return (e = (t = this.get(A)) == null ? void 0 : t.node.current) != null ? e : void 0;
  }
}
const $8 = {
  activatorEvent: null,
  active: null,
  activeNode: null,
  activeNodeRect: null,
  collisions: null,
  containerNodeRect: null,
  draggableNodes: /* @__PURE__ */ new Map(),
  droppableRects: /* @__PURE__ */ new Map(),
  droppableContainers: /* @__PURE__ */ new Uc(),
  over: null,
  dragOverlay: {
    nodeRef: {
      current: null
    },
    rect: null,
    setRef: df
  },
  scrollableAncestors: [],
  scrollableAncestorRects: [],
  measuringConfiguration: sf,
  measureDroppableContainers: df,
  windowRect: null,
  measuringScheduled: !1
}, AW = {
  activatorEvent: null,
  activators: [],
  active: null,
  activeNodeRect: null,
  ariaDescribedById: {
    draggable: ""
  },
  dispatch: df,
  draggableNodes: /* @__PURE__ */ new Map(),
  over: null,
  measureDroppableContainers: df
}, Pf = /* @__PURE__ */ qC(AW), Gk = /* @__PURE__ */ qC($8);
function eW() {
  return {
    draggable: {
      active: null,
      initialCoordinates: {
        x: 0,
        y: 0
      },
      nodes: /* @__PURE__ */ new Map(),
      translate: {
        x: 0,
        y: 0
      }
    },
    droppable: {
      containers: new Uc()
    }
  };
}
function tW(g, A) {
  switch (A.type) {
    case $n.DragStart:
      return {
        ...g,
        draggable: {
          ...g.draggable,
          initialCoordinates: A.initialCoordinates,
          active: A.active
        }
      };
    case $n.DragMove:
      return g.draggable.active ? {
        ...g,
        draggable: {
          ...g.draggable,
          translate: {
            x: A.coordinates.x - g.draggable.initialCoordinates.x,
            y: A.coordinates.y - g.draggable.initialCoordinates.y
          }
        }
      } : g;
    case $n.DragEnd:
    case $n.DragCancel:
      return {
        ...g,
        draggable: {
          ...g.draggable,
          active: null,
          initialCoordinates: {
            x: 0,
            y: 0
          },
          translate: {
            x: 0,
            y: 0
          }
        }
      };
    case $n.RegisterDroppable: {
      const {
        element: e
      } = A, {
        id: t
      } = e, i = new Uc(g.droppable.containers);
      return i.set(t, e), {
        ...g,
        droppable: {
          ...g.droppable,
          containers: i
        }
      };
    }
    case $n.SetDroppableDisabled: {
      const {
        id: e,
        key: t,
        disabled: i
      } = A, n = g.droppable.containers.get(e);
      if (!n || t !== n.key)
        return g;
      const r = new Uc(g.droppable.containers);
      return r.set(e, {
        ...n,
        disabled: i
      }), {
        ...g,
        droppable: {
          ...g.droppable,
          containers: r
        }
      };
    }
    case $n.UnregisterDroppable: {
      const {
        id: e,
        key: t
      } = A, i = g.droppable.containers.get(e);
      if (!i || t !== i.key)
        return g;
      const n = new Uc(g.droppable.containers);
      return n.delete(e), {
        ...g,
        droppable: {
          ...g.droppable,
          containers: n
        }
      };
    }
    default:
      return g;
  }
}
function iW(g) {
  let {
    disabled: A
  } = g;
  const {
    active: e,
    activatorEvent: t,
    draggableNodes: i
  } = za(Pf), n = ay(t), r = ay(e?.id);
  return gi(() => {
    if (!A && !t && n && r != null) {
      if (!lm(n) || document.activeElement === n.target)
        return;
      const s = i.get(r);
      if (!s)
        return;
      const {
        activatorNode: B,
        node: I
      } = s;
      if (!B.current && !I.current)
        return;
      requestAnimationFrame(() => {
        for (const E of [B.current, I.current]) {
          if (!E)
            continue;
          const C = zP(E);
          if (C) {
            C.focus();
            break;
          }
        }
      });
    }
  }, [t, A, i, r, n]), null;
}
function nW(g, A) {
  let {
    transform: e,
    ...t
  } = A;
  return g != null && g.length ? g.reduce((i, n) => n({
    transform: i,
    ...t
  }), e) : e;
}
function gW(g) {
  return ni(
    () => ({
      draggable: {
        ...sf.draggable,
        ...g?.draggable
      },
      droppable: {
        ...sf.droppable,
        ...g?.droppable
      },
      dragOverlay: {
        ...sf.dragOverlay,
        ...g?.dragOverlay
      }
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [g?.draggable, g?.droppable, g?.dragOverlay]
  );
}
function rW(g) {
  let {
    activeNode: A,
    measure: e,
    initialRect: t,
    config: i = !0
  } = g;
  const n = Dt(!1), {
    x: r,
    y: s
  } = typeof i == "boolean" ? {
    x: i,
    y: i
  } : i;
  Es(() => {
    if (!r && !s || !A) {
      n.current = !1;
      return;
    }
    if (n.current || !t)
      return;
    const I = A?.node.current;
    if (!I || I.isConnected === !1)
      return;
    const E = e(I), C = pk(E, t);
    if (r || (C.x = 0), s || (C.y = 0), n.current = !0, Math.abs(C.x) > 0 || Math.abs(C.y) > 0) {
      const c = Dk(I);
      c && c.scrollBy({
        top: C.y,
        left: C.x
      });
    }
  }, [A, r, s, t, e]);
}
const vk = /* @__PURE__ */ qC({
  ...ls,
  scaleX: 1,
  scaleY: 1
});
var sB;
(function(g) {
  g[g.Uninitialized = 0] = "Uninitialized", g[g.Initializing = 1] = "Initializing", g[g.Initialized = 2] = "Initialized";
})(sB || (sB = {}));
const oW = /* @__PURE__ */ mK(function(A) {
  var e, t, i, n;
  let {
    id: r,
    accessibility: s,
    autoScroll: B = !0,
    children: I,
    sensors: E = Z8,
    collisionDetection: C = I8,
    measuring: c,
    modifiers: u,
    ...d
  } = A;
  const p = wf(tW, void 0, eW), [D, f] = p, [S, y] = e8(), [m, N] = cn(sB.Uninitialized), F = m === sB.Initialized, {
    draggable: {
      active: G,
      nodes: k,
      translate: v
    },
    droppable: {
      containers: x
    }
  } = D, H = G ? k.get(G) : null, _ = Dt({
    initial: null,
    translated: null
  }), j = ni(() => {
    var UA;
    return G != null ? {
      id: G,
      // It's possible for the active node to unmount while dragging
      data: (UA = H?.data) != null ? UA : X8,
      rect: _
    } : null;
  }, [G, H]), V = Dt(null), [iA, eA] = cn(null), [oA, P] = cn(null), J = qc(d, Object.values(d)), tA = wu("DndDescribedBy", r), Y = ni(() => x.getEnabled(), [x]), rA = gW(c), {
    droppableRects: QA,
    measureDroppableContainers: aA,
    measuringScheduled: MA
  } = b8(Y, {
    dragging: F,
    dependencies: [v.x, v.y],
    config: rA.droppable
  }), hA = T8(k, G), fA = ni(() => oA ? Iy(oA) : null, [oA]), wA = RA(), yA = Y8(hA, rA.draggable.measure);
  rW({
    activeNode: G ? k.get(G) : null,
    config: wA.layoutShiftCompensation,
    initialRect: yA,
    measure: rA.draggable.measure
  });
  const kA = oG(hA, rA.draggable.measure, yA), FA = oG(hA ? hA.parentElement : null), dA = Dt({
    activatorEvent: null,
    active: null,
    activeNode: hA,
    collisionRect: null,
    collisions: null,
    droppableRects: QA,
    draggableNodes: k,
    draggingNode: null,
    draggingNodeRect: null,
    droppableContainers: x,
    over: null,
    scrollableAncestors: [],
    scrollAdjustedTranslate: null
  }), vA = x.getNodeFor((e = dA.current.over) == null ? void 0 : e.id), JA = j8({
    measure: rA.dragOverlay.measure
  }), ne = (t = JA.nodeRef.current) != null ? t : hA, ee = F ? (i = JA.rect) != null ? i : kA : null, pe = !!(JA.nodeRef.current && JA.rect), Ae = J8(pe ? null : kA), ie = Fk(ne ? Fr(ne) : null), de = O8(F ? vA ?? hA : null), O = z8(de), AA = nW(u, {
    transform: {
      x: v.x - Ae.x,
      y: v.y - Ae.y,
      scaleX: 1,
      scaleY: 1
    },
    activatorEvent: oA,
    active: j,
    activeNodeRect: kA,
    containerNodeRect: FA,
    draggingNodeRect: ee,
    over: dA.current.over,
    overlayNodeRect: JA.rect,
    scrollableAncestors: de,
    scrollableAncestorRects: O,
    windowRect: ie
  }), q = fA ? SE(fA, v) : null, Z = q8(de), $ = aG(Z), BA = aG(Z, [kA]), GA = SE(AA, $), bA = ee ? Q8(ee, AA) : null, DA = j && bA ? C({
    active: j,
    collisionRect: bA,
    droppableRects: QA,
    droppableContainers: Y,
    pointerCoordinates: q
  }) : null, SA = fk(DA, "id"), [EA, mA] = cn(null), YA = pe ? AA : SE(AA, BA), ZA = B8(YA, (n = EA?.rect) != null ? n : null, kA), _A = dg(
    (UA, TA) => {
      let {
        sensor: ge,
        options: Me
      } = TA;
      if (V.current == null)
        return;
      const xe = k.get(V.current);
      if (!xe)
        return;
      const we = UA.nativeEvent, Ee = new ge({
        active: V.current,
        activeNode: xe,
        event: we,
        options: Me,
        // Sensors need to be instantiated with refs for arguments that change over time
        // otherwise they are frozen in time with the stale arguments
        context: dA,
        onStart(_e) {
          const Pe = V.current;
          if (Pe == null)
            return;
          const Nt = k.get(Pe);
          if (!Nt)
            return;
          const {
            onDragStart: Jt
          } = J.current, vi = {
            active: {
              id: Pe,
              data: Nt.data,
              rect: _
            }
          };
          Zl(() => {
            Jt?.(vi), N(sB.Initializing), f({
              type: $n.DragStart,
              initialCoordinates: _e,
              active: Pe
            }), S({
              type: "onDragStart",
              event: vi
            });
          });
        },
        onMove(_e) {
          f({
            type: $n.DragMove,
            coordinates: _e
          });
        },
        onEnd: he($n.DragEnd),
        onCancel: he($n.DragCancel)
      });
      Zl(() => {
        eA(Ee), P(UA.nativeEvent);
      });
      function he(_e) {
        return async function() {
          const {
            active: Nt,
            collisions: Jt,
            over: vi,
            scrollAdjustedTranslate: je
          } = dA.current;
          let Ri = null;
          if (Nt && je) {
            const {
              cancelDrop: lA
            } = J.current;
            Ri = {
              activatorEvent: we,
              active: Nt,
              collisions: Jt,
              delta: je,
              over: vi
            }, _e === $n.DragEnd && typeof lA == "function" && await Promise.resolve(lA(Ri)) && (_e = $n.DragCancel);
          }
          V.current = null, Zl(() => {
            f({
              type: _e
            }), N(sB.Uninitialized), mA(null), eA(null), P(null);
            const lA = _e === $n.DragEnd ? "onDragEnd" : "onDragCancel";
            if (Ri) {
              const jA = J.current[lA];
              jA?.(Ri), S({
                type: lA,
                event: Ri
              });
            }
          });
        };
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [k]
  ), Se = dg((UA, TA) => (ge, Me) => {
    const xe = ge.nativeEvent, we = k.get(Me);
    if (
      // Another sensor is already instantiating
      V.current !== null || // No active draggable
      !we || // Event has already been captured
      xe.dndKit || xe.defaultPrevented
    )
      return;
    const Ee = {
      active: we
    };
    UA(ge, TA.options, Ee) === !0 && (xe.dndKit = {
      capturedBy: TA.sensor
    }, V.current = Me, _A(ge, TA));
  }, [k, _A]), cA = K8(E, Se);
  P8(E), Es(() => {
    kA && m === sB.Initializing && N(sB.Initialized);
  }, [kA, m]), gi(
    () => {
      const {
        onDragMove: UA
      } = J.current, {
        active: TA,
        activatorEvent: ge,
        collisions: Me,
        over: xe
      } = dA.current;
      if (!TA || !ge)
        return;
      const we = {
        active: TA,
        activatorEvent: ge,
        collisions: Me,
        delta: {
          x: GA.x,
          y: GA.y
        },
        over: xe
      };
      Zl(() => {
        UA?.(we), S({
          type: "onDragMove",
          event: we
        });
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [GA.x, GA.y]
  ), gi(
    () => {
      const {
        active: UA,
        activatorEvent: TA,
        collisions: ge,
        droppableContainers: Me,
        scrollAdjustedTranslate: xe
      } = dA.current;
      if (!UA || V.current == null || !TA || !xe)
        return;
      const {
        onDragOver: we
      } = J.current, Ee = Me.get(SA), he = Ee && Ee.rect.current ? {
        id: Ee.id,
        rect: Ee.rect.current,
        data: Ee.data,
        disabled: Ee.disabled
      } : null, _e = {
        active: UA,
        activatorEvent: TA,
        collisions: ge,
        delta: {
          x: xe.x,
          y: xe.y
        },
        over: he
      };
      Zl(() => {
        mA(he), we?.(_e), S({
          type: "onDragOver",
          event: _e
        });
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [SA]
  ), Es(() => {
    dA.current = {
      activatorEvent: oA,
      active: j,
      activeNode: hA,
      collisionRect: bA,
      collisions: DA,
      droppableRects: QA,
      draggableNodes: k,
      draggingNode: ne,
      draggingNodeRect: ee,
      droppableContainers: x,
      over: EA,
      scrollableAncestors: de,
      scrollAdjustedTranslate: GA
    }, _.current = {
      initial: ee,
      translated: bA
    };
  }, [j, hA, DA, bA, k, ne, ee, QA, x, EA, de, GA]), k8({
    ...wA,
    delta: v,
    draggingRect: bA,
    pointerCoordinates: q,
    scrollableAncestors: de,
    scrollableAncestorRects: O
  });
  const xA = ni(() => ({
    active: j,
    activeNode: hA,
    activeNodeRect: kA,
    activatorEvent: oA,
    collisions: DA,
    containerNodeRect: FA,
    dragOverlay: JA,
    draggableNodes: k,
    droppableContainers: x,
    droppableRects: QA,
    over: EA,
    measureDroppableContainers: aA,
    scrollableAncestors: de,
    scrollableAncestorRects: O,
    measuringConfiguration: rA,
    measuringScheduled: MA,
    windowRect: ie
  }), [j, hA, kA, oA, DA, FA, JA, k, x, QA, EA, aA, de, O, rA, MA, ie]), gA = ni(() => ({
    activatorEvent: oA,
    activators: cA,
    active: j,
    activeNodeRect: kA,
    ariaDescribedById: {
      draggable: tA
    },
    dispatch: f,
    draggableNodes: k,
    over: EA,
    measureDroppableContainers: aA
  }), [oA, cA, j, kA, f, tA, k, EA, aA]);
  return qi.createElement(uk.Provider, {
    value: y
  }, qi.createElement(Pf.Provider, {
    value: gA
  }, qi.createElement(Gk.Provider, {
    value: xA
  }, qi.createElement(vk.Provider, {
    value: ZA
  }, I)), qi.createElement(iW, {
    disabled: s?.restoreFocus === !1
  })), qi.createElement(n8, {
    ...s,
    hiddenTextDescribedById: tA
  }));
  function RA() {
    const UA = iA?.autoScrollEnabled === !1, TA = typeof B == "object" ? B.enabled === !1 : B === !1, ge = F && !UA && !TA;
    return typeof B == "object" ? {
      ...B,
      enabled: ge
    } : {
      enabled: ge
    };
  }
}), sW = /* @__PURE__ */ qC(null), IG = "button", aW = "Droppable";
function IW(g) {
  let {
    id: A,
    data: e,
    disabled: t = !1,
    attributes: i
  } = g;
  const n = wu(aW), {
    activators: r,
    activatorEvent: s,
    active: B,
    activeNodeRect: I,
    ariaDescribedById: E,
    draggableNodes: C,
    over: c
  } = za(Pf), {
    role: u = IG,
    roleDescription: d = "draggable",
    tabIndex: p = 0
  } = i ?? {}, D = B?.id === A, f = za(D ? vk : sW), [S, y] = hf(), [m, N] = hf(), F = W8(r, A), G = qc(e);
  Es(
    () => (C.set(A, {
      id: A,
      key: n,
      node: S,
      activatorNode: m,
      data: G
    }), () => {
      const v = C.get(A);
      v && v.key === n && C.delete(A);
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [C, A]
  );
  const k = ni(() => ({
    role: u,
    tabIndex: p,
    "aria-disabled": t,
    "aria-pressed": D && u === IG ? !0 : void 0,
    "aria-roledescription": d,
    "aria-describedby": E.draggable
  }), [t, u, p, D, d, E.draggable]);
  return {
    active: B,
    activatorEvent: s,
    activeNodeRect: I,
    attributes: k,
    isDragging: D,
    listeners: t ? void 0 : F,
    node: S,
    over: c,
    setNodeRef: y,
    setActivatorNodeRef: N,
    transform: f
  };
}
function BW() {
  return za(Gk);
}
const CW = "Droppable", QW = {
  timeout: 25
};
function EW(g) {
  let {
    data: A,
    disabled: e = !1,
    id: t,
    resizeObserverConfig: i
  } = g;
  const n = wu(CW), {
    active: r,
    dispatch: s,
    over: B,
    measureDroppableContainers: I
  } = za(Pf), E = Dt({
    disabled: e
  }), C = Dt(!1), c = Dt(null), u = Dt(null), {
    disabled: d,
    updateMeasurementsFor: p,
    timeout: D
  } = {
    ...QW,
    ...i
  }, f = qc(p ?? t), S = dg(
    () => {
      if (!C.current) {
        C.current = !0;
        return;
      }
      u.current != null && clearTimeout(u.current), u.current = setTimeout(() => {
        I(Array.isArray(f.current) ? f.current : [f.current]), u.current = null;
      }, D);
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [D]
  ), y = qf({
    callback: S,
    disabled: d || !r
  }), m = dg((k, v) => {
    y && (v && (y.unobserve(v), C.current = !1), k && y.observe(k));
  }, [y]), [N, F] = hf(m), G = qc(A);
  return gi(() => {
    !y || !N.current || (y.disconnect(), C.current = !1, y.observe(N.current));
  }, [N, y]), Es(
    () => (s({
      type: $n.RegisterDroppable,
      element: {
        id: t,
        key: n,
        disabled: e,
        node: N,
        rect: c,
        data: G
      }
    }), () => s({
      type: $n.UnregisterDroppable,
      key: n,
      id: t
    })),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [t]
  ), gi(() => {
    e !== E.current.disabled && (s({
      type: $n.SetDroppableDisabled,
      id: t,
      key: n,
      disabled: e
    }), E.current.disabled = e);
  }, [t, n, e, s]), {
    active: r,
    rect: c,
    isOver: B?.id === t,
    node: N,
    over: B,
    setNodeRef: F
  };
}
function fm(g, A, e) {
  const t = g.slice();
  return t.splice(e < 0 ? t.length + e : e, 0, t.splice(A, 1)[0]), t;
}
function lW(g, A) {
  return g.reduce((e, t, i) => {
    const n = A.get(t);
    return n && (e[i] = n), e;
  }, Array(g.length));
}
function zd(g) {
  return g !== null && g >= 0;
}
function cW(g, A) {
  if (g === A)
    return !0;
  if (g.length !== A.length)
    return !1;
  for (let e = 0; e < g.length; e++)
    if (g[e] !== A[e])
      return !1;
  return !0;
}
function uW(g) {
  return typeof g == "boolean" ? {
    draggable: g,
    droppable: g
  } : g;
}
const Uk = (g) => {
  let {
    rects: A,
    activeIndex: e,
    overIndex: t,
    index: i
  } = g;
  const n = fm(A, t, e), r = A[i], s = n[i];
  return !s || !r ? null : {
    x: s.left - r.left,
    y: s.top - r.top,
    scaleX: s.width / r.width,
    scaleY: s.height / r.height
  };
}, Vd = {
  scaleX: 1,
  scaleY: 1
}, hW = (g) => {
  var A;
  let {
    activeIndex: e,
    activeNodeRect: t,
    index: i,
    rects: n,
    overIndex: r
  } = g;
  const s = (A = n[e]) != null ? A : t;
  if (!s)
    return null;
  if (i === e) {
    const I = n[r];
    return I ? {
      x: 0,
      y: e < r ? I.top + I.height - (s.top + s.height) : I.top - s.top,
      ...Vd
    } : null;
  }
  const B = dW(n, i, e);
  return i > e && i <= r ? {
    x: 0,
    y: -s.height - B,
    ...Vd
  } : i < e && i >= r ? {
    x: 0,
    y: s.height + B,
    ...Vd
  } : {
    x: 0,
    y: 0,
    ...Vd
  };
};
function dW(g, A, e) {
  const t = g[A], i = g[A - 1], n = g[A + 1];
  return t ? e < A ? i ? t.top - (i.top + i.height) : n ? n.top - (t.top + t.height) : 0 : n ? n.top - (t.top + t.height) : i ? t.top - (i.top + i.height) : 0 : 0;
}
const kk = "Sortable", xk = /* @__PURE__ */ qi.createContext({
  activeIndex: -1,
  containerId: kk,
  disableTransforms: !1,
  items: [],
  overIndex: -1,
  useDragOverlay: !1,
  sortedRects: [],
  strategy: Uk,
  disabled: {
    draggable: !1,
    droppable: !1
  }
});
function fW(g) {
  let {
    children: A,
    id: e,
    items: t,
    strategy: i = Uk,
    disabled: n = !1
  } = g;
  const {
    active: r,
    dragOverlay: s,
    droppableRects: B,
    over: I,
    measureDroppableContainers: E
  } = BW(), C = wu(kk, e), c = s.rect !== null, u = ni(() => t.map((F) => typeof F == "object" && "id" in F ? F.id : F), [t]), d = r != null, p = r ? u.indexOf(r.id) : -1, D = I ? u.indexOf(I.id) : -1, f = Dt(u), S = !cW(u, f.current), y = D !== -1 && p === -1 || S, m = uW(n);
  Es(() => {
    S && d && E(u);
  }, [S, u, d, E]), gi(() => {
    f.current = u;
  }, [u]);
  const N = ni(
    () => ({
      activeIndex: p,
      containerId: C,
      disabled: m,
      disableTransforms: y,
      items: u,
      overIndex: D,
      useDragOverlay: c,
      sortedRects: lW(u, B),
      strategy: i
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [p, C, m.draggable, m.droppable, y, u, D, B, c, i]
  );
  return qi.createElement(xk.Provider, {
    value: N
  }, A);
}
const pW = (g) => {
  let {
    id: A,
    items: e,
    activeIndex: t,
    overIndex: i
  } = g;
  return fm(e, t, i).indexOf(A);
}, Lk = (g) => {
  let {
    containerId: A,
    isSorting: e,
    wasDragging: t,
    index: i,
    items: n,
    newIndex: r,
    previousItems: s,
    previousContainerId: B,
    transition: I
  } = g;
  return !I || !t || s !== n && i === r ? !1 : e ? !0 : r !== i && A === B;
}, DW = {
  duration: 200,
  easing: "ease"
}, Tk = "transform", wW = /* @__PURE__ */ Wc.Transition.toString({
  property: Tk,
  duration: 0,
  easing: "linear"
}), yW = {
  roleDescription: "sortable"
};
function mW(g) {
  let {
    disabled: A,
    index: e,
    node: t,
    rect: i
  } = g;
  const [n, r] = cn(null), s = Dt(e);
  return Es(() => {
    if (!A && e !== s.current && t.current) {
      const B = i.current;
      if (B) {
        const I = zE(t.current, {
          ignoreTransform: !0
        }), E = {
          x: B.left - I.left,
          y: B.top - I.top,
          scaleX: B.width / I.width,
          scaleY: B.height / I.height
        };
        (E.x || E.y) && r(E);
      }
    }
    e !== s.current && (s.current = e);
  }, [A, e, t, i]), gi(() => {
    n && r(null);
  }, [n]), n;
}
function SW(g) {
  let {
    animateLayoutChanges: A = Lk,
    attributes: e,
    disabled: t,
    data: i,
    getNewIndex: n = pW,
    id: r,
    strategy: s,
    resizeObserverConfig: B,
    transition: I = DW
  } = g;
  const {
    items: E,
    containerId: C,
    activeIndex: c,
    disabled: u,
    disableTransforms: d,
    sortedRects: p,
    overIndex: D,
    useDragOverlay: f,
    strategy: S
  } = za(xk), y = MW(t, u), m = E.indexOf(r), N = ni(() => ({
    sortable: {
      containerId: C,
      index: m,
      items: E
    },
    ...i
  }), [C, i, m, E]), F = ni(() => E.slice(E.indexOf(r)), [E, r]), {
    rect: G,
    node: k,
    isOver: v,
    setNodeRef: x
  } = EW({
    id: r,
    data: N,
    disabled: y.droppable,
    resizeObserverConfig: {
      updateMeasurementsFor: F,
      ...B
    }
  }), {
    active: H,
    activatorEvent: _,
    activeNodeRect: j,
    attributes: V,
    setNodeRef: iA,
    listeners: eA,
    isDragging: oA,
    over: P,
    setActivatorNodeRef: J,
    transform: tA
  } = IW({
    id: r,
    data: N,
    attributes: {
      ...yW,
      ...e
    },
    disabled: y.draggable
  }), Y = JP(x, iA), rA = !!H, QA = rA && !d && zd(c) && zd(D), aA = !f && oA, MA = aA && QA ? tA : null, fA = QA ? MA ?? (s ?? S)({
    rects: p,
    activeNodeRect: j,
    activeIndex: c,
    overIndex: D,
    index: m
  }) : null, wA = zd(c) && zd(D) ? n({
    id: r,
    items: E,
    activeIndex: c,
    overIndex: D
  }) : m, yA = H?.id, kA = Dt({
    activeId: yA,
    items: E,
    newIndex: wA,
    containerId: C
  }), FA = E !== kA.current.items, dA = A({
    active: H,
    containerId: C,
    isDragging: oA,
    isSorting: rA,
    id: r,
    index: m,
    items: E,
    newIndex: kA.current.newIndex,
    previousItems: kA.current.items,
    previousContainerId: kA.current.containerId,
    transition: I,
    wasDragging: kA.current.activeId != null
  }), vA = mW({
    disabled: !dA,
    index: m,
    node: k,
    rect: G
  });
  return gi(() => {
    rA && kA.current.newIndex !== wA && (kA.current.newIndex = wA), C !== kA.current.containerId && (kA.current.containerId = C), E !== kA.current.items && (kA.current.items = E);
  }, [rA, wA, C, E]), gi(() => {
    if (yA === kA.current.activeId)
      return;
    if (yA && !kA.current.activeId) {
      kA.current.activeId = yA;
      return;
    }
    const ne = setTimeout(() => {
      kA.current.activeId = yA;
    }, 50);
    return () => clearTimeout(ne);
  }, [yA]), {
    active: H,
    activeIndex: c,
    attributes: V,
    data: N,
    rect: G,
    index: m,
    newIndex: wA,
    items: E,
    isOver: v,
    isSorting: rA,
    isDragging: oA,
    listeners: eA,
    node: k,
    overIndex: D,
    over: P,
    setNodeRef: Y,
    setActivatorNodeRef: J,
    setDroppableNodeRef: x,
    setDraggableNodeRef: iA,
    transform: vA ?? fA,
    transition: JA()
  };
  function JA() {
    if (
      // Temporarily disable transitions for a single frame to set up derived transforms
      vA || // Or to prevent items jumping to back to their "new" position when items change
      FA && kA.current.newIndex === m
    )
      return wW;
    if (!(aA && !lm(_) || !I) && (rA || dA))
      return Wc.Transition.toString({
        ...I,
        property: Tk
      });
  }
}
function MW(g, A) {
  var e, t;
  return typeof g == "boolean" ? {
    draggable: g,
    // Backwards compatibility
    droppable: !1
  } : {
    draggable: (e = g?.draggable) != null ? e : A.draggable,
    droppable: (t = g?.droppable) != null ? t : A.droppable
  };
}
function pf(g) {
  if (!g)
    return !1;
  const A = g.data.current;
  return !!(A && "sortable" in A && typeof A.sortable == "object" && "containerId" in A.sortable && "items" in A.sortable && "index" in A.sortable);
}
const RW = [ri.Down, ri.Right, ri.Up, ri.Left], NW = (g, A) => {
  let {
    context: {
      active: e,
      collisionRect: t,
      droppableRects: i,
      droppableContainers: n,
      over: r,
      scrollableAncestors: s
    }
  } = A;
  if (RW.includes(g.code)) {
    if (g.preventDefault(), !e || !t)
      return;
    const B = [];
    n.getEnabled().forEach((C) => {
      if (!C || C != null && C.disabled)
        return;
      const c = i.get(C.id);
      if (c)
        switch (g.code) {
          case ri.Down:
            t.top < c.top && B.push(C);
            break;
          case ri.Up:
            t.top > c.top && B.push(C);
            break;
          case ri.Left:
            t.left > c.left && B.push(C);
            break;
          case ri.Right:
            t.left < c.left && B.push(C);
            break;
        }
    });
    const I = s8({
      active: e,
      collisionRect: t,
      droppableRects: i,
      droppableContainers: B,
      pointerCoordinates: null
    });
    let E = fk(I, "id");
    if (E === r?.id && I.length > 1 && (E = I[1].id), E != null) {
      const C = n.get(e.id), c = n.get(E), u = c ? i.get(c.id) : null, d = c?.node.current;
      if (d && u && C && c) {
        const D = Of(d).some((F, G) => s[G] !== F), f = Kk(C, c), S = FW(C, c), y = D || !f ? {
          x: 0,
          y: 0
        } : {
          x: S ? t.width - u.width : 0,
          y: S ? t.height - u.height : 0
        }, m = {
          x: u.left,
          y: u.top
        };
        return y.x && y.y ? m : Pc(m, y);
      }
    }
  }
};
function Kk(g, A) {
  return !pf(g) || !pf(A) ? !1 : g.data.current.sortable.containerId === A.data.current.sortable.containerId;
}
function FW(g, A) {
  return !pf(g) || !pf(A) || !Kk(g, A) ? !1 : g.data.current.sortable.index < A.data.current.sortable.index;
}
const GW = ({
  id: g,
  name: A,
  image: e
}) => {
  const {
    pastedStickers: t,
    setPastedStickers: i,
    setSelectedSticker: n,
    setRotation: r,
    setScale: s,
    selectedSticker: B
  } = dB(), I = (S) => Lk({ ...S, wasDragging: !0 }), { attributes: E, listeners: C, setNodeRef: c, transform: u, transition: d } = SW({ id: g, animateLayoutChanges: I }), p = {
    transform: Wc.Transform.toString(u),
    transition: d
  }, D = (S) => {
    S.toString() === B && n(""), i((y) => y.filter((m) => m.id !== S));
  }, f = (S) => {
    const y = t.find((m) => m.id === S);
    r(y.rotationAngle), s(y.scale), n(y.id);
  };
  return /* @__PURE__ */ Wi(
    "div",
    {
      ref: c,
      style: p,
      className: `${B === g ? "ms-bg-gray-300" : "ms-bg-gray-200"} ms-rounded-sm ms-p-1.5 ms-flex ms-items-center ms-justify-between ms-my-2 ms-cursor-pointer`,
      children: [
        /* @__PURE__ */ Wi(
          "div",
          {
            className: "ms-flex ms-items-center ms-flex-grow ms-space-x-2",
            onClick: () => f(g),
            children: [
              /* @__PURE__ */ fe(
                "img",
                {
                  src: e,
                  alt: A,
                  className: "ms-w-8 ms-h-8 ms-rounded-sm"
                }
              ),
              /* @__PURE__ */ fe("span", { className: "ms-text-sm", children: A })
            ]
          }
        ),
        /* @__PURE__ */ Wi("div", { className: "ms-flex ms-items-center", children: [
          /* @__PURE__ */ fe(
            "button",
            {
              onClick: () => D(g),
              className: "ms-p-1.5 hover:ms-bg-gray-400 ms-rounded-md",
              children: /* @__PURE__ */ fe(
                "svg",
                {
                  xmlns: "http://www.w3.org/2000/svg",
                  fill: "none",
                  viewBox: "0 0 24 24",
                  strokeWidth: 1.5,
                  stroke: "currentColor",
                  className: "ms-w-4 ms-h-4",
                  children: /* @__PURE__ */ fe(
                    "path",
                    {
                      strokeLinecap: "round",
                      strokeLinejoin: "round",
                      d: "M6 18L18 6M6 6l12 12"
                    }
                  )
                }
              )
            }
          ),
          /* @__PURE__ */ fe(
            "button",
            {
              ...E,
              ...C,
              className: "ms-p-1.5 hover:ms-bg-gray-400 ms-rounded-md",
              children: /* @__PURE__ */ fe("svg", { viewBox: "0 0 20 20", width: "12", children: /* @__PURE__ */ fe("path", { d: "M7 2a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 2zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 8zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 14zm6-8a2 2 0 1 0-.001-4.001A2 2 0 0 0 13 6zm0 2a2 2 0 1 0 .001 4.001A2 2 0 0 0 13 8zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 13 14z" }) })
            }
          )
        ] })
      ]
    }
  );
}, vW = 2, UW = 0.8, BG = 0.4, kW = /* @__PURE__ */ fe(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    className: "ms-w-5 ms-h-5",
    children: /* @__PURE__ */ fe(
      "path",
      {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6"
      }
    )
  }
), xW = /* @__PURE__ */ fe(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    className: "ms-w-5 ms-h-5",
    children: /* @__PURE__ */ fe(
      "path",
      {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM13.5 10.5h-6"
      }
    )
  }
), LW = () => {
  const { cameraControls: g } = Vc(), [A, e] = cn(0);
  return /* @__PURE__ */ Wi(Df, { children: [
    /* @__PURE__ */ fe("div", { className: "ms-w-3/5 ms-absolute ms-bottom-1 ms-left-0 ms-right-0 ms-mx-auto", children: /* @__PURE__ */ fe(
      sy,
      {
        min: -180,
        max: 180,
        value: A,
        onChange: (r) => {
          g?.current?.rotate(
            bg.degToRad(Number.parseFloat(r.currentTarget.value) - A),
            0,
            !0
          ), e(Number.parseFloat(r.currentTarget.value));
        }
      }
    ) }),
    /* @__PURE__ */ Wi("div", { className: "ms-absolute ms-bottom-1 ms-right-4 ms-flex ms-flex-col ms-space-y-2", children: [
      /* @__PURE__ */ fe(JN, { icon: kW, onClick: () => {
        g?.current?.zoom(BG, !0);
      } }),
      /* @__PURE__ */ fe(JN, { icon: xW, onClick: () => {
        g?.current?.zoom(-BG, !0);
      } })
    ] })
  ] });
}, TW = () => {
  const { pastedStickers: g, setPastedStickers: A } = dB(), e = g8(
    $F(dm, { activationConstraint: { distance: 10 } }),
    $F(um, {
      coordinateGetter: NW
    })
  );
  return /* @__PURE__ */ fe(
    oW,
    {
      sensors: e,
      collisionDetection: o8,
      onDragEnd: (i) => {
        const { active: n, over: r } = i;
        n.id !== r?.id && A((s) => {
          const B = s.findIndex(
            (E) => E.id === n.id
          ), I = s.findIndex(
            (E) => E.id === r?.id
          );
          return fm(s, B, I);
        });
      },
      measuring: { droppable: { strategy: TE.Always } },
      children: /* @__PURE__ */ fe(
        fW,
        {
          items: g,
          strategy: hW,
          children: [...g].reverse().map((i, n) => /* @__PURE__ */ fe(
            GW,
            {
              id: i.id,
              image: i.image,
              name: `Layer ${g.length - n}`
            },
            i.id
          ))
        }
      )
    }
  );
}, CG = {
  POSITION: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "unsigned byte normalized",
    "short",
    "short normalized",
    "unsigned short",
    "unsigned short normalized"
  ],
  NORMAL: [
    "byte normalized",
    "short normalized"
  ],
  TANGENT: [
    "byte normalized",
    "short normalized"
  ],
  TEXCOORD: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "short",
    "short normalized",
    "unsigned short"
  ]
};
class pm {
  constructor() {
    this.pluginCallbacks = [], this.register(function(A) {
      return new WW(A);
    }), this.register(function(A) {
      return new zW(A);
    }), this.register(function(A) {
      return new ZW(A);
    }), this.register(function(A) {
      return new XW(A);
    }), this.register(function(A) {
      return new $W(A);
    }), this.register(function(A) {
      return new Az(A);
    }), this.register(function(A) {
      return new VW(A);
    }), this.register(function(A) {
      return new jW(A);
    }), this.register(function(A) {
      return new ez(A);
    }), this.register(function(A) {
      return new tz(A);
    });
  }
  register(A) {
    return this.pluginCallbacks.indexOf(A) === -1 && this.pluginCallbacks.push(A), this;
  }
  unregister(A) {
    return this.pluginCallbacks.indexOf(A) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(A), 1), this;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Function} onError  Callback on errors
   * @param  {Object} options options
   */
  parse(A, e, t, i) {
    const n = new PW(), r = [];
    for (let s = 0, B = this.pluginCallbacks.length; s < B; s++)
      r.push(this.pluginCallbacks[s](n));
    n.setPlugins(r), n.write(A, e, i).catch(t);
  }
  parseAsync(A, e) {
    const t = this;
    return new Promise(function(i, n) {
      t.parse(A, i, n, e);
    });
  }
}
const ii = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  ARRAY_BUFFER: 34962,
  ELEMENT_ARRAY_BUFFER: 34963,
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  REPEAT: 10497
}, ow = "KHR_mesh_quantization", to = {};
to[un] = ii.NEAREST;
to[NE] = ii.NEAREST_MIPMAP_NEAREST;
to[RC] = ii.NEAREST_MIPMAP_LINEAR;
to[Gi] = ii.LINEAR;
to[Zc] = ii.LINEAR_MIPMAP_NEAREST;
to[Cs] = ii.LINEAR_MIPMAP_LINEAR;
to[Jn] = ii.CLAMP_TO_EDGE;
to[Bs] = ii.REPEAT;
to[kC] = ii.MIRRORED_REPEAT;
const QG = {
  scale: "scale",
  position: "translation",
  quaternion: "rotation",
  morphTargetInfluences: "weights"
}, KW = new ke(), EG = 12, bW = 1179937895, YW = 2, lG = 8, HW = 1313821514, _W = 5130562;
function mc(g, A) {
  return g.length === A.length && g.every(function(e, t) {
    return e === A[t];
  });
}
function JW(g) {
  return new TextEncoder().encode(g).buffer;
}
function OW(g) {
  return mc(g.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
}
function qW(g, A, e) {
  const t = {
    min: new Array(g.itemSize).fill(Number.POSITIVE_INFINITY),
    max: new Array(g.itemSize).fill(Number.NEGATIVE_INFINITY)
  };
  for (let i = A; i < A + e; i++)
    for (let n = 0; n < g.itemSize; n++) {
      let r;
      g.itemSize > 4 ? r = g.array[i * g.itemSize + n] : (n === 0 ? r = g.getX(i) : n === 1 ? r = g.getY(i) : n === 2 ? r = g.getZ(i) : n === 3 && (r = g.getW(i)), g.normalized === !0 && (r = bg.normalize(r, g.array))), t.min[n] = Math.min(t.min[n], r), t.max[n] = Math.max(t.max[n], r);
    }
  return t;
}
function bk(g) {
  return Math.ceil(g / 4) * 4;
}
function sw(g, A = 0) {
  const e = bk(g.byteLength);
  if (e !== g.byteLength) {
    const t = new Uint8Array(e);
    if (t.set(new Uint8Array(g)), A !== 0)
      for (let i = g.byteLength; i < e; i++)
        t[i] = A;
    return t.buffer;
  }
  return g;
}
function cG() {
  return typeof document > "u" && typeof OffscreenCanvas < "u" ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
}
function uG(g, A) {
  if (g.toBlob !== void 0)
    return new Promise((t) => g.toBlob(t, A));
  let e;
  return A === "image/jpeg" ? e = 0.92 : A === "image/webp" && (e = 0.8), g.convertToBlob({
    type: A,
    quality: e
  });
}
class PW {
  constructor() {
    this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.extensionsRequired = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = {
      asset: {
        version: "2.0",
        generator: "THREE.GLTFExporter"
      }
    }, this.cache = {
      meshes: /* @__PURE__ */ new Map(),
      attributes: /* @__PURE__ */ new Map(),
      attributesNormalized: /* @__PURE__ */ new Map(),
      materials: /* @__PURE__ */ new Map(),
      textures: /* @__PURE__ */ new Map(),
      images: /* @__PURE__ */ new Map()
    };
  }
  setPlugins(A) {
    this.plugins = A;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */
  async write(A, e, t = {}) {
    this.options = Object.assign({
      // default options
      binary: !1,
      trs: !1,
      onlyVisible: !0,
      maxTextureSize: 1 / 0,
      animations: [],
      includeCustomExtensions: !1
    }, t), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(A), await Promise.all(this.pending);
    const i = this, n = i.buffers, r = i.json;
    t = i.options;
    const s = i.extensionsUsed, B = i.extensionsRequired, I = new Blob(n, { type: "application/octet-stream" }), E = Object.keys(s), C = Object.keys(B);
    if (E.length > 0 && (r.extensionsUsed = E), C.length > 0 && (r.extensionsRequired = C), r.buffers && r.buffers.length > 0 && (r.buffers[0].byteLength = I.size), t.binary === !0) {
      const c = new FileReader();
      c.readAsArrayBuffer(I), c.onloadend = function() {
        const u = sw(c.result), d = new DataView(new ArrayBuffer(lG));
        d.setUint32(0, u.byteLength, !0), d.setUint32(4, _W, !0);
        const p = sw(JW(JSON.stringify(r)), 32), D = new DataView(new ArrayBuffer(lG));
        D.setUint32(0, p.byteLength, !0), D.setUint32(4, HW, !0);
        const f = new ArrayBuffer(EG), S = new DataView(f);
        S.setUint32(0, bW, !0), S.setUint32(4, YW, !0);
        const y = EG + D.byteLength + p.byteLength + d.byteLength + u.byteLength;
        S.setUint32(8, y, !0);
        const m = new Blob([
          f,
          D,
          p,
          d,
          u
        ], { type: "application/octet-stream" }), N = new FileReader();
        N.readAsArrayBuffer(m), N.onloadend = function() {
          e(N.result);
        };
      };
    } else if (r.buffers && r.buffers.length > 0) {
      const c = new FileReader();
      c.readAsDataURL(I), c.onloadend = function() {
        const u = c.result;
        r.buffers[0].uri = u, e(r);
      };
    } else
      e(r);
  }
  /**
   * Serializes a userData.
   *
   * @param {THREE.Object3D|THREE.Material} object
   * @param {Object} objectDef
   */
  serializeUserData(A, e) {
    if (Object.keys(A.userData).length === 0)
      return;
    const t = this.options, i = this.extensionsUsed;
    try {
      const n = JSON.parse(JSON.stringify(A.userData));
      if (t.includeCustomExtensions && n.gltfExtensions) {
        e.extensions === void 0 && (e.extensions = {});
        for (const r in n.gltfExtensions)
          e.extensions[r] = n.gltfExtensions[r], i[r] = !0;
        delete n.gltfExtensions;
      }
      Object.keys(n).length > 0 && (e.extras = n);
    } catch (n) {
      console.warn("THREE.GLTFExporter: userData of '" + A.name + "' won't be serialized because of JSON.stringify error - " + n.message);
    }
  }
  /**
   * Returns ids for buffer attributes.
   * @param  {Object} object
   * @return {Integer}
   */
  getUID(A, e = !1) {
    if (this.uids.has(A) === !1) {
      const i = /* @__PURE__ */ new Map();
      i.set(!0, this.uid++), i.set(!1, this.uid++), this.uids.set(A, i);
    }
    return this.uids.get(A).get(e);
  }
  /**
   * Checks if normal attribute values are normalized.
   *
   * @param {BufferAttribute} normal
   * @returns {Boolean}
   */
  isNormalizedNormalAttribute(A) {
    if (this.cache.attributesNormalized.has(A))
      return !1;
    const t = new IA();
    for (let i = 0, n = A.count; i < n; i++)
      if (Math.abs(t.fromBufferAttribute(A, i).length() - 1) > 5e-4)
        return !1;
    return !0;
  }
  /**
   * Creates normalized normal buffer attribute.
   *
   * @param {BufferAttribute} normal
   * @returns {BufferAttribute}
   *
   */
  createNormalizedNormalAttribute(A) {
    const e = this.cache;
    if (e.attributesNormalized.has(A))
      return e.attributesNormalized.get(A);
    const t = A.clone(), i = new IA();
    for (let n = 0, r = t.count; n < r; n++)
      i.fromBufferAttribute(t, n), i.x === 0 && i.y === 0 && i.z === 0 ? i.setX(1) : i.normalize(), t.setXYZ(n, i.x, i.y, i.z);
    return e.attributesNormalized.set(A, t), t;
  }
  /**
   * Applies a texture transform, if present, to the map definition. Requires
   * the KHR_texture_transform extension.
   *
   * @param {Object} mapDef
   * @param {THREE.Texture} texture
   */
  applyTextureTransform(A, e) {
    let t = !1;
    const i = {};
    (e.offset.x !== 0 || e.offset.y !== 0) && (i.offset = e.offset.toArray(), t = !0), e.rotation !== 0 && (i.rotation = e.rotation, t = !0), (e.repeat.x !== 1 || e.repeat.y !== 1) && (i.scale = e.repeat.toArray(), t = !0), t && (A.extensions = A.extensions || {}, A.extensions.KHR_texture_transform = i, this.extensionsUsed.KHR_texture_transform = !0);
  }
  buildMetalRoughTexture(A, e) {
    if (A === e)
      return A;
    function t(u) {
      return u.encoding === Ht ? function(p) {
        return p < 0.04045 ? p * 0.0773993808 : Math.pow(p * 0.9478672986 + 0.0521327014, 2.4);
      } : function(p) {
        return p;
      };
    }
    console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");
    const i = A ? A.image : null, n = e ? e.image : null, r = Math.max(i ? i.width : 0, n ? n.width : 0), s = Math.max(i ? i.height : 0, n ? n.height : 0), B = cG();
    B.width = r, B.height = s;
    const I = B.getContext("2d");
    I.fillStyle = "#00ffff", I.fillRect(0, 0, r, s);
    const E = I.getImageData(0, 0, r, s);
    if (i) {
      I.drawImage(i, 0, 0, r, s);
      const u = t(A), d = I.getImageData(0, 0, r, s).data;
      for (let p = 2; p < d.length; p += 4)
        E.data[p] = u(d[p] / 256) * 256;
    }
    if (n) {
      I.drawImage(n, 0, 0, r, s);
      const u = t(e), d = I.getImageData(0, 0, r, s).data;
      for (let p = 1; p < d.length; p += 4)
        E.data[p] = u(d[p] / 256) * 256;
    }
    I.putImageData(E, 0, 0);
    const c = (A || e).clone();
    return c.source = new IB(B), c.encoding = ta, c;
  }
  /**
   * Process a buffer to append to the default one.
   * @param  {ArrayBuffer} buffer
   * @return {Integer}
   */
  processBuffer(A) {
    const e = this.json, t = this.buffers;
    return e.buffers || (e.buffers = [{ byteLength: 0 }]), t.push(A), 0;
  }
  /**
   * Process and generate a BufferView
   * @param  {BufferAttribute} attribute
   * @param  {number} componentType
   * @param  {number} start
   * @param  {number} count
   * @param  {number} target (Optional) Target usage of the BufferView
   * @return {Object}
   */
  processBufferView(A, e, t, i, n) {
    const r = this.json;
    r.bufferViews || (r.bufferViews = []);
    let s;
    switch (e) {
      case ii.BYTE:
      case ii.UNSIGNED_BYTE:
        s = 1;
        break;
      case ii.SHORT:
      case ii.UNSIGNED_SHORT:
        s = 2;
        break;
      default:
        s = 4;
    }
    const B = bk(i * A.itemSize * s), I = new DataView(new ArrayBuffer(B));
    let E = 0;
    for (let u = t; u < t + i; u++)
      for (let d = 0; d < A.itemSize; d++) {
        let p;
        A.itemSize > 4 ? p = A.array[u * A.itemSize + d] : (d === 0 ? p = A.getX(u) : d === 1 ? p = A.getY(u) : d === 2 ? p = A.getZ(u) : d === 3 && (p = A.getW(u)), A.normalized === !0 && (p = bg.normalize(p, A.array))), e === ii.FLOAT ? I.setFloat32(E, p, !0) : e === ii.INT ? I.setInt32(E, p, !0) : e === ii.UNSIGNED_INT ? I.setUint32(E, p, !0) : e === ii.SHORT ? I.setInt16(E, p, !0) : e === ii.UNSIGNED_SHORT ? I.setUint16(E, p, !0) : e === ii.BYTE ? I.setInt8(E, p) : e === ii.UNSIGNED_BYTE && I.setUint8(E, p), E += s;
      }
    const C = {
      buffer: this.processBuffer(I.buffer),
      byteOffset: this.byteOffset,
      byteLength: B
    };
    return n !== void 0 && (C.target = n), n === ii.ARRAY_BUFFER && (C.byteStride = A.itemSize * s), this.byteOffset += B, r.bufferViews.push(C), {
      id: r.bufferViews.length - 1,
      byteLength: 0
    };
  }
  /**
   * Process and generate a BufferView from an image Blob.
   * @param {Blob} blob
   * @return {Promise<Integer>}
   */
  processBufferViewImage(A) {
    const e = this, t = e.json;
    return t.bufferViews || (t.bufferViews = []), new Promise(function(i) {
      const n = new FileReader();
      n.readAsArrayBuffer(A), n.onloadend = function() {
        const r = sw(n.result), s = {
          buffer: e.processBuffer(r),
          byteOffset: e.byteOffset,
          byteLength: r.byteLength
        };
        e.byteOffset += r.byteLength, i(t.bufferViews.push(s) - 1);
      };
    });
  }
  /**
   * Process attribute to generate an accessor
   * @param  {BufferAttribute} attribute Attribute to process
   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
   * @param  {Integer} start (Optional)
   * @param  {Integer} count (Optional)
   * @return {Integer|null} Index of the processed accessor on the "accessors" array
   */
  processAccessor(A, e, t, i) {
    const n = this.json, r = {
      1: "SCALAR",
      2: "VEC2",
      3: "VEC3",
      4: "VEC4",
      9: "MAT3",
      16: "MAT4"
    };
    let s;
    if (A.array.constructor === Float32Array)
      s = ii.FLOAT;
    else if (A.array.constructor === Int32Array)
      s = ii.INT;
    else if (A.array.constructor === Uint32Array)
      s = ii.UNSIGNED_INT;
    else if (A.array.constructor === Int16Array)
      s = ii.SHORT;
    else if (A.array.constructor === Uint16Array)
      s = ii.UNSIGNED_SHORT;
    else if (A.array.constructor === Int8Array)
      s = ii.BYTE;
    else if (A.array.constructor === Uint8Array)
      s = ii.UNSIGNED_BYTE;
    else
      throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
    if (t === void 0 && (t = 0), i === void 0 && (i = A.count), i === 0)
      return null;
    const B = qW(A, t, i);
    let I;
    e !== void 0 && (I = A === e.index ? ii.ELEMENT_ARRAY_BUFFER : ii.ARRAY_BUFFER);
    const E = this.processBufferView(A, s, t, i, I), C = {
      bufferView: E.id,
      byteOffset: E.byteOffset,
      componentType: s,
      count: i,
      max: B.max,
      min: B.min,
      type: r[A.itemSize]
    };
    return A.normalized === !0 && (C.normalized = !0), n.accessors || (n.accessors = []), n.accessors.push(C) - 1;
  }
  /**
   * Process image
   * @param  {Image} image to process
   * @param  {Integer} format of the image (RGBAFormat)
   * @param  {Boolean} flipY before writing out the image
   * @param  {String} mimeType export format
   * @return {Integer}     Index of the processed texture in the "images" array
   */
  processImage(A, e, t, i = "image/png") {
    if (A !== null) {
      const n = this, r = n.cache, s = n.json, B = n.options, I = n.pending;
      r.images.has(A) || r.images.set(A, {});
      const E = r.images.get(A), C = i + ":flipY/" + t.toString();
      if (E[C] !== void 0)
        return E[C];
      s.images || (s.images = []);
      const c = { mimeType: i }, u = cG();
      u.width = Math.min(A.width, B.maxTextureSize), u.height = Math.min(A.height, B.maxTextureSize);
      const d = u.getContext("2d");
      if (t === !0 && (d.translate(0, u.height), d.scale(1, -1)), A.data !== void 0) {
        e !== tr && console.error("GLTFExporter: Only RGBAFormat is supported."), (A.width > B.maxTextureSize || A.height > B.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", A);
        const D = new Uint8ClampedArray(A.height * A.width * 4);
        for (let f = 0; f < D.length; f += 4)
          D[f + 0] = A.data[f + 0], D[f + 1] = A.data[f + 1], D[f + 2] = A.data[f + 2], D[f + 3] = A.data[f + 3];
        d.putImageData(new ImageData(D, A.width, A.height), 0, 0);
      } else
        d.drawImage(A, 0, 0, u.width, u.height);
      B.binary === !0 ? I.push(
        uG(u, i).then((D) => n.processBufferViewImage(D)).then((D) => {
          c.bufferView = D;
        })
      ) : u.toDataURL !== void 0 ? c.uri = u.toDataURL(i) : I.push(
        uG(u, i).then((D) => new FileReader().readAsDataURL(D)).then((D) => {
          c.uri = D;
        })
      );
      const p = s.images.push(c) - 1;
      return E[C] = p, p;
    } else
      throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.");
  }
  /**
   * Process sampler
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "samplers" array
   */
  processSampler(A) {
    const e = this.json;
    e.samplers || (e.samplers = []);
    const t = {
      magFilter: to[A.magFilter],
      minFilter: to[A.minFilter],
      wrapS: to[A.wrapS],
      wrapT: to[A.wrapT]
    };
    return e.samplers.push(t) - 1;
  }
  /**
   * Process texture
   * @param  {Texture} map Map to process
   * @return {Integer} Index of the processed texture in the "textures" array
   */
  processTexture(A) {
    const e = this.cache, t = this.json;
    if (e.textures.has(A))
      return e.textures.get(A);
    t.textures || (t.textures = []);
    let i = A.userData.mimeType;
    i === "image/webp" && (i = "image/png");
    const n = {
      sampler: this.processSampler(A),
      source: this.processImage(A.image, A.format, A.flipY, i)
    };
    A.name && (n.name = A.name), this._invokeAll(function(s) {
      s.writeTexture && s.writeTexture(A, n);
    });
    const r = t.textures.push(n) - 1;
    return e.textures.set(A, r), r;
  }
  /**
   * Process material
   * @param  {THREE.Material} material Material to process
   * @return {Integer|null} Index of the processed material in the "materials" array
   */
  processMaterial(A) {
    const e = this.cache, t = this.json;
    if (e.materials.has(A))
      return e.materials.get(A);
    if (A.isShaderMaterial)
      return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
    t.materials || (t.materials = []);
    const i = { pbrMetallicRoughness: {} };
    A.isMeshStandardMaterial !== !0 && A.isMeshBasicMaterial !== !0 && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    const n = A.color.toArray().concat([A.opacity]);
    if (mc(n, [1, 1, 1, 1]) || (i.pbrMetallicRoughness.baseColorFactor = n), A.isMeshStandardMaterial ? (i.pbrMetallicRoughness.metallicFactor = A.metalness, i.pbrMetallicRoughness.roughnessFactor = A.roughness) : (i.pbrMetallicRoughness.metallicFactor = 0.5, i.pbrMetallicRoughness.roughnessFactor = 0.5), A.metalnessMap || A.roughnessMap) {
      const s = this.buildMetalRoughTexture(A.metalnessMap, A.roughnessMap), B = { index: this.processTexture(s) };
      this.applyTextureTransform(B, s), i.pbrMetallicRoughness.metallicRoughnessTexture = B;
    }
    if (A.map) {
      const s = { index: this.processTexture(A.map) };
      this.applyTextureTransform(s, A.map), i.pbrMetallicRoughness.baseColorTexture = s;
    }
    if (A.emissive) {
      const s = A.emissive;
      if (Math.max(s.r, s.g, s.b) > 0 && (i.emissiveFactor = A.emissive.toArray()), A.emissiveMap) {
        const I = { index: this.processTexture(A.emissiveMap) };
        this.applyTextureTransform(I, A.emissiveMap), i.emissiveTexture = I;
      }
    }
    if (A.normalMap) {
      const s = { index: this.processTexture(A.normalMap) };
      A.normalScale && A.normalScale.x !== 1 && (s.scale = A.normalScale.x), this.applyTextureTransform(s, A.normalMap), i.normalTexture = s;
    }
    if (A.aoMap) {
      const s = {
        index: this.processTexture(A.aoMap),
        texCoord: 1
      };
      A.aoMapIntensity !== 1 && (s.strength = A.aoMapIntensity), this.applyTextureTransform(s, A.aoMap), i.occlusionTexture = s;
    }
    A.transparent ? i.alphaMode = "BLEND" : A.alphaTest > 0 && (i.alphaMode = "MASK", i.alphaCutoff = A.alphaTest), A.side === Rr && (i.doubleSided = !0), A.name !== "" && (i.name = A.name), this.serializeUserData(A, i), this._invokeAll(function(s) {
      s.writeMaterial && s.writeMaterial(A, i);
    });
    const r = t.materials.push(i) - 1;
    return e.materials.set(A, r), r;
  }
  /**
   * Process mesh
   * @param  {THREE.Mesh} mesh Mesh to process
   * @return {Integer|null} Index of the processed mesh in the "meshes" array
   */
  processMesh(A) {
    const e = this.cache, t = this.json, i = [A.geometry.uuid];
    if (Array.isArray(A.material))
      for (let y = 0, m = A.material.length; y < m; y++)
        i.push(A.material[y].uuid);
    else
      i.push(A.material.uuid);
    const n = i.join(":");
    if (e.meshes.has(n))
      return e.meshes.get(n);
    const r = A.geometry;
    let s;
    A.isLineSegments ? s = ii.LINES : A.isLineLoop ? s = ii.LINE_LOOP : A.isLine ? s = ii.LINE_STRIP : A.isPoints ? s = ii.POINTS : s = A.material.wireframe ? ii.LINES : ii.TRIANGLES;
    const B = {}, I = {}, E = [], C = [], c = {
      uv: "TEXCOORD_0",
      uv2: "TEXCOORD_1",
      color: "COLOR_0",
      skinWeight: "WEIGHTS_0",
      skinIndex: "JOINTS_0"
    }, u = r.getAttribute("normal");
    u !== void 0 && !this.isNormalizedNormalAttribute(u) && (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), r.setAttribute("normal", this.createNormalizedNormalAttribute(u)));
    let d = null;
    for (let y in r.attributes) {
      if (y.slice(0, 5) === "morph")
        continue;
      const m = r.attributes[y];
      if (y = c[y] || y.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(y) || (y = "_" + y), e.attributes.has(this.getUID(m))) {
        I[y] = e.attributes.get(this.getUID(m));
        continue;
      }
      d = null;
      const F = m.array;
      y === "JOINTS_0" && !(F instanceof Uint16Array) && !(F instanceof Uint8Array) && (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), d = new Pt(new Uint16Array(F), m.itemSize, m.normalized));
      const G = this.processAccessor(d || m, r);
      G !== null && (y.startsWith("_") || this.detectMeshQuantization(y, m), I[y] = G, e.attributes.set(this.getUID(m), G));
    }
    if (u !== void 0 && r.setAttribute("normal", u), Object.keys(I).length === 0)
      return null;
    if (A.morphTargetInfluences !== void 0 && A.morphTargetInfluences.length > 0) {
      const y = [], m = [], N = {};
      if (A.morphTargetDictionary !== void 0)
        for (const F in A.morphTargetDictionary)
          N[A.morphTargetDictionary[F]] = F;
      for (let F = 0; F < A.morphTargetInfluences.length; ++F) {
        const G = {};
        let k = !1;
        for (const v in r.morphAttributes) {
          if (v !== "position" && v !== "normal") {
            k || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), k = !0);
            continue;
          }
          const x = r.morphAttributes[v][F], H = v.toUpperCase(), _ = r.attributes[v];
          if (e.attributes.has(this.getUID(x, !0))) {
            G[H] = e.attributes.get(this.getUID(x, !0));
            continue;
          }
          const j = x.clone();
          if (!r.morphTargetsRelative)
            for (let V = 0, iA = x.count; V < iA; V++)
              for (let eA = 0; eA < x.itemSize; eA++)
                eA === 0 && j.setX(V, x.getX(V) - _.getX(V)), eA === 1 && j.setY(V, x.getY(V) - _.getY(V)), eA === 2 && j.setZ(V, x.getZ(V) - _.getZ(V)), eA === 3 && j.setW(V, x.getW(V) - _.getW(V));
          G[H] = this.processAccessor(j, r), e.attributes.set(this.getUID(_, !0), G[H]);
        }
        C.push(G), y.push(A.morphTargetInfluences[F]), A.morphTargetDictionary !== void 0 && m.push(N[F]);
      }
      B.weights = y, m.length > 0 && (B.extras = {}, B.extras.targetNames = m);
    }
    const p = Array.isArray(A.material);
    if (p && r.groups.length === 0)
      return null;
    const D = p ? A.material : [A.material], f = p ? r.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
    for (let y = 0, m = f.length; y < m; y++) {
      const N = {
        mode: s,
        attributes: I
      };
      if (this.serializeUserData(r, N), C.length > 0 && (N.targets = C), r.index !== null) {
        let G = this.getUID(r.index);
        (f[y].start !== void 0 || f[y].count !== void 0) && (G += ":" + f[y].start + ":" + f[y].count), e.attributes.has(G) ? N.indices = e.attributes.get(G) : (N.indices = this.processAccessor(r.index, r, f[y].start, f[y].count), e.attributes.set(G, N.indices)), N.indices === null && delete N.indices;
      }
      const F = this.processMaterial(D[f[y].materialIndex]);
      F !== null && (N.material = F), E.push(N);
    }
    B.primitives = E, t.meshes || (t.meshes = []), this._invokeAll(function(y) {
      y.writeMesh && y.writeMesh(A, B);
    });
    const S = t.meshes.push(B) - 1;
    return e.meshes.set(n, S), S;
  }
  /**
   * If a vertex attribute with a
   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)
   * is used, it is checked whether it is a valid data type according to the
   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
   * extension.
   * In this case the extension is automatically added to the list of used extensions.
   *
   * @param {string} attributeName
   * @param {THREE.BufferAttribute} attribute
   */
  detectMeshQuantization(A, e) {
    if (this.extensionsUsed[ow])
      return;
    let t;
    switch (e.array.constructor) {
      case Int8Array:
        t = "byte";
        break;
      case Uint8Array:
        t = "unsigned byte";
        break;
      case Int16Array:
        t = "short";
        break;
      case Uint16Array:
        t = "unsigned short";
        break;
      default:
        return;
    }
    e.normalized && (t += " normalized");
    const i = A.split("_", 1)[0];
    CG[i] && CG[i].includes(t) && (this.extensionsUsed[ow] = !0, this.extensionsRequired[ow] = !0);
  }
  /**
   * Process camera
   * @param  {THREE.Camera} camera Camera to process
   * @return {Integer}      Index of the processed mesh in the "camera" array
   */
  processCamera(A) {
    const e = this.json;
    e.cameras || (e.cameras = []);
    const t = A.isOrthographicCamera, i = {
      type: t ? "orthographic" : "perspective"
    };
    return t ? i.orthographic = {
      xmag: A.right * 2,
      ymag: A.top * 2,
      zfar: A.far <= 0 ? 1e-3 : A.far,
      znear: A.near < 0 ? 0 : A.near
    } : i.perspective = {
      aspectRatio: A.aspect,
      yfov: bg.degToRad(A.fov),
      zfar: A.far <= 0 ? 1e-3 : A.far,
      znear: A.near < 0 ? 0 : A.near
    }, A.name !== "" && (i.name = A.type), e.cameras.push(i) - 1;
  }
  /**
   * Creates glTF animation entry from AnimationClip object.
   *
   * Status:
   * - Only properties listed in PATH_PROPERTIES may be animated.
   *
   * @param {THREE.AnimationClip} clip
   * @param {THREE.Object3D} root
   * @return {number|null}
   */
  processAnimation(A, e) {
    const t = this.json, i = this.nodeMap;
    t.animations || (t.animations = []), A = pm.Utils.mergeMorphTargetTracks(A.clone(), e);
    const n = A.tracks, r = [], s = [];
    for (let B = 0; B < n.length; ++B) {
      const I = n[B], E = xt.parseTrackName(I.name);
      let C = xt.findNode(e, E.nodeName);
      const c = QG[E.propertyName];
      if (E.objectName === "bones" && (C.isSkinnedMesh === !0 ? C = C.skeleton.getBoneByName(E.objectIndex) : C = void 0), !C || !c)
        return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', I.name), null;
      const u = 1;
      let d = I.values.length / I.times.length;
      c === QG.morphTargetInfluences && (d /= C.morphTargetInfluences.length);
      let p;
      I.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === !0 ? (p = "CUBICSPLINE", d /= 3) : I.getInterpolation() === TC ? p = "STEP" : p = "LINEAR", s.push({
        input: this.processAccessor(new Pt(I.times, u)),
        output: this.processAccessor(new Pt(I.values, d)),
        interpolation: p
      }), r.push({
        sampler: s.length - 1,
        target: {
          node: i.get(C),
          path: c
        }
      });
    }
    return t.animations.push({
      name: A.name || "clip_" + t.animations.length,
      samplers: s,
      channels: r
    }), t.animations.length - 1;
  }
  /**
   * @param {THREE.Object3D} object
   * @return {number|null}
   */
  processSkin(A) {
    const e = this.json, t = this.nodeMap, i = e.nodes[t.get(A)], n = A.skeleton;
    if (n === void 0)
      return null;
    const r = A.skeleton.bones[0];
    if (r === void 0)
      return null;
    const s = [], B = new Float32Array(n.bones.length * 16), I = new Ve();
    for (let C = 0; C < n.bones.length; ++C)
      s.push(t.get(n.bones[C])), I.copy(n.boneInverses[C]), I.multiply(A.bindMatrix).toArray(B, C * 16);
    return e.skins === void 0 && (e.skins = []), e.skins.push({
      inverseBindMatrices: this.processAccessor(new Pt(B, 16)),
      joints: s,
      skeleton: t.get(r)
    }), i.skin = e.skins.length - 1;
  }
  /**
   * Process Object3D node
   * @param  {THREE.Object3D} node Object3D to processNode
   * @return {Integer} Index of the node in the nodes list
   */
  processNode(A) {
    const e = this.json, t = this.options, i = this.nodeMap;
    e.nodes || (e.nodes = []);
    const n = {};
    if (t.trs) {
      const s = A.quaternion.toArray(), B = A.position.toArray(), I = A.scale.toArray();
      mc(s, [0, 0, 0, 1]) || (n.rotation = s), mc(B, [0, 0, 0]) || (n.translation = B), mc(I, [1, 1, 1]) || (n.scale = I);
    } else
      A.matrixAutoUpdate && A.updateMatrix(), OW(A.matrix) === !1 && (n.matrix = A.matrix.elements);
    if (A.name !== "" && (n.name = String(A.name)), this.serializeUserData(A, n), A.isMesh || A.isLine || A.isPoints) {
      const s = this.processMesh(A);
      s !== null && (n.mesh = s);
    } else
      A.isCamera && (n.camera = this.processCamera(A));
    if (A.isSkinnedMesh && this.skins.push(A), A.children.length > 0) {
      const s = [];
      for (let B = 0, I = A.children.length; B < I; B++) {
        const E = A.children[B];
        if (E.visible || t.onlyVisible === !1) {
          const C = this.processNode(E);
          C !== null && s.push(C);
        }
      }
      s.length > 0 && (n.children = s);
    }
    this._invokeAll(function(s) {
      s.writeNode && s.writeNode(A, n);
    });
    const r = e.nodes.push(n) - 1;
    return i.set(A, r), r;
  }
  /**
   * Process Scene
   * @param  {Scene} node Scene to process
   */
  processScene(A) {
    const e = this.json, t = this.options;
    e.scenes || (e.scenes = [], e.scene = 0);
    const i = {};
    A.name !== "" && (i.name = A.name), e.scenes.push(i);
    const n = [];
    for (let r = 0, s = A.children.length; r < s; r++) {
      const B = A.children[r];
      if (B.visible || t.onlyVisible === !1) {
        const I = this.processNode(B);
        I !== null && n.push(I);
      }
    }
    n.length > 0 && (i.nodes = n), this.serializeUserData(A, i);
  }
  /**
   * Creates a Scene to hold a list of objects and parse it
   * @param  {Array} objects List of objects to process
   */
  processObjects(A) {
    const e = new UE();
    e.name = "AuxScene";
    for (let t = 0; t < A.length; t++)
      e.children.push(A[t]);
    this.processScene(e);
  }
  /**
   * @param {THREE.Object3D|Array<THREE.Object3D>} input
   */
  processInput(A) {
    const e = this.options;
    A = A instanceof Array ? A : [A], this._invokeAll(function(i) {
      i.beforeParse && i.beforeParse(A);
    });
    const t = [];
    for (let i = 0; i < A.length; i++)
      A[i] instanceof UE ? this.processScene(A[i]) : t.push(A[i]);
    t.length > 0 && this.processObjects(t);
    for (let i = 0; i < this.skins.length; ++i)
      this.processSkin(this.skins[i]);
    for (let i = 0; i < e.animations.length; ++i)
      this.processAnimation(e.animations[i], A[0]);
    this._invokeAll(function(i) {
      i.afterParse && i.afterParse(A);
    });
  }
  _invokeAll(A) {
    for (let e = 0, t = this.plugins.length; e < t; e++)
      A(this.plugins[e]);
  }
}
class WW {
  constructor(A) {
    this.writer = A, this.name = "KHR_lights_punctual";
  }
  writeNode(A, e) {
    if (!A.isLight)
      return;
    if (!A.isDirectionalLight && !A.isPointLight && !A.isSpotLight) {
      console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", A);
      return;
    }
    const t = this.writer, i = t.json, n = t.extensionsUsed, r = {};
    A.name && (r.name = A.name), r.color = A.color.toArray(), r.intensity = A.intensity, A.isDirectionalLight ? r.type = "directional" : A.isPointLight ? (r.type = "point", A.distance > 0 && (r.range = A.distance)) : A.isSpotLight && (r.type = "spot", A.distance > 0 && (r.range = A.distance), r.spot = {}, r.spot.innerConeAngle = (A.penumbra - 1) * A.angle * -1, r.spot.outerConeAngle = A.angle), A.decay !== void 0 && A.decay !== 2 && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), A.target && (A.target.parent !== A || A.target.position.x !== 0 || A.target.position.y !== 0 || A.target.position.z !== -1) && console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), n[this.name] || (i.extensions = i.extensions || {}, i.extensions[this.name] = { lights: [] }, n[this.name] = !0);
    const s = i.extensions[this.name].lights;
    s.push(r), e.extensions = e.extensions || {}, e.extensions[this.name] = { light: s.length - 1 };
  }
}
class zW {
  constructor(A) {
    this.writer = A, this.name = "KHR_materials_unlit";
  }
  writeMaterial(A, e) {
    if (!A.isMeshBasicMaterial)
      return;
    const i = this.writer.extensionsUsed;
    e.extensions = e.extensions || {}, e.extensions[this.name] = {}, i[this.name] = !0, e.pbrMetallicRoughness.metallicFactor = 0, e.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
}
class VW {
  constructor(A) {
    this.writer = A, this.name = "KHR_materials_clearcoat";
  }
  writeMaterial(A, e) {
    if (!A.isMeshPhysicalMaterial || A.clearcoat === 0)
      return;
    const t = this.writer, i = t.extensionsUsed, n = {};
    if (n.clearcoatFactor = A.clearcoat, A.clearcoatMap) {
      const r = { index: t.processTexture(A.clearcoatMap) };
      t.applyTextureTransform(r, A.clearcoatMap), n.clearcoatTexture = r;
    }
    if (n.clearcoatRoughnessFactor = A.clearcoatRoughness, A.clearcoatRoughnessMap) {
      const r = { index: t.processTexture(A.clearcoatRoughnessMap) };
      t.applyTextureTransform(r, A.clearcoatRoughnessMap), n.clearcoatRoughnessTexture = r;
    }
    if (A.clearcoatNormalMap) {
      const r = { index: t.processTexture(A.clearcoatNormalMap) };
      t.applyTextureTransform(r, A.clearcoatNormalMap), n.clearcoatNormalTexture = r;
    }
    e.extensions = e.extensions || {}, e.extensions[this.name] = n, i[this.name] = !0;
  }
}
class jW {
  constructor(A) {
    this.writer = A, this.name = "KHR_materials_iridescence";
  }
  writeMaterial(A, e) {
    if (!A.isMeshPhysicalMaterial || A.iridescence === 0)
      return;
    const t = this.writer, i = t.extensionsUsed, n = {};
    if (n.iridescenceFactor = A.iridescence, A.iridescenceMap) {
      const r = { index: t.processTexture(A.iridescenceMap) };
      t.applyTextureTransform(r, A.iridescenceMap), n.iridescenceTexture = r;
    }
    if (n.iridescenceIor = A.iridescenceIOR, n.iridescenceThicknessMinimum = A.iridescenceThicknessRange[0], n.iridescenceThicknessMaximum = A.iridescenceThicknessRange[1], A.iridescenceThicknessMap) {
      const r = { index: t.processTexture(A.iridescenceThicknessMap) };
      t.applyTextureTransform(r, A.iridescenceThicknessMap), n.iridescenceThicknessTexture = r;
    }
    e.extensions = e.extensions || {}, e.extensions[this.name] = n, i[this.name] = !0;
  }
}
class ZW {
  constructor(A) {
    this.writer = A, this.name = "KHR_materials_transmission";
  }
  writeMaterial(A, e) {
    if (!A.isMeshPhysicalMaterial || A.transmission === 0)
      return;
    const t = this.writer, i = t.extensionsUsed, n = {};
    if (n.transmissionFactor = A.transmission, A.transmissionMap) {
      const r = { index: t.processTexture(A.transmissionMap) };
      t.applyTextureTransform(r, A.transmissionMap), n.transmissionTexture = r;
    }
    e.extensions = e.extensions || {}, e.extensions[this.name] = n, i[this.name] = !0;
  }
}
class XW {
  constructor(A) {
    this.writer = A, this.name = "KHR_materials_volume";
  }
  writeMaterial(A, e) {
    if (!A.isMeshPhysicalMaterial || A.transmission === 0)
      return;
    const t = this.writer, i = t.extensionsUsed, n = {};
    if (n.thicknessFactor = A.thickness, A.thicknessMap) {
      const r = { index: t.processTexture(A.thicknessMap) };
      t.applyTextureTransform(r, A.thicknessMap), n.thicknessTexture = r;
    }
    n.attenuationDistance = A.attenuationDistance, n.attenuationColor = A.attenuationColor.toArray(), e.extensions = e.extensions || {}, e.extensions[this.name] = n, i[this.name] = !0;
  }
}
class $W {
  constructor(A) {
    this.writer = A, this.name = "KHR_materials_ior";
  }
  writeMaterial(A, e) {
    if (!A.isMeshPhysicalMaterial || A.ior === 1.5)
      return;
    const i = this.writer.extensionsUsed, n = {};
    n.ior = A.ior, e.extensions = e.extensions || {}, e.extensions[this.name] = n, i[this.name] = !0;
  }
}
class Az {
  constructor(A) {
    this.writer = A, this.name = "KHR_materials_specular";
  }
  writeMaterial(A, e) {
    if (!A.isMeshPhysicalMaterial || A.specularIntensity === 1 && A.specularColor.equals(KW) && !A.specularIntensityMap && !A.specularColorTexture)
      return;
    const t = this.writer, i = t.extensionsUsed, n = {};
    if (A.specularIntensityMap) {
      const r = { index: t.processTexture(A.specularIntensityMap) };
      t.applyTextureTransform(r, A.specularIntensityMap), n.specularTexture = r;
    }
    if (A.specularColorMap) {
      const r = { index: t.processTexture(A.specularColorMap) };
      t.applyTextureTransform(r, A.specularColorMap), n.specularColorTexture = r;
    }
    n.specularFactor = A.specularIntensity, n.specularColorFactor = A.specularColor.toArray(), e.extensions = e.extensions || {}, e.extensions[this.name] = n, i[this.name] = !0;
  }
}
class ez {
  constructor(A) {
    this.writer = A, this.name = "KHR_materials_sheen";
  }
  writeMaterial(A, e) {
    if (!A.isMeshPhysicalMaterial || A.sheen == 0)
      return;
    const t = this.writer, i = t.extensionsUsed, n = {};
    if (A.sheenRoughnessMap) {
      const r = { index: t.processTexture(A.sheenRoughnessMap) };
      t.applyTextureTransform(r, A.sheenRoughnessMap), n.sheenRoughnessTexture = r;
    }
    if (A.sheenColorMap) {
      const r = { index: t.processTexture(A.sheenColorMap) };
      t.applyTextureTransform(r, A.sheenColorMap), n.sheenColorTexture = r;
    }
    n.sheenRoughnessFactor = A.sheenRoughness, n.sheenColorFactor = A.sheenColor.toArray(), e.extensions = e.extensions || {}, e.extensions[this.name] = n, i[this.name] = !0;
  }
}
class tz {
  constructor(A) {
    this.writer = A, this.name = "KHR_materials_emissive_strength";
  }
  writeMaterial(A, e) {
    if (!A.isMeshStandardMaterial || A.emissiveIntensity === 1)
      return;
    const i = this.writer.extensionsUsed, n = {};
    n.emissiveStrength = A.emissiveIntensity, e.extensions = e.extensions || {}, e.extensions[this.name] = n, i[this.name] = !0;
  }
}
pm.Utils = {
  insertKeyframe: function(g, A) {
    const t = g.getValueSize(), i = new g.TimeBufferType(g.times.length + 1), n = new g.ValueBufferType(g.values.length + t), r = g.createInterpolant(new g.ValueBufferType(t));
    let s;
    if (g.times.length === 0) {
      i[0] = A;
      for (let B = 0; B < t; B++)
        n[B] = 0;
      s = 0;
    } else if (A < g.times[0]) {
      if (Math.abs(g.times[0] - A) < 1e-3)
        return 0;
      i[0] = A, i.set(g.times, 1), n.set(r.evaluate(A), 0), n.set(g.values, t), s = 0;
    } else if (A > g.times[g.times.length - 1]) {
      if (Math.abs(g.times[g.times.length - 1] - A) < 1e-3)
        return g.times.length - 1;
      i[i.length - 1] = A, i.set(g.times, 0), n.set(g.values, 0), n.set(r.evaluate(A), g.values.length), s = i.length - 1;
    } else
      for (let B = 0; B < g.times.length; B++) {
        if (Math.abs(g.times[B] - A) < 1e-3)
          return B;
        if (g.times[B] < A && g.times[B + 1] > A) {
          i.set(g.times.slice(0, B + 1), 0), i[B + 1] = A, i.set(g.times.slice(B + 1), B + 2), n.set(g.values.slice(0, (B + 1) * t), 0), n.set(r.evaluate(A), (B + 1) * t), n.set(g.values.slice((B + 1) * t), (B + 2) * t), s = B + 1;
          break;
        }
      }
    return g.times = i, g.values = n, s;
  },
  mergeMorphTargetTracks: function(g, A) {
    const e = [], t = {}, i = g.tracks;
    for (let n = 0; n < i.length; ++n) {
      let r = i[n];
      const s = xt.parseTrackName(r.name), B = xt.findNode(A, s.nodeName);
      if (s.propertyName !== "morphTargetInfluences" || s.propertyIndex === void 0) {
        e.push(r);
        continue;
      }
      if (r.createInterpolant !== r.InterpolantFactoryMethodDiscrete && r.createInterpolant !== r.InterpolantFactoryMethodLinear) {
        if (r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), r = r.clone(), r.setInterpolation(uB);
      }
      const I = B.morphTargetInfluences.length, E = B.morphTargetDictionary[s.propertyIndex];
      if (E === void 0)
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + s.propertyIndex);
      let C;
      if (t[B.uuid] === void 0) {
        C = r.clone();
        const u = new C.ValueBufferType(I * C.times.length);
        for (let d = 0; d < C.times.length; d++)
          u[d * I + E] = C.values[d];
        C.name = (s.nodeName || "") + ".morphTargetInfluences", C.values = u, t[B.uuid] = C, e.push(C);
        continue;
      }
      const c = r.createInterpolant(new r.ValueBufferType(1));
      C = t[B.uuid];
      for (let u = 0; u < C.times.length; u++)
        C.values[u * I + E] = c.evaluate(C.times[u]);
      for (let u = 0; u < r.times.length; u++) {
        const d = this.insertKeyframe(C, r.times[u]);
        C.values[d * I + E] = r.values[u];
      }
    }
    return g.tracks = e, g;
  }
};
const iz = (g, A) => {
  g.traverse((e) => {
    e.userData.hideOnExport && (e.visible = A);
  });
}, nz = (g) => {
  const A = g.clone().getObjectByName("MODEL_GROUP");
  return new Promise((e, t) => {
    new pm().parse(
      A,
      (n) => {
        if (n instanceof ArrayBuffer)
          e(new Blob([n]));
        else {
          n.materials = n.materials.map((s) => (s?.pbrMetallicRoughness?.baseColorTexture?.extensions && delete s.pbrMetallicRoughness.baseColorTexture.extensions, s));
          const r = JSON.stringify(n, null, 2);
          e(new Blob([r]));
        }
      },
      t
    );
  });
}, gz = (g) => {
  const A = g.camera.zoom, e = new IA();
  return g.getPosition(e), g.zoomTo(1), new Promise((t, i) => {
    setTimeout(() => {
      of.beginGIFRecord({
        name: "model animation",
        quality: 0.2,
        fps: 24,
        onExport: (n) => {
          t(n), g.zoomTo(A || 1, !0), g.setPosition(
            e.x,
            e.y,
            e.z
          );
        },
        onError(n) {
          i(n);
        }
      });
    }, 100);
  });
}, rz = (g, A, e) => {
  const t = function() {
    let i = 0, n = 0;
    return document?.querySelector("canvas") ? (i = Number(document?.querySelector("canvas")?.clientWidth), n = Number(document?.querySelector("canvas")?.clientHeight)) : (i = window.innerWidth, n = window.innerHeight), {
      width: i,
      height: n
    };
  };
  if (g.background) {
    const i = t(), n = A / e / (i.width / i.height), r = g.background;
    r.offset.x = n > 1 ? (1 - 1 / n) / 2 : 0, r.offset.y = n > 1 ? 0 : (1 - n) / 2, r.repeat.x = n > 1 ? 1 / n : 1, r.repeat.y = n > 1 ? 1 : n;
  }
};
class oz {
  constructor() {
    this.textureMap = {}, this.loader = new Tf();
  }
  async _loadTexture(A) {
    return new Promise((e, t) => {
      this.loader.load(
        A,
        (i) => {
          e(i);
        },
        () => {
        },
        (i) => t(i)
      );
    });
  }
  // loads texture alongside both width and height
  async loadTexture(A) {
    if (!(A in this.textureMap)) {
      const e = new Promise((t, i) => {
        const n = new Image();
        n.onload = async () => {
          try {
            const r = await this._loadTexture(A);
            r.encoding = Ht, t({ texture: r, width: n.width, height: n.height });
          } catch (r) {
            i(r);
          }
        }, n.onerror = i, n.src = A;
      });
      this.textureMap[A] = await e;
    }
    return this.textureMap[A];
  }
}
const sz = new oz(), az = /* @__PURE__ */ fe(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    className: "ms-w-4 ms-h-4",
    children: /* @__PURE__ */ fe(
      "path",
      {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M6.429 9.75L2.25 12l4.179 2.25m0-4.5l5.571 3 5.571-3m-11.142 0L2.25 7.5 12 2.25l9.75 5.25-4.179 2.25m0 0L21.75 12l-4.179 2.25m0 0l4.179 2.25L12 21.75 2.25 16.5l4.179-2.25m11.142 0l-5.571 3-5.571-3"
      }
    )
  }
), Iz = /* @__PURE__ */ fe(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    className: "ms-w-4 ms-h-4",
    children: /* @__PURE__ */ fe(
      "path",
      {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15"
      }
    )
  }
), Bz = /* @__PURE__ */ fe(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    className: "ms-w-4 ms-h-4",
    children: /* @__PURE__ */ fe(
      "path",
      {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99"
      }
    )
  }
), Cz = /* @__PURE__ */ fe(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    className: "ms-w-4 ms-h-4",
    children: /* @__PURE__ */ fe(
      "path",
      {
        fillRule: "evenodd",
        d: "M1 5.25A2.25 2.25 0 013.25 3h13.5A2.25 2.25 0 0119 5.25v9.5A2.25 2.25 0 0116.75 17H3.25A2.25 2.25 0 011 14.75v-9.5zm1.5 5.81v3.69c0 .414.336.75.75.75h13.5a.75.75 0 00.75-.75v-2.69l-2.22-2.219a.75.75 0 00-1.06 0l-1.91 1.909.47.47a.75.75 0 11-1.06 1.06L6.53 8.091a.75.75 0 00-1.06 0l-2.97 2.97zM12 7a1 1 0 11-2 0 1 1 0 012 0z",
        clipRule: "evenodd"
      }
    )
  }
), Qz = () => {
  const { sceneRef: g } = Vc(), {
    rotation: A,
    setRotation: e,
    backgrounds: t,
    scale: i,
    setScale: n,
    currentBackground: r,
    setCurrentBackground: s
  } = dB(), B = async (I) => {
    const E = await sz.loadTexture(I.url);
    g.current.background = E.texture, rz(g.current, E.width, E.height), s(I.id);
  };
  return /* @__PURE__ */ Wi("div", { className: "ms-hidden lg:ms-block ms-pb-10 ms-h-full ms-max-h-full", children: [
    /* @__PURE__ */ fe("h4", { className: "ms-mx-2 ms-mb-4 ms-font-semibold", children: "Customize" }),
    /* @__PURE__ */ fe(
      Kd,
      {
        title: "Layer",
        icon: az,
        expanded: !0,
        className: "ms-max-h-[50%] ms-overflow-y-auto no__scrollbar",
        children: /* @__PURE__ */ fe(TW, {})
      }
    ),
    /* @__PURE__ */ fe(Kd, { title: "Size", icon: Iz, children: /* @__PURE__ */ fe(
      sy,
      {
        min: 0.1,
        max: 1.3,
        step: 1e-4,
        value: i,
        onChange: (I) => n(+I.target.value)
      }
    ) }),
    /* @__PURE__ */ fe(Kd, { title: "Rotate", icon: Bz, children: /* @__PURE__ */ fe(
      sy,
      {
        min: -50,
        max: 50,
        value: A,
        onChange: (I) => e(Number.parseFloat(I.target.value))
      }
    ) }),
    /* @__PURE__ */ fe(Kd, { title: "Background", icon: Cz, children: /* @__PURE__ */ fe("div", { className: "ms-flex ms-flex-wrap", children: t?.map((I) => /* @__PURE__ */ fe(
      "img",
      {
        src: I.url,
        className: `ms-w-10 ms-h-10 ms-mt-2 ms-mr-2 ms-rounded-lg ms-cursor-pointer ${I.id === r ? "ms-border ms-border-dashed ms-border-black" : "hover:ms-scale-105"}`,
        alt: "Sticker",
        onClick: () => B(I)
      },
      I.id
    )) }) })
  ] });
}, Ez = zc(
  (g, A) => (qE((e, t) => {
    A !== null && typeof A != "function" && A?.current?.update(t);
  }), /* @__PURE__ */ fe(
    lq,
    {
      enabled: !1,
      ref: A,
      minZoom: UW,
      maxZoom: vW
    }
  ))
);
var lz = (() => {
  var g = import.meta.url;
  return function(e) {
    e = e || {};
    var e = typeof e < "u" ? e : {}, t, i;
    e.ready = new Promise(function(T, b) {
      t = T, i = b;
    }), ["_main", "___getTypeName", "__embind_initialize_bindings", "_fflush", "onRuntimeInitialized"].forEach((T) => {
      Object.getOwnPropertyDescriptor(e.ready, T) || Object.defineProperty(e.ready, T, { get: () => SA("You are getting " + T + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"), set: () => SA("You are setting " + T + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js") });
    });
    var n = Object.assign({}, e), r = "./this.program", s = typeof window == "object", B = typeof importScripts == "function", I = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", E = !s && !I && !B;
    if (e.ENVIRONMENT)
      throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)");
    var C = "";
    function c(T) {
      return e.locateFile ? e.locateFile(T, C) : C + T;
    }
    var u, d, p;
    if (I) {
      if (typeof process > "u" || !process.release || process.release.name !== "node")
        throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
      B ? C = require("path").dirname(C) + "/" : C = __dirname + "/";
      var D, f;
      typeof require == "function" && (D = require("fs"), f = require("path")), u = (T, b) => {
        var X = Ti(T);
        return X ? b ? X : X.toString() : (T = f.normalize(T), D.readFileSync(T, b ? void 0 : "utf8"));
      }, p = (T) => {
        var b = u(T, !0);
        return b.buffer || (b = new Uint8Array(b)), _(b.buffer), b;
      }, d = (T, b, X) => {
        var CA = Ti(T);
        CA && b(CA), T = f.normalize(T), D.readFile(T, function(NA, KA) {
          NA ? X(NA) : b(KA.buffer);
        });
      }, process.argv.length > 1 && (r = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", function(T) {
        if (!(T instanceof RA))
          throw T;
      }), process.on("unhandledRejection", function(T) {
        throw T;
      }), e.inspect = function() {
        return "[Emscripten Module object]";
      };
    } else if (E) {
      if (typeof process == "object" && typeof require == "function" || typeof window == "object" || typeof importScripts == "function")
        throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
      typeof read < "u" && (u = function(b) {
        const X = Ti(b);
        return X ? TA(X) : read(b);
      }), p = function(b) {
        let X;
        return X = Ti(b), X || (typeof readbuffer == "function" ? new Uint8Array(readbuffer(b)) : (X = read(b, "binary"), _(typeof X == "object"), X));
      }, d = function(b, X, CA) {
        setTimeout(() => X(p(b)), 0);
      }, typeof scriptArgs < "u" && scriptArgs, typeof print < "u" && (typeof console > "u" && (console = {}), console.log = print, console.warn = console.error = typeof printErr < "u" ? printErr : print);
    } else if (s || B) {
      if (B ? C = self.location.href : typeof document < "u" && document.currentScript && (C = document.currentScript.src), g && (C = g), C.indexOf("blob:") !== 0 ? C = C.substr(0, C.replace(/[?#].*/, "").lastIndexOf("/") + 1) : C = "", !(typeof window == "object" || typeof importScripts == "function"))
        throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
      u = (T) => {
        try {
          var b = new XMLHttpRequest();
          return b.open("GET", T, !1), b.send(null), b.responseText;
        } catch (CA) {
          var X = Ti(T);
          if (X)
            return TA(X);
          throw CA;
        }
      }, B && (p = (T) => {
        try {
          var b = new XMLHttpRequest();
          return b.open("GET", T, !1), b.responseType = "arraybuffer", b.send(null), new Uint8Array(b.response);
        } catch (CA) {
          var X = Ti(T);
          if (X)
            return X;
          throw CA;
        }
      }), d = (T, b, X) => {
        var CA = new XMLHttpRequest();
        CA.open("GET", T, !0), CA.responseType = "arraybuffer", CA.onload = () => {
          if (CA.status == 200 || CA.status == 0 && CA.response) {
            b(CA.response);
            return;
          }
          var NA = Ti(T);
          if (NA) {
            b(NA.buffer);
            return;
          }
          X();
        }, CA.onerror = X, CA.send(null);
      };
    } else
      throw new Error("environment detection error");
    var S = e.print || console.log.bind(console), y = e.printErr || console.warn.bind(console);
    Object.assign(e, n), n = null, la(), e.arguments && e.arguments, m("arguments", "arguments_"), e.thisProgram && (r = e.thisProgram), m("thisProgram", "thisProgram"), e.quit && e.quit, m("quit", "quit_"), _(typeof e.memoryInitializerPrefixURL > "u", "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead"), _(typeof e.pthreadMainPrefixURL > "u", "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead"), _(typeof e.cdInitializerPrefixURL > "u", "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead"), _(typeof e.filePackagePrefixURL > "u", "Module.filePackagePrefixURL option was removed, use Module.locateFile instead"), _(typeof e.read > "u", "Module.read option was removed (modify read_ in JS)"), _(typeof e.readAsync > "u", "Module.readAsync option was removed (modify readAsync in JS)"), _(typeof e.readBinary > "u", "Module.readBinary option was removed (modify readBinary in JS)"), _(typeof e.setWindowTitle > "u", "Module.setWindowTitle option was removed (modify setWindowTitle in JS)"), _(typeof e.TOTAL_MEMORY > "u", "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY"), m("read", "read_"), m("readAsync", "readAsync"), m("readBinary", "readBinary"), m("setWindowTitle", "setWindowTitle"), _(!E, "shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.");
    function m(T, b) {
      Object.getOwnPropertyDescriptor(e, T) || Object.defineProperty(e, T, { configurable: !0, get: function() {
        SA("Module." + T + " has been replaced with plain " + b + " (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)");
      } });
    }
    function N(T) {
      Object.getOwnPropertyDescriptor(e, T) && SA("`Module." + T + "` was supplied but `" + T + "` not included in INCOMING_MODULE_JS_API");
    }
    function F(T) {
      return T === "FS_createPath" || T === "FS_createDataFile" || T === "FS_createPreloadedFile" || T === "FS_unlink" || T === "addRunDependency" || T === "FS_createLazyFile" || T === "FS_createDevice" || T === "removeRunDependency";
    }
    function G(T) {
      typeof globalThis < "u" && !Object.getOwnPropertyDescriptor(globalThis, T) && Object.defineProperty(globalThis, T, { configurable: !0, get: function() {
        var b = "`" + T + "` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line", X = T;
        X.startsWith("_") || (X = "$" + T), b += " (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE=" + X + ")", F(T) && (b += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you"), ge(b);
      } });
    }
    function k(T) {
      Object.getOwnPropertyDescriptor(e, T) || Object.defineProperty(e, T, { configurable: !0, get: function() {
        var b = "'" + T + "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)";
        F(T) && (b += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you"), SA(b);
      } });
    }
    var v;
    e.wasmBinary && (v = e.wasmBinary), m("wasmBinary", "wasmBinary"), e.noExitRuntime, m("noExitRuntime", "noExitRuntime"), typeof WebAssembly != "object" && SA("no native wasm support detected");
    var x, H = !1;
    function _(T, b) {
      T || SA("Assertion failed" + (b ? ": " + b : ""));
    }
    var j = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
    function V(T, b, X) {
      for (var CA = b + X, NA = b; T[NA] && !(NA >= CA); )
        ++NA;
      if (NA - b > 16 && T.buffer && j)
        return j.decode(T.subarray(b, NA));
      for (var KA = ""; b < NA; ) {
        var WA = T[b++];
        if (!(WA & 128)) {
          KA += String.fromCharCode(WA);
          continue;
        }
        var OA = T[b++] & 63;
        if ((WA & 224) == 192) {
          KA += String.fromCharCode((WA & 31) << 6 | OA);
          continue;
        }
        var zA = T[b++] & 63;
        if ((WA & 240) == 224 ? WA = (WA & 15) << 12 | OA << 6 | zA : ((WA & 248) != 240 && ge("Invalid UTF-8 leading byte 0x" + WA.toString(16) + " encountered when deserializing a UTF-8 string in wasm memory to a JS string!"), WA = (WA & 7) << 18 | OA << 12 | zA << 6 | T[b++] & 63), WA < 65536)
          KA += String.fromCharCode(WA);
        else {
          var Ce = WA - 65536;
          KA += String.fromCharCode(55296 | Ce >> 10, 56320 | Ce & 1023);
        }
      }
      return KA;
    }
    function iA(T, b) {
      return T ? V(Y, T, b) : "";
    }
    function eA(T, b, X, CA) {
      if (!(CA > 0))
        return 0;
      for (var NA = X, KA = X + CA - 1, WA = 0; WA < T.length; ++WA) {
        var OA = T.charCodeAt(WA);
        if (OA >= 55296 && OA <= 57343) {
          var zA = T.charCodeAt(++WA);
          OA = 65536 + ((OA & 1023) << 10) | zA & 1023;
        }
        if (OA <= 127) {
          if (X >= KA)
            break;
          b[X++] = OA;
        } else if (OA <= 2047) {
          if (X + 1 >= KA)
            break;
          b[X++] = 192 | OA >> 6, b[X++] = 128 | OA & 63;
        } else if (OA <= 65535) {
          if (X + 2 >= KA)
            break;
          b[X++] = 224 | OA >> 12, b[X++] = 128 | OA >> 6 & 63, b[X++] = 128 | OA & 63;
        } else {
          if (X + 3 >= KA)
            break;
          OA > 1114111 && ge("Invalid Unicode code point 0x" + OA.toString(16) + " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF)."), b[X++] = 240 | OA >> 18, b[X++] = 128 | OA >> 12 & 63, b[X++] = 128 | OA >> 6 & 63, b[X++] = 128 | OA & 63;
        }
      }
      return b[X] = 0, X - NA;
    }
    function oA(T, b, X) {
      return _(typeof X == "number", "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!"), eA(T, Y, b, X);
    }
    function P(T) {
      for (var b = 0, X = 0; X < T.length; ++X) {
        var CA = T.charCodeAt(X);
        CA <= 127 ? b++ : CA <= 2047 ? b += 2 : CA >= 55296 && CA <= 57343 ? (b += 4, ++X) : b += 3;
      }
      return b;
    }
    var J, tA, Y, rA, QA, aA, MA, hA, fA;
    function wA(T) {
      J = T, e.HEAP8 = tA = new Int8Array(T), e.HEAP16 = rA = new Int16Array(T), e.HEAP32 = aA = new Int32Array(T), e.HEAPU8 = Y = new Uint8Array(T), e.HEAPU16 = QA = new Uint16Array(T), e.HEAPU32 = MA = new Uint32Array(T), e.HEAPF32 = hA = new Float32Array(T), e.HEAPF64 = fA = new Float64Array(T);
    }
    var yA = 5242880;
    e.STACK_SIZE && _(yA === e.STACK_SIZE, "the stack size can no longer be determined at runtime");
    var kA = e.INITIAL_MEMORY || 16777216;
    m("INITIAL_MEMORY", "INITIAL_MEMORY"), _(kA >= yA, "INITIAL_MEMORY should be larger than STACK_SIZE, was " + kA + "! (STACK_SIZE=" + yA + ")"), _(typeof Int32Array < "u" && typeof Float64Array < "u" && Int32Array.prototype.subarray != null && Int32Array.prototype.set != null, "JS engine does not provide full typed array support"), _(!e.wasmMemory, "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally"), _(kA == 16777216, "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically");
    var FA;
    function dA() {
      var T = br();
      _((T & 3) == 0), MA[T >> 2] = 34821223, MA[T + 4 >> 2] = 2310721022, MA[0] = 1668509029;
    }
    function vA() {
      if (!H) {
        var T = br(), b = MA[T >> 2], X = MA[T + 4 >> 2];
        (b != 34821223 || X != 2310721022) && SA("Stack overflow! Stack cookie has been overwritten at 0x" + T.toString(16) + ", expected hex dwords 0x89BACDFE and 0x2135467, but received 0x" + X.toString(16) + " 0x" + b.toString(16)), MA[0] !== 1668509029 && SA("Runtime error: The application has corrupted its heap memory area (address zero)!");
      }
    }
    (function() {
      var T = new Int16Array(1), b = new Int8Array(T.buffer);
      if (T[0] = 25459, b[0] !== 115 || b[1] !== 99)
        throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";
    })();
    var JA = [], ne = [], ee = [], pe = !1;
    function Ae() {
      if (e.preRun)
        for (typeof e.preRun == "function" && (e.preRun = [e.preRun]); e.preRun.length; )
          O(e.preRun.shift());
      UA(JA);
    }
    function ie() {
      _(!pe), pe = !0, vA(), UA(ne);
    }
    function de() {
      if (vA(), e.postRun)
        for (typeof e.postRun == "function" && (e.postRun = [e.postRun]); e.postRun.length; )
          q(e.postRun.shift());
      UA(ee);
    }
    function O(T) {
      JA.unshift(T);
    }
    function AA(T) {
      ne.unshift(T);
    }
    function q(T) {
      ee.unshift(T);
    }
    _(Math.imul, "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"), _(Math.fround, "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"), _(Math.clz32, "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"), _(Math.trunc, "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
    var Z = 0, $ = null, BA = null, GA = {};
    function bA(T) {
      Z++, e.monitorRunDependencies && e.monitorRunDependencies(Z), T ? (_(!GA[T]), GA[T] = 1, $ === null && typeof setInterval < "u" && ($ = setInterval(function() {
        if (H) {
          clearInterval($), $ = null;
          return;
        }
        var b = !1;
        for (var X in GA)
          b || (b = !0, y("still waiting on run dependencies:")), y("dependency: " + X);
        b && y("(end of list)");
      }, 1e4))) : y("warning: run dependency added without ID");
    }
    function DA(T) {
      if (Z--, e.monitorRunDependencies && e.monitorRunDependencies(Z), T ? (_(GA[T]), delete GA[T]) : y("warning: run dependency removed without ID"), Z == 0 && ($ !== null && (clearInterval($), $ = null), BA)) {
        var b = BA;
        BA = null, b();
      }
    }
    function SA(T) {
      e.onAbort && e.onAbort(T), T = "Aborted(" + T + ")", y(T), H = !0;
      var b = new WebAssembly.RuntimeError(T);
      throw i(b), b;
    }
    var EA = { error: function() {
      SA("Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM");
    }, init: function() {
      EA.error();
    }, createDataFile: function() {
      EA.error();
    }, createPreloadedFile: function() {
      EA.error();
    }, createLazyFile: function() {
      EA.error();
    }, open: function() {
      EA.error();
    }, mkdev: function() {
      EA.error();
    }, registerDevice: function() {
      EA.error();
    }, analyzePath: function() {
      EA.error();
    }, loadFilesFromDB: function() {
      EA.error();
    }, ErrnoError: function() {
      EA.error();
    } };
    e.FS_createDataFile = EA.createDataFile, e.FS_createPreloadedFile = EA.createPreloadedFile;
    var mA = "data:application/octet-stream;base64,";
    function YA(T) {
      return T.startsWith(mA);
    }
    function ZA(T) {
      return T.startsWith("file://");
    }
    function _A(T, b) {
      return function() {
        var X = T, CA = b;
        return b || (CA = e.asm), _(pe, "native function `" + X + "` called before runtime initialization"), CA[T] || _(CA[T], "exported native function `" + X + "` not found"), CA[T].apply(null, arguments);
      };
    }
    var Se;
    Se = "data:application/octet-stream;base64,AGFzbQEAAAABvgVKYAJ/fwBgAX8Bf2ABfwBgA39/fwBgA39/fwF/YAJ/fwF/YAR/f39/AGAGf39/f39/AX9gBX9/f39/AX9gBH9/f38Bf2AGf39/f39/AGAAAGAFf39/f38AYAd/f39/f39/AGAAAX9gCH9/f39/f39/AX9gB39/f39/f38Bf2AIf39/f39/f38AYAp/f39/f39/f39/AGABfwF8YAV/fn5+fgBgCX9/f39/f39/fwBgAn9/AXxgBH9/f38BfmAFf39/f34Bf2AKf39/f39/f39/fwF/YAl/f39/f39/f38Bf2ADf39/AXxgBX9/fn9/AGAMf39/f39/f39/f39/AX9gEH9/f39/f39/f39/f39/f38AYAN/fn8BfmAEf35+fwBgBn9/f39+fgF/YAd/f39/f35+AX9gDX9/f39/f39/f39/f38AYA5/f39/f39/f39/f39/fwBgBH9/f38BfGADf398AGADf398AX9gAnx/AXxgBX9/f398AX9gC39/f39/f39/f39/AX9gD39/f39/f39/f39/f39/fwBgDn9/f39/f39/f39/fH9/AGARf39/f39/f39/f39/f39/f38AYAt/f39/f39/f39/fwBgD39/f39/f39/f39/f39/fwF/YAR/f39/AX1gBH9/f3wBf2AFf39/f3wAYAN/fHwBf2AHf39/f39/fABgDX9/f39/f39/f398f38AYAZ/f39/f3wAYAx/f39/f39/fH9/f38AYA5/f39/f39/f39/f39/fwF/YAx/f39/f39/f39/f38AYAJ8fAF8YAF8AXxgBH5+fn4Bf2ADfn5+AX9gAn9+AGACf3wAYAJ/fwF+YAJ+fgF9YAJ+fgF8YAN/f34AYAJ+fwF/YAZ/fH9/f38Bf2AEf39/fgF+YAN/f38BfWAEf39+fgBgBX9/f39/AX4ClA1BA2VudhZfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzACMDZW52Il9lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY29uc3RydWN0b3IACgNlbnYlX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jbGFzc19mdW5jdGlvbgANA2Vudh9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2Z1bmN0aW9uABEDZW52GV9lbWJpbmRfcmVnaXN0ZXJfZnVuY3Rpb24ACgNlbnYKaW52b2tlX2lpaQAEA2VudhtfX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzIADgNlbnYRX19yZXN1bWVFeGNlcHRpb24AAgNlbnYNX19hc3NlcnRfZmFpbAAGA2VudgxpbnZva2VfdmlpaWkADANlbnYLaW52b2tlX3ZpaWkABgNlbnYJaW52b2tlX3ZpAAADZW52CWludm9rZV9paQAFA2VudgppbnZva2VfdmlpAAMDZW52GF9fY3hhX2FsbG9jYXRlX2V4Y2VwdGlvbgABA2VudgtfX2N4YV90aHJvdwADA2VudghpbnZva2VfaQABA2VudhVpbnZva2VfdmlpaWlpaWlpaWlkaWkALANlbnYPaW52b2tlX3ZpaWlpaWlpABEDZW52FF9fY3hhX2ZyZWVfZXhjZXB0aW9uAAIDZW52C2ludm9rZV9paWlpAAkDZW52DGludm9rZV9paWlpaQAIA2Vudg5pbnZva2VfdmlpaWlpaQANA2VudhhpbnZva2VfdmlpaWlpaWlpaWlpaWlpaWkALQNlbnYSaW52b2tlX3ZpaWlpaWlpaWlpAC4DZW52Fmludm9rZV9paWlpaWlpaWlpaWlpaWkALwNlbnYRaW52b2tlX2lpaWlpaWlpaWkAGQNlbnYQaW52b2tlX2lpaWlpaWlpaQAaA2Vudg9pbnZva2VfaWlpaWlpaWkADwNlbnYRaW52b2tlX3ZpaWlpaWlpaWkAEgNlbnYNaW52b2tlX3ZpaWlpaQAKA2VudhtfX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzMAAQNlbnYSbGx2bV9laF90eXBlaWRfZm9yAAEDZW52EV9fY3hhX2JlZ2luX2NhdGNoAAEDZW52D19fY3hhX2VuZF9jYXRjaAALA2VudghpbnZva2VfdgACA2VudhBpbnZva2VfdmlpaWlpaWlpABUDZW52Dmludm9rZV9paWlpaWlpABADZW52FWludm9rZV92aWlpaWlpaWlpaWlpaQAkA2VudhVfZW1iaW5kX3JlZ2lzdGVyX3ZvaWQAAANlbnYVX2VtYmluZF9yZWdpc3Rlcl9ib29sAAwDZW52GF9lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcgAMA2VudhZfZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0AAMDZW52G19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZwAAA2VudhxfZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nAAMDZW52Fl9lbWJpbmRfcmVnaXN0ZXJfZW12YWwAAANlbnYcX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldwADA2VudhVlbXNjcmlwdGVuX21lbWNweV9iaWcAAwNlbnYWZW1zY3JpcHRlbl9yZXNpemVfaGVhcAABA2Vudg1fX2N4YV9yZXRocm93AAsDZW52GV9fY3hhX3VuY2F1Z2h0X2V4Y2VwdGlvbnMADgNlbnYNaW52b2tlX2lpaWlpaQAHFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfd3JpdGUACRZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxCGZkX2Nsb3NlAAEDZW52C2ludm9rZV9maWlpADADZW52C2ludm9rZV9kaWlpACUWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MRFlbnZpcm9uX3NpemVzX2dldAAFFndhc2lfc25hcHNob3RfcHJldmlldzELZW52aXJvbl9nZXQABQNlbnYKc3RyZnRpbWVfbAAIA2VudhNpbnZva2VfaWlpaWlpaWlpaWlpAB0DZW52F2ludm9rZV92aWlpaWlpaWlpaWlpaWlpAB4DZW52BWFib3J0AAsDZW52F19lbWJpbmRfcmVnaXN0ZXJfYmlnaW50AA0Wd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQdmZF9zZWVrAAgDZW52DGludm9rZV9qaWlpaQAIA+kH5wcLCwECBAUFAQQDAzEGAwAFAQUBFhsTFhMKBwAmAAMAAycDBAMDABslBjIDAwECBQYBAgUFAQQDBQAABQEBARMKBwABAQEAAAADJwMEAwMDAQIBAwECAQMBAgEDAQIzBRYTEwEFAQQDAwkGAwAFABYTAAUKBwAAAAMEAwMDAAYJBgwDAwEFBgEFAQQDBQAABQATCgcAAAAAAwQDAwMDAQEDAQEDAQEDBQUCBQMCCwMCAgUFAgIDBQAFAAAAAAUFAwUDAgUFAwUAAAUAAAAABgMGBgYGAwIAADQDAwM1Ng03DQMCBQECAgIEBQELBAAEBQMAAgUBAwMGBQMCAAAGAwMDAwAABgAAAwMAAAIJAwkKCh4SOBoPEAQBFQEMBgoJByQREgMVBgMR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IABCADcCtAVBpO4BQQA2AgBBgQIgAEGYBWogA0EoahAFGkGk7gEoAgAhAkGk7gFBADYCACACQQFGBEAQBiECIAEQ7wEgABDzAQwCCyADKAI0IgAEQCAAIABBAWstAABrENYDCyADKAI4IgAEQCAAIABBAWstAABrENYDCyADKAI8IgAEQCAAIABBAWstAABrENYDCyADQUBrKAIAIgAEQCAAIABBAWstAABrENYDCyADQdAAaiQADwsQBiECCyADQShqEPQBIAIQBwALQcAqQasZQcwAQa4PEAgAC40BAQJ/IwBBwAVrIgMkACAAKAIAIQQgAyABIAAoAgQiAEEBdWoiASACIABBAXEEfyABKAIAIARqKAIABSAECxEDAEGk7gFBADYCAEH9ASADEAwhAEGk7gEoAgAhAUGk7gFBADYCACABQQFHBEAgAxCkAhogA0HABWokACAADwsQBiEAIAMQpAIaIAAQBwALzAMBAX8jAEFAaiIDJAAgAyACQZgFajYCECADIAFBmAVqNgIMIANBADoACCABKAKcBSACKAKgBUYEQCADQgA3AiQgA0EsaiIBQgA3AgAgA0IANwI0IANCADcCHCADQQA6ABhBpO4BQQA2AgBBhwIgA0EYaiADQQhqEA1BpO4BKAIAIQJBpO4BQQA2AgAgAkEBRgRAEAYhACABEO8BIAAQBwALQaTuAUEANgIAQYACIAAgABAFIQBBpO4BKAIAIQFBpO4BQQA2AgACQCABQQFHBEAgAEEAOgCYBSAAQgA3ApwFIABCADcCpAUgAEGsBWoiAkIANwIAIABCADcCtAVBpO4BQQA2AgBBgQIgAEGYBWogA0EYahAFGkGk7gEoAgAhAUGk7gFBADYCACABQQFGBEAQBiEBIAIQ7wEgABDzAQwCCyADKAIkIgAEQCAAIABBAWstAABrENYDCyADKAIoIgAEQCAAIABBAWstAABrENYDCyADKAIsIgAEQCAAIABBAWstAABrENYDCyADKAIwIgAEQCAAIABBAWstAABrENYDCyADQUBrJAAPCxAGIQELIANBGGoQ9AEgARAHAAtB7zpBtBZB5ABBxAsQCAAL3QMBAX8jAEFAaiIDJAAgAyACQZgFajYCECADIAFBmAVqNgIMIANBADoACAJAIAEoAqAFIAIoAqAFRw0AIAEoApwFIAIoApwFRw0A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IAdBAWoiByADRw0ACwwBC0EAIQRBACEBIAZBBE8EQCAGQXxxIQdBACEDA0AgAiABQQJ0aiABIAVtNgIAIAIgAUEBciIIQQJ0aiAIIAVtNgIAIAIgAUECciIIQQJ0aiAIIAVtNgIAIAIgAUEDciIIQQJ0aiAIIAVtNgIAIAFBBGohASADQQRqIgMgB0cNAAsLIAZBA3EiA0UNAANAIAIgAUECdGogASAFbTYCACABQQFqIQEgBEEBaiIEIANHDQALCyAAKAIQIgIEQCACIAJBAWstAABrENYDCyAAQQA2AhAPC0HBwwBBxBRB4QVBjQgQCAALQbEqQfQcQagBQeMgEAgAC5gDAQF/IABBADoACCAAIAE2AgAgAEIANwIcIABBfzYCGCAAQRRqIgJBADoAACAAQQA7ARAgAEEANgIMIABCADcCJCAAQgA3AiwgAEEANgI0QaTuAUEANgIAQesBIAJBAEEAEApBpO4BKAIAIQJBpO4BQQA2AgAgAkEBRgRAEAYhAiAAKAIoIgEEQCABIAFBAWstAABrENYDCyAAKAIsIgAEQCAAIABBAWstAABrENYDCyACEAcACyAAQQA7AXggAEIANwNgIABCADcDWCAAQgA3A1AgAEIANwNIIABBQGtCADcDACAAQgA3AzggAEEBOgBwIABCgICAgICAgPg/NwNoQaTuAUEANgIAQfYBIABBgAFqIAEQBRpBpO4BKAIAIQJBpO4BQQA2AgACQAJAIAJBAUcEQCAAIAE2AsADQaTuAUEANgIAQfcBIABByANqEAwaQaTuASgCACEBQaTuAUEANgIAIAFBAUYNASAAQQA7AZAFIAAPCxAGIQEMAQsQBiEBIABBiAFqEKYCCyAAQQhqEKcCIAEQBwALoB0CEH8BfCABLQAABEAgACgCDCECIAAgASgCDDYCDCABIAI2AgwgACgCCCECIAAgASgCCDYCCCABIAI2AgggACgCBCECIAAgASgCBDYCBCABIAI2AgQgACgCECECIAAgASgCEDYCECABIAI2AhAgACgCFCECIAAgASgCFDYCFCABIAI2AhQgACgCGCECIAAgASgCGDYCGCABIAI2AhggACgCHCECIAAgASgCHDYCHCABIAI2AhwgACgCICECIAAgASgCIDYCICABIAI2AiAgAA8LIAAgAUcEQCAAIAEoAgggASgCBBDu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IAVqIgEgAjYCHCABIAI2AhggASACNgIUIAEgAjYCECABIAI2AgwgASACNgIIIAEgAjYCBCAFIANBCGoiA0ECdGogAjYCACADIARHDQALC0Gk7gFBADYCACAGQQE6AAhB7gEgACAGQQhqEAUaQaTuASgCACEAQaTuAUEANgIAIABBAUYNACAGKAIUIgAEQCAAIABBAWstAABrENYDCyAGKAIYIgAEQCAAIABBAWstAABrENYDCyAGKAIcIgAEQCAAIABBAWstAABrENYDCyAGKAIgIgBFDQMgACAAQQFrLQAAaxDWAwwDCxAGIQAgBkEIahD0ASAAEAcACwALIAMNASAAKAIgIARIBEAgAEEUaiAEEK0CCyAJQQBKBEAgACgCHCEDQQAhCwNAAkACQAJAAkAgAyAAKAIMIgEgC0ECdCIMaigCAEYEQCABIAtBAWoiC0ECdCIKaiIBKAIADQEgASADNgIAIA4oAgwiBCAMaigCACIBAn8gDigCECICRQRAIAQgCmooAgAMAQsgAiAMaigCACABagsiD04NBCAOKAIYIRAgDigCFCERIAMhBANAIAAoAgwiAyAKaiICKAIAIARHDQMgESABQQN0aisDACESIBAgAUECdGooAgAhDSADIAxqKAIAIARHBEAgACgCGCAEQQJ0akEEaygCACANTg0FCyACIARBAWoiAzYCAAJAIAQgACgCICICSARAIAAoAhghAgwBCyAEQX5MDQsgA0GAgICAAU8NCyACQYCAgIACTw0LIANBBHQhCAJAAkAgACgCFCIFRQRAIAhBEGoQ1QMiAgRAIAJBECACQY8CcWsiB0EfcWohAgwCC0EAIQIgA0UNAgwOCwJAIAUgBUEBay0AAGsiByAIQRBqENcDIgIEQCACIAdHDQEgBSECDAMLQQAhAiADRQ0CDA4LIAJBECACQY8CcWsiB0EfcWoiAiAFIAgQywMaCyACQQFrIAc6AAALIAAgAjYCFCAAKAIgQYCAgIAETw0LIANBA3QhCAJAAkAgACgCGCIFRQRAIAhBEGoQ1QMiAgRAIAJBECACQY8CcWsiB0EfcWohAgwCC0EAIQIgA0UNAgwOCwJAIAUgBUEBay0AAGsiByAIQRBqENcDIgIEQCACIAdHDQEgBSECDAMLQQAhAiADRQ0CDA4LIAJBECACQY8CcWsiB0EfcWoiAiAF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AkEASA0AIAYoAhwhCiAGKAIMIQggAiEBA0ACQCAIIAFBAnRqKAIABEAgASEDDAELQX8hAyABQQBKIQQgAUEBayEBIAQNAQsLIAIgA0wNACACIANBf3NqIQUgAiADa0EHcSIEBEBBACEBA0AgCCADQQFqIgNBAnRqIAo2AgAgAUEBaiIBIARHDQALCyAFQQdJDQADQCADQQJ0IAhqIgEgCjYCHCABIAo2AhggASAKNgIUIAEgCjYCECABIAo2AgwgASAKNgIIIAEgCjYCBCAIIANBCGoiA0ECdGogCjYCACACIANHDQALC0Gk7gFBADYCACAGQQE6AABB7gEgACAGEAUaQaTuASgCACEAQaTuAUEANgIAIABBAUYNACAGKAIMIgAEQCAAIABBAWstAABrENYDCyAGKAIQIgAEQCAAIABBAWstAABrENYDCyAGKAIUIgAEQCAAIABBAWstAABrENYDCyAGKAIYIgBFDQIgACAAQQFrLQAAaxDWAwwCCxAGIQAgBhD0AQwFCyADDQEgACgCICAESARAQaTuAUEANgIAQaICIABBFGogBBANQaTuASgCACEBQaTuAUEANgIAIAFBAUYNBAsgDUEASgRAIAAoAhwhAwNAAkACfyADIAAoAgwiASARQQJ0IhJqKAIARwRAQZ83IQRBnwMMAQsgASARQQFqIhFBAnQiDGoiASgCAEUNAUHHNiEEQaADCyEAQaTuAUEANgIAQeMBIARBxBQgAEHuIhAJQaTuASgCACEAQaTuAUEANgIAIABBAUcNBRAGIQAMBwsgASADNgIAAkAgBygCACIFKAIMIgQgEmooAgAiAQJ/IAUoAhAiAkUEQCAEIAxqKAIADAELIAIgEmooAgAgAWoLIg5ODQAgBSgCGCEKIAUoAhQhCCADIQQCQANAAkACfyAEIAAoAgwiAiAMaiIDKAIARwRAQa7LACEEQYkDDAELIAogAUECdGooAgAhECAIIAFBA3RqKwMAIRMgBCACIBJqKAIARg0BIAAoAhggBEECdGpBBGsoAgAgEEgNAUGRzAAhBEGKAwshAEGk7gFBADYCAEHjASAEQcQUIABBvw4QCQwCCyADIARBAWoiAzYCAAJAAkAgBCAAKAIgIgJIBEAgACgCGCECDAELIARBf0gNASADQf////8ASw0BIAJB/////wFLDQEgA0EEdCEL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IAFBAWstAABrENYDCyAALAAXQQBIBEAgACgCDBDWAwsL3AEBAX8gACgCUCIBBEAgASABQQFrLQAAaxDWAwsgACgCSCIBBEAgASABQQFrLQAAaxDWAwsgACgCQCIBBEAgASABQQFrLQAAaxDWAwsgACgCOCIBBEAgASABQQFrLQAAaxDWAwsgACgCMCIBBEAgASABQQFrLQAAaxDWAwsgACgCGCIBBEAgASABQQFrLQAAaxDWAwsgACgCHCIBBEAgASABQQFrLQAAaxDWAwsgACgCICIBBEAgASABQQFrLQAAaxDWAwsgACgCJCIABEAgACAAQQFrLQAAaxDWAwsL7gMBA38jAEEwayIDJAAgACAAEPEBIgBBADoAmAUgAEIANwOgBSAAQX82ApwFIABCADcDqAUgAEIANwOwBSAAQQA2ArgFQaTuAUEANgIAQesBIABBmAVqIgRBAEEAEApBpO4BKAIAIQVBpO4BQQA2AgACQCAFQQFGBEAQBiEBIABBrAVqEO8BDAELIANCADcCFCADQRxqIgVCADcCACADQgA3AiQgA0IANwIMIANBADoACEGk7gFBADYCAEHrASADQQhqIAEgAhAKQaTuASgCACEBQaTuAUEANgIAAkAgAUEBRgRAEAYhASAFEO8BDAELQaTuAUEANgIAQe4BIAQgA0EIahAFGkGk7gEoAgAhAUGk7gFBADYCACABQQFHBEAgAygCFCIBBEAgASABQQFrLQAAaxDWAwsgAygCGCIBBEAgASABQQFrLQAAaxDWAwsgAygCHCIBBEAgASABQQFrLQAAaxDWAwsgAygCICIBBEAgASABQQFrLQAAaxDWAwsgAEEANgK0BQJAIAAoApwFIgFBAEgNACAAKAKkBUEAIAFBAnQiAkEEahDNAxogACgCqAUiBEUNACABRQ0AIARBACACEM0DGgsgA0EwaiQAIAAPCxAGIQEgA0EIahD0AQsgBBD0AQsgABDzASABEAcAC8ECAQF/IABBADoACCAAIAE2AgAgAEEAOwAfIABCADcDKCAAQX82AiQgAEEAOgAUIABCADcDMCAAQgA3AzggAEFAa0EANgIAQaTuAUEANgIAQesBIABBIGpBAEEAEApBpO4BKAIAIQFBpO4BQQA2AgAgAUEBRgRAEAYhAiAAKAI0IgEEQCABIAFBAWstAABrENYDCyAAKAI4IgEEQCABIAFBAWstAABrENYDCyAALAAfQQBIBEAgACgCFBDWAwsgAhAHAAsgAEIANwLcASAAQQA6AGggAEIANwLkASAAQgA3AuwBIABBADoAgAIgAEHsAGpBAEHoABDNAxogAEEBNgKwAiAAQoCAgICAgID4PzcDoAIgAEEAOwG4AiAAQoiAgIDAAjcClAIgAEKAgYCAgAI3AowCIABCkICAgBA3AoQCIAALwQMBA38gAEEAOwEAIABBADsAEyAAQQA6AAggAEIANwIcIABBfzYCGCAAQgA3AiQgAEIANwIsIABBADYCNEGk7gFBADYCAEHrASAAQRRqIgJBAEEAEApBpO4BKAIAIQFBpO4BQQA2AgACQAJAIAFBAUYEQBAGIQEgAEEoahDvAQwBCyAAQQA6ADggAEFAa0IANwMAIABBfzYCPCAAQgA3A0ggAEIANwNQIABBADYCWEGk7gFBADYCAEHrASAAQThqIgNBAEEAEApBpO4BKAIAIQFBpO4BQQA2AgACQCABQQFGBEAQBiEBIABBzABqEO8BDAELIABBADoAXCAAQgA3AmQgAEF/NgJgIABCADcCbCAAQgA3AnQgAEEANgJ8QaTuAUEANgIAQesBIABB3ABqQQBBABAKQaTuASgCACEBQaTuAUEANgIAIAFBAUcNAhAGIQEgAEHwAGoQ7wEgAxD0AQsgAhD0AQsgACwAE0EASARAIAAoAggQ1gMLIAEQBwALIABCADcDgAEgAEIANwOwASAAQQE6AKgBIABCADcDmAEgAEIANwOQASAAQgA3A4gBIABCADcDuAEgAEEAOwHAASAACwkAQYsfEKICAAu8AQEBfwJAAkACQCAARQRAIAFBEGoQ1QMiAARAIABBECAAQY8CcWsiA0EfcWohAgwCC0EAIQIgAUUNAgwDCwJAIAAgAEEBay0AAGsiAyABQRBqENcDIgIEQCACIANHDQEgAA8LQQAhAiABRQ0CDAMLIAJBECACQY8CcWsiA0EfcWoiAiAAIAEQywMaCyACQQFrIAM6AAALIAIPC0EEEA4iAEGM5gE2AgAgAEHk5QE2AgAgAEHY5gFBjQIQDwALjwEBAX8gAUGAgICAAkkEQAJAIAAoAgwiAkGAgICAAk8NACAAIAAoAgAgAUEDdCACQQN0EKwCNgIAIAAoAgwiAkGAgICABE8NACAAKAIEIAFBAnQgAkECdBCsAiECIAAgATYCDCAAIAI2AgQPCwtBBBAOIgBBjOYBNgIAIABB5OUBNgIAIABB2OYBQY0CEA8AC98BAQF/AkACQCAAKAIMIAFBAnRqIgMoAgQiASAAKAIcRgRAIAMoAgAgAUcEQCAAKAIYIAFBAnRqQQRrKAIAIAJODQILIAMgAUEBaiIDNgIEIAEgACgCIE4EQCABQX5MDQMgAEEUaiADQQF0EK0CCyAAIAM2AhwgACgCFCABQQN0aiIDQgA3AwAgACgCGCABQQJ0aiACNgIAIAMPC0GuywBBxBRBiQNBvw4QCAALQZHMAEHEFEGKA0G/DhAIAAtBBBAOIgBBjOYBNgIAIABB5OUBNgIAIABB2OYBQY0CEA8AC/oBAQV/IwBBEGsiAiQAIAAgABDxASEAIAEoAhAhAyABKAIMIQUgAEIANwKcBSAAQQA6AJgFIABCADcCpAUgAEGsBWoiBkIANwIAIABCADcCtAVBpO4BQQA2AgBB6wEgAEGYBWoiBCAFIAMQCkGk7gEoAgAhA0Gk7gFBADYCAAJAAkAgA0EBRgRAEAYhASAGEO8BDAELIAIgASgCADYCCCABKAIEIQFBpO4BQQA2AgAgAiABNgIAQe8BIAJBCGogAiAEEApBpO4BKAIAIQFBpO4BQQA2AgAgAUEBRw0BEAYhASAEEPQBCyAAEPMBIAEQBwALIAJBEGokACAAC84BAQF/IAAgAjYCCCAAQQA2AhwCQCABIAAoAgQiAkZBACACG0UEQCABQQFqIgNBgICAgARPDQEgAkEBaiICQYCAgIAETw0BIAAoAgwgA0ECdCACQQJ0EKwCIQIgACABNgIEIAAgAjYCDAsgACgCECICBEAgAiACQQFrLQAAaxDWAyAAQQA2AhAgACgCBCEBCyABQQBOBEAgACgCDEEAIAFBAnRBBGoQzQMaCw8LQQQQDiIAQYzmATYCACAAQeTlATYCACAAQdjmAUGNAhAPAAv5CAETfyAAKAIEIQQCQAJAAkAgACgCECIGRQRAAkAgBARAIARBgICAgARPDQQgBEECdEEQahDVAyIFDQEMBAsgAEEANgIQQQAhBgwCCyAFQRAgBUGPAnFrIgJBH3FqIg9BAWsgAjoAACAAIA82AhBBACEGIAEoAgQiAkEAIAJBAEobIQkgACgCDCELIAEoAgAhDEEAIQUDQCAPIANBAnQiCGogBTYCACADIAlGDQQgCyADQQFqIgNBAnRqKAIAIAggDGooAgAiAiAFamogCCALaigCAGshBSACIAZqIQYgAyAERw0ACwwBCwJAIARBAWoiAkUNACACQYCAgIAETw0CIAJBAnRBEGoQ1QMiBUUNAiAFQRAgBUGPAnFrIgJBH3FqIgpBAWsgAjoAACAERQ0AIAEoAgQiAkEAIAJBAEobIQwgASgCACEFIAAoAgwhCQNAIAogA0ECdCIIaiAHNgIAIAMgDEYNBCAGIAhqKAIAIgEgB2ogBSAIaigCACICIAkgA0EBaiIDQQJ0aigCACAIIAlqKAIAIAFqayIBIAEgAkgbaiEHIAMgBEcNAAsLIAogBEECdGogBzYCACAHIAAoAiBKBEAgAEEUaiAHEK0CIAAoAgQhBAsgACAHNgIcIAAoAgwhDQJAAkAgBEEASgRAIAAoAhghDiAAKAIUIQsgACgCECEIA0ACQCAKIAQiAUEBayIEQQJ0IgJqIgkoAgAiByACIA1qIgMoAgAiBkwNACACIAhqKAIAIgVBAEwNAANAIA4gByAFQQFrIgJqQQJ0aiAOIAIgBmpBAnRqKAIANgIAIAsgCSgCACIHIAJqQQN0aiALIAMoAgAiBiACakEDdGorAwA5AwAgBUEBSyEMIAIhBSAMDQALCyABQQFKDQALIAAgCjYCDAwBCyAAIAo2AgwgDUUNAQsgDSANQQFrLQAAaxDWAwsPCyAAQRRqIREgACgCHCAGaiICIAAoAiBKBEAgESACEK0CIAAoAgQhBAsgACgCDCISIARBAnRqIRACQAJAAkAgBEEASgRAIAAoAhghEyAAKAIQIQsgACgCFCEUIBAoAgAhAyAEIQIDQCAPIAJBAWsiDEECdCIKaiIIKAIAIQcgAyAKIBJqIg0oAgAiBmsiDiEFIA5BAEoEQANAIBMgByAFQQFrIgNqQQJ0aiATIAMgBmpBAnRqKAIANgIAIBQgCCgCACIHIANqQQN0aiAUIA0oAgAiBiADakEDdGorAwA5AwAgBUEBSyEJIAMhBSAJDQALCyANIAc2AgAgCiALaiAONgIAIAJBAUohBSAMIQIgBiEDIAUNAAsgBEEASg0BCyAQKAIAIQMMAQsgASgCBCAESA0BIBAgBEECdEEEayICIAAoAhBqKAIAIAIgEmooAgBqIAEoAgAgAmooAgBqIgM2AgALIAMgACgCIEoEQCARIAMQrQILIAAgAzYCHA8LDAELQQQQDiIAQYzmATYCACAAQeTlATYCACAAQdjmAUGNAhAPAAtB9zVBlxxBpQFB/yIQCAALrwYBEX8jAEEQayIDJAACQAJAAkACQCAAKAIQBEAgACgCCCEBIANCADcDCAJAAkAgAUEASARAQaTuAUEANgIAQeMBQacpQewbQbwCQewfEAlBpO4BKAIAIQBBpO4BQQA2AgAgAEEBRg0BDAcLQaTuAUEANgIAQZQCIANBCGogASABQQEQCUGk7gEoAgAhAUGk7gFBADYCACABQQFHDQELEAYhBCADKAIIIgBFDQQgACAAQQFrLQAAaxDWAwwECyADKAIMIghBAEgEQEGk7gFBADYCAEHjAUHAKkGrGUHMAEGuDxAJQaTuASgCACEAQaTuAUEANgIAIABBAUcNBQwDCyAIBEAgAygCCEH/ASAIQQJ0EM0DGgsgACgCECEGIAAoAgwhCiAAKAIEIgtBAEwNASAAKAIYIQxBACEBA0AgCiANQQJ0IgVqIQ4gBSAGaigCACIFQQBKBEAgBSAOKAIAIgRqIQ8gACgCFCEHIAMoAgghECABIQIDQCAMIARBAnRqKAIAIglBAE4gCCAJSnFFBEBBpO4BQQA2AgBB4wFB9zVBlxxBrQNBsDUQCUGk7gEoAgAhAEGk7gFBADYCACAAQQFHDQgMBgsCQCABIBAgCUECdGoiESgCACIFTARAIAcgBUEDdGoiBSAFKwMAIAcgBEEDdGorAwCgOQMADAELIAcgAkEDdGogByAEQQN0aisDADkDACAMIAJBAnRqIAk2AgAgESACNgIAIAJBAWohAgsgBEEBaiIEIA9IDQALCyAOIAE2AgAgAiEBIAsgDUEBaiINRw0ACwwBC0G3NkHEFEHfCEHUDRAIAAsgCiALQQJ0aiACNgIAIAYEQCAGIAZBAWstAABrENYDIAAoAgwgACgCBEECdGooAgAhAgsgAEEANgIQAkAgAiAAKAIgSgRAQaTuAUEANgIAQaICIABBFGogAhANQaTuASgCACEBQaTuAUEANgIAIAFBAUYNAQsgACACNgIcIAMoAggiAARAIAAgAEEBay0AAGsQ1gMLIANBEGokAA8LCxAGIQQgAygCCCIARQ0AIAAgAEEBay0AAGsQ1gMgBBAHAAsgBBAHAAsAC8gMAQ1/IwBBMGsiAiQAIAEoAgghAyABKAIEIQQgAkIANwIUIAJBHGoiBkIANwIAIAJCADcCJCACQgA3AgwgAkEAOgAIQaTuAUEANgIAQesBIAJBCGogBCADEApBpO4BKAIAIQNBpO4BQQA2AgAgA0EBRgRAEAYhACAGEO8BIAAQBwALAkACQAJAAkAgAigCDCIJQQBIBEBBpO4BQQA2AgBB4wFBsSpB9BxBqAFB4yAQCUGk7gEoAgAhAEGk7gFBADYCACAAQQFGDQEMBAsgAigCFCEEIAkEQCAEQQAgCUECdBDNAxoLIAEoAgQiCkEATA0BIAEoAhghCyABKAIMIQxBACEGIAEoAhAiBUUEQANAIAZBAnQhAwJAIAwgBkEBaiIGQQJ0aigCACIHIAMgDGooAgAiA0wNACAHIANBf3NqIQhBACEFIAcgA2tBA3EiDQRAA0AgBCALIANBAnRqKAIAQQJ0aiIOIA4oAgBBAWo2AgAgA0EBaiEDIAVBAWoiBSANRw0ACwsgCEECTQ0AA0AgBCALIANBAnRqIgUoAgBBAnRqIgggCCgCAEEBajYCACAEIAUoAgRBAnRqIgggCCgCAEEBajYCACAEIAUoAghBAnRqIgggCCgCAEEBajYCACAEIAUoAgxBAnRqIgUgBSgCAEEBajYCACADQQRqIgMgB0cNAAsLIAYgCkcNAAwDCwALA0AgBSAGQQJ0IgNqKAIAIgdBAEoEQCAHIAMgDGooAgAiA2ohBwNAIAQgCyADQQJ0aigCAEECdGoiCCAIKAIAQQFqNgIAIANBAWoiAyAHSA0ACwsgCiAGQQFqIgZHDQALDAELEAYhAwwBC0EAIQRBpO4BQQA2AgAgAkIANwMAQZQCIAIgCSAJQQEQCUGk7gEoAgAhA0Gk7gFBADYCAAJAAkAgA0EBRwRAIAIoAhQhBiACKAIMIgVBAEwNAUEAIQMgAigCBCIEQQAgBEEAShshCSACKAIAIQtBACEEA0ACQCAGIANBAnQiDGoiBygCACEKIAcgBDYCACADIAlGDQAgCyAMaiAENgIAIAQgCmohBCAFIANBAWoiA0cNAQwDCwtBpO4BQQA2AgBB4wFB9zVBlxxBnANB/yIQCUGk7gEoAgAhAEGk7gFBADYCACAAQQFHDQQMAgsMAQsgBiAFQQJ0aiAENgIAAkAgBCACKAIoSgRAQaTuAUEANgIAQaICIAJBHGogBBANQaTuASgCACEDQaTuAUEANgIAIANBAUYNAQsgAiAENgIkIAEoAgQiCUEASgRAIAEoAhghCyABKAIQIQYgASgCDCEMIAEoAhQhB0EAIQUDQCAMIAVBAnQiAWoiCigCACIDAn8gBkUEQCAKKAIEDAELIAEgBmooAgAgA2oLIgpIBEAgAigCHCEIIAIoAiAhDSACKAIAIQ4DQAJAIAsgA0ECdGooAgAiAUEATgRAIAIoAgQgAUoNAQtBpO4BQQA2AgBB4wFB9zVBlxxBnANB/yIQCUGk7gEoAgAhAEGk7gFBADYCACAAQQFHDQgMBgsgDiABQQJ0aiIBIAEoAgAiAUEBajYCACANIAFBAnRqIAU2AgAgCCABQQN0aiAHIANBA3RqKwMAOQMAIANBAWoiAyAKRw0ACwsgBUEBaiIFIAlHDQALCyAAKAIMIQMgACACKAIUNgIMIAIgAzYCFCAAKAIIIQEgACACKAIQNgIIIAIgATYCECAAKAIEIQEgACACKAIMNgIEIAIgATYCDCAAKAIQIQEgACACKAIYNgIQIAIgATYCGCAAKAIUIQEgACACKAIcNgIUIAIgATYCHCAAKAIYIQEgACACKAIgNgIYIAIgATYCICAAKAIcIQEgACAENgIcIAIgATYCJCAAKAIgIQEgACACKAIoNgIgIAIgATYCKCACKAIAIgEEQCABIAFBAWstAABrENYDIAIoAhQhAwsgAwRAIAMgA0EBay0AAGsQ1gMLIAIoAhgiAQRAIAEgAUEBay0AAGsQ1gMLIAIoAhwiAQRAIAEgAUEBay0AAGsQ1gMLIAIoAiAiAQRAIAEgAUEBay0AAGsQ1gMLIAJBMGokACAADwsLEAYhAyACKAIAIgBFDQAgACAAQQFrLQAAaxDWAwsgAkEIahD0ASADEAcACwAL6AEBA39BwAUQ4AchA0Gk7gFBADYCAEHtASADIAMQBSEBQaTuASgCACECQaTuAUEANgIAAkAgAkEBRwRAIAFBADoAmAUgAUIANwKcBSABQgA3AqQFIAFCADcCrAUgAUIANwK0BUGk7gFBADYCAEHuASABQZgFaiAAQZgFahAFGkGk7gEoAgAhAEGk7gFBADYCACAAQQFGBEAQBiEAIAEoAqwFIgIEQCACIAJBAWstAABrENYDCyABKAKwBSICBEAgAiACQQFrLQAAaxDWAwsgARDzAQwCCyABDwsQBiEACyADENYDIAAQBwAL6AYCCX8BfCMAQSBrIgYkACAAKAIEIQIgACgCCCEDIAZCADcDECAGIAM2AgwgBiACNgIIAkAgAiADckEATgRAIAAgBkEIaiAGQRhqEOsBAkAgACgCCCAAKAIEbCIEQQBMDQAgBisDECEMIAAoAgAhAwJAIARBB3EiBUUEQCAEIQIMAQsgBCECA0AgAyAMOQMAIAJBAWshAiADQQhqIQMgB0EBaiIHIAVHDQALCyAEQQhJDQADQCADIAw5AzggAyAMOQMwIAMgDDkDKCADIAw5AyAgAyAMOQMYIAMgDDkDECADIAw5AwggAyAMOQMAIANBQGshAyACQQlrIQQgAkEIayECIARBfkkNAAsLIAEoAgQhBAJAAkACQAJAAn8gASgCCCICIAAoAgRGBEAgAiEDIAQgACgCCCAERg0BGgsgAiAEckEASA0BAkAgAkUNACAERQ0AQf////8HIARtIAJIDQMLIAAgAiAEbCACIAQQjgIgACgCBCEDIAAoAggLIQUgAiADRw0CIAQgBUcNAgwDC0H0xABB7BtBoQJB7B8QCAALQQQQDiIAQYzmATYCACAAQeTlATYCACAAQdjmAUGNAhAPAAtBkAxB0BdB/gVBoCEQCAALIAEoAgQiCkEATA0BIAAoAgQhCyAAKAIAIQUgASgCGCEHIAEoAgwhCSABKAIUIQggASgCECIBBEBBACEAA0AgASAAQQJ0IgJqKAIAIgRBAEoEQCAEIAIgCWooAgAiA2ohAiAAIAtsIQQDQCAFIAcgA0ECdGooAgAgBGpBA3RqIAggA0EDdGorAwA5AwAgA0EBaiIDIAJIDQALCyAAQQFqIgAgCkcNAAsMAgsgCSgCACEAQQAhAgNAAkAgACIDIAkgAiIEQQFqIgJBAnRqKAIAIgBODQAgA0EBaiEBIAQgC2whBCAAIANrQQFxBEAgBSAHIANBAnRqKAIAIARqQQN0aiAIIANBA3RqKwMAOQMAIAEhAwsgACABRg0AA0AgBSAHIANBAnRqKAIAIARqQQN0aiAIIANBA3RqKwMAOQMAIAUgByADQQFqIgFBAnRqKAIAIARqQQN0aiAIIAFBA3RqKwMAOQMAIANBAmoiAyAARw0ACwsgAiAKRw0ACwwBC0HAKkGrGUHMAEGuDxAIAAsgBkEgaiQAC/4GAQR/IwBB0ABrIgMkAAJAAkAgACgCCCIEIAEoAgQiBUoEQCADQgA3AjQgA0E8aiIGQgA3AgAgA0IANwJEIANCADcCLCADQQA6AChBpO4BQQA2AgBB6wEgA0EoaiAEIAUQCkGk7gEoAgAhBEGk7gFBADYCACAEQQFGDQJBpO4BQQA2AgBByQIgACABIANBKGpBARAJQaTuASgCACEAQaTuAUEANgIAAkAgAEEBRg0AQaTuAUEANgIAIANBAToAKEHuASACIANBKGoQBRpBpO4BKAIAIQBBpO4BQQA2AgAgAEEBRg0AIAMoAjQiAARAIAAgAEEBay0AAGsQ1gMLIAMoAjgiAARAIAAgAEEBay0AAGsQ1gMLIAMoAjwiAARAIAAgAEEBay0AAGsQ1gMLIANBQGsoAgAiAEUNAiAAIABBAWstAABrENYDDAILEAYhACADQShqEPQBIAAQBwALIANCADcCNCADQTxqIgZCADcCACADQgA3AkQgA0IANwIsIANBADoAKEGk7gFBADYCAEHrASADQShqIAQgBRAKQaTuASgCACEEQaTuAUEANgIAIARBAUYNAUGk7gFBADYCAEHJAiAAIAEgA0EoakEAEAlBpO4BKAIAIQBBpO4BQQA2AgACQAJAIABBAUcEQCADQgA3AgwgA0EUaiIAQgA3AgAgA0IANwIcIANCADcCBCADQQA6AABBpO4BQQA2AgBBygIgAyADQShqEAUaQaTuASgCACEBQaTuAUEANgIAIAFBAUYEQBAGIQEgABDvAQwDC0Gk7gFBADYCACADQQE6AABBoQIgAiADEAUaQaTuASgCACEAQaTuAUEANgIAIABBAUYNASADKAIMIgAEQCAAIABBAWstAABrENYDCyADKAIQIgAEQCAAIABBAWstAABrENYDCyADKAIUIgAEQCAAIABBAWstAABrENYDCyADKAIYIgAEQCAAIABBAWstAABrENYDCyADKAI0IgAEQCAAIABBAWstAABrENYDCyADKAI4IgAEQCAAIABBAWstAABrENYDCyADKAI8IgAEQCAAIABBAWstAABrENYDCyADQUBrKAIAIgBFDQMgACAAQQFrLQAAaxDWAwwDCxAGIQEMAQsQBiEBIAMQ9AELIANBKGoQ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IARBADYCbCAEIAc2AmggBCAGNgJkIARBADoAYCAEQQE6AAggBEEANgIECyACKAKoAiIABEAgACAAQQFrLQAAaxDWAwsgAigCsAIiAARAIAAgAEEBay0AAGsQ1gMLIAIoArgCIgAEQCAAIABBAWstAABrENYDCyACKALAAiIABEAgACAAQQFrLQAAaxDWAwsgAigCyAIiAARAIAAgAEEBay0AAGsQ1gMLIAIoAtACIgAEQCAAIABBAWstAABrENYDCyACKALYAiIABEAgACAAQQFrLQAAaxDWAwsgAigC4AIiAARAIAAgAEEBay0AAGsQ1gMLIAIoAugCIgAEQCAAIABBAWstAABrENYDCyACKALwAiIABEAgACAAQQFrLQAAaxDWAwsgAigC+AIiAEUNACAAIABBAWstAABrENYDCyACQYADaiQADwtBsSpB9BxBqAFB4yAQCAALDBALQcg9Qe8dQdkEQfMfEAgAC0GzOkHvHUHYBEHzHxAIAAsQBiEDCyACKAKoAiIARQ0AIAAgAEEBay0AAGsQ1gMLIAIoArACIgBFDQAgACAAQQFrLQAAaxDWAwsgAigCuAIiAEUNACAAIABBAWstAABrENYDCyACKALAAiIARQ0AIAAgAEEBay0AAGsQ1gMLIAIoAsgCIgBFDQAgACAAQQFrLQAAaxDWAwsgAigC0AIiAEUNACAAIABBAWstAABrENYDCyACKALYAiIARQ0AIAAgAEEBay0AAGsQ1gMLIAIoAuACIgBFDQAgACAAQQFrLQAAaxDWAwsgAigC6AIiAEUNACAAIABBAWstAABrENYDCyACKALwAiIARQ0AIAAgAEEBay0AAGsQ1gMLIAIoAvgCIgBFDQAgACAAQQFrLQAAaxDWAyADEAcACyADEAcACwALQfc1QZccQa0DQbA1EAgAC0GnKUHsG0G8AkHsHxAIAAvgPwIofwJ8IwBBgAJrIhIkAAJAAkACQAJAIAAoAhBFBEAgACgCBCINIAAoAggiDHIgACgCDCICIA1BAnRqKAIAIAIoAgBrIglyQQBIBH9BfwUgDEEEdEEQakECdiANaiANQRhsQRhqQQJ2aiAJQQF0aiAJQQVuagshAiASQfAAakEAQZABEM0DGiASQoCAgICAgIDwPzcDaCASQoCAgICAgIDwPzcDYCASQgA3AwgCQAJAIA1BfkwE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RAAAAAAAAAAAYQRAIAorAwhEAAAAAAAAAABhDQELIAIgBygCCCIMNgK4ASACIAE2ArABIAxBAEgNASAHKAIAIQQgAiADQQFrIhA2AnwgAiAEQRBqNgJ4IAIgDDYCgAEgDCAQckEASEEAIAQbDQ8gAiAHKQIINwKMASACIAcoAhg2ApwBIAIgBykCEDcClAEgAiAHKQIANwKEASACQgE3A6ABIAIgAigCkAEoAgQ2AqgBIANBAEwNCyAIKAIEIQMgCCgCACEEIAIgCCgCMDYCOCACIAgpAig3AzAgAiAIKQIgNwMoIAIgCCkCGDcDICACIAgpAhA3AxggAiAIKQIINwMQIAIgBDYCCCACIAM2AgwgAiACKQOAATcDSCACIAIpA4gBNwNQIAIgAikDkAE3A1ggAiACKQOYATcDYCACIAIpA6ABNwNoIAIgAigCqAE2AnAgAiACKQN4NwNAIAMgEEcNAiAMIAIoAkhHDREgDARAIAFBACAMQQR0EM0DGgsgAkIANwPYASACQoCAgICAgID4PzcD0AEgAkHQAWohDSMAQYABayIDJAACQAJAAkAgAkFAayIBKAIIQQFGBEAgAigCDCEEIAIoAgghBSABKAIAIgtBACABKAIEIgFBAEgbDRMgASAERw0CAkAgBEUEQCADQUBrQgA3AwAgA0IANwM4DAELIARBAEwNFSADIAUrAwAiHiALKwMIIiCiIAUrAwgiHyALKwMAIiGioSIdOQNAIAMgHiAhoiAfICCioCIeOQM4QQEhASAEQQFGDQADQCAdIAUgAUEEdCITaiIRKwMAIiAgCyATaiITKwMIIh+iIBErAwgiISATKwMAIiKioaAhHSAeICAgIqIgISAfoqCgIR4gAUEBaiIBIARHDQALIAMgHjkDOCADIB05A0ALIAMgDSADQThqEP8BIAIoArABIgEgAysDACABKwMAoDkDACABIAMrAwggASsDCKA5AwgMAQsgAyACKAK4ATYCeCADIAIpArABNwNwIAMgASgCMDYCaCADIAEpAig3A2AgAyABKQIgNwNYIAMgASkCGDcDUCADIAEpAhA3A0ggA0FAayABKQIINwMAIAMgASkCADcDOCADIAIpAjg3AzAgAyACKQIwNwMoIAMgAikCKDcDICADIAIpAiA3AxggAyACKQIYNwMQIAMgAikCEDcDCCADIAIp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QQJ0akEEaygCACACTg0CCyADIAFBAWoiAzYCBCABIAAoAiBOBEAgAUF+TA0DIABBFGogA0EBdBCOAwsgACADNgIcIAFBBHQiAyAAKAIUaiIEQgA3AwAgBEIANwMIIAAoAhggAUECdGogAjYCACAAKAIUIANqDwtBrssAQcQUQYkDQb8OEAgAC0GRzABBxBRBigNBvw4QCAALQQQQDiIAQYzmATYCACAAQeTlATYCACAAQdjmAUGNAhAPAAv6AQEFfyMAQRBrIgIkACAAIAAQgwIhACABKAIQIQMgASgCDCEFIABCADcCnAUgAEEAOgCYBSAAQgA3AqQFIABBrAVqIgZCADcCACAAQgA3ArQFQaTuAUEANgIAQf4BIABBmAVqIgQgBSADEApBpO4BKAIAIQNBpO4BQQA2AgACQAJAIANBAUYEQBAGIQEgBhDvAQwBCyACIAEoAgA2AgggASgCBCEBQaTuAUEANgIAIAIgATYCAEGCAiACQQhqIAIgBBAKQaTuASgCACEBQaTuAUEANgIAIAFBAUcNARAGIQEgBBD0AQsgABDzASABEAcACyACQRBqJAAgAAuoCQEMfyAAKAIEIQQCQAJAAkAgACgCECIFRQRAAkAgBARAIARBgICAgARPDQQgBEECdEEQahDVAyICDQEMBAsgAEEANgIQDAILIAJBECACQY8CcWsiA0EfcWoiBkEBayADOgAAIAAgBjYCECABKAIEIgJBACACQQBKGyEKIAAoAgwhByABKAIAIQtBACECQQAhAwNAIAYgA0ECdCIFaiACNgIAIAMgCkYNBCAHIANBAWoiA0ECdGooAgAgBSALaigCACIJIAJqaiAFIAdqKAIAayECIAggCWohCCADIARHDQALDAELAkAgBEEBaiIDRQ0AIANBgICAgARPDQIgA0ECdEEQahDVAyIDRQ0CIANBECADQY8CcWsiB0EfcWoiCEEBayAHOgAAIARFDQBBACEDIAEoAgQiAkEAIAJBAEobIQYgASgCACEKIAAoAgwhB0EAIQIDQCAIIANBAnQiAWogAjYCACADIAZGDQQgAiABIAVqKAIAIgtqIAEgCmooAgAiAiAHIANBAWoiA0ECdGooAgAgASAHaigCACALamsiASABIAJIG2ohAiADIARHDQALCyAIIARBAnRqIAI2AgAgAiAAKAIgSgRAIABB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AEgNBCACKAIEIAVMDQQgCiAFQQJ0aiIFIAUoAgAiBUEBajYCACACKAIgIAVBAnRqIAQ2AgAgAigCHCAFQQR0aiIFIAkgA0EEdGoiBikDADcDACAFIAYpAwg3AwggA0EBaiIDIAdHDQALIAEoAgQhBQsgBEEBaiIEIAVIDQALIAIoAiQhAwsgACgCDCEEIAAgAigCFDYCDCACIAQ2AhQgACgCCCEBIAAgAigCEDYCCCACIAE2AhAgACgCBCEBIAAgAigCDDYCBCACIAE2AgwgACgCECEBIAAgAigCGDYCECACIAE2AhggACgCFCEBIAAgAigCHDYCFCACIAE2AhwgACgCGCEBIAAgAigCIDYCGCACIAE2AiAgACgCHCEBIAAgAzYCHCACIAE2AiQgACgCICEBIAAgAigCKDYCICACIAE2AiggAigCACIBBEAgASABQQFrLQAAaxDWAyACKAIUIQQLIAQEQCAEIARBAWstAABrENYDCyACKAIYIgEEQCABIAFBAWstAABrENYDCyACKAIcIgEEQCABIAFBAWstAABrENYDCyACKAIgIgEEQCABIAFBAWstAABrENYDCyACQTBqJAAgAA8LQaTuAUEANgIAQeMBQfc1QZccQZwDQf8iEAlBpO4BKAIAIQBBpO4BQQA2AgAgAEEBRw0DCwsQBiEDIAIoAgAiAEUNACAAIABBAWstAABrENYDCyACQQhqEPQBIAMQBwALAAvoAQEDf0HABRDgByEDQaTuAUEANgIAQYACIAMgAxAFIQFBpO4BKAIAIQJBpO4BQQA2AgACQCACQQFHBEAgAUEAOgCYBSABQgA3ApwFIAFCADcCpAUgAUIANwKsBSABQgA3ArQFQaTuAUEANgIAQYECIAFBmAVqIABBmAVqEAUaQaTuASgCACEAQaTuAUEANgIAIABBAUYEQBAGIQAgASgCrAUiAgRAIAIgAkEBay0AAGsQ1gMLIAEoArAFIgIEQCACIAJBAWstAABrENYDCyABEPMBDAILIAEPCxAGIQALIAMQ1gMgABAHAAvlBgEKfyMAQTBrIgQkACAAKAIEIQIgACgCCCEFIARCADcDECAEQgA3AwggBCAFNgIEIAQgAjYCACACIAVyQQBOBEAgACAEIARBGGoQgQIgACgCACEDIAAoAgghAiAAKAIEIQUgBCAEKQMQNwMoIAQg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BikDADcDACAFIAYpAwg3AwggA0EBaiIDIAdHDQALIAEoAgQhBQsgBSAEQQFqIgRKDQEMBQsLQaTuAUEANgIAQeMBQfc1QZccQZwDQf8iEAlBpO4BKAIAIQBBpO4BQQA2AgAgAEEBRw0FCwsQBiEDIAIoAgAiAEUNACAAIABBAWstAABrENYDCyACQQhqEPQBIAMQBwALIAIoAiQhAwsgACgCDCEEIAAgAigCFDYCDCACIAQ2AhQgACgCCCEBIAAgAigCEDYCCCACIAE2AhAgACgCBCEBIAAgAigCDDYCBCACIAE2AgwgACgCECEBIAAgAigCGDYCECACIAE2AhggACgCFCEBIAAgAigCHDYCFCACIAE2AhwgACgCGCEBIAAgAigCIDYCGCACIAE2AiAgACgCHCEBIAAgAzYCHCACIAE2AiQgACgCICEBIAAgAigCKDYCICACIAE2AiggAigCACIBBEAgASABQQFrLQAAaxDWAyACKAIUIQQLIAQEQCAEIARBAWstAABrENYDCyACKAIYIgEEQCABIAFBAWstAABrENYDCyACKAIcIgEEQCABIAFBAWstAABrENYDCyACKAIgIgEEQCABIAFBAWstAABrENYDCyACQTBqJAAgAA8LAAv9DgIPfBF/IwBBMGsiEyQAIAEoAgQiFigCCCESAkACQAJAAkAgASgCACIVKAIIIgIgACgCBEYEQCAAKAIIIBJGDQELIAIgEnJBAEgNAQJAIAJFDQAgEkUNAEH/////ByASbSACSA0DCyAAIAIgEmwgAiASEPcCIAAoAgghEiAAKAIEIQIgASgCBCEWIAEoAgAhFQsgE0IANwMQIBNCADcDCCATIAI2AgAgEyASNgIEIAIgEnJBAEgNAiAAIBMgE0EYahCBAiAAKAIAIRIgACgCCCECIAAoAgQhASATIBMpAxA3AyggEyATKQMINwMgAkAgASACbCIUQQBMDQACQCAUQQNxIhhFBEAgFCECDAELQQAhASAUIQIDQCASIBMpAyA3AwAgEiATKQMoNwMIIAJBAWshAiASQRBqIRIgAUEBaiIBIBhHDQALCyAUQQRJDQADQCASIBMpAyA3AwAgEiATKQMoNwMIIBIgEykDKDcDGCASIBMpAyA3AxAgEiATKQMoNwMoIBIgEykDIDcDICASIBMpAyA3AzAgEiATKQMoNwM4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AnRBEGoQ1QMiBEUNAyAEQRAgBEGPAnFrIgZBH3FqIghBAWsgBjoAACABRQ0AIAkoAgwhCyAJKAIIIQ4gAygCDCEGQQAhBANAIAggBEECdCIHaiAANgIAIAAgByAKaigCACINaiALQQAgBCAORhsiACAGIARBAWoiBEECdGooAgAgBiAHaigCACANamsiByAAIAdKG2ohACABIARHDQALCyAIIAFBAnRqIAA2AgAgACADKAIgSgRAIANBFGogABCOAyADKAIEIQELIAMgADYCHCABQQBKBEADQAJAIAggASIGQQFrIgFBAnQiB2oiCigCACADKAIMIAdqKAIATA0AIAMoAhAgB2ooAgAiAEEATA0AA0AgAygCGCILIABBAWsiBCAKKAIAakECdGogCyADKAIMIAdqIg4oAgAgBGpBAnRqKAIANgIAIAMoAhQiCyAKKAIAIARqQQR0aiINIAsgDigCACAEakEEdGoiCykDADcDACANIAspAwg3AwggAEEBSyELIAQhACALDQALCyAGQQFKDQALCyADKAIMIQAgAyAINgIMIAAEQCAAIABBAWstAABrENYDCwwDCyANRQ0AIAcgBEECdGogADYCACAGQQAgBCAKRhsgCGohCAsgA0EUaiELIAMoAhwgCGoiACADKAIgSgRAIAsgABCOAyADKAIEIQELAkACQCABQQBKBEAgAygCDCIEIAFBAnRqKAIAIQADQCAAIAQgAUEBayIIQQJ0IgpqKAIAIgBrIgZBAEoEQCAHIApqIQ4gBiEAA0AgAygCGCINIABBAWsiBCAOKAIAakECdGogDSADKAIMIApqIhEoAgAgBGpBAnRqKAIANgIAIAMoAhQiDSAOKAIAIARqQQR0aiIQIA0gESgCACAEakEEdGoiDSkDADcDACAQIA0pAwg3AwggAEEBSyENIAQhACANDQALIAMoAgwiBCAKaigCACEACyAEIApqIAcgCmooAgA2AgAgAygCECAKaiAGNgIAIAFBAUohBiAIIQEgBg0ACyADKAIEIgFBAEoNAQsgAygCDCABQQJ0aigCACEEDAELIAMoAgwiACABQQJ0aiABQQFrIgFBAnQiBCADKAIQaigCACAAIARqKAIAaiAJKAIMQQAgCSgCCCABRhtqIgQ2AgALIAQgAygCIEoEQCALIAQQjgMLIAMgBDYCHAwBC0EE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AAsMAgsgAkEDTQ0AA0AgAyABKAIANgIAIAFBBGohASADQQRqIQMgAkEEayICQQNLDQALCyACRQ0AA0AgAyABLQAAOgAAIANBAWohAyABQQFqIQEgAkEBayICDQALCyAAC/ICAgJ/AX4CQCACRQ0AIAAgAToAACAAIAJqIgNBAWsgAToAACACQQNJDQAgACABOgACIAAgAToAASADQQNrIAE6AAAgA0ECayABOgAAIAJBB0kNACAAIAE6AAMgA0EEayABOgAAIAJBCUkNACAAQQAgAGtBA3EiBGoiAyABQf8BcUGBgoQIbCIBNgIAIAMgAiAEa0F8cSIEaiICQQRrIAE2AgAgBEEJSQ0AIAMgATYCCCADIAE2AgQgAkEIayABNgIAIAJBDGsgATYCACAEQRlJDQAgAyABNgIYIAMgATYCFCADIAE2AhAgAyABNgIMIAJBEGsgATYCACACQRRrIAE2AgAgAkEYayABNgIAIAJBHGsgATYCACAEIANBBHFBGHIiBGsiAkEgSQ0AIAGtQoGAgIAQfiEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkEgayICQR9LDQALCyAAC7wCAwN/A34BfCMAQSBrIgIkACAAvUL///////////8AgyIFIAG9Qv///////////wCDIgYgBSAGVBsiB78hAQJAIAdCNIinIgNB/w9GDQAgBSAGIAUgBlYbIgW/IQACQCAHUA0AIAVCNIinIgRB/w9GDQAgBCADa0HBAE4EQCAAIAGgIQEMAgsCfCAEQf4LTwRAIAFEAAAAAAAAMBSiIQEgAEQAAAAAAAAwFKIhAEQAAAAAAACwawwBC0QAAAAAAADwPyADQbwESw0AGiABRAAAAAAAALBroiEBIABEAAAAAAAAsGuiIQBEAAAAAAAAMBQLIQggAkEYaiACQRBqIAAQzwMgAkEIaiACIAEQzwMgCCACKwMAIAIrAxCgIAIrAwigIAIrAxign6IhAQwBCyAAIQELIAJBIGokACABC0UBAnwgACACIAKiIgQ5AwAgASACIAJEAAAAAgAAoEGiIgMgAiADoaAiAqEiAyADoiACIAKgIAOiIAIgAqIgBKGgoDkDAAvIAQIBfwF+IAC9QoCAgICAgID4/wCDQoCAgICAgID4/wBRBEAgACAAog8L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DSAIIAQoAgQgBRDnBCIETQ0BIA0gCCAEa08NASADIAQgDWpqLQAADQEgDCADIARqEOYEIgRFBEAgAyAPIBJqQQJ0aiIHKAIAIAUQ5wQhBiAIIAcoAgQgBRDnBCIFTQ0CIAYgCCAFa08NAkEAIAMgBWogAyAFIAZqai0AABshCwwCCyAGQQFGDQEgCiAGIAprIARBAEgiBBshBiAHIBEgBBshBwwACwALIAsFQQALIgMgDCADGyIDENMDIghBgAhPBEAgASADQf8HEMsDGiABQQA6AP8HQcQADAELIAEgAyAIQQFqEMsDGkEACyIDQQFqDgIAAgELQbDqASgCACEDC0HB0wAhASADQRxGDQAQPQALIAEtAABFBEAgCSACNgIAIAlBEGoiAUGACEG6IiAJEPsEGgtBsOoBIA42AgAgACABEMEEGiAJQZAIaiQADwsgAEH6DRDBBBoLhgIBBH8jAEEQayIFJAAgARDTAyECIwBBEGsiAyQAAkAgAkHv////B00EQAJAIAJBC0kEQCAAIAAtAAtBgAFxIAJyOgALIAAgAC0AC0H/AHE6AAsgACEEDAELIANBCGogACACQQtPBH8gAkEQakFwcSIEIARBAWsiBCAEQQtGGwVBCgtBAWoQuQQgAygCDBogACADKAIIIgQ2AgAgACAAKAIIQYCAgIB4cSADKAIMQf////8HcXI2AgggACAAKAIIQYCAgIB4cjYCCCAAIAI2AgQLIAQgASACEP0DIANBADoAByACIARqIAMtAAc6AAAgA0EQaiQADAELEKsCAAsgBUEQaiQAIAAL+wECAn8BfiMAQRBrIgMkACADIAIpAgAiBTcDACADIAU3AwgCfyMAQSBrIgIkACACIAEQwQQhAUGk7gFBADYCAEGmByACQRBqIAMgARAKQaTuASgCACEEQaTuAUEANgIAAkACQCAEQQFHBEBBpO4BQQA2AgBBpwcgACACQRBqEAUhAEGk7gEoAgAhBEGk7gFBADYCACAEQQFGDQEgAkEQahDmBxogARDmBxogAEGk3gE2AgAgACADKQIANwIIIAJBIGokACAADAMLEAYhAAwBCxAGIQAgAkEQahDmBxoLIAEQ5gcaIAAQBwALIgBBrPQANgIAIANBEGokACAACwcAIAAQlwgLDQAgABCXCBogABDWAws8AQJ/IAAoAighAgNAIAIEQCABIAAgAkEBayICQQJ0IgMgACgCJGooAgAgACgCICADaigCABEDAAwBCwsLGwAgACABKAIcIgA2AgAgACAAKAIEQQFqNgIEC7oBAQF/IAAgACgCGEUgAXIiATYCECAAKAIUIAFxBEAjAEEQayICJABBEBAOIQEjAEEQayIAJABB8O4BLQAARQRAQfDuAUEBOgAACyAAQdToATYCDCAAQQE2AgggAkEIaiICIAApAwg3AgAgAEEQaiQAQaTuAUEANgIAQe8DIAFBiA8gAhAUGkGk7gEoAgAhAEGk7gFBADYCACAAQQFHBEAgAUGA9QBB8AMQDwALEAYhACABEBMgABAHAAsLjgEBAn8gAEHA9AA2AgBBpO4BQQA2AgBB7gMgAEEAEA1BpO4BKAIAIQFBpO4BQQA2AgAgAUEBRwRAIAAoAhwiASABKAIEQQFrIgI2AgQgAkF/RgRAIAEgASgCACgCCBECAAsgACgCIBDWAyAAKAIkENYDIAAoAjAQ1gMgACgCPBDWAyAADwtBABAfGhD5BwALDQAgABDIBBogABDWAwtAACAAQQA2AhQgACABNgIYIABBADYCDCAAQoKggIDgADcCBCAAIAFFNgIQIABBIGpBAEEoEM0DGiAAQRxqEPAGCx0AIAAgACgCEEEBcjYCECAALQAUQQFxBEAQMQALCwcAIAAQ1gMLRwECfyAAIAE3A3AgACAAKAIsIAAoAgQiA2usNwN4IAAoAgghAgJAIAFQDQAgAiADa6wgAVcNACADIAGnaiECCyAAIAI2AmgLjAICA38CfgJAIAApA3AiBEIAUiAEIAApA3ggACgCBCIBIAAoAiwiAmusfCIFV3FFBEAjAEEQayICJABBfyEBAkAgABDyAw0AIAAgAkEPakEBIAAoAiARBABBAUcNACACLQAPIQELIAJBEGokACABIgNBAE4NASAAKAIEIQEgACgCLCECCyAAQn83A3AgACABNgJoIAAgBSACIAFrrHw3A3hBfw8LIAVCAXwhBSAAKAIEIQEgACgCCCECAkAgACkDcCIEUA0AIAQgBX0iBCACIAFrrFkNACABIASnaiECCyAAIAI2AmggACAFIAAoAiwiACABa6x8NwN4IAAgAU8EQCABQQFrIAM6AAALIAMLCgAgAEEwa0EKSQtQAQF+AkAgA0HAAHEEQCABIANBQGqthiECQgAhAQwBCyADRQ0AIAIgA60iBIYgAUHAACADa62IhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAt/AgJ/AX4jAEEQayIDJAAgAAJ+IAFFBEBCAAwBCyADIAEgAUEfdSICcyACayICrUIAIAJnIgJB0QBqENAEIAMpAwhCgICAgICAwACFQZ6AASACa61CMIZ8IAFBgICAgHhxrUIghoQhBCADKQMACzcDACAAIAQ3AwggA0EQaiQAC1ABAX4CQCADQcAAcQRAIAIgA0FAaq2IIQFCACECDAELIANFDQAgAkHAACADa62GIAEgA60iBIiEIQEgAiAEiCECCyAAIAE3AwAgACACNwMIC8sKAgV/D34jAEHgAGsiBSQAIARC////////P4MhDCACIASFQoCAgICAgICAgH+DIQogAkL///////8/gyINQiCIIQ4gBEIwiKdB//8BcSEHAkACQCACQjCIp0H//wFxIglB//8Ba0GCgH5PBEAgB0H//wFrQYGAfksNAQsgAVAgAkL///////////8AgyILQoCAgICAgMD//wBUIAtCgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhCgwCCyADUCAEQv///////////wCDIgJCgICAgICAwP//AFQgAkKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCEKIAMhAQwCCyABIAtCgICAgICAwP//AIWEUARAIAIgA4RQBEBCgICAgICA4P//ACEKQgAhAQwDCyAKQoCAgICAgMD//wCEIQpCACEBDAILIAMgAkKAgICAgIDA//8AhYRQBEAgASALhCECQgAhASACUARAQoCAgICAgOD//wAhCgwDCyAKQoCAgICAgMD//wCEIQoMAgsgASALhFAEQEIAIQEMAgsgAiADhFAEQEIAIQEMAgsgC0L///////8/WARAIAVB0ABqIAEgDSABIA0gDVAiBht5IAZBBnStfKciBkEPaxDQBEEQIAZrIQYgBSkDWCINQiCIIQ4gBSkDUCEBCyACQv///////z9WDQAgBUFAayADIAwgAyAMIAxQIggbeSAIQQZ0rXynIghBD2sQ0AQgBiAIa0EQaiEGIAUpA0ghDCAFKQNAIQMLIANCD4YiC0KAgP7/D4MiAiABQiCIIgR+IhAgC0IgiCITIAFC/////w+DIgF+fCIPQiCGIhEgASACfnwiCyARVK0gAiANQv////8PgyINfiIVIAQgE358IhEgDEIPhiISIANCMYiEQv////8PgyIDIAF+fCIUIA8gEFStQiCGIA9CIIiEfCIPIAIgDkKAgASEIgx+IhYgDSATfnwiDiASQiCIQoCAgIAIhCICIAF+fCIQIAMgBH58IhJCIIZ8Ihd8IQEgByAJaiAGakH//wBrIQYCQCACIAR+IhggDCATfnwiBCAYVK0gBCAEIAMgDX58IgRWrXwgAiAMfnwgBCAEIBEgFVStIBEgFFatfHwiBFatfCADIAx+IgMgAiANfnwiAiADVK1CIIYgAkIgiIR8IAQgAkIghnwiAiAEVK18IAIgAiAQIBJWrSAOIBZUrSAOIBBWrXx8QiCGIBJCIIiEfCICVq18IAIgAiAPIBRUrSAPIBdWrXx8IgJWrXwiBEKAgICAgIDAAINCAFIEQCAGQQFqIQYMAQsgC0I/iCEDIARCAYYgAkI/iIQhBCACQgGGIAFCP4iEIQIgC0IBhiELIAMgAUIBhoQhAQsgBkH//wFOBEAgCkKAgICAgIDA//8AhCEKQgAhAQwBCwJ+IAZBAEwEQEEBIAZrIgdBgAFPBEBCACEBDAMLIAVBMGogCyABIAZB/wBqIgYQ0AQgBUEgaiACIAQgBhDQBCAFQRBqIAsgASAHENIEIAUgAiAEIAcQ0gQgBSkDMCAFKQM4hEIAUq0gBSkDICAFKQMQhIQhCyAFKQMoIAUpAxiEIQEgBSkDACECIAUpAwgMAQsgBEL///////8/gyAGrUIwhoQLIAqEIQogC1AgAUIAWSABQoCAgICAgICAgH9RG0UEQCAKIAJCAXwiASACVK18IQoMAQsgCyABQoCAgICAgICAgH+FhEIAUgRAIAIhAQwBCyAKIAIgAkIBg3wiASACVK18IQoLIAAgATcDACAAIAo3AwggBUHgAGokAAvMCQIEfwV+IwBB8ABrIgYkACAEQv///////////wCDIQkCQAJAIAFQIgUgAkL///////////8AgyIKQoCAgICAgMD//wB9QoCAgICAgMCAgH9UIApQG0UEQCADQgBSIAlCgICAgICAwP//AH0iC0KAgICAgIDAgIB/ViALQoCAgICAgMCAgH9RGw0BCyAFIApCgICAgICAwP//AFQgCkKAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEEIAEhAwwCCyADUCAJQoCAgICAgMD//wBUIAlCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhBAwCCyABIApCgICAgICAwP//AIWEUARAQoCAgICAgOD//wAgAiABIAOFIAIgBIVCgICAgICAgICAf4WEUCIFGyEEQgAgASAFGyEDDAILIAMgCUKAgICAgIDA//8AhYRQDQEgASAKhFAEQCADIAmEQgBSDQIgASADgyEDIAIgBIMhBAwCCyADIAmEQgBSDQAgASEDIAIhBAwBCyADIAEgASADVCAJIApWIAkgClEbIggbIQogBCACIAgbIgtC////////P4MhCSACIAQgCBsiAkIwiKdB//8BcSEHIAtCMIinQf//AXEiBUUEQCAGQeAAaiAKIAkgCiAJIAlQIgUbeSAFQQZ0rXynIgVBD2sQ0AQgBikDaCEJIAYpA2AhCkEQIAVrIQULIAEgAyAIGyEDIAJC////////P4MhBCAHRQRAIAZB0ABqIAMgBCADIAQgBFAiBxt5IAdBBnStfKciB0EPaxDQBEEQIAdrIQcgBikDWCEEIAYpA1AhAwsgBEIDhiADQj2IhEKAgICAgICABIQhASAJQgOGIApCPYiEIQQgAiALhSENAn4gA0IDhiICIAUgB0YNABogBSAHayIHQf8ASwRAQgAhAUIBDAELIAZBQGsgAiABQYABIAdrENAEIAZBMGogAiABIAcQ0gQgBikDOCEBIAYpAzAgBikDQCAGKQNIhEIAUq2ECyEJIARCgICAgICAgASEIQwgCkIDhiEKAkAgDUIAUwRAQgAhA0IAIQQgCSAKhSABIAyFhFANAiAKIAl9IQIgDCABfSAJIApWrX0iBEL/////////A1YNASAGQSBqIAIgBCACIAQgBFAiBxt5IAdBBnStfKdBDGsiBxDQBCAFIAdrIQUgBikDKCEEIAYpAyAhAgwBCyAJIAp8IgIgCVStIAEgDHx8IgRCgICAgICAgAiDUA0AIAlCAYMgBEI/hiACQgGIhIQhAiAFQQFqIQUgBEIBiCEECyALQoCAgICAgICAgH+DIQEgBUH//wFOBEAgAUKAgICAgIDA//8AhCEEQgAhAwwBC0EAIQcCQCAFQQBKBEAgBSEHDAELIAZBEGogAiAEIAVB/wBqENAEIAYgAiAEQQEgBWsQ0gQgBikDACAGKQMQIAYpAxiEQgBSrYQhAiAGKQMIIQQLIAKnQQdxIgVBBEutIARCPYYgAkIDiIQiAnwiAyACVK0gBEIDiEL///////8/gyAHrUIwhoQgAYR8IQQCQCAFQQRGBEAgBCADQgGDIgEgA3wiAyABVK18IQQMAQsgBUUNAQsLIAAgAzcDACAAIAQ3AwggBkHwAGokAAv6AQIDfgJ/IwBBEGsiBSQAAn4gAb0iA0L///////////8AgyICQoCAgICAgIAIfUL/////////7/8AWARAIAJCPIYhBCACQgSIQoCAgICAgICAPHwMAQsgAkKAgICAgICA+P8AWgRAIANCPIYhBCADQgSIQoCAgICAgMD//wCEDAELIAJQBEBCAAwBCyAFIAJCACADp2dBIGogAkIgiKdnIAJCgICAgBBUGyIGQTFqENAEIAUpAwAhBCAFKQMIQoCAgICAgMAAhUGM+AAgBmutQjCGhAshAiAAIAQ3AwAgACACIANCgICAgICAgICAf4OENwMIIAVBEGokAAs1ACAAIAE3AwAgACACQv///////z+DIARCMIinQYCAAnEgAkIwiKdB//8BcXKtQjCGhDcDCAtkAgF/AX4jAEEQayICJAAgAAJ+IAFFBEBCAAwBCyACIAGtQgAgAWciAUHRAGoQ0AQgAikDCEKAgICAgIDAAIVBnoABIAFrrUIwhnwhAyACKQMACzcDACAAIAM3AwggAkEQaiQAC0UBAX8jAEEQayIFJAAgBSABIAIgAyAEQoCAgICAgICAgH+FENQEIAUpAwAhASAAIAUpAwg3AwggACABNwMAIAVBEGokAAvEAgEBfyMAQdAAayIEJAACQCADQYCAAU4EQCAEQSBqIAEgAkIAQoCAgICAgID//wAQ0wQgBCkDKCECIAQpAyAhASADQf//AUkEQCADQf//AGshAwwCCyAEQRBqIAEgAkIAQoCAgICAgID//wAQ0wRB/f8CIAMgA0H9/wJOG0H+/wFrIQMgBCkDGCECIAQpAxAhAQwBCyADQYGAf0oNACAEQUBrIAEgAkIAQoCAgICAgIA5ENMEIAQpA0ghAiAEKQNAIQEgA0H0gH5LBEAgA0GN/wBqIQMMAQsgBEEwaiABIAJCAEKAgICAgICAORDTBEHogX0gAyADQeiBfUwbQZr+AWohAyAEKQM4IQIgBCkDMCEBCyAEIAEgAkIAIANB//8Aaq1CMIYQ0wQgACAEKQMINwMIIAAgBCkDADcDACAEQdAAaiQAC3UBAX4gACABIAR+IAIgA358IANCIIgiAiABQiCIIgR+fCADQv////8PgyIDIAFC/////w+DIgF+IgVCIIggAyAEfnwiA0IgiHwgASACfiADQv////8Pg3wiAUIgiHw3AwggACAFQv////8PgyABQiCGhDcDAAu+DwIFfw9+IwBB0AJrIgUkACAEQv///////z+DIQsgAkL///////8/gyEKIAIgBIVCgICAgICAgICAf4MhDSAEQjCIp0H//wFxIQgCQAJAIAJCMIinQf//AXEiCUH//wFrQYKAfk8EQCAIQf//AWtBgYB+Sw0BCyABUCACQv///////////wCDIgxCgICAgICAwP//AFQgDEKAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCENDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQ0gAyEBDAILIAEgDEKAgICAgIDA//8AhYRQBEAgAyACQoCAgICAgMD//wCFhFAEQEIAIQFCgICAgICA4P//ACENDAMLIA1CgICAgICAwP//AIQhDUIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQEIAIQEMAgsgASAMhFAEQEKAgICAgIDg//8AIA0gAiADhFAbIQ1CACEBDAILIAIgA4RQBEAgDUKAgICAgIDA//8AhCENQgAhAQwCCyAMQv///////z9YBEAgBUHAAmogASAKIAEgCiAKUCIGG3kgBkEGdK18pyIGQQ9rENAEQRAgBmshBiAFKQPIAiEKIAUpA8ACIQELIAJC////////P1YNACAFQbACaiADIAsgAyALIAtQIgcbeSAHQQZ0rXynIgdBD2sQ0AQgBiAHakEQayEGIAUpA7gCIQsgBSkDsAIhAwsgBUGgAmogC0KAgICAgIDAAIQiEkIPhiADQjGIhCICQgBCgICAgLDmvIL1ACACfSIEQgAQ2gQgBUGQAmpCACAFKQOoAn1CACAEQgAQ2gQgBUGAAmogBSkDmAJCAYYgBSkDkAJCP4iEIgRCACACQgAQ2gQgBUHwAWogBEIAQgAgBSkDiAJ9QgAQ2gQgBUHgAWog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QgGGIARCP4iEDAELIApCAYYgBEI/iIQLIQogBEIBhiEEIAZBAWsiBiAHSg0ACyAHIQYLAkAgCiAJfSADIARWrX0iCUIAUwRAIAohCQwBCyAJIAQgA30iBIRCAFINACAFQTBqIAEgAkIAQgAQ0wQgBSkDOCECIAUpAzAhBAwBCyAJQv///////z9YBEADQCAEQj+IIQEgBkEBayEGIARCAYYhBCABIAlCAYaEIglCgICAgICAwABUDQALCyAIQYCAAnEhByAGQQBMBEAgBUFAayAEIAlC////////P4MgBkH4AGogB3KtQjCGhEIAQoCAgICAgMDDPxDTBCAFKQNIIQIgBSkDQCEEDAELIAlC////////P4MgBiAHcq1CMIaEIQILIAAgBDcDACAAIAI3AwggBUGAAWokAAufMwMPfwd+AXwjAEEwayIMJAACQCACQQJNBEAgAkECdCICQfz1AGooAgAhDyACQfD1AGooAgAhDgNAAn8gASgCBCICIAEoAmhHBEAgASACQQFqNgIEIAItAAAMAQsgARDOBAsiAkEgRiACQQlrQQVJcg0AC0EBIQYCQAJAIAJBK2sOAwABAAELQX9BASACQS1GGyEGIAEoAgQiAiABKAJoRwRAIAEgAkEBajYCBCACLQAAIQIMAQsgARDOBCECCwJAAkADQCAFQZkIaiwAACACQSByRgRAAkAgBUEGSw0AIAEoAgQiAiABKAJoRwRAIAEgAkEBajYCBCACLQAAIQIMAQsgARDOBCECCyAFQQFqIgVBCEcNAQwCCwsgBUEDRwRAIAVBCEYNASADRQ0CIAVBBEkNAiAFQQhGDQELIAEpA3AiE0IAWQRAIAEgASgCBEEBazYCBAsgA0UNACAFQQRJDQAgE0IAUyECA0AgAkUEQCABIAEoAgRBAWs2AgQLIAVBAWsiBUEDSw0ACwtCACETIwBBEGsiAiQAAn4gBrJDAACAf5S8IgNB/////wdxIgFBgICABGtB////9wdNBEAgAa1CGYZCgICAgICAgMA/fAwBCyADrUIZhkKAgICAgIDA//8AhCABQYCAgPwHTw0AGkIAIAFFDQAaIAIgAa1CACABZyIBQdEAahDQBCACKQMAIRMgAikDCEKAgICAgIDAAIVBif8AIAFrrUIwhoQLIRQgDCATNwMAIAwgFCADQYCAgIB4ca1CIIaENwMIIAJBEGokACAMKQMIIRMgDCkDACEUDAILAkACQAJAIAUNAEEAIQUDQCAFQYIRaiwAACACQSByRw0BAkAgBUEBSw0AIAEoAgQiAiABKAJoRwRAIAEgAkEBajYCBCACLQAAIQIMAQsgARDOBCECCyAFQQFqIgVBA0cNAAsMAQsCQAJAIAUOBAABAQIBCwJAIAJBMEcNAAJ/IAEoAgQiBSABKAJoRwRAIAEgBUEBajYCBCAFLQAADAELIAEQzgQLQV9xQdgARgRAIwBBsANrIgIkAAJ/IAEoAgQiBSABKAJoRwRAIAEgBUEBajYCBCAFLQAADAELIAEQzgQLIQUCQAJ/A0AgBUEwRwRAAkAgBUEuRw0EIAEoAgQiBSABKAJoRg0AIAEgBUEBajYCBCAFLQAADAMLBSABKAIEIgUgASgCaEcEf0EBIQogASAFQQFqNgIEIAUtAAAFQQEhCiABEM4ECyEFDAELCyABEM4ECyEFQQEhBCAFQTBHDQADQCAWQgF9IRYCfyABKAIEIgUgASgCaEcEQCABIAVBAWo2AgQgBS0AAAwBCyABEM4ECyIFQTBGDQALQQEhCgtCgICAgICAwP8/IRQDQAJAIAVBIHIhCwJAAkAgBUEwayIIQQpJDQAgBUEuRyALQeEAa0EGT3ENAiAFQS5HDQAgBA0CQQEhBCATIRYMAQsgC0HXAGsgCCAFQTlKGyEFAkAgE0IHVwRAIAUgCUEEdGohCQwBCyATQhxYBEAgAkEwaiAFENEEIAJBIGogGCAUQgBCgICAgICAwP0/ENMEIAJBEGogAikDMCACKQM4IAIpAyAiGCACKQMoIhQQ0wQgAiACKQMQIAIpAxggFSAXENQEIAIpAwghFyACKQMAIRUMAQsgBUUNACAHDQAgAkHQAGogGCAUQgBCgICAgICAgP8/ENMEIAJBQGsgAikDUCACKQNYIBUgFxDUBCACKQNIIRdBASEHIAIpA0AhFQsgE0IBfCETQQEhCgsgASgCBCIFIAEoAmhHBH8gASAFQQFqNgIEIAUtAAAFIAEQzgQLIQUMAQsLAn4gCkUEQAJAAkAgASkDcEIAWQRAIAEgASgCBCIFQQFrNgIEIANFDQEgASAFQQJrNgIEIARFDQIgASAFQQNrNgIEDAILIAMNAQsgAUIAEM0ECyACQeAAaiAGt0QAAAAAAAAAAKIQ1QQgAikDYCEVIAIpA2gMAQsgE0IHVwRAIBMhFANAIAlBBHQhCSAUQgF8IhRCCFINAAsLAkACQAJAIAVBX3FB0ABGBEAgASADEN4EIhRCgICAgICAgICAf1INAyADBEAgASkDcEIAWQ0CDAMLQgAhFSABQgAQzQRCAAwEC0IAIRQgASkDcEIAUw0CCyABIAEoAgRBAWs2AgQLQgAhFAsgCUUEQCACQfAAaiAGt0QAAAAAAAAAAKIQ1QQgAikDcCEVIAIpA3gMAQsgFiATIAQbQgKGIBR8QiB9IhNBACAPa61VBEBBsOoBQcQANgIAIAJBoAFqIAYQ0QQgAkGQAWogAikDoAEgAikDqAFCf0L///////+///8AENMEIAJBgAFqIAIpA5ABIAIpA5gBQn9C////////v///ABDTBCACKQOAASEVIAIpA4gBDAELIA9B4gFrrCATVwRAIAlBAE4EQANAIAJBoANqIBUgF0IAQoCAgICAgMD/v38Q1AQgFSAXQoCAgICAgID/PxDeAyEBIAJBkANqIBUgFyAVIAIpA6ADIAFBAEgiAxsgFyACKQOoAyADGxDUBCATQgF9IRMgAikDmAMhFyACKQOQAyEVIAlBAXQgAUEATnIiCUEATg0ACwsCfiATIA+sfUIgfCIUpyIBQQAgAUEAShsgDiAUIA6tUxsiAUHxAE4EQCACQYADaiAGENEEIAIpA4gDIRYgAikDgAMhGEIADAELIAJB4AJqRAAAAAAAAPA/QZABIAFrENIDENUEIAJB0AJqIAYQ0QQgAkHwAmogAikD4AIgAikD6AIgAikD0AIiGCACKQPYAiIWENYEIAIpA/gCIRkgAikD8AILIRQgAkHAAmogCSAJQQFxRSAVIBdCAEIAEN0DQQBHIAFBIEhxcSIBahDXBCACQbACaiAYIBYgAikDwAIgAikDyAIQ0wQgAkGQAmogAikDsAIgAikDuAIgFCAZENQEIAJBoAJqIBggFkIAIBUgARtCACAXIAEbENMEIAJBgAJqIAIpA6ACIAIpA6gCIAIpA5ACIAIpA5gCENQEIAJB8AFqIAIpA4ACIAIpA4gCIBQgGRDYBCACKQPwASIUIAIpA/gBIhZCAEIAEN0DRQRAQbDqAUHEADYCAAsgAkHgAWogFCAWIBOnENkEIAIpA+ABIRUgAikD6AEMAQtBsOoBQcQANgIAIAJB0AFqIAYQ0QQgAkHAAWogAikD0AEgAikD2AFCAEKAgICAgIDAABDTBCACQbABaiACKQPAASACKQPIAUIAQoCAgICAgMAAENMEIAIpA7ABIRUgAikDuAELIRMgDCAVNwMQIAwgEzcDGCACQbADaiQAIAwpAxghEyAMKQMQIRQMBgsgASkDcEIAUw0AIAEgASgCBEEBazYCBAsgASEFIAYhCSADIQpBACEDQQAhBiMAQZDGAGsiBCQAQQAgD2siECAOayESAkACfwNAIAJBMEcEQAJAIAJBLkcNBCAFKAIEIgEgBSgCaEYNACAFIAFBAWo2AgQgAS0AAAwDCwUgBSgCBCIBIAUoAmhHBH9BASEDIAUgAUEBajYCBCABLQAABUEBIQMgBRDOBAshAgwBCwsgBRDOBAshAkEBIQcgAkEwRw0AA0AgE0IBfSETAn8gBSgCBCIBIAUoAmhHBEAgBSABQQFqNgIEIAEtAAAMAQsgBRDOBAsiAkEwRg0AC0EBIQMLIARBADYCkAYgAkEwayEIIAwCfgJAAkACQAJAAkACQAJAIAJBLkYiAQ0AIAhBCU0NAAwBCwNAAkAgAUEBcQRAIAdFBEAgFCETQQEhBwwCCyADRSEBDAQLIBRCAXwhFCAGQfwPTARAIA0gFKcgAkEwRhshDSAEQZAGaiAGQQJ0aiIBIAsEfyACIAEoAgBBCmxqQTBrBSAICzYCAEEBIQNBACALQQFqIgEgAUEJRiIBGyELIAEgBmohBgwBCyACQTBGDQAgBCAEKAKARkEBcjYCgEZB3I8BIQ0LAn8gBSgCBCIBIAUoAmhHBEAgBSABQQFqNgIEIAEtAAAMAQsgBRDOBAsiAkEwayEIIAJBLkYiAQ0AIAhBCkkNAAsLIBMgFCAHGyETAkAgA0UNACACQV9xQcUARw0AAkAgBSAKEN4EIhVCgICAgICAgICAf1INACAKRQ0FQgAhFSAFKQNwQgBTDQAgBSAFKAIEQQFrNgIECyADRQ0DIBMgFXwhEwwFCyADRSEBIAJBAEgNAQsgBSkDcEIAUw0AIAUgBSgCBEEBazYCBAsgAUUNAgtBsOoBQRw2AgALQgAhFCAFQgAQzQRCAAwBCyAEKAKQBiIBRQRAIAQgCbdEAAAAAAAAAACiENUEIAQpAwAhFCAEKQMIDAELAkAgFEIJVQ0AIBMgFFINACAOQR5MQQAgASAOdhsNACAEQTBqIAkQ0QQgBEEgaiABENcEIARBEGogBCkDMCAEKQM4IAQpAyAgBCkDKBDTBCAEKQMQIRQgBCkDGAwBCyAQQQF2rSATUwRAQbDqAUHEADYCACAEQeAAaiAJENEEIARB0ABqIAQpA2AgBCkDaEJ/Qv///////7///wAQ0wQgBEFAayAEKQNQIAQpA1hCf0L///////+///8AENMEIAQpA0AhFCAEKQNIDAELIA9B4gFrrCATVQRAQbDqAUHEADYCACAEQZABaiAJENEEIARBgAFqIAQpA5ABIAQpA5gBQgBCgICAgICAwAAQ0wQgBEHwAGogBCkDgAEgBCkDiAFCAEKAgICAgIDAABDTBCAEKQNwIRQgBCkDeAwBCyALBEAgC0EITARAIARBkAZqIAZBAnRqIgEoAgAhBQNAIAVBCmwhBSALQQFqIgtBCUcNAAsgASAFNgIACyAGQQFqIQYLIBOnIQcCQCANQQlODQAgByANSA0AIAdBEUoNACAHQQlGBEAgBEHAAWogCRDRBCAEQbABaiAEKAKQBhDXBCAEQaABaiAEKQPAASAEKQPIASAEKQOwASAEKQO4ARDTBCAEKQOgASEUIAQpA6gBDAILIAdBCEwEQCAEQZACaiAJENEEIARBgAJqIAQoApAGENcEIARB8AFqIAQpA5ACIAQpA5gCIAQpA4ACIAQpA4gCENMEIARB4AFqQQAgB2tBAnRB8PUAaigCABDRBCAEQdABaiAEKQPwASAEKQP4ASAEKQPgASAEKQPoARDbBCAEKQPQASEUIAQpA9gBDAILIA4gB0F9bGpBG2oiAUEeTEEAIAQoApAGIgIgAXYbDQAgBEHgAmogCRDRBCAEQdACaiACENcEIARBwAJqIAQpA+ACIAQpA+gCIAQpA9ACIAQpA9gCENMEIARBsAJqIAdBAnRBqPUAaigCABDRBCAEQaACaiAEKQPAAiAEKQPIAiAEKQOwAiAEKQO4AhDTBCAEKQOgAiEUIAQpA6gCDAELA0AgBEGQBmogBiICQQFrIgZBAnRqKAIARQ0AC0EAIQsCQCAHQQlvIgNFBEBBACEBDAELQQAhASADQQlqIAMgB0EASBshAwJAIAJFBEBBACECDAELQYCU69wDQQAgA2tBAnRB8PUAaigCACIGbSEKQQAhCEEAIQUDQCAEQZAGaiAFQQJ0aiINIAggDSgCACINIAZuIhBqIgg2AgAgAUEBakH/D3EgASAIRSABIAVGcSIIGyEBIAdBCWsgByAIGyEHIAogDSAGIBBsa2whCCAFQQFqIgUgAkcNAAsgCEUNACAEQZAGaiACQQJ0aiAINgIAIAJBAWohAgsgByADa0EJaiEHCwNAIARBkAZqIAFBAnRqIQUCQANAIAdBJE4EQCAHQSRHDQIgBSgCAEHR6fkETw0CCyACQf8PaiEDQQAhCANAIAitIARBkAZqIANB/w9xIgZBAnRqIgM1AgBCHYZ8IhNCgZTr3ANUBH9BAAUgEyATQoCU69wDgCIUQoCU69wDfn0hEyAUpwshCCADIBOnIgM2AgAgAiACIAIgBiADGyABIAZGGyAGIAJBAWtB/w9xRxshAiAGQQFrIQMgASAGRw0ACyALQR1rIQsgCEUNAAsgAiABQQFrQf8PcSIBRgRAIARBkAZqIgMgAkH+D2pB/w9xQQJ0aiIGIAYoAgAgAkEBa0H/D3EiAkECdCADaigCAHI2AgALIAdBCWohByAEQZAGaiABQQJ0aiAINgIADAELCwJAA0AgAkEBakH/D3EhBiAEQZAGaiACQQFrQf8PcUECdGohCANAQQlBASAHQS1KGyEKAkADQCABIQNBACEFAkADQAJAIAMgBWpB/w9xIgEgAkYNACAEQZAGaiABQQJ0aigCACIBIAVBAnRBwPUAaigCACINSQ0AIAEgDUsNAiAFQQFqIgVBBEcNAQsLIAdBJEcNAEIAIRNBACEFQgAhFANAIAIgAyAFakH/D3EiAUYEQCACQQFqQf8PcSICQQJ0IARqQQA2AowGCyAEQYAGaiAEQZAGaiABQQJ0aigCABDXBCAEQfAFaiATIBRCAEKAgICA5Zq3jsAAENMEIARB4AVqIAQpA/AFIAQpA/gFIAQpA4AGIAQpA4gGENQEIAQpA+gFIRQgBCkD4AUhEyAFQQFqIgVBBEcNAAsgBEHQBWogCRDRBCAEQcAFaiATIBQgBCkD0AUgBCkD2AUQ0wQgBCkDyAUhFEIAIRMgBCkDwAUhFSALQfEAaiIHIA9rIgZBACAGQQBKGyAOIAYgDkgiBRsiAUHwAEwNAgwFCyAKIAtqIQsgAyACIgFGDQALQYCU69wDIAp2IQ1BfyAKdEF/cyEQQQAhBSADIQEDQCAEQZAGaiADQQJ0aiIRIAUgESgCACIRIAp2aiIFNgIAIAFBAWpB/w9xIAEgBUUgASADRnEiBRshASAHQQlrIAcgBRshByAQIBFxIA1sIQUgA0EBakH/D3EiAyACRw0ACyAFRQ0BIAEgBkcEQCAEQZAGaiACQQJ0aiAFNgIAIAYhAgwDCyAIIAgoAgBBAXI2AgAMAQsLCyAEQZAFakQAAAAAAADwP0HhASABaxDSAxDVBCAEQbAFaiAEKQOQBSAEKQOYBSAVIBQQ1gQgBCkDuAUhGCAEKQOwBSEXIARBgAVqRAAAAAAAAPA/QfEAIAFrENIDENUEIARBoAVqIBUgFCAEKQOABSAEKQOIBRDcBCAEQfAEaiAVIBQgBCkDoAUiEyAEKQOoBSIWENgEIARB4ARqIBcgGCAEKQPwBCAEKQP4BBDUBCAEKQPoBCEUIAQpA+AEIRULAkAgA0EEakH/D3EiCiACRg0AAkAgBEGQBmogCkECdGooAgAiCkH/ybXuAU0EQCAKRSADQQVqQf8PcSACRnENASAEQfADaiAJt0QAAAAAAADQP6IQ1QQgBEHgA2ogEyAWIAQpA/ADIAQpA/gDENQEIAQpA+gDIRYgBCkD4AMhEwwBCyAKQYDKte4BRwRAIARB0ARqIAm3RAAAAAAAAOg/ohDVBCAEQcAEaiATIBYgBCkD0AQgBCkD2AQQ1AQgBCkDyAQhFiAEKQPABCETDAELIAm3IRogAiADQQVqQf8PcUYEQCAEQZAEaiAaRAAAAAAAAOA/ohDVBCAEQYAEaiATIBYgBCkDkAQgBCkDmAQQ1AQgBCkDiAQhFiAEKQOABCETDAELIARBsARqIBpEAAAAAAAA6D+iENUEIARBoARqIBMgFiAEKQOwBCAEKQO4BBDUBCAEKQOoBCEWIAQpA6AEIRMLIAFB7wBKDQAgBEHQA2ogEyAWQgBCgICAgICAwP8/ENwEIAQpA9ADIAQpA9gDQgBCABDdAw0AIARBwANqIBMgFkIAQoCAgICAgMD/PxDUBCAEKQPIAyEWIAQpA8ADIRMLIARBsANqIBUgFCATIBYQ1AQgBEGgA2ogBCkDsAMgBCkDuAMgFyAYENgEIAQpA6gDIRQgBCkDoAMhFQJAIBJBAmsgB0H/////B3FODQAgBCAUQv///////////wCDNwOYAyAEIBU3A5ADIARBgANqIBUgFEIAQoCAgICAgID/PxDTBCAEKQOQAyAEKQOYA0KAgICAgICAuMAAEN4DIQIgFCAEKQOIAyACQQBIIgMbIRQgFSAEKQOAAyADGyEVIBMgFkIAQgAQ3QNBAEcgBSAFIAEgBkdxIAMbcUUgEiALIAJBAE5qIgtB7gBqTnENAEGw6gFBxAA2AgALIARB8AJqIBUgFCALENkEIAQpA/ACIRQgBCkD+AILNwMoIAwgFDcDICAEQZDGAGokACAMKQMoIRMgDCkDICEUDAQLIAEpA3BCAFkEQCABIAEoAgRBAWs2AgQLDAELAkACfyABKAIEIgIgASgCaEcEQCABIAJBAWo2AgQgAi0AAAwBCyABEM4EC0EoRgRAQQEhBQwBC0KAgICAgIDg//8AIRMgASkDcEIAUw0DIAEgASgCBEEBazYCBAwDCwNAAn8gASgCBCICIAEoAmhHBEAgASACQQFqNgIEIAItAAAMAQsgARDOBAsiAkHBAGshBgJAAkAgAkEwa0EKSQ0AIAZBGkkNACACQd8ARg0AIAJB4QBrQRpPDQELIAVBAWohBQwBCwtCgICAgICA4P//ACETIAJBKUYNAiABKQNwIhZCAFkEQCABIAEoAgRBAWs2AgQLAkAgAwRAIAUNAQwECwwBCwNAIAVBAWshBSAWQgBZBEAgASABKAIEQQFrNgIECyAFDQALDAILQbDqAUEcNgIAIAFCABDNBAtCACETCyAAIBQ3AwAgACATNwMIIAxBMGokAAuRBAIEfwF+AkACQAJAAkACQAJ/IAAoAgQiAiAAKAJoRwRAIAAgAkEBajYCBCACLQAADAELIAAQzgQLIgJBK2sOAwABAAELIAJBLUYhBQJ/IAAoAgQiAyAAKAJoRwRAIAAgA0EBajYCBCADLQAADAELIAAQzgQLIgNBOmshBCABRQ0BIARBdUsNASAAKQNwQgBTDQIgACAAKAIEQQFrNgIEDAILIAJBOmshBCACIQMLIARBdkkNACADQTBrIgRBCkkEQEEAIQIDQCADIAJBCmxqIQECfyAAKAIEIgIgACgCaEcEQCAAIAJBAWo2AgQgAi0AAAwBCyAAEM4ECyIDQTBrIgRBCU0gAUEwayICQcyZs+YASHENAAsgAqwhBgsCQCAEQQpPDQADQCADrSAGQgp+fEIwfSEGAn8gACgCBCIBIAAoAmhHBEAgACABQQFqNgIEIAEtAAAMAQsgABDOBAsiA0EwayIEQQlLDQEgBkKuj4XXx8LrowFTDQALCyAEQQpJBEADQAJ/IAAoAgQiASAAKAJoRwRAIAAgAUEBajYCBCABLQAADAELIAAQzgQLQTBrQQpJDQALCyAAKQNwQgBZBEAgACAAKAIEQQFrNgIEC0IAIAZ9IAYgBRshBgwBC0KAgICAgICAgIB/IQYgACkDcEIAUw0AIAAgACgCBEEBazYCBEKAgICAgICAgIB/DwsgBgu2AwIDfwF+IwBBIGsiAyQAAkAgAUL///////////8AgyIFQoCAgICAgMDAP30gBUKAgICAgIDAv8AAfVQEQCABQhmIpyEEIABQIAFC////D4MiBUKAgIAIVCAFQoCAgAhRG0UEQCAEQYGAgIAEaiECDAILIARBgICAgARqIQIgACAFQoCAgAiFhEIAUg0BIAIgBEEBcWohAgwBCyAAUCAFQoCAgICAgMD//wBUIAVCgICAgICAwP//AFEbRQRAIAFCGYinQf///wFxQYCAgP4HciECDAELQYCAgPwHIQIgBUL///////+/v8AAVg0AQQAhAiAFQjCIpyIEQZH+AEkNACADQRBqIAAgAUL///////8/g0KAgICAgIDAAIQiBSAEQYH+AGsQ0AQgAyAAIAVBgf8AIARrENIEIAMpAwgiAEIZiKchAiADKQMAIAMpAxAgAykDGIRCAFKthCIFUCAAQv///w+DIgBCgICACFQgAEKAgIAIURtFBEAgAkEBaiECDAELIAUgAEKAgIAIhYRCAFINACACQQFxIAJqIQILIANBIGokACACIAFCIIinQYCAgIB4cXK+C9MDAgJ+An8jAEEgayIEJAACQCABQv///////////wCDIgNCgICAgICAwIA8fSADQoCAgICAgMD/wwB9VARAIAFCBIYgAEI8iIQhAyAAQv//////////D4MiAEKBgICAgICAgAhaBEAgA0KBgICAgICAgMAAfCECDAILIANCgICAgICAgIBAfSECIABCgICAgICAgIAIUg0BIAIgA0IBg3whAgwBCyAAUCADQoCAgICAgMD//wBUIANCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQIMAQtCgICAgICAgPj/ACECIANC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KAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACEPYECw8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAAuDAQIDfwF+AkAgAEKAgICAEFQEQCAAIQUMAQsDQCABQQFrIgEgACAAQgqAIgVCCn59p0EwcjoAACAAQv////+fAVYhAiAFIQAgAg0ACwsgBaciAgRAA0AgAUEBayIBIAIgAkEKbiIDQQpsa0EwcjoAACACQQlLIQQgAyECIAQNAAsLIAELcgEBfyMAQYACayIFJAACQCACIANMDQAgBEGAwARxDQAgBSABQf8BcSACIANrIgNBgAIgA0GAAkkiARsQzQMaIAFFBEADQCAAIAVBgAIQ7wQgA0GAAmsiA0H/AUsNAAsLIAAgBSADEO8ECyAFQYACaiQAC80CAQN/IwBB0AFrIgMkACADIAI2AswBIANBoAFqIgJBAEEoEM0DGiADIAMoAswBNgLIAQJAQQAgASADQcgBaiADQdAAaiACEO4EQQBIBEBBfyEADAELIAAoAkxBAE4hBSAAKAIAIQIgACgCSEEATARAIAAgAkFfcTYCAAsCfwJAAkAgACgCMEUEQCAAQdAANgIwIABBADYCHCAAQgA3AxAgACgCLCEEIAAgAzYCLAwBCyAAKAIQDQELQX8gABDzAw0BGgsgACABIANByAFqIANB0ABqIANBoAFqEO4ECyEBIAQEQCAAQQBBACAAKAIkEQQAGiAAQQA2AjAgACAENgIsIABBADYCHCAAKAIUIQQgAEIANwMQIAFBfyAEGyEBCyAAIAAoAgAiACACQSBxcjYCAEF/IAEgAEEgcRshACAFRQ0ACyADQdABaiQAIAALuhgDEX8BfAJ+IwBBsARrIgskACALQQA2AiwCQCABvSIYQgBTBEBBASERQZEKIRMgAZoiAb0hGAwBCyAEQYAQcQRAQQEhEUGU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IAAgAigCCDYCFCACQRBqJAAgACAEIAAoAhAgBGtqNgIMIAAgACgCFDYCCCAGIAAoAgw2AgggBiAAKAIINgIMIABBIGokACAGKAIMIQAgBkEQaiQAIAMkACAAC1EBAn9BCBAOIQFBpO4BQQA2AgBBvwQgASAAEAUhAEGk7gEoAgAhAkGk7gFBADYCACACQQFHBEAgAEH85wFBwAQQDwALEAYhACABEBMgABAHAAsFAEH/AAsIACAAEKIEGgtdAQF/IwBBEGsiAiQAIwBBEGsiASQAIAAgAC0AC0GAAXFBAXI6AAsgACAALQALQf8AcToACyAAQQFBLRDoByABQQA6AAcgACABLQAHOgABIAFBEGokACACQRBqJAALDAAgAEGChoAgNgAACwgAQf////8HCwwAIABBAUEtEO0FGgufAgEEfyMAQRBrIgQkAAJAIAEtAAtBB3ZFBEAgACABKAIINgIIIAAgASkCADcCAAwBCyABKAIAIQUgASgCBCECIwBBEGsiAyQAAkACQAJAIAJBC0kEQCAAIgEgAS0AC0GAAXEgAnI6AAsgASABLQALQf8AcToACwwBCyACQe////8HSw0BIANBCGogACACQQtPBH8gAkEQakFwcSIBIAFBAWsiASABQQtGGwVBCgtBAWoQuQQgAygCDBogACADKAIIIgE2AgAgACAAKAIIQYCAgIB4cSADKAIMQf////8HcXI2AgggACAAKAIIQYCAgIB4cjYCCCAAIAI2AgQLIAEgBSACQQFqEP0DIANBEGokAAwBCxCrAgALCyAEQRBqJAALjAcBAn8jAEGgAmsiACQAIAAgAjYCkAIgACABNgKYAiAAQcIENgIQIABBmAFqIABBoAFqIABBEGoQlwUhAUGk7gFBADYCACAAIAQoAhwiBzYCkAEgByAHKAIEQQFqNgIEQaTuASgCACEHQaTuAUEANgIAAkACQAJAAkACQAJAAn8CQAJAAkAgB0EBRwRAQaTuAUEANgIAQcQDIABBkAFqEAwhB0Gk7gEoAgAhCEGk7gFBADYCACAIQQFGDQEgAEEAOgCPASAEKAIEIQRBpO4BQQA2AgBBwwQgAEGYAmogAiADIABBkAFqIAQgBSAAQY8BaiAHIAEgAEGUAWogAEGEAmoQOyECQaTuASgCACEDQaTuAUEANgIAIANBAUYNBiACRQ0FIABB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RQRAQbjzAUGKIxDBBBpBxPMBQQE6AAALQbjzAQsKAEG48wEQ5gcaCyUAQdTzAS0AAEUEQEHI8wFB5KMBEKoHQdTzAUEBOgAAC0HI8wELCgBByPMBEO4HGgslAEHk8wEtAABFBEBB2PMBQb0PEMEEGkHk8wFBAToAAAtB2PMBCwoAQdjzARDmBxoLJQBB9PMBLQAARQRAQejzAUG4pAEQqgdB9PMBQQE6AAALQejzAQsKAEHo8wEQ7gcaCwoAIAAQzAcQ1gMLfQEDfyAAKAIIIQFBpO4BQQA2AgBBmwQQECECQaTuASgCACEDQaTuAUEANgIAAkACQCADQQFGDQAgASACRwRAIAAoAgghAUGk7gFBADYCACABEP0EQaTuASgCACEBQaTuAUEANgIAIAFBAUYNAQsMAQtBABAfGhD5BwALIAALGQAgASACEM4HIQEgACACNgIEIAAgATYCAAscACABQf////8DSwRAEO0BAAsgAUECdEEEELoECzEBAX8jAEEQayIDJAAgACACEJwGIANBADoADyABIAJqIAMtAA86AAAgA0EQaiQAIAALCwAgACABIAIQ0QcLPQBBpO4BQQA2AgBBzwMgASACQQJ0QQQQCkGk7gEoAgAhAEGk7gFBADYCACAAQQFHBEAPC0EAEB8aEPkHAAs8AQF/IwBBEGsiAyQAIAMgARDTBzYCDCADIAIQ0wc2AgggACADKAIMNgIAIAAgAygCCDYCBCADQRBqJAALQgECfyMAQRBrIgEkACABIAA2AgggASgCCCECIwBBEGsiACQAIAAgAjYCCCAAKAIIIQIgAEEQaiQAIAFBEGokACACC5ABAQR/IwBBEGsiACQAIABB/////wM2AgxBpO4BQQA2AgAgAEH/////BzYCCCMAQRBrIgEkACAAQQhqIgIoAgAgAEEMaiIDKAIASSEEIAFBEGokACACIAMgBBshAUGk7gEoAgAhAkGk7gFBADYCACACQQFHBEAgASgCACEBIABBEGokACABDwtBABAfGhD5BwALSwEBfyMAQRBrIgMkAAJAAkAgAkEeSw0AIAEtAHgNACABQQE6AHgMAQsgA0EIaiACEM4HIQELIANBEGokACAAIAI2AgQgACABNgIACwkAIAFBADYCAAtRAQJ/IAAoAgQhAgJAA0AgASACRg0BQaTuAUEANgIAIAJBBGsh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Q29tcGxleFNwYXJzZU1hdHJpeABDb21wbGV4RGVuc2VNYXRyaXgAc3ViTWF0cml4AHRpbWVzQ29tcGxleAAtKyAgIDBYMHgALTBYKzBYIDBYLTB4KzB4IDB4AFNwYXJzZVNlbGZBZGpvaW50VmlldwBOb3YAbHUAVGh1AEF1Z3VzdABzdGQ6OmJhZF9jYXN0AHVuc2lnbmVkIHNob3J0AGluc2VydABkb3QAdW5zaWduZWQgaW50AGNvbnN0YW50AGFwcGx5VHJhbnNwb3NpdGlvbk9uVGhlUmlnaHQAc2V0AENvbXBsZXhUcmlwbGV0AGdldABhc3NpZ25Qcm9kdWN0AE9jdABmbG9hdAB2Y2F0AGhjYXQAU2F0AHVpbnQ2NF90AG5Sb3dzAG1pbnVzAHBsdXMAc2V0X2Zyb21fdHJpcGxldHMAZHN0LnJvd3MoKSA9PSBkc3RSb3dzICYmIGRzdC5jb2xzKCkgPT0gZHN0Q29scwBuQ29scwBzdGFydFJvdyA+PSAwICYmIGJsb2NrUm93cyA+PSAwICYmIHN0YXJ0Um93IDw9IHhwci5yb3dzKCkgLSBibG9ja1Jvd3MgJiYgc3RhcnRDb2wgPj0gMCAmJiBibG9ja0NvbHMgPj0gMCAmJiBzdGFydENvbCA8PSB4cHIuY29scygpIC0gYmxvY2tDb2xzAGNvbGxhcHNlRHVwbGljYXRlcwBvbmVzAHFyAEFwcgB2ZWN0b3IAdW5zcGVjaWZpZWQgaW9zdHJlYW1fY2F0ZWdvcnkgZXJyb3IAbW9uZXlfZ2V0IGVycm9yAGJsYXNfZGF0YV9tYXBwZXIAaW5zZXJ0QmFja0J5T3V0ZXJJbm5lcgBPY3RvYmVyAE5vdmVtYmVyAFNlcHRlbWJlcgBEZWNlbWJlcgB1bnNpZ25lZCBjaGFyAGlvc19iYXNlOjpjbGVhcgBNYXIAU2VwAEN3aXNlQmluYXJ5T3AAQ3dpc2VOdWxsYXJ5T3AAJUk6JU06JVMgJXAAaW5mbwBldmFsVG8Ac2NhbGVBbmRBZGRUbwBydW4AU3VuAEp1bgBhbmFseXplUGF0dGVybgBzdGQ6OmV4Y2VwdGlvbgB0ZXJtaW5hdGVfaGFuZGxlciB1bmV4cGVjdGVkbHkgdGhyZXcgYW4gZXhjZXB0aW9uAEVtcHR5IHJvdyBmb3VuZCBkdXJpbmcgbnVtZXJpY2FsIGZhY3Rvcml6YXRpb24AY29sc1Blcm11dGF0aW9uAE1vbgBuYW4ASmFuAHN1bQBub3JtAGZyb2Jlbml1c05vcm0AcmFuZG9tAGlvc3RyZWFtAEp1bABjb25zZXJ2YXRpdmVfc3BhcnNlX3NwYXJzZV9wcm9kdWN0X2ltcGwAX3NvbHZlX2ltcGwAYm9vbABjaG9sAGxsAEFwcmlsAGVtc2NyaXB0ZW46OnZhbAByZWFsAHRpbWVzUmVhbAByYW5rAEJsb2NrAEZyaQBpdCAmJiBpdC5pbmRleCgpPT1pAGJhZF9hcnJheV9uZXdfbGVuZ3RoAE1hcmNoAGMrKy9laWdlbi9FaWdlbi9zcmMvU3BhcnNlQ2hvbGVza3kvU2ltcGxpY2lhbENob2xlc2t5LmgAYysrL2VpZ2VuL0VpZ2VuL3NyYy9TcGFyc2VDb3JlL1NwYXJzZVJlZHV4LmgAYysrL2VpZ2VuL0VpZ2VuL3NyYy9Db3JlL1JlZHV4LmgAYysrL2VpZ2VuL0VpZ2VuL3NyYy9Db3JlL3Byb2R1Y3RzL0dlbmVyYWxNYXRyaXhNYXRyaXguaABjKysvZWlnZW4vRWlnZW4vc3JjL0NvcmUvUGVybXV0YXRpb25NYXRyaXguaABjKysvZWlnZW4vRWlnZW4vc3JjL1NwYXJzZUNvcmUvU3BhcnNlTWF0cml4LmgAYysrL2VpZ2VuL0VpZ2VuL3NyYy9TcGFyc2VDb3JlL1NwYXJzZVNlbGZBZGpvaW50Vmlldy5oAGMrKy9laWdlbi9FaWdlbi9zcmMvU3BhcnNlQ29yZS9TcGFyc2VEb3QuaABjKysvZWlnZW4vRWlnZW4vc3JjL0NvcmUvRG90LmgAYysrL2VpZ2VuL0VpZ2VuL3NyYy9TcGFyc2VDb3JlL0NvbnNlcnZhdGl2ZVNwYXJzZVNwYXJzZVByb2R1Y3QuaABjKysvZWlnZW4vRWlnZW4vc3JjL0NvcmUvUHJvZHVjdC5oAGMrKy9laWdlbi9FaWdlbi9zcmMvQ29yZS9Qcm9kdWN0RXZhbHVhdG9ycy5oAGMrKy9laWdlbi9FaWdlbi9zcmMvQ29yZS9NYXRoRnVuY3Rpb25zLmgAYysrL2VpZ2VuL0VpZ2VuL3NyYy9Db3JlL1Zpc2l0b3IuaABjKysvZWlnZW4vRWlnZW4vc3JjL0NvcmUvQXNzaWduRXZhbHVhdG9yLmgAYysrL2VpZ2VuL0VpZ2VuL3NyYy9TcGFyc2VDb3JlL1RyaWFuZ3VsYXJTb2x2ZXIuaABjKysvZWlnZW4vRWlnZW4vc3JjL0NvcmUvdXRpbC9YcHJIZWxwZXIuaABjKysvZWlnZW4vRWlnZW4vc3JjL0NvcmUvU29sdmVUcmlhbmd1bGFyLmgAYysrL2VpZ2VuL0VpZ2VuL3NyYy9Db3JlL0N3aXNlQmluYXJ5T3AuaABjKysvZWlnZW4vRWlnZW4vc3JjL0NvcmUvQ3dpc2VOdWxsYXJ5T3AuaABjKysvZWlnZW4vRWlnZW4vc3JjL1NwYXJzZUNob2xlc2t5L1NpbXBsaWNpYWxDaG9sZXNreV9pbXBsLmgAYysrL2VpZ2VuL0VpZ2VuL3NyYy9Db3JlL3V0aWwvQmxhc1V0aWwuaABjKysvZWlnZW4vRWlnZW4vc3JjL0NvcmUvcHJvZHVjdHMvR2VuZXJhbEJsb2NrUGFuZWxLZXJuZWwuaABjKysvZWlnZW4vRWlnZW4vc3JjL0NvcmUvQmxvY2suaABjKysvZWlnZW4vRWlnZW4vc3JjL09yZGVyaW5nTWV0aG9kcy9PcmRlcmluZy5oAGMrKy9laWdlbi9FaWdlbi9zcmMvQ29yZS9UcmFuc3Bvc2UuaABjKysvZWlnZW4vRWlnZW4vc3JjL0NvcmUvUGxhaW5PYmplY3RCYXNlLmgAYysrL2VpZ2VuL0VpZ2VuL3NyYy9Db3JlL0RlbnNlQ29lZmZzQmFzZS5oAGMrKy9laWdlbi9FaWdlbi9zcmMvU3BhcnNlQ29yZS9TcGFyc2VTb2x2ZXJCYXNlLmgAYysrL2VpZ2VuL0VpZ2VuL3NyYy9Db3JlL01hcEJhc2UuaABjKysvZWlnZW4vRWlnZW4vc3JjL0NvcmUvRGVuc2VCYXNlLmgAYysrL2VpZ2VuL0VpZ2VuL3NyYy9TcGFyc2VMVS9TcGFyc2VMVV9wYW5lbF9ibW9kLmgAYysrL2VpZ2VuL0VpZ2VuL3NyYy9TcGFyc2VMVS9TcGFyc2VMVS5oAGMrKy9laWdlbi9FaWdlbi9zcmMvUVIvQ29sUGl2SG91c2Vob2xkZXJRUi5oAGMrKy9laWdlbi9FaWdlbi9zcmMvU3BhcnNlUVIvU3BhcnNlUVIuaABBdWcAdW5zaWduZWQgbG9uZwBzdGQ6OndzdHJpbmcAYmFzaWNfc3RyaW5nAHN0ZDo6c3RyaW5nAHN0ZDo6dTE2c3RyaW5nAHN0ZDo6dTMyc3RyaW5nAG9yZGVyaW5nAGltYWcAZGlhZwBpbmYAbWF4Q29lZmYAJS4wTGYAJUxmAHJlc2l6ZQBmYWN0b3JpemUAcmVzZXJ2ZQBzb2x2ZQB0cnVlAFR1ZQBzb2x2ZVBvc2l0aXZlRGVmaW5pdGUAY29uanVnYXRlAHRpbWVzU3BhcnNlAHRyYW5zcG9zZQB0aW1lc0RlbnNlAHRvRGVuc2UAZmFsc2UATWFwQmFzZQBzb2x2ZVNxdWFyZQBKdW5lAGRvdWJsZQBzb2x2ZUluUGxhY2UAcGFuZWxfYm1vZAB2b2lkAHJlc2l6ZV9pZl9hbGxvd2VkAGxvY2FsZSBub3Qgc3VwcG9ydGVkAG5lZ2F0ZWQAaW5zZXJ0VW5jb21wcmVzc2VkAGluc2VydEJhY2tVbmNvbXByZXNzZWQAZmFjdG9yaXplX3ByZW9yZGVyZWQAdGVybWluYXRlX2hhbmRsZXIgdW5leHBlY3RlZGx5IHJldHVybmVkAFdlZABVbmtub3duIGVycm9yICVkAHN0ZDo6YmFkX2FsbG9jAHZhcmlhYmxlX2lmX2R5bmFtaWMAc3RhcnRWZWMARGVjAEZlYgBvcGVyYXRvcltdACVhICViICVkICVIOiVNOiVTICVZAFBPU0lYAENvbXBsZXhMVQAlSDolTTolUwBDb21wbGV4UVIAVEhFIE1BVFJJWCBJUyBTVFJVQ1RVUkFMTFkgU0lOR1VMQVIATkFOAFBNAEFNAExDX0FMTABMQU5HAElORgBDAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4AMDEyMzQ1Njc4OQBDLlVURi04AGxvZzIAaW5jcj09MQB0ZW1wdi5zaXplKCk+dypsZHUgKyBucm93KncgKyAxAHg+PTAAKChTaXplQXRDb21waWxlVGltZSA9PSBEeW5hbWljICYmIChNYXhTaXplQXRDb21waWxlVGltZT09RHluYW1pYyB8fCBzaXplPD1NYXhTaXplQXRDb21waWxlVGltZSkpIHx8IFNpemVBdENvbXBpbGVUaW1lID09IHNpemUpICYmIHNpemU+PTAAdmVjU2l6ZSA+PSAwAC4Acm93cyA+PSAwICYmIChSb3dzQXRDb21waWxlVGltZSA9PSBEeW5hbWljIHx8IFJvd3NBdENvbXBpbGVUaW1lID09IHJvd3MpICYmIGNvbHMgPj0gMCAmJiAoQ29sc0F0Q29tcGlsZVRpbWUgPT0gRHluYW1pYyB8fCBDb2xzQXRDb21waWxlVGltZSA9PSBjb2xzKQAobnVsbCkAdiA9PSBUKFZhbHVlKQAoKCFQYW5lbE1vZGUpICYmIHN0cmlkZT09MCAmJiBvZmZzZXQ9PTApIHx8IChQYW5lbE1vZGUgJiYgc3RyaWRlPj1kZXB0aCAmJiBvZmZzZXQ8PXN0cmlkZSkAbV9pbm5lck5vblplcm9zW291dGVyXTw9KG1fb3V0ZXJJbmRleFtvdXRlcisxXSAtIG1fb3V0ZXJJbmRleFtvdXRlcl0pAChkYXRhUHRyID09IDApIHx8ICggcm93cyA+PSAwICYmIChSb3dzQXRDb21waWxlVGltZSA9PSBEeW5hbWljIHx8IFJvd3NBdENvbXBpbGVUaW1lID09IHJvd3MpICYmIGNvbHMgPj0gMCAmJiAoQ29sc0F0Q29tcGlsZVRpbWUgPT0gRHluYW1pYyB8fCBDb2xzQXRDb21waWxlVGltZSA9PSBjb2xzKSkAKGk+PTApICYmICggKChCbG9ja1Jvd3M9PTEpICYmIChCbG9ja0NvbHM9PVhwclR5cGU6OkNvbHNBdENvbXBpbGVUaW1lKSAmJiBpPHhwci5yb3dzKCkpIHx8KChCbG9ja1Jvd3M9PVhwclR5cGU6OlJvd3NBdENvbXBpbGVUaW1lKSAmJiAoQmxvY2tDb2xzPT0xKSAmJiBpPHhwci5jb2xzKCkpKQBkZXJpdmVkKCkuY29scygpID09IGRlcml2ZWQoKS5yb3dzKCkgJiYgKChTaWRlPT1PblRoZUxlZnQgJiYgZGVyaXZlZCgpLmNvbHMoKSA9PSBvdGhlci5yb3dzKCkpIHx8IChTaWRlPT1PblRoZVJpZ2h0ICYmIGRlcml2ZWQoKS5jb2xzKCkgPT0gb3RoZXIuY29scygpKSkAbGhzLmNvbHMoKSA9PSByaHMucm93cygpAGRlcml2ZWQoKS5jb2xzKCkgPT0gZGVyaXZlZCgpLnJvd3MoKSAmJiBkZXJpdmVkKCkuY29scygpID09IG90aGVyLnJvd3MoKQBtX3BhcmVudC5zaXplKCk9PWFwLnJvd3MoKQBtX25vblplcm9zUGVyQ29sLnNpemUoKT09YXAucm93cygpAEJhc2U6Om1fbWF0cml4LnJvd3MoKT09Yi5yb3dzKCkAcm93Pj0wICYmIHJvdzxyb3dzKCkgJiYgY29sPj0wICYmIGNvbDxjb2xzKCkAaXQtPnJvdygpPj0wICYmIGl0LT5yb3coKTxtYXQucm93cygpICYmIGl0LT5jb2woKT49MCAmJiBpdC0+Y29sKCk8bWF0LmNvbHMoKQBkc3Qucm93cygpPT1hX2xocy5yb3dzKCkgJiYgZHN0LmNvbHMoKT09YV9yaHMuY29scygpAGFMaHMucm93cygpID09IGFSaHMucm93cygpICYmIGFMaHMuY29scygpID09IGFSaHMuY29scygpAGFwLnJvd3MoKT09YXAuY29scygpAGRzdC5yb3dzKCkgPT0gc3JjLnJvd3MoKSAmJiBkc3QuY29scygpID09IHNyYy5jb2xzKCkAYS5yb3dzKCk9PWEuY29scygpAHJvdyA+PSAwICYmIHJvdyA8IHJvd3MoKSAmJiBjb2wgPj0gMCAmJiBjb2wgPCBjb2xzKCkAb3BlcmF0b3IoKQBpPj0wICYmIGo+PTAgJiYgaTxzaXplKCkgJiYgajxzaXplKCkAc2l6ZSgpID09IG90aGVyLnNpemUoKQBpbmRleCA+PSAwICYmIGluZGV4IDwgc2l6ZSgpAGxocy5vdXRlclNpemUoKSA9PSByaHMuaW5uZXJTaXplKCkAIWlzQ29tcHJlc3NlZCgpAG1fb3V0ZXJJbmRleFtvdXRlcisxXT09MCAmJiAiWW91IG11c3QgY2FsbCBzdGFydFZlYyBmb3IgZWFjaCBpbm5lciB2ZWN0b3Igc2VxdWVudGlhbGx5IgBtX291dGVySW5kZXhbb3V0ZXJdPT1JbmRleChtX2RhdGEuc2l6ZSgpKSAmJiAiWW91IG11c3QgY2FsbCBzdGFydFZlYyBmb3IgZWFjaCBpbm5lciB2ZWN0b3Igc2VxdWVudGlhbGx5IgB0aGlzLT5yb3dzKCk+MCAmJiB0aGlzLT5jb2xzKCk+MCAmJiAieW91IGFyZSB1c2luZyBhbiBlbXB0eSBtYXRyaXgiAHRoaXMtPnJvd3MoKSA9PSBCLnJvd3MoKSAmJiAiU3BhcnNlUVI6OnNvbHZlKCkgOiBpbnZhbGlkIG51bWJlciBvZiByb3dzIGluIHRoZSByaWdodCBoYW5kIHNpZGUgbWF0cml4IgByb3dzKCk+MCAmJiBjb2xzKCk+MCAmJiAieW91IGFyZSB1c2luZyBhIG5vbiBpbml0aWFsaXplZCBtYXRyaXgiAG1fZmFjdG9yaXphdGlvbklzT2sgJiYgIlRoZSBtYXRyaXggc2hvdWxkIGJlIGZhY3Rvcml6ZWQgZmlyc3QiAG1fYW5hbHlzaXNJc09rICYmICJhbmFseXplUGF0dGVybigpIHNob3VsZCBiZSBjYWxsZWQgZmlyc3QiAGxocy5jb2xzKCkgPT0gcmhzLnJvd3MoKSAmJiAiaW52YWxpZCBtYXRyaXggcHJvZHVjdCIgJiYgImlmIHlvdSB3YW50ZWQgYSBjb2VmZi13aXNlIG9yIGEgZG90IHByb2R1Y3QgdXNlIHRoZSByZXNwZWN0aXZlIGV4cGxpY2l0IGZ1bmN0aW9ucyIAbV9xci5tX1Eucm93cygpID09IG1fb3RoZXIucm93cygpICYmICJOb24gY29uZm9ybWluZyBvYmplY3Qgc2l6ZXMiAG1fcXIubWF0cml4USgpLmNvbHMoKSA9PSBtX290aGVyLnJvd3MoKSAmJiAiTm9uIGNvbmZvcm1pbmcgb2JqZWN0IHNpemVzIgByb3dzKCk9PWNvbHMoKSAmJiAiU2VsZkFkam9pbnRWaWV3IGlzIG9ubHkgZm9yIHNxdWFyZWQgbWF0cmljZXMiAChtYXRyaXgucm93cygpID09IG1hdHJpeC5jb2xzKCkpICYmICJPbmx5IGZvciBzcXVhcmVkIG1hdHJpY2VzIgBvdGhlci5zaXplKCk+MCAmJiAieW91IGFyZSB1c2luZyBhIG5vbiBpbml0aWFsaXplZCB2ZWN0b3IiAG1fYW5hbHlzaXNJc29rICYmICJhbmFseXplUGF0dGVybigpIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIHRoaXMgc3RlcCIAbWF0LmlzQ29tcHJlc3NlZCgpICYmICJDT0xBTURPcmRlcmluZyByZXF1aXJlcyBhIHNwYXJzZSBtYXRyaXggaW4gY29tcHJlc3NlZCBtb2RlLiBDYWxsIC5tYWtlQ29tcHJlc3NlZCgpIGJlZm9yZSBwYXNzaW5nIGl0IHRvIENPTEFNRE9yZGVyaW5nIgAocDw9c3RhcnRJZCB8fCBtX2RhdGEuaW5kZXgocC0xKSE9aW5uZXIpICYmICJ5b3UgY2Fubm90IGluc2VydCBhbiBlbGVtZW50IHRoYXQgYWxyZWFkeSBleGlzdHMsIHlvdSBtdXN0IGNhbGwgY29lZmZSZWYgdG8gdGhpcyBlbmQiACggKChpbnRlcm5hbDo6VUludFB0cihtX2RhdGEpICUgaW50ZXJuYWw6OnRyYWl0czxEZXJpdmVkPjo6QWxpZ25tZW50KSA9PSAwKSB8fCAoY29scygpICogcm93cygpICogbWluSW5uZXJTdHJpZGUgKiBzaXplb2YoU2NhbGFyKSkgPCBpbnRlcm5hbDo6dHJhaXRzPERlcml2ZWQ+OjpBbGlnbm1lbnQgKSAmJiAiZGF0YSBpcyBub3QgYWxpZ25lZCIAZGVyaXZlZCgpLnJvd3MoKT09Yi5yb3dzKCkgJiYgInNvbHZlKCk6IGludmFsaWQgbnVtYmVyIG9mIHJvd3Mgb2YgdGhlIHJpZ2h0IGhhbmQgc2lkZSBtYXRyaXggYiIAcm93cygpID09IGNvbHMoKSAmJiAiT05MWSBGT1IgU1FVQVJFRCBNQVRSSUNFUyIAbWF0LmlzQ29tcHJlc3NlZCgpICYmICJTcGFyc2VRUiByZXF1aXJlcyBhIHNwYXJzZSBtYXRyaXggaW4gY29tcHJlc3NlZCBtb2RlLiBDYWxsIC5tYWtlQ29tcHJlc3NlZCgpIGJlZm9yZSBwYXNzaW5nIGl0IHRvIFNwYXJzZVFSIgBpbnRlcm5hbDo6Y2hlY2tfaW1wbGljYXRpb24oUm93c0F0Q29tcGlsZVRpbWUhPUR5bmFtaWMsIHJvd3M9PVJvd3NBdENvbXBpbGVUaW1lKSAmJiBpbnRlcm5hbDo6Y2hlY2tfaW1wbGljYXRpb24oQ29sc0F0Q29tcGlsZVRpbWUhPUR5bmFtaWMsIGNvbHM9PUNvbHNBdENvbXBpbGVUaW1lKSAmJiBpbnRlcm5hbDo6Y2hlY2tfaW1wbGljYXRpb24oUm93c0F0Q29tcGlsZVRpbWU9PUR5bmFtaWMgJiYgTWF4Um93c0F0Q29tcGlsZVRpbWUhPUR5bmFtaWMsIHJvd3M8PU1heFJvd3NBdENvbXBpbGVUaW1lKSAmJiBpbnRlcm5hbDo6Y2hlY2tfaW1wbGljYXRpb24oQ29sc0F0Q29tcGlsZVRpbWU9PUR5bmFtaWMgJiYgTWF4Q29sc0F0Q29tcGlsZVRpbWUhPUR5bmFtaWMsIGNvbHM8PU1heENvbHNBdENvbXBpbGVUaW1lKSAmJiByb3dzPj0wICYmIGNvbHM+PTAgJiYgIkludmFsaWQgc2l6ZXMgd2hlbiByZXNpemluZyBhIG1hdHJpeCBvciBhcnJheS4iAHJvd3MgPT0gdGhpcy0+cm93cygpICYmIGNvbHMgPT0gdGhpcy0+Y29scygpICYmICJEZW5zZUJhc2U6OnJlc2l6ZSgpIGRvZXMgbm90IGFjdHVhbGx5IGFsbG93IHRvIHJlc2l6ZS4iAGlzQ29tcHJlc3NlZCgpICYmICJUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IG1ha2Ugc2Vuc2UgaW4gbm9uIGNvbXByZXNzZWQgbW9kZS4iAG1faXNJbml0aWFsaXplZCAmJiAiU29sdmVyIGlzIG5vdCBpbml0aWFsaXplZC4iAG1faXNJbml0aWFsaXplZCAmJiAiRGVjb21wb3NpdGlvbiBpcyBub3QgaW5pdGlhbGl6ZWQuIgBtX2lzSW5pdGlhbGl6ZWQgJiYgIkNvbFBpdkhvdXNlaG9sZGVyUVIgaXMgbm90IGluaXRpYWxpemVkLiIASW5kZXgobV9vdXRlckluZGV4W291dGVyKzFdKSA9PSBtX2RhdGEuc2l6ZSgpICYmICJJbnZhbGlkIG9yZGVyZWQgaW5zZXJ0aW9uIChpbnZhbGlkIG91dGVyIGluZGV4KSIAKG1fb3V0ZXJJbmRleFtvdXRlcisxXS1tX291dGVySW5kZXhbb3V0ZXJdPT0wIHx8IG1fZGF0YS5pbmRleChtX2RhdGEuc2l6ZSgpLTEpPGlubmVyKSAmJiAiSW52YWxpZCBvcmRlcmVkIGluc2VydGlvbiAoaW52YWxpZCBpbm5lciBpbmRleCkiAG1fYW5hbHlzaXNJc09rICYmICJZb3UgbXVzdCBmaXJzdCBjYWxsIGFuYWx5emVQYXR0ZXJuKCkiACghY2hlY2tfdHJhbnNwb3NlX2FsaWFzaW5nX3J1bl90aW1lX3NlbGVjdG9yIDx0eXBlbmFtZSBEZXJpdmVkOjpTY2FsYXIsYmxhc190cmFpdHM8RGVyaXZlZD46OklzVHJhbnNwb3NlZCxPdGhlckRlcml2ZWQ+IDo6cnVuKGV4dHJhY3RfZGF0YShkc3QpLCBvdGhlcikpICYmICJhbGlhc2luZyBkZXRlY3RlZCBkdXJpbmcgdHJhbnNwb3NpdGlvbiwgdXNlIHRyYW5zcG9zZUluUGxhY2UoKSAiICJvciBldmFsdWF0ZSB0aGUgcmhzIGludG8gYSB0ZW1wb3JhcnkgdXNpbmcgLmV2YWwoKSIAbV9pc0luaXRpYWxpemVkICYmICJUaGUgZmFjdG9yaXphdGlvbiBzaG91bGQgYmUgY2FsbGVkIGZpcnN0LCB1c2UgY29tcHV0ZSgpIgBCYXNlOjptX2ZhY3Rvcml6YXRpb25Jc09rICYmICJUaGUgZGVjb21wb3NpdGlvbiBpcyBub3QgaW4gYSB2YWxpZCBzdGF0ZSBmb3Igc29sdmluZywgeW91IG11c3QgZmlyc3QgY2FsbCBlaXRoZXIgY29tcHV0ZSgpIG9yIHN5bWJvbGljKCkvbnVtZXJpYygpIgBpbmZvICYmICJDT0xBTUQgZmFpbGVkICIAUHVyZSB2aXJ0dWFsIGZ1bmN0aW9uIGNhbGxlZCEAIC4uLiBaRVJPIENPTFVNTiBBVCAAbGliYysrYWJpOiAAVU5BQkxFIFRPIEVYUEFORCBNRU1PUlkgSU4gQ09MVU1OX0RGUygpIABVTkFCTEUgVE8gRVhQQU5EIE1FTU9SWSBJTiBDT1BZX1RPX1VDT0woKSAAVU5BQkxFIFRPIEVYUEFORCBNRU1PUlkgSU4gQ09MVU1OX0JNT0QoKSAAVU5BQkxFIFRPIEFMTE9DQVRFIFdPUktJTkcgTUVNT1JZCgoAMTFEZW5zZU1hdHJpeElkRQAA6HEAAMIpAABQMTFEZW5zZU1hdHJpeElkRQAAAMhyAADcKQAAAAAAANQpAABQSzExRGVuc2VNYXRyaXhJZEUAAMhyAAAAKgAAAQAAANQpAABpaQB2AHZpAPApAACEcQAAhHEAAGlpaWkAAAAA8CkAANQpAABpaWkA1CkAAIRxAACEcQBB4NQAC0fUKQAAhHEAAIRxAADYcQAAaWlpaWQAAADUKQAAFCoAAIRxAAAUKgAA2HEAABQqAACEcQAAZGlpaQAAAADYcQAAFCoAAGRpaQBBsNUAC4UB1CkAABQqAACEcQAAhHEAAIRxAACEcQAAaWlpaWlpaQAkcQAA8CkAANhxAAB2aWlkAAAAACRxAADwKQAA8CkAAHZpaWkAAAAA1CkAAPApAADYcQAAaWlpZAAAAADUKQAA8CkAAPApAADUKQAA8CkAANhxAAAUKgAAhHEAAIRxAABkaWlpaQBBwNYAC7YCJHEAAPApAACEcQAAhHEAANhxAAB2aWlpaWQAN1RyaXBsZXRJZEUAAOhxAABbKwAAUDdUcmlwbGV0SWRFAAAAAMhyAABwKwAAAAAAAGgrAABQSzdUcmlwbGV0SWRFAAAAyHIAAJArAAABAAAAaCsAAIArAACEcQAAhHEAAAAAAAAkcQAAgCsAAIRxAACEcQAA2HEAADEyU3BhcnNlTWF0cml4SWRFAAAA6HEAANQrAABQMTJTcGFyc2VNYXRyaXhJZEUAAMhyAADwKwAAAAAAAOgrAABQSzEyU3BhcnNlTWF0cml4SWRFAMhyAAAULAAAAQAAAOgrAAAELAAAhHEAAIRxAAAELAAAgCsAAOgrAACEcQAAhHEAAOgrAADUKQAA6CsAACgsAACEcQAAKCwAANhxAAAoLABBgNkAC+oB6CsAACgsAACEcQAAhHEAAIRxAACEcQAA1CkAACgsAADMLAAABCwAAFA4Q2hvbGVza3lJZEUAOENob2xlc2t5SWRFAADocQAAtiwAAMhyAACoLAAAAAAAAMQsAAD8LAAABCwAAFAyTFVJZEUAMkxVSWRFAADocQAA7CwAAMhyAADkLAAAAAAAAPQsAAAsLQAABCwAAFAyUVJJZEUAMlFSSWRFAADocQAAHC0AAMhyAAAULQAAAAAAACQtAAAkcQAABCwAANhxAAAkcQAABCwAAAQsAADoKwAABCwAANhxAADoKwAABCwAAAQsAEH02gALngUJAAAAAQAAAAoAAAANAAAAFQAAAAIAAAAdAAAACwAAAA4AAAAQAAAAEgAAABYAAAAZAAAAAwAAAB4AAAAIAAAADAAAABQAAAAcAAAADwAAABEAAAAYAAAABwAAABMAAAAbAAAAFwAAAAYAAAAaAAAABQAAAAQAAAAfAAAA1CkAAAQsAADwKQAAUEs4Q2hvbGVza3lJZEUAAMhyAAD8LQAAAQAAAMQsAADMLAAA6CsAANQpAADMLAAA8CkAAFBLMkxVSWRFAAAAAMhyAAAwLgAAAQAAAPQsAAD8LAAA6CsAANQpAAD8LAAA8CkAAFBLMlFSSWRFAAAAAMhyAABgLgAAAQAAACQtAAAsLQAA6CsAANQpAAAsLQAA8CkAAE5TdDNfXzI3Y29tcGxleElkRUUA6HEAAJAuAABQTlN0M19fMjdjb21wbGV4SWRFRQAAAADIcgAArC4AAAAAAACkLgAAUEtOU3QzX18yN2NvbXBsZXhJZEVFAAAAyHIAANQuAAABAAAApC4AAMQuAADYcQAA2HEAAGlpZGQAAAAA2HEAAKQuAAAxMURlbnNlTWF0cml4SU5TdDNfXzI3Y29tcGxleElkRUVFAADocQAAGC8AAFAxMURlbnNlTWF0cml4SU5TdDNfXzI3Y29tcGxleElkRUVFAMhyAABELwAAAAAAADwvAABQSzExRGVuc2VNYXRyaXhJTlN0M19fMjdjb21wbGV4SWRFRUUAAAAAyHIAAHgvAAABAAAAPC8AAGgvAACEcQAAhHEAAGgvAAA8LwAAPC8AAIRxAACEcQAAPC8AAIRxAACEcQAApC4AAGlpaWlpAAAAPC8AAKAvAACEcQAAoC8AANhxAACgLwAAhHEAANhxAACgLwAApC4AAKAvAEGg4AALlhU8LwAAoC8AAIRxAACEcQAAhHEAAIRxAAAkcQAAaC8AAKQuAAAkcQAAaC8AAGgvAAA8LwAAaC8AAKQuAAA8LwAAaC8AAGgvAAA8LwAAaC8AAKQuAACgLwAAhHEAAIRxAAAkcQAAaC8AAIRxAACEcQAApC4AAHZpaWlpaQA3VHJpcGxldElOU3QzX18yN2NvbXBsZXhJZEVFRQAAAADocQAAmzAAAFA3VHJpcGxldElOU3QzX18yN2NvbXBsZXhJZEVFRQAAyHIAAMQwAAAAAAAAvDAAAFBLN1RyaXBsZXRJTlN0M19fMjdjb21wbGV4SWRFRUUAyHIAAPQwAAABAAAAvDAAAOQwAACEcQAAhHEAACRxAADkMAAAhHEAAIRxAACkLgAAMTJTcGFyc2VNYXRyaXhJTlN0M19fMjdjb21wbGV4SWRFRUUA6HEAAEQxAABQMTJTcGFyc2VNYXRyaXhJTlN0M19fMjdjb21wbGV4SWRFRUUAAAAAyHIAAHAxAAAAAAAAaDEAAFBLMTJTcGFyc2VNYXRyaXhJTlN0M19fMjdjb21wbGV4SWRFRUUAAADIcgAAqDEAAAEAAABoMQAAmDEAAIRxAACEcQAAmDEAAOQwAABoMQAAhHEAAIRxAABoMQAAPC8AAGgxAADQMQAAhHEAANAxAADYcQAA0DEAAGgxAADQMQAAhHEAAIRxAACEcQAAhHEAADwvAADQMQAAkDIAAJgxAABQOENob2xlc2t5SU5TdDNfXzI3Y29tcGxleElkRUVFADhDaG9sZXNreUlOU3QzX18yN2NvbXBsZXhJZEVFRQAA6HEAAGgyAADIcgAASDIAAAAAAACIMgAA5DIAAJgxAABQMkxVSU5TdDNfXzI3Y29tcGxleElkRUVFADJMVUlOU3QzX18yN2NvbXBsZXhJZEVFRQAA6HEAAMIyAADIcgAAqDIAAAAAAADcMgAAODMAAJgxAABQMlFSSU5TdDNfXzI3Y29tcGxleElkRUVFADJRUklOU3QzX18yN2NvbXBsZXhJZEVFRQAA6HEAABYzAADIcgAA/DIAAAAAAAAwMwAAJHEAAJgxAACkLgAAJHEAAJgxAACYMQAAaDEAAJgxAACkLgAAaDEAAJgxAACYMQAAPC8AAJgxAABoLwAAUEs4Q2hvbGVza3lJTlN0M19fMjdjb21wbGV4SWRFRUUAAAAAyHIAAIQzAAABAAAAiDIAAJAyAABoMQAAPC8AAJAyAABoLwAAUEsyTFVJTlN0M19fMjdjb21wbGV4SWRFRUUAAMhyAADMMwAAAQAAANwyAADkMgAAaDEAADwvAADkMgAAaC8AAFBLMlFSSU5TdDNfXzI3Y29tcGxleElkRUVFAADIcgAADDQAAAEAAAAwMwAAODMAAGgxAAA8LwAAODMAAGgvAABOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQAA6HEAAEw0AABOU3QzX18yMTJiYXNpY19zdHJpbmdJaE5TXzExY2hhcl90cmFpdHNJaEVFTlNfOWFsbG9jYXRvckloRUVFRQAA6HEAAJQ0AABOU3QzX18yMTJiYXNpY19zdHJpbmdJd05TXzExY2hhcl90cmFpdHNJd0VFTlNfOWFsbG9jYXRvckl3RUVFRQAA6HEAANw0AABOU3QzX18yMTJiYXNpY19zdHJpbmdJRHNOU18xMWNoYXJfdHJhaXRzSURzRUVOU185YWxsb2NhdG9ySURzRUVFRQAAAOhxAAAkNQAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURpTlNfMTFjaGFyX3RyYWl0c0lEaUVFTlNfOWFsbG9jYXRvcklEaUVFRUUAAADocQAAcDUAAE4xMGVtc2NyaXB0ZW4zdmFsRQAA6HEAALw1AABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ljRUUAAOhxAADYNQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJYUVFAADocQAAADYAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWhFRQAA6HEAACg2AABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUAAOhxAABQNgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAADocQAAeDYAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQAA6HEAAKA2AABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUAAOhxAADINgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAADocQAA8DYAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQAA6HEAABg3AABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lmRUUAAOhxAABANwAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZEVFAADocQAAaDcAAAAAAACsOAAA0AEAANEBAADSAQAA0wEAANQBAADVAQAA1gEAANcBAADYAQAA2QEAANoBAADbAQAA3AEAAN0BAAAEAAAAAAAAAOQ4AADeAQAA3wEAAPz////8////5DgAAOABAADhAQAA3DcAAPA3AAAAAAAAQDkAAOIBAADjAQAA0gEAANMBAADkAQAA5QEAANYBAADXAQAA2AEAAOYBAADaAQAA5wEAANwBAADoAQAATlN0M19fMjliYXNpY19pb3NJY05TXzExY2hhcl90cmFpdHNJY0VFRUUAAAAQcgAAQDgAAFw6AABOU3QzX18yMTViYXNpY19zdHJlYW1idWZJY05TXzExY2hhcl90cmFpdHNJY0VFRUUAAAAA6HEAAHg4AABOU3QzX18yMTNiYXNpY19vc3RyZWFtSWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFAABscgAAtDgAAAAAAAABAAAAbDgAAAP0//9OU3QzX18yMTViYXNpY19zdHJpbmdidWZJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQAAABByAAD8OAAArDgAADgAAAAAAAAA9DkAAOkBAADqAQAAyP///8j////0OQAA6wEAAOwBAABYOQAAkDkAAKQ5AABsOQAAOAAAAAAAAADkOAAA3gEAAN8BAADI////yP///+Q4AADgAQAA4QEAAE5TdDNfXzIxOWJhc2ljX29zdHJpbmdzdHJlYW1JY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQAAABByAACsOQAA5DgAAAAAAACsOgAA8QEAAPIBAADzAQAA9AEAAPUBAAD2AQAA9wEAAAAAAACAOgAA8AEAAPgBAAD5AQAAAAAAAFw6AAD6AQAA+wEAAE5TdDNfXzI4aW9zX2Jhc2VFAAAA6HEAAEg6AABOU3QzX18yOGlvc19iYXNlN2ZhaWx1cmVFAAAAEHIAAGQ6AABIbwAATlN0M19fMjE5X19pb3N0cmVhbV9jYXRlZ29yeUUAAAAQcgAAjDoAAJBvAEHA9QAL0wTRdJ4AV529KoBwUg///z4nCgAAAGQAAADoAwAAECcAAKCGAQBAQg8AgJaYAADh9QUYAAAANQAAAHEAAABr////zvv//5K///8AAAAAAAAAAP////////////////////////////////////////////////////////////////8AAQIDBAUGBwgJ/////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAECBAcDBgUAAAAAAAAAAgAAwAMAAMAEAADABQAAwAYAAMAHAADACAAAwAkAAMAKAADACwAAwAwAAMANAADADgAAwA8AAMAQAADAEQAAwBIAAMATAADAFAAAwBUAAMAWAADAFwAAwBgAAMAZAADAGgAAwBsAAMAcAADAHQAAwB4AAMAfAADAAAAAswEAAMMCAADDAwAAwwQAAMMFAADDBgAAwwcAAMMIAADDCQAAwwoAAMMLAADDDAAAww0AANMOAADDDwAAwwAADLsBAAzDAgAMwwMADMMEAAzbAAAAAN4SBJUAAAAA////////////////8DwAABQAAABDLlVURi04AEHA+gALAgQ9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cnkAUmVzb3VyY2UgYnVzeQBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbABSZXNvdXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yawBDb25uZWN0aW9uIGFib3J0ZWQATm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZQBTb2NrZXQgaXMgY29ubmVjdGVkAFNvY2tldCBub3QgY29ubmVjdGVkAENhbm5vdCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93bgBPcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcwBPcGVyYXRpb24gaW4gcHJvZ3Jlc3MAU3RhbGUgZmlsZSBoYW5kbGUAUmVtb3RlIEkvTyBlcnJvcgBRdW90YSBleGNlZWRlZABObyBtZWRpdW0gZm91bmQAV3JvbmcgbWVkaXVtIHR5cGUATXVsdGlob3AgYXR0ZW1wdGVkAEHy2wELlgGlAlsA8AG1BYwFJQGDBh0DlAT/AMcDMQMLBrwBjwF/A8oEKwDaBq8AQgNOA9wBDgQVAKEGDQGUAgsCOAZkArwC/wJdA+cECwfPAssF7wXbBeECHgZFAoUAggJsA28E8QDzAxgF2QDaA0wGVAJ7AZ0DvQQAAFEAFQK7ALMDbQD/AYUELwX5BDgAZQFGAZ8AtwaoAXMCUwEAQbjdAQsMIQQAAAAAAAAAAC8CAEHY3QELBjUERwRWBABB7t0BCwKgBABBgt4BC8gKRgVgBW4FYQYAAM8BAAAAAAAAAADJBukG+QYAAAAASG8AAKgDAACpAwAA+QEAAE5TdDNfXzIxMnN5c3RlbV9lcnJvckUAABByAAAwbwAA/HMAAE5TdDNfXzIxNGVycm9yX2NhdGVnb3J5RQAAAADocQAAVG8AAE5TdDNfXzIxMl9fZG9fbWVzc2FnZUUAABByAAB4bwAAcG8AAGB0AABOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAAAQcgAAoG8AACx0AABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAAAQcgAA0G8AAMRvAABOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAAAQcgAAAHAAAMRvAABOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQAQcgAAMHAAACRwAABOMTBfX2N4eGFiaXYxMjBfX2Z1bmN0aW9uX3R5cGVfaW5mb0UAAAAAEHIAAGBwAADEbwAATjEwX19jeHhhYml2MTI5X19wb2ludGVyX3RvX21lbWJlcl90eXBlX2luZm9FAAAAEHIAAJRwAAAkcAAAAAAAABRxAACvAwAAsAMAALEDAACyAwAAswMAAE4xMF9fY3h4YWJpdjEyM19fZnVuZGFtZW50YWxfdHlwZV9pbmZvRQAQcgAA7HAAAMRvAAB2AAAA2HAAACBxAABEbgAA2HAAACxxAABiAAAA2HAAADhxAABjAAAA2HAAAERxAABoAAAA2HAAAFBxAABhAAAA2HAAAFxxAABzAAAA2HAAAGhxAAB0AAAA2HAAAHRxAABpAAAA2HAAAIBxAABqAAAA2HAAAIxxAABsAAAA2HAAAJhxAABtAAAA2HAAAKRxAAB4AAAA2HAAALBxAAB5AAAA2HAAALxxAABmAAAA2HAAAMhxAABkAAAA2HAAANRxAAAAAAAA9G8AAK8DAAC0AwAAsQMAALIDAAC1AwAAtgMAALcDAAC4AwAAAAAAAFhyAACvAwAAuQMAALEDAACyAwAAtQMAALoDAAC7AwAAvAMAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAAAQcgAAMHIAAPRvAAAAAAAAtHIAAK8DAAC9AwAAsQMAALIDAAC1AwAAvgMAAL8DAADAAwAATjEwX19jeHhhYml2MTIxX192bWlfY2xhc3NfdHlwZV9pbmZvRQAAABByAACMcgAA9G8AAAAAAABUcAAArwMAAMEDAACxAwAAsgMAAMIDAAAAAAAAWHMAAA0BAADDAwAAxAMAAAAAAABkcwAADQEAAMUDAADGAwAAAAAAAChzAAANAQAAxwMAAMgDAABTdDlleGNlcHRpb24AAAAA6HEAABhzAABTdDIwYmFkX2FycmF5X25ld19sZW5ndGgAU3Q5YmFkX2FsbG9jAAAAEHIAAElzAAAocwAAEHIAADBzAABYcwAAAAAAAKhzAABHAQAAyQMAAMoDAAAAAAAA/HMAAEACAADLAwAA+QEAAFN0MTFsb2dpY19lcnJvcgAQcgAAmHMAAChzAAAAAAAA3HMAAEcBAADMAwAAygMAAFN0MTJsZW5ndGhfZXJyb3IAAAAAEHIAAMhzAACocwAAU3QxM3J1bnRpbWVfZXJyb3IAAAAQcgAA6HMAAChzAAAAAAAAQHQAAM4BAADNAwAAzgMAAFN0OXR5cGVfaW5mbwAAAADocQAAHHQAAFN0OGJhZF9jYXN0ABByAAA0dAAAKHMAQdDoAQsRUIBQAAg6AACqAwAAAAAAAAUAQezoAQsCqwMAQYTpAQsKrAMAAK0DAABEgABBnOkBCwECAEGs6QELCP//////////AEHw6QELAmB0", YA(Se) || (Se = c(Se));
    function cA(T) {
      try {
        if (T == Se && v)
          return new Uint8Array(v);
        var b = Ti(T);
        if (b)
          return b;
        if (p)
          return p(T);
        throw "both async and sync fetching of the wasm failed";
      } catch (X) {
        SA(X);
      }
    }
    function xA() {
      if (!v && (s || B)) {
        if (typeof fetch == "function" && !ZA(Se))
          return fetch(Se, { credentials: "same-origin" }).then(function(T) {
            if (!T.ok)
              throw "failed to load wasm binary file at '" + Se + "'";
            return T.arrayBuffer();
          }).catch(function() {
            return cA(Se);
          });
        if (d)
          return new Promise(function(T, b) {
            d(Se, function(X) {
              T(new Uint8Array(X));
            }, b);
          });
      }
      return Promise.resolve().then(function() {
        return cA(Se);
      });
    }
    function gA() {
      var T = { env: Kr, wasi_snapshot_preview1: Kr };
      function b(OA, zA) {
        var Ce = OA.exports;
        e.asm = Ce, x = e.asm.memory, _(x, "memory not found in wasm exports"), wA(x.buffer), FA = e.asm.__indirect_function_table, _(FA, "table not found in wasm exports"), AA(e.asm.__wasm_call_ctors), DA("wasm-instantiate");
      }
      bA("wasm-instantiate");
      var X = e;
      function CA(OA) {
        _(e === X, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?"), X = null, b(OA.instance);
      }
      function NA(OA) {
        return xA().then(function(zA) {
          return WebAssembly.instantiate(zA, T);
        }).then(function(zA) {
          return zA;
        }).then(OA, function(zA) {
          y("failed to asynchronously prepare wasm: " + zA), ZA(Se) && y("warning: Loading from a file URI (" + Se + ") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing"), SA(zA);
        });
      }
      function KA() {
        return !v && typeof WebAssembly.instantiateStreaming == "function" && !YA(Se) && !ZA(Se) && !I && typeof fetch == "function" ? fetch(Se, { credentials: "same-origin" }).then(function(OA) {
          var zA = WebAssembly.instantiateStreaming(OA, T);
          return zA.then(CA, function(Ce) {
            return y("wasm streaming compile failed: " + Ce), y("falling back to ArrayBuffer instantiation"), NA(CA);
          });
        }) : NA(CA);
      }
      if (e.instantiateWasm)
        try {
          var WA = e.instantiateWasm(T, b);
          return WA;
        } catch (OA) {
          y("Module.instantiateWasm callback failed with error: " + OA), i(OA);
        }
      return KA().catch(i), {};
    }
    function RA(T) {
      this.name = "ExitStatus", this.message = "Program terminated with exit(" + T + ")", this.status = T;
    }
    function UA(T) {
      for (; T.length > 0; )
        T.shift()(e);
    }
    function TA(T) {
      for (var b = [], X = 0; X < T.length; X++) {
        var CA = T[X];
        CA > 255 && (_(!1, "Character code " + CA + " (" + String.fromCharCode(CA) + ")  at offset " + X + " not in 0x00-0xFF."), CA &= 255), b.push(String.fromCharCode(CA));
      }
      return b.join("");
    }
    function ge(T) {
      ge.shown || (ge.shown = {}), ge.shown[T] || (ge.shown[T] = 1, I && (T = "warning: " + T), y(T));
    }
    function Me(T, b, X, CA) {
      SA("Assertion failed: " + iA(T) + ", at: " + [b ? iA(b) : "unknown filename", X, CA ? iA(CA) : "unknown function"]);
    }
    function xe(T) {
      return Ms(T + 24) + 24;
    }
    var we = [];
    function Ee(T) {
      T.add_ref();
    }
    var he = 0;
    function _e(T) {
      var b = new Nt(T);
      return b.get_caught() || (b.set_caught(!0), he--), b.set_rethrown(!1), we.push(b), Ee(b), b.get_exception_ptr();
    }
    var Pe = 0;
    function Nt(T) {
      this.excPtr = T, this.ptr = T - 24, this.set_type = function(b) {
        MA[this.ptr + 4 >> 2] = b;
      }, this.get_type = function() {
        return MA[this.ptr + 4 >> 2];
      }, this.set_destructor = function(b) {
        MA[this.ptr + 8 >> 2] = b;
      }, this.get_destructor = function() {
        return MA[this.ptr + 8 >> 2];
      }, this.set_refcount = function(b) {
        aA[this.ptr >> 2] = b;
      }, this.set_caught = function(b) {
        b = b ? 1 : 0, tA[this.ptr + 12 >> 0] = b;
      }, this.get_caught = function() {
        return tA[this.ptr + 12 >> 0] != 0;
      }, this.set_rethrown = function(b) {
        b = b ? 1 : 0, tA[this.ptr + 13 >> 0] = b;
      }, this.get_rethrown = function() {
        return tA[this.ptr + 13 >> 0] != 0;
      }, this.init = function(b, X) {
        this.set_adjusted_ptr(0), this.set_type(b), this.set_destructor(X), this.set_refcount(0), this.set_caught(!1), this.set_rethrown(!1);
      }, this.add_ref = function() {
        var b = aA[this.ptr >> 2];
        aA[this.ptr >> 2] = b + 1;
      }, this.release_ref = function() {
        var b = aA[this.ptr >> 2];
        return aA[this.ptr >> 2] = b - 1, _(b > 0), b === 1;
      }, this.set_adjusted_ptr = function(b) {
        MA[this.ptr + 16 >> 2] = b;
      }, this.get_adjusted_ptr = function() {
        return MA[this.ptr + 16 >> 2];
      }, this.get_exception_ptr = function() {
        var b = Ci(this.get_type());
        if (b)
          return MA[this.excPtr >> 2];
        var X = this.get_adjusted_ptr();
        return X !== 0 ? X : this.excPtr;
      };
    }
    function Jt(T) {
      try {
        return en(new Nt(T).ptr);
      } catch (b) {
        y("exception during __cxa_free_exception: " + b);
      }
    }
    var vi = [];
    function je(T) {
      var b = vi[T];
      return b || (T >= vi.length && (vi.length = T + 1), vi[T] = b = FA.get(T)), _(FA.get(T) == b, "JavaScript-side Wasm function table mirror is out of date!"), b;
    }
    function Ri(T) {
      if (T.release_ref() && !T.get_rethrown()) {
        var b = T.get_destructor();
        b && je(b)(T.excPtr), Jt(T.excPtr);
      }
    }
    function lA() {
      Rt(0), _(we.length > 0);
      var T = we.pop();
      Ri(T), Pe = 0;
    }
    function jA(T) {
      throw Pe || (Pe = T), T;
    }
    function se() {
      var T = Pe;
      if (!T)
        return Vi(0), 0;
      var b = new Nt(T);
      b.set_adjusted_ptr(T);
      var X = b.get_type();
      if (!X)
        return Vi(0), T;
      for (var CA = 0; CA < arguments.length; CA++) {
        var NA = arguments[CA];
        if (NA === 0 || NA === X)
          break;
        var KA = b.ptr + 16;
        if (ji(NA, X, KA))
          return Vi(NA), T;
      }
      return Vi(X), T;
    }
    function PA() {
      var T = Pe;
      if (!T)
        return Vi(0), 0;
      var b = new Nt(T);
      b.set_adjusted_ptr(T);
      var X = b.get_type();
      if (!X)
        return Vi(0), T;
      for (var CA = 0; CA < arguments.length; CA++) {
        var NA = arguments[CA];
        if (NA === 0 || NA === X)
          break;
        var KA = b.ptr + 16;
        if (ji(NA, X, KA))
          return Vi(NA), T;
      }
      return Vi(X), T;
    }
    function Be() {
      var T = we.pop();
      T || SA("no exception to throw");
      var b = T.excPtr;
      throw T.get_rethrown() || (we.push(T), T.set_rethrown(!0), T.set_caught(!1), he++), Pe = b, b;
    }
    function At(T, b, X) {
      var CA = new Nt(T);
      throw CA.init(b, X), Pe = T, he++, T;
    }
    function rt() {
      return he;
    }
    function it(T, b, X, CA, NA) {
    }
    function Et(T) {
      switch (T) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw new TypeError("Unknown type size: " + T);
      }
    }
    function Bt() {
      for (var T = new Array(256), b = 0; b < 256; ++b)
        T[b] = String.fromCharCode(b);
      ft = T;
    }
    var ft = void 0;
    function tt(T) {
      for (var b = "", X = T; Y[X]; )
        b += ft[Y[X++]];
      return b;
    }
    var Ft = {}, ui = {}, Li = {}, $i = 48, hi = 57;
    function pt(T) {
      if (T === void 0)
        return "_unknown";
      T = T.replace(/[^a-zA-Z0-9_]/g, "$");
      var b = T.charCodeAt(0);
      return b >= $i && b <= hi ? "_" + T : T;
    }
    function Gr(T, b) {
      return T = pt(T), new Function("body", "return function " + T + `() {
    "use strict";    return body.apply(this, arguments);
};
`)(b);
    }
    function Ui(T, b) {
      var X = Gr(b, function(CA) {
        this.name = b, this.message = CA;
        var NA = new Error(CA).stack;
        NA !== void 0 && (this.stack = this.toString() + `
` + NA.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return X.prototype = Object.create(T.prototype), X.prototype.constructor = X, X.prototype.toString = function() {
        return this.message === void 0 ? this.name : this.name + ": " + this.message;
      }, X;
    }
    var Rn = void 0;
    function St(T) {
      throw new Rn(T);
    }
    var Nn = void 0;
    function Wt(T) {
      throw new Nn(T);
    }
    function ot(T, b, X) {
      T.forEach(function(OA) {
        Li[OA] = b;
      });
      function CA(OA) {
        var zA = X(OA);
        zA.length !== T.length && Wt("Mismatched type converter count");
        for (var Ce = 0; Ce < T.length; ++Ce)
          pi(T[Ce], zA[Ce]);
      }
      var NA = new Array(b.length), KA = [], WA = 0;
      b.forEach((OA, zA) => {
        ui.hasOwnProperty(OA) ? NA[zA] = ui[OA] : (KA.push(OA), Ft.hasOwnProperty(OA) || (Ft[OA] = []), Ft[OA].push(() => {
          NA[zA] = ui[OA], ++WA, WA === KA.length && CA(NA);
        }));
      }), KA.length === 0 && CA(NA);
    }
    function pi(T, b, X = {}) {
      if (!("argPackAdvance" in b))
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      var CA = b.name;
      if (T || St('type "' + CA + '" must have a positive integer typeid pointer'), ui.hasOwnProperty(T)) {
        if (X.ignoreDuplicateRegistrations)
          return;
        St("Cannot register type '" + CA + "' twice");
      }
      if (ui[T] = b, delete Li[T], Ft.hasOwnProperty(T)) {
        var NA = Ft[T];
        delete Ft[T], NA.forEach((KA) => KA());
      }
    }
    function zi(T, b, X, CA, NA) {
      var KA = Et(X);
      b = tt(b), pi(T, { name: b, fromWireType: function(WA) {
        return !!WA;
      }, toWireType: function(WA, OA) {
        return OA ? CA : NA;
      }, argPackAdvance: 8, readValueFromPointer: function(WA) {
        var OA;
        if (X === 1)
          OA = tA;
        else if (X === 2)
          OA = rA;
        else if (X === 4)
          OA = aA;
        else
          throw new TypeError("Unknown boolean type size: " + b);
        return this.fromWireType(OA[WA >> KA]);
      }, destructorFunction: null });
    }
    function Mt(T) {
      if (!(this instanceof Ur) || !(T instanceof Ur))
        return !1;
      for (var b = this.$$.ptrType.registeredClass, X = this.$$.ptr, CA = T.$$.ptrType.registeredClass, NA = T.$$.ptr; b.baseClass; )
        X = b.upcast(X), b = b.baseClass;
      for (; CA.baseClass; )
        NA = CA.upcast(NA), CA = CA.baseClass;
      return b === CA && X === NA;
    }
    function sg(T) {
      return { count: T.count, deleteScheduled: T.deleteScheduled, preservePointerOnDelete: T.preservePointerOnDelete, ptr: T.ptr, ptrType: T.ptrType, smartPtr: T.smartPtr, smartPtrType: T.smartPtrType };
    }
    function nr(T) {
      function b(X) {
        return X.$$.ptrType.registeredClass.name;
      }
      St(b(T) + " instance already deleted");
    }
    var An = !1;
    function na(T) {
    }
    function ZC(T) {
      T.smartPtr ? T.smartPtrType.rawDestructor(T.smartPtr) : T.ptrType.registeredClass.rawDestructor(T.ptr);
    }
    function DB(T) {
      T.count.value -= 1;
      var b = T.count.value === 0;
      b && ZC(T);
    }
    function xo(T, b, X) {
      if (b === X)
        return T;
      if (X.baseClass === void 0)
        return null;
      var CA = xo(T, b, X.baseClass);
      return CA === null ? null : X.downcast(CA);
    }
    var tI = {};
    function fg() {
      return Object.keys(so).length;
    }
    function wB() {
      var T = [];
      for (var b in so)
        so.hasOwnProperty(b) && T.push(so[b]);
      return T;
    }
    var ds = [];
    function iI() {
      for (; ds.length; ) {
        var T = ds.pop();
        T.$$.deleteScheduled = !1, T.delete();
      }
    }
    var ro = void 0;
    function fs(T) {
      ro = T, ds.length && ro && ro(iI);
    }
    function oo() {
      e.getInheritedInstanceCount = fg, e.getLiveInheritedInstances = wB, e.flushPendingDeletes = iI, e.setDelayFunction = fs;
    }
    var so = {};
    function _g(T, b) {
      for (b === void 0 && St("ptr should not be undefined"); T.baseClass; )
        b = T.upcast(b), T = T.baseClass;
      return b;
    }
    function ga(T, b) {
      return b = _g(T, b), so[b];
    }
    function fn(T, b) {
      (!b.ptrType || !b.ptr) && Wt("makeClassHandle requires ptr and ptrType");
      var X = !!b.smartPtrType, CA = !!b.smartPtr;
      return X !== CA && Wt("Both smartPtrType and smartPtr must be specified"), b.count = { value: 1 }, vr(Object.create(T, { $$: { value: b } }));
    }
    function nI(T) {
      var b = this.getPointee(T);
      if (!b)
        return this.destructor(T), null;
      var X = ga(this.registeredClass, b);
      if (X !== void 0) {
        if (X.$$.count.value === 0)
          return X.$$.ptr = b, X.$$.smartPtr = T, X.clone();
        var CA = X.clone();
        return this.destructor(T), CA;
      }
      function NA() {
        return this.isSmartPointer ? fn(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: b, smartPtrType: this, smartPtr: T }) : fn(this.registeredClass.instancePrototype, { ptrType: this, ptr: T });
      }
      var KA = this.registeredClass.getActualType(b), WA = tI[KA];
      if (!WA)
        return NA.call(this);
      var OA;
      this.isConst ? OA = WA.constPointerType : OA = WA.pointerType;
      var zA = xo(b, this.registeredClass, OA.registeredClass);
      return zA === null ? NA.call(this) : this.isSmartPointer ? fn(OA.registeredClass.instancePrototype, { ptrType: OA, ptr: zA, smartPtrType: this, smartPtr: T }) : fn(OA.registeredClass.instancePrototype, { ptrType: OA, ptr: zA });
    }
    function vr(T) {
      return typeof FinalizationRegistry > "u" ? (vr = (b) => b, T) : (An = new FinalizationRegistry((b) => {
        console.warn(b.leakWarning.stack.replace(/^Error: /, "")), DB(b.$$);
      }), vr = (b) => {
        var X = b.$$, CA = !!X.smartPtr;
        if (CA) {
          var NA = { $$: X }, KA = X.ptrType.registeredClass;
          NA.leakWarning = new Error("Embind found a leaked C++ instance " + KA.name + " <0x" + X.ptr.toString(16) + `>.
We'll free it automatically in this case, but this functionality is not reliable across various environments.
Make sure to invoke .delete() manually once you're done with the instance instead.
Originally allocated`), "captureStackTrace" in Error && Error.captureStackTrace(NA.leakWarning, nI), An.register(b, NA, b);
        }
        return b;
      }, na = (b) => An.unregister(b), vr(T));
    }
    function VE() {
      if (this.$$.ptr || nr(this), this.$$.preservePointerOnDelete)
        return this.$$.count.value += 1, this;
      var T = vr(Object.create(Object.getPrototypeOf(this), { $$: { value: sg(this.$$) } }));
      return T.$$.count.value += 1, T.$$.deleteScheduled = !1, T;
    }
    function yB() {
      this.$$.ptr || nr(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && St("Object already scheduled for deletion"), na(this), DB(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);
    }
    function $t() {
      return !this.$$.ptr;
    }
    function XC() {
      return this.$$.ptr || nr(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && St("Object already scheduled for deletion"), ds.push(this), ds.length === 1 && ro && ro(iI), this.$$.deleteScheduled = !0, this;
    }
    function ao() {
      Ur.prototype.isAliasOf = Mt, Ur.prototype.clone = VE, Ur.prototype.delete = yB, Ur.prototype.isDeleted = $t, Ur.prototype.deleteLater = XC;
    }
    function Ur() {
    }
    function mB(T, b, X) {
      if (T[b].overloadTable === void 0) {
        var CA = T[b];
        T[b] = function() {
          return T[b].overloadTable.hasOwnProperty(arguments.length) || St("Function '" + X + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + T[b].overloadTable + ")!"), T[b].overloadTable[arguments.length].apply(this, arguments);
        }, T[b].overloadTable = [], T[b].overloadTable[CA.argCount] = CA;
      }
    }
    function $C(T, b, X) {
      e.hasOwnProperty(T) ? ((X === void 0 || e[T].overloadTable !== void 0 && e[T].overloadTable[X] !== void 0) && St("Cannot register public name '" + T + "' twice"), mB(e, T, T), e.hasOwnProperty(X) && St("Cannot register multiple overloads of a function with the same number of arguments (" + X + ")!"), e[T].overloadTable[X] = b) : (e[T] = b, X !== void 0 && (e[T].numArguments = X));
    }
    function ki(T, b, X, CA, NA, KA, WA, OA) {
      this.name = T, this.constructor = b, this.instancePrototype = X, this.rawDestructor = CA, this.baseClass = NA, this.getActualType = KA, this.upcast = WA, this.downcast = OA, this.pureVirtualFunctions = [];
    }
    function ra(T, b, X) {
      for (; b !== X; )
        b.upcast || St("Expected null or instance of " + X.name + ", got an instance of " + b.name), T = b.upcast(T), b = b.baseClass;
      return T;
    }
    function jE(T, b) {
      if (b === null)
        return this.isReference && St("null is not a valid " + this.name), 0;
      b.$$ || St('Cannot pass "' + ag(b) + '" as a ' + this.name), b.$$.ptr || St("Cannot pass deleted object as a pointer of type " + this.name);
      var X = b.$$.ptrType.registeredClass, CA = ra(b.$$.ptr, X, this.registeredClass);
      return CA;
    }
    function SB(T, b) {
      var X;
      if (b === null)
        return this.isReference && St("null is not a valid " + this.name), this.isSmartPointer ? (X = this.rawConstructor(), T !== null && T.push(this.rawDestructor, X), X) : 0;
      b.$$ || St('Cannot pass "' + ag(b) + '" as a ' + this.name), b.$$.ptr || St("Cannot pass deleted object as a pointer of type " + this.name), !this.isConst && b.$$.ptrType.isConst && St("Cannot convert argument of type " + (b.$$.smartPtrType ? b.$$.smartPtrType.name : b.$$.ptrType.name) + " to parameter type " + this.name);
      var CA = b.$$.ptrType.registeredClass;
      if (X = ra(b.$$.ptr, CA, this.registeredClass), this.isSmartPointer)
        switch (b.$$.smartPtr === void 0 && St("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) {
          case 0:
            b.$$.smartPtrType === this ? X = b.$$.smartPtr : St("Cannot convert argument of type " + (b.$$.smartPtrType ? b.$$.smartPtrType.name : b.$$.ptrType.name) + " to parameter type " + this.name);
            break;
          case 1:
            X = b.$$.smartPtr;
            break;
          case 2:
            if (b.$$.smartPtrType === this)
              X = b.$$.smartPtr;
            else {
              var NA = b.clone();
              X = this.rawShare(X, Ko.toHandle(function() {
                NA.delete();
              })), T !== null && T.push(this.rawDestructor, X);
            }
            break;
          default:
            St("Unsupporting sharing policy");
        }
      return X;
    }
    function ZE(T, b) {
      if (b === null)
        return this.isReference && St("null is not a valid " + this.name), 0;
      b.$$ || St('Cannot pass "' + ag(b) + '" as a ' + this.name), b.$$.ptr || St("Cannot pass deleted object as a pointer of type " + this.name), b.$$.ptrType.isConst && St("Cannot convert argument of type " + b.$$.ptrType.name + " to parameter type " + this.name);
      var X = b.$$.ptrType.registeredClass, CA = ra(b.$$.ptr, X, this.registeredClass);
      return CA;
    }
    function Lo(T) {
      return this.fromWireType(aA[T >> 2]);
    }
    function gr(T) {
      return this.rawGetPointee && (T = this.rawGetPointee(T)), T;
    }
    function XE(T) {
      this.rawDestructor && this.rawDestructor(T);
    }
    function $E(T) {
      T !== null && T.delete();
    }
    function rr() {
      Fn.prototype.getPointee = gr, Fn.prototype.destructor = XE, Fn.prototype.argPackAdvance = 8, Fn.prototype.readValueFromPointer = Lo, Fn.prototype.deleteObject = $E, Fn.prototype.fromWireType = nI;
    }
    function Fn(T, b, X, CA, NA, KA, WA, OA, zA, Ce, Ge) {
      this.name = T, this.registeredClass = b, this.isReference = X, this.isConst = CA, this.isSmartPointer = NA, this.pointeeType = KA, this.sharingPolicy = WA, this.rawGetPointee = OA, this.rawConstructor = zA, this.rawShare = Ce, this.rawDestructor = Ge, !NA && b.baseClass === void 0 ? CA ? (this.toWireType = jE, this.destructorFunction = null) : (this.toWireType = ZE, this.destructorFunction = null) : this.toWireType = SB;
    }
    function oa(T, b, X) {
      e.hasOwnProperty(T) || Wt("Replacing nonexistant public symbol"), e[T].overloadTable !== void 0 && X !== void 0 ? e[T].overloadTable[X] = b : (e[T] = b, e[T].argCount = X);
    }
    function MB(T, b, X) {
      _("dynCall_" + T in e, "bad function pointer type - dynCall function not found for sig '" + T + "'"), X && X.length ? _(X.length === T.substring(1).replace(/j/g, "--").length) : _(T.length == 1);
      var CA = e["dynCall_" + T];
      return X && X.length ? CA.apply(null, [b].concat(X)) : CA.call(null, b);
    }
    function RB(T, b, X) {
      if (T.includes("j"))
        return MB(T, b, X);
      _(je(b), "missing table entry in dynCall: " + b);
      var CA = je(b).apply(null, X);
      return CA;
    }
    function Al(T, b) {
      _(T.includes("j") || T.includes("p"), "getDynCaller should only be called with i64 sigs");
      var X = [];
      return function() {
        return X.length = 0, Object.assign(X, arguments), RB(T, b, X);
      };
    }
    function Gn(T, b) {
      T = tt(T);
      function X() {
        return T.includes("j") ? Al(T, b) : je(b);
      }
      var CA = X();
      return typeof CA != "function" && St("unknown function pointer with signature " + T + ": " + b), CA;
    }
    var AQ = void 0;
    function gI(T) {
      var b = Oo(T), X = tt(b);
      return en(b), X;
    }
    function sa(T, b) {
      var X = [], CA = {};
      function NA(KA) {
        if (!CA[KA] && !ui[KA]) {
          if (Li[KA]) {
            Li[KA].forEach(NA);
            return;
          }
          X.push(KA), CA[KA] = !0;
        }
      }
      throw b.forEach(NA), new AQ(T + ": " + X.map(gI).join([", "]));
    }
    function Jg(T, b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve, Le) {
      Ge = tt(Ge), KA = Gn(NA, KA), OA && (OA = Gn(WA, OA)), Ce && (Ce = Gn(zA, Ce)), Le = Gn(ve, Le);
      var ct = pt(Ge);
      $C(ct, function() {
        sa("Cannot construct " + Ge + " due to unbound types", [CA]);
      }), ot([T, b, X], CA ? [CA] : [], function(st) {
        st = st[0];
        var Vt, Ai;
        CA ? (Vt = st.registeredClass, Ai = Vt.instancePrototype) : Ai = Ur.prototype;
        var gn = Gr(ct, function() {
          if (Object.getPrototypeOf(this) !== ye)
            throw new Rn("Use 'new' to construct " + Ge);
          if (et.constructor_body === void 0)
            throw new Rn(Ge + " has no accessible constructor");
          var tg = et.constructor_body[arguments.length];
          if (tg === void 0)
            throw new Rn("Tried to invoke ctor of " + Ge + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(et.constructor_body).toString() + ") parameters instead!");
          return tg.apply(this, arguments);
        }), ye = Object.create(Ai, { constructor: { value: gn } });
        gn.prototype = ye;
        var et = new ki(Ge, gn, ye, Le, Vt, KA, OA, Ce), bi = new Fn(Ge, et, !0, !1, !1), Yi = new Fn(Ge + "*", et, !1, !1, !1), Mg = new Fn(Ge + " const*", et, !1, !0, !1);
        return tI[T] = { pointerType: Yi, constPointerType: Mg }, oa(ct, gn), [bi, Yi, Mg];
      });
    }
    function aa(T, b) {
      if (!(T instanceof Function))
        throw new TypeError("new_ called with constructor type " + typeof T + " which is not a function");
      var X = Gr(T.name || "unknownFunctionName", function() {
      });
      X.prototype = T.prototype;
      var CA = new X(), NA = T.apply(CA, b);
      return NA instanceof Object ? NA : CA;
    }
    function Ia(T) {
      for (; T.length; ) {
        var b = T.pop(), X = T.pop();
        X(b);
      }
    }
    function kr(T, b, X, CA, NA) {
      var KA = b.length;
      KA < 2 && St("argTypes array size mismatch! Must at least get return value and 'this' types!");
      for (var WA = b[1] !== null && X !== null, OA = !1, zA = 1; zA < b.length; ++zA)
        if (b[zA] !== null && b[zA].destructorFunction === void 0) {
          OA = !0;
          break;
        }
      for (var Ce = b[0].name !== "void", Ge = "", ve = "", zA = 0; zA < KA - 2; ++zA)
        Ge += (zA !== 0 ? ", " : "") + "arg" + zA, ve += (zA !== 0 ? ", " : "") + "arg" + zA + "Wired";
      var Le = "return function " + pt(T) + "(" + Ge + `) {
if (arguments.length !== ` + (KA - 2) + `) {
throwBindingError('function ` + T + " called with ' + arguments.length + ' arguments, expected " + (KA - 2) + ` args!');
}
`;
      OA && (Le += `var destructors = [];
`);
      var ct = OA ? "destructors" : "null", st = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"], Vt = [St, CA, NA, Ia, b[0], b[1]];
      WA && (Le += "var thisWired = classParam.toWireType(" + ct + `, this);
`);
      for (var zA = 0; zA < KA - 2; ++zA)
        Le += "var arg" + zA + "Wired = argType" + zA + ".toWireType(" + ct + ", arg" + zA + "); // " + b[zA + 2].name + `
`, st.push("argType" + zA), Vt.push(b[zA + 2]);
      if (WA && (ve = "thisWired" + (ve.length > 0 ? ", " : "") + ve), Le += (Ce ? "var rv = " : "") + "invoker(fn" + (ve.length > 0 ? ", " : "") + ve + `);
`, OA)
        Le += `runDestructors(destructors);
`;
      else
        for (var zA = WA ? 1 : 2; zA < b.length; ++zA) {
          var Ai = zA === 1 ? "thisWired" : "arg" + (zA - 2) + "Wired";
          b[zA].destructorFunction !== null && (Le += Ai + "_dtor(" + Ai + "); // " + b[zA].name + `
`, st.push(Ai + "_dtor"), Vt.push(b[zA].destructorFunction));
        }
      Ce && (Le += `var ret = retType.fromWireType(rv);
return ret;
`), Le += `}
`, st.push(Le);
      var gn = aa(Function, st).apply(null, Vt);
      return gn;
    }
    function To(T, b) {
      for (var X = [], CA = 0; CA < T; CA++)
        X.push(MA[b + CA * 4 >> 2]);
      return X;
    }
    function NB(T, b, X, CA, NA, KA, WA) {
      var OA = To(X, CA);
      b = tt(b), KA = Gn(NA, KA), ot([], [T], function(zA) {
        zA = zA[0];
        var Ce = zA.name + "." + b;
        function Ge() {
          sa("Cannot call " + Ce + " due to unbound types", OA);
        }
        b.startsWith("@@") && (b = Symbol[b.substring(2)]);
        var ve = zA.registeredClass.constructor;
        return ve[b] === void 0 ? (Ge.argCount = X - 1, ve[b] = Ge) : (mB(ve, b, Ce), ve[b].overloadTable[X - 1] = Ge), ot([], OA, function(Le) {
          var ct = [Le[0], null].concat(Le.slice(1)), st = kr(Ce, ct, null, KA, WA);
          return ve[b].overloadTable === void 0 ? (st.argCount = X - 1, ve[b] = st) : ve[b].overloadTable[X - 1] = st, [];
        }), [];
      });
    }
    function FB(T, b, X, CA, NA, KA) {
      _(b > 0);
      var WA = To(b, X);
      NA = Gn(CA, NA), ot([], [T], function(OA) {
        OA = OA[0];
        var zA = "constructor " + OA.name;
        if (OA.registeredClass.constructor_body === void 0 && (OA.registeredClass.constructor_body = []), OA.registeredClass.constructor_body[b - 1] !== void 0)
          throw new Rn("Cannot register multiple constructors with identical number of parameters (" + (b - 1) + ") for class '" + OA.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
        return OA.registeredClass.constructor_body[b - 1] = () => {
          sa("Cannot construct " + OA.name + " due to unbound types", WA);
        }, ot([], WA, function(Ce) {
          return Ce.splice(1, 0, null), OA.registeredClass.constructor_body[b - 1] = kr(zA, Ce, null, NA, KA), [];
        }), [];
      });
    }
    function rI(T, b, X, CA, NA, KA, WA, OA) {
      var zA = To(X, CA);
      b = tt(b), KA = Gn(NA, KA), ot([], [T], function(Ce) {
        Ce = Ce[0];
        var Ge = Ce.name + "." + b;
        b.startsWith("@@") && (b = Symbol[b.substring(2)]), OA && Ce.registeredClass.pureVirtualFunctions.push(b);
        function ve() {
          sa("Cannot call " + Ge + " due to unbound types", zA);
        }
        var Le = Ce.registeredClass.instancePrototype, ct = Le[b];
        return ct === void 0 || ct.overloadTable === void 0 && ct.className !== Ce.name && ct.argCount === X - 2 ? (ve.argCount = X - 2, ve.className = Ce.name, Le[b] = ve) : (mB(Le, b, Ge), Le[b].overloadTable[X - 2] = ve), ot([], zA, function(st) {
          var Vt = kr(Ge, st, Ce, KA, WA);
          return Le[b].overloadTable === void 0 ? (Vt.argCount = X - 2, Le[b] = Vt) : Le[b].overloadTable[X - 2] = Vt, [];
        }), [];
      });
    }
    var Ba = [], qn = [{}, { value: void 0 }, { value: null }, { value: !0 }, { value: !1 }];
    function pg(T) {
      T > 4 && --qn[T].refcount === 0 && (qn[T] = void 0, Ba.push(T));
    }
    function Og() {
      for (var T = 0, b = 5; b < qn.length; ++b)
        qn[b] !== void 0 && ++T;
      return T;
    }
    function or() {
      for (var T = 5; T < qn.length; ++T)
        if (qn[T] !== void 0)
          return qn[T];
      return null;
    }
    function GB() {
      e.count_emval_handles = Og, e.get_first_emval = or;
    }
    var Ko = { toValue: (T) => (T || St("Cannot use deleted val. handle = " + T), qn[T].value), toHandle: (T) => {
      switch (T) {
        case void 0:
          return 1;
        case null:
          return 2;
        case !0:
          return 3;
        case !1:
          return 4;
        default: {
          var b = Ba.length ? Ba.pop() : qn.length;
          return qn[b] = { refcount: 1, value: T }, b;
        }
      }
    } };
    function xr(T, b) {
      b = tt(b), pi(T, { name: b, fromWireType: function(X) {
        var CA = Ko.toValue(X);
        return pg(X), CA;
      }, toWireType: function(X, CA) {
        return Ko.toHandle(CA);
      }, argPackAdvance: 8, readValueFromPointer: Lo, destructorFunction: null });
    }
    function ag(T) {
      if (T === null)
        return "null";
      var b = typeof T;
      return b === "object" || b === "array" || b === "function" ? T.toString() : "" + T;
    }
    function oI(T, b) {
      switch (b) {
        case 2:
          return function(X) {
            return this.fromWireType(hA[X >> 2]);
          };
        case 3:
          return function(X) {
            return this.fromWireType(fA[X >> 3]);
          };
        default:
          throw new TypeError("Unknown float type: " + T);
      }
    }
    function eQ(T, b, X) {
      var CA = Et(X);
      b = tt(b), pi(T, { name: b, fromWireType: function(NA) {
        return NA;
      }, toWireType: function(NA, KA) {
        if (typeof KA != "number" && typeof KA != "boolean")
          throw new TypeError('Cannot convert "' + ag(KA) + '" to ' + this.name);
        return KA;
      }, argPackAdvance: 8, readValueFromPointer: oI(b, CA), destructorFunction: null });
    }
    function sI(T, b, X, CA, NA, KA) {
      var WA = To(b, X);
      T = tt(T), NA = Gn(CA, NA), $C(T, function() {
        sa("Cannot call " + T + " due to unbound types", WA);
      }, b - 1), ot([], WA, function(OA) {
        var zA = [OA[0], null].concat(OA.slice(1));
        return oa(T, kr(T, zA, null, NA, KA), b - 1), [];
      });
    }
    function tQ(T, b, X) {
      switch (b) {
        case 0:
          return X ? function(NA) {
            return tA[NA];
          } : function(NA) {
            return Y[NA];
          };
        case 1:
          return X ? function(NA) {
            return rA[NA >> 1];
          } : function(NA) {
            return QA[NA >> 1];
          };
        case 2:
          return X ? function(NA) {
            return aA[NA >> 2];
          } : function(NA) {
            return MA[NA >> 2];
          };
        default:
          throw new TypeError("Unknown integer type: " + T);
      }
    }
    function iQ(T, b, X, CA, NA) {
      b = tt(b), NA === -1 && (NA = 4294967295);
      var KA = Et(X), WA = (ve) => ve;
      if (CA === 0) {
        var OA = 32 - 8 * X;
        WA = (ve) => ve << OA >>> OA;
      }
      var zA = b.includes("unsigned"), Ce = (ve, Le) => {
        if (typeof ve != "number" && typeof ve != "boolean")
          throw new TypeError('Cannot convert "' + ag(ve) + '" to ' + Le);
        if (ve < CA || ve > NA)
          throw new TypeError('Passing a number "' + ag(ve) + '" from JS side to C/C++ side to an argument of type "' + b + '", which is outside the valid range [' + CA + ", " + NA + "]!");
      }, Ge;
      zA ? Ge = function(ve, Le) {
        return Ce(Le, this.name), Le >>> 0;
      } : Ge = function(ve, Le) {
        return Ce(Le, this.name), Le;
      }, pi(T, { name: b, fromWireType: WA, toWireType: Ge, argPackAdvance: 8, readValueFromPointer: tQ(b, KA, CA !== 0), destructorFunction: null });
    }
    function aI(T, b, X) {
      var CA = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], NA = CA[b];
      function KA(WA) {
        WA = WA >> 2;
        var OA = MA, zA = OA[WA], Ce = OA[WA + 1];
        return new NA(J, Ce, zA);
      }
      X = tt(X), pi(T, { name: X, fromWireType: KA, argPackAdvance: 8, readValueFromPointer: KA }, { ignoreDuplicateRegistrations: !0 });
    }
    function II(T, b) {
      b = tt(b);
      var X = b === "std::string";
      pi(T, { name: b, fromWireType: function(CA) {
        var NA = MA[CA >> 2], KA = CA + 4, WA;
        if (X)
          for (var OA = KA, zA = 0; zA <= NA; ++zA) {
            var Ce = KA + zA;
            if (zA == NA || Y[Ce] == 0) {
              var Ge = Ce - OA, ve = iA(OA, Ge);
              WA === void 0 ? WA = ve : (WA += String.fromCharCode(0), WA += ve), OA = Ce + 1;
            }
          }
        else {
          for (var Le = new Array(NA), zA = 0; zA < NA; ++zA)
            Le[zA] = String.fromCharCode(Y[KA + zA]);
          WA = Le.join("");
        }
        return en(CA), WA;
      }, toWireType: function(CA, NA) {
        NA instanceof ArrayBuffer && (NA = new Uint8Array(NA));
        var KA, WA = typeof NA == "string";
        WA || NA instanceof Uint8Array || NA instanceof Uint8ClampedArray || NA instanceof Int8Array || St("Cannot pass non-string to std::string"), X && WA ? KA = P(NA) : KA = NA.length;
        var OA = Ms(4 + KA + 1), zA = OA + 4;
        if (MA[OA >> 2] = KA, X && WA)
          oA(NA, zA, KA + 1);
        else if (WA)
          for (var Ce = 0; Ce < KA; ++Ce) {
            var Ge = NA.charCodeAt(Ce);
            Ge > 255 && (en(zA), St("String has UTF-16 code units that do not fit in 8 bits")), Y[zA + Ce] = Ge;
          }
        else
          for (var Ce = 0; Ce < KA; ++Ce)
            Y[zA + Ce] = NA[Ce];
        return CA !== null && CA.push(en, OA), OA;
      }, argPackAdvance: 8, readValueFromPointer: Lo, destructorFunction: function(CA) {
        en(CA);
      } });
    }
    var vB = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0;
    function nQ(T, b) {
      _(T % 2 == 0, "Pointer passed to UTF16ToString must be aligned to two bytes!");
      for (var X = T, CA = X >> 1, NA = CA + b / 2; !(CA >= NA) && QA[CA]; )
        ++CA;
      if (X = CA << 1, X - T > 32 && vB)
        return vB.decode(Y.subarray(T, X));
      for (var KA = "", WA = 0; !(WA >= b / 2); ++WA) {
        var OA = rA[T + WA * 2 >> 1];
        if (OA == 0)
          break;
        KA += String.fromCharCode(OA);
      }
      return KA;
    }
    function gQ(T, b, X) {
      if (_(b % 2 == 0, "Pointer passed to stringToUTF16 must be aligned to two bytes!"), _(typeof X == "number", "stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!"), X === void 0 && (X = 2147483647), X < 2)
        return 0;
      X -= 2;
      for (var CA = b, NA = X < T.length * 2 ? X / 2 : T.length, KA = 0; KA < NA; ++KA) {
        var WA = T.charCodeAt(KA);
        rA[b >> 1] = WA, b += 2;
      }
      return rA[b >> 1] = 0, b - CA;
    }
    function UB(T) {
      return T.length * 2;
    }
    function ps(T, b) {
      _(T % 4 == 0, "Pointer passed to UTF32ToString must be aligned to four bytes!");
      for (var X = 0, CA = ""; !(X >= b / 4); ) {
        var NA = aA[T + X * 4 >> 2];
        if (NA == 0)
          break;
        if (++X, NA >= 65536) {
          var KA = NA - 65536;
          CA += String.fromCharCode(55296 | KA >> 10, 56320 | KA & 1023);
        } else
          CA += String.fromCharCode(NA);
      }
      return CA;
    }
    function Ds(T, b, X) {
      if (_(b % 4 == 0, "Pointer passed to stringToUTF32 must be aligned to four bytes!"), _(typeof X == "number", "stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!"), X === void 0 && (X = 2147483647), X < 4)
        return 0;
      for (var CA = b, NA = CA + X - 4, KA = 0; KA < T.length; ++KA) {
        var WA = T.charCodeAt(KA);
        if (WA >= 55296 && WA <= 57343) {
          var OA = T.charCodeAt(++KA);
          WA = 65536 + ((WA & 1023) << 10) | OA & 1023;
        }
        if (aA[b >> 2] = WA, b += 4, b + 4 > NA)
          break;
      }
      return aA[b >> 2] = 0, b - CA;
    }
    function BI(T) {
      for (var b = 0, X = 0; X < T.length; ++X) {
        var CA = T.charCodeAt(X);
        CA >= 55296 && CA <= 57343 && ++X, b += 4;
      }
      return b;
    }
    function CI(T, b, X) {
      X = tt(X);
      var CA, NA, KA, WA, OA;
      b === 2 ? (CA = nQ, NA = gQ, WA = UB, KA = () => QA, OA = 1) : b === 4 && (CA = ps, NA = Ds, WA = BI, KA = () => MA, OA = 2), pi(T, { name: X, fromWireType: function(zA) {
        for (var Ce = MA[zA >> 2], Ge = KA(), ve, Le = zA + 4, ct = 0; ct <= Ce; ++ct) {
          var st = zA + 4 + ct * b;
          if (ct == Ce || Ge[st >> OA] == 0) {
            var Vt = st - Le, Ai = CA(Le, Vt);
            ve === void 0 ? ve = Ai : (ve += String.fromCharCode(0), ve += Ai), Le = st + b;
          }
        }
        return en(zA), ve;
      }, toWireType: function(zA, Ce) {
        typeof Ce != "string" && St("Cannot pass non-string to C++ string type " + X);
        var Ge = WA(Ce), ve = Ms(4 + Ge + b);
        return MA[ve >> 2] = Ge >> OA, NA(Ce, ve + 4, Ge + b), zA !== null && zA.push(en, ve), ve;
      }, argPackAdvance: 8, readValueFromPointer: Lo, destructorFunction: function(zA) {
        en(zA);
      } });
    }
    function Dg(T, b) {
      b = tt(b), pi(T, { isVoid: !0, name: b, argPackAdvance: 0, fromWireType: function() {
      }, toWireType: function(X, CA) {
      } });
    }
    function wg() {
      SA("native code called abort()");
    }
    function bo(T, b, X) {
      Y.copyWithin(T, b, b + X);
    }
    function Lr() {
      return 2147483648;
    }
    function Tr(T) {
      try {
        return x.grow(T - J.byteLength + 65535 >>> 16), wA(x.buffer), 1;
      } catch (b) {
        y("emscripten_realloc_buffer: Attempted to grow heap from " + J.byteLength + " bytes to " + T + " bytes, but got error: " + b);
      }
    }
    function Yo(T) {
      var b = Y.length;
      T = T >>> 0, _(T > b);
      var X = Lr();
      if (T > X)
        return y("Cannot enlarge memory, asked to go up to " + T + " bytes, but the limit is " + X + " bytes!"), !1;
      let CA = (zA, Ce) => zA + (Ce - zA % Ce) % Ce;
      for (var NA = 1; NA <= 4; NA *= 2) {
        var KA = b * (1 + 0.2 / NA);
        KA = Math.min(KA, T + 100663296);
        var WA = Math.min(X, CA(Math.max(T, KA), 65536)), OA = Tr(WA);
        if (OA)
          return !0;
      }
      return y("Failed to grow the heap from " + b + " bytes to " + WA + " bytes, not enough memory!"), !1;
    }
    var QI = {};
    function kB() {
      return r || "./this.program";
    }
    function Ho() {
      if (!Ho.strings) {
        var T = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", b = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: T, _: kB() };
        for (var X in QI)
          QI[X] === void 0 ? delete b[X] : b[X] = QI[X];
        var CA = [];
        for (var X in b)
          CA.push(X + "=" + b[X]);
        Ho.strings = CA;
      }
      return Ho.strings;
    }
    function Ig(T, b, X) {
      for (var CA = 0; CA < T.length; ++CA)
        _(T.charCodeAt(CA) === (T.charCodeAt(CA) & 255)), tA[b++ >> 0] = T.charCodeAt(CA);
      X || (tA[b >> 0] = 0);
    }
    function vn(T, b) {
      var X = 0;
      return Ho().forEach(function(CA, NA) {
        var KA = b + X;
        MA[T + NA * 4 >> 2] = KA, Ig(CA, KA), X += CA.length + 1;
      }), 0;
    }
    function Di(T, b) {
      var X = Ho();
      MA[T >> 2] = X.length;
      var CA = 0;
      return X.forEach(function(NA) {
        CA += NA.length + 1;
      }), MA[b >> 2] = CA, 0;
    }
    function ws(T) {
      SA("fd_close called without SYSCALLS_REQUIRE_FILESYSTEM");
    }
    function yg(T, b, X, CA, NA) {
      return 70;
    }
    var xB = [null, [], []];
    function LB(T, b) {
      var X = xB[T];
      _(X), b === 0 || b === 10 ? ((T === 1 ? S : y)(V(X, 0)), X.length = 0) : X.push(b);
    }
    function EI(T, b, X, CA) {
      for (var NA = 0, KA = 0; KA < X; KA++) {
        var WA = MA[b >> 2], OA = MA[b + 4 >> 2];
        b += 8;
        for (var zA = 0; zA < OA; zA++)
          LB(T, Y[WA + zA]);
        NA += OA;
      }
      return MA[CA >> 2] = NA, 0;
    }
    function lI(T) {
      return T;
    }
    function ys(T) {
      return T % 4 === 0 && (T % 100 !== 0 || T % 400 === 0);
    }
    function Ca(T, b) {
      for (var X = 0, CA = 0; CA <= b; X += T[CA++])
        ;
      return X;
    }
    var _o = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ms = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function Jo(T, b) {
      for (var X = new Date(T.getTime()); b > 0; ) {
        var CA = ys(X.getFullYear()), NA = X.getMonth(), KA = (CA ? _o : ms)[NA];
        if (b > KA - X.getDate())
          b -= KA - X.getDate() + 1, X.setDate(1), NA < 11 ? X.setMonth(NA + 1) : (X.setMonth(0), X.setFullYear(X.getFullYear() + 1));
        else
          return X.setDate(X.getDate() + b), X;
      }
      return X;
    }
    function qg(T, b, X) {
      var CA = X > 0 ? X : P(T) + 1, NA = new Array(CA), KA = eA(T, NA, 0, NA.length);
      return b && (NA.length = KA), NA;
    }
    function cI(T, b) {
      _(T.length >= 0, "writeArrayToMemory array must have a length (should be an array or typed array)"), tA.set(T, b);
    }
    function Qa(T, b, X, CA) {
      var NA = aA[CA + 40 >> 2], KA = { tm_sec: aA[CA >> 2], tm_min: aA[CA + 4 >> 2], tm_hour: aA[CA + 8 >> 2], tm_mday: aA[CA + 12 >> 2], tm_mon: aA[CA + 16 >> 2], tm_year: aA[CA + 20 >> 2], tm_wday: aA[CA + 24 >> 2], tm_yday: aA[CA + 28 >> 2], tm_isdst: aA[CA + 32 >> 2], tm_gmtoff: aA[CA + 36 >> 2], tm_zone: NA ? iA(NA) : "" }, WA = iA(X), OA = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
      for (var zA in OA)
        WA = WA.replace(new RegExp(zA, "g"), OA[zA]);
      var Ce = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], Ge = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      function ve(ye, et, bi) {
        for (var Yi = typeof ye == "number" ? ye.toString() : ye || ""; Yi.length < et; )
          Yi = bi[0] + Yi;
        return Yi;
      }
      function Le(ye, et) {
        return ve(ye, et, "0");
      }
      function ct(ye, et) {
        function bi(Mg) {
          return Mg < 0 ? -1 : Mg > 0 ? 1 : 0;
        }
        var Yi;
        return (Yi = bi(ye.getFullYear() - et.getFullYear())) === 0 && (Yi = bi(ye.getMonth() - et.getMonth())) === 0 && (Yi = bi(ye.getDate() - et.getDate())), Yi;
      }
      function st(ye) {
        switch (ye.getDay()) {
          case 0:
            return new Date(ye.getFullYear() - 1, 11, 29);
          case 1:
            return ye;
          case 2:
            return new Date(ye.getFullYear(), 0, 3);
          case 3:
            return new Date(ye.getFullYear(), 0, 2);
          case 4:
            return new Date(ye.getFullYear(), 0, 1);
          case 5:
            return new Date(ye.getFullYear() - 1, 11, 31);
          case 6:
            return new Date(ye.getFullYear() - 1, 11, 30);
        }
      }
      function Vt(ye) {
        var et = Jo(new Date(ye.tm_year + 1900, 0, 1), ye.tm_yday), bi = new Date(et.getFullYear(), 0, 4), Yi = new Date(et.getFullYear() + 1, 0, 4), Mg = st(bi), tg = st(Yi);
        return ct(Mg, et) <= 0 ? ct(tg, et) <= 0 ? et.getFullYear() + 1 : et.getFullYear() : et.getFullYear() - 1;
      }
      var Ai = { "%a": function(ye) {
        return Ce[ye.tm_wday].substring(0, 3);
      }, "%A": function(ye) {
        return Ce[ye.tm_wday];
      }, "%b": function(ye) {
        return Ge[ye.tm_mon].substring(0, 3);
      }, "%B": function(ye) {
        return Ge[ye.tm_mon];
      }, "%C": function(ye) {
        var et = ye.tm_year + 1900;
        return Le(et / 100 | 0, 2);
      }, "%d": function(ye) {
        return Le(ye.tm_mday, 2);
      }, "%e": function(ye) {
        return ve(ye.tm_mday, 2, " ");
      }, "%g": function(ye) {
        return Vt(ye).toString().substring(2);
      }, "%G": function(ye) {
        return Vt(ye);
      }, "%H": function(ye) {
        return Le(ye.tm_hour, 2);
      }, "%I": function(ye) {
        var et = ye.tm_hour;
        return et == 0 ? et = 12 : et > 12 && (et -= 12), Le(et, 2);
      }, "%j": function(ye) {
        return Le(ye.tm_mday + Ca(ys(ye.tm_year + 1900) ? _o : ms, ye.tm_mon - 1), 3);
      }, "%m": function(ye) {
        return Le(ye.tm_mon + 1, 2);
      }, "%M": function(ye) {
        return Le(ye.tm_min, 2);
      }, "%n": function() {
        return `
`;
      }, "%p": function(ye) {
        return ye.tm_hour >= 0 && ye.tm_hour < 12 ? "AM" : "PM";
      }, "%S": function(ye) {
        return Le(ye.tm_sec, 2);
      }, "%t": function() {
        return "	";
      }, "%u": function(ye) {
        return ye.tm_wday || 7;
      }, "%U": function(ye) {
        var et = ye.tm_yday + 7 - ye.tm_wday;
        return Le(Math.floor(et / 7), 2);
      }, "%V": function(ye) {
        var et = Math.floor((ye.tm_yday + 7 - (ye.tm_wday + 6) % 7) / 7);
        if ((ye.tm_wday + 371 - ye.tm_yday - 2) % 7 <= 2 && et++, et) {
          if (et == 53) {
            var Yi = (ye.tm_wday + 371 - ye.tm_yday) % 7;
            Yi != 4 && (Yi != 3 || !ys(ye.tm_year)) && (et = 1);
          }
        } else {
          et = 52;
          var bi = (ye.tm_wday + 7 - ye.tm_yday - 1) % 7;
          (bi == 4 || bi == 5 && ys(ye.tm_year % 400 - 1)) && et++;
        }
        return Le(et, 2);
      }, "%w": function(ye) {
        return ye.tm_wday;
      }, "%W": function(ye) {
        var et = ye.tm_yday + 7 - (ye.tm_wday + 6) % 7;
        return Le(Math.floor(et / 7), 2);
      }, "%y": function(ye) {
        return (ye.tm_year + 1900).toString().substring(2);
      }, "%Y": function(ye) {
        return ye.tm_year + 1900;
      }, "%z": function(ye) {
        var et = ye.tm_gmtoff, bi = et >= 0;
        return et = Math.abs(et) / 60, et = et / 60 * 100 + et % 60, (bi ? "+" : "-") + ("0000" + et).slice(-4);
      }, "%Z": function(ye) {
        return ye.tm_zone;
      }, "%%": function() {
        return "%";
      } };
      WA = WA.replace(/%%/g, "\0\0");
      for (var zA in Ai)
        WA.includes(zA) && (WA = WA.replace(new RegExp(zA, "g"), Ai[zA](KA)));
      WA = WA.replace(/\0\0/g, "%");
      var gn = qg(WA, !1);
      return gn.length > b ? 0 : (cI(gn, T), gn.length - 1);
    }
    function Ss(T, b, X, CA, NA) {
      return Qa(T, b, X, CA);
    }
    Bt(), Rn = e.BindingError = Ui(Error, "BindingError"), Nn = e.InternalError = Ui(Error, "InternalError"), ao(), oo(), rr(), AQ = e.UnboundTypeError = Ui(Error, "UnboundTypeError"), GB();
    var uI = typeof atob == "function" ? atob : function(T) {
      var b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", X = "", CA, NA, KA, WA, OA, zA, Ce, Ge = 0;
      T = T.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      do
        WA = b.indexOf(T.charAt(Ge++)), OA = b.indexOf(T.charAt(Ge++)), zA = b.indexOf(T.charAt(Ge++)), Ce = b.indexOf(T.charAt(Ge++)), CA = WA << 2 | OA >> 4, NA = (OA & 15) << 4 | zA >> 2, KA = (zA & 3) << 6 | Ce, X = X + String.fromCharCode(CA), zA !== 64 && (X = X + String.fromCharCode(NA)), Ce !== 64 && (X = X + String.fromCharCode(KA));
      while (Ge < T.length);
      return X;
    };
    function Ea(T) {
      if (typeof I == "boolean" && I) {
        var b = Buffer.from(T, "base64");
        return new Uint8Array(b.buffer, b.byteOffset, b.byteLength);
      }
      try {
        for (var X = uI(T), CA = new Uint8Array(X.length), NA = 0; NA < X.length; ++NA)
          CA[NA] = X.charCodeAt(NA);
        return CA;
      } catch {
        throw new Error("Converting base64 string to bytes failed.");
      }
    }
    function Ti(T) {
      if (YA(T))
        return Ea(T.slice(mA.length));
    }
    function la() {
      N("fetchSettings");
    }
    var Kr = { __assert_fail: Me, __cxa_allocate_exception: xe, __cxa_begin_catch: _e, __cxa_end_catch: lA, __cxa_find_matching_catch_2: se, __cxa_find_matching_catch_3: PA, __cxa_free_exception: Jt, __cxa_rethrow: Be, __cxa_throw: At, __cxa_uncaught_exceptions: rt, __resumeException: jA, _embind_register_bigint: it, _embind_register_bool: zi, _embind_register_class: Jg, _embind_register_class_class_function: NB, _embind_register_class_constructor: FB, _embind_register_class_function: rI, _embind_register_emval: xr, _embind_register_float: eQ, _embind_register_function: sI, _embind_register_integer: iQ, _embind_register_memory_view: aI, _embind_register_std_string: II, _embind_register_std_wstring: CI, _embind_register_void: Dg, abort: wg, emscripten_memcpy_big: bo, emscripten_resize_heap: Yo, environ_get: vn, environ_sizes_get: Di, fd_close: ws, fd_seek: yg, fd_write: EI, invoke_diii: Po, invoke_fiii: Lt, invoke_i: Fs, invoke_ii: sr, invoke_iii: qt, invoke_iiii: ar, invoke_iiiii: Pg, invoke_iiiiii: ha, invoke_iiiiiii: rQ, invoke_iiiiiiii: si, invoke_iiiiiiiii: Ct, invoke_iiiiiiiiii: TB, invoke_iiiiiiiiiii: De, invoke_iiiiiiiiiiii: Yr, invoke_iiiiiiiiiiiii: nn, invoke_iiiiiiiiiiiiiii: qo, invoke_jiiii: Br, invoke_v: Sg, invoke_vi: Rs, invoke_vii: Ns, invoke_viii: Ei, invoke_viiii: mi, invoke_viiiii: Ki, invoke_viiiiii: Ir, invoke_viiiiiid: tn, invoke_viiiiiii: Gs, invoke_viiiiiiidiiii: ca, invoke_viiiiiiii: vs, invoke_viiiiiiiii: zt, invoke_viiiiiiiiii: hI, invoke_viiiiiiiiiidii: mg, invoke_viiiiiiiiiiii: fI, invoke_viiiiiiiiiiiii: dI, invoke_viiiiiiiiiiiiiii: Hr, invoke_viiiiiiiiiiiiiiii: ua, llvm_eh_typeid_for: lI, strftime_l: Ss };
    gA(), e.___wasm_call_ctors = _A("__wasm_call_ctors");
    var en = e._free = _A("free");
    e.getTempRet0 = _A("getTempRet0");
    var Ms = e._malloc = _A("malloc"), Oo = e.___getTypeName = _A("__getTypeName");
    e.__embind_initialize_bindings = _A("_embind_initialize_bindings"), e.___errno_location = _A("__errno_location"), e._fflush = _A("fflush");
    var Rt = e._setThrew = _A("setThrew"), Vi = e.setTempRet0 = _A("setTempRet0"), di = e._emscripten_stack_init = function() {
      return (di = e._emscripten_stack_init = e.asm.emscripten_stack_init).apply(null, arguments);
    };
    e._emscripten_stack_get_free = function() {
      return (e._emscripten_stack_get_free = e.asm.emscripten_stack_get_free).apply(null, arguments);
    }, e._emscripten_stack_get_base = function() {
      return (e._emscripten_stack_get_base = e.asm.emscripten_stack_get_base).apply(null, arguments);
    };
    var br = e._emscripten_stack_get_end = function() {
      return (br = e._emscripten_stack_get_end = e.asm.emscripten_stack_get_end).apply(null, arguments);
    }, lt = e.stackSave = _A("stackSave"), ht = e.stackRestore = _A("stackRestore");
    e.stackAlloc = _A("stackAlloc");
    var ji = e.___cxa_can_catch = _A("__cxa_can_catch"), Ci = e.___cxa_is_pointer_type = _A("__cxa_is_pointer_type");
    e.dynCall_viijii = _A("dynCall_viijii");
    var Io = e.dynCall_jiiii = _A("dynCall_jiiii");
    e.dynCall_iiiiij = _A("dynCall_iiiiij"), e.dynCall_iiiiijj = _A("dynCall_iiiiijj"), e.dynCall_iiiiiijj = _A("dynCall_iiiiiijj"), e.dynCall_jiji = _A("dynCall_jiji");
    function qt(T, b, X) {
      var CA = lt();
      try {
        return je(T)(b, X);
      } catch (NA) {
        if (ht(CA), NA !== NA + 0)
          throw NA;
        Rt(1, 0);
      }
    }
    function mi(T, b, X, CA, NA) {
      var KA = lt();
      try {
        je(T)(b, X, CA, NA);
      } catch (WA) {
        if (ht(KA), WA !== WA + 0)
          throw WA;
        Rt(1, 0);
      }
    }
    function Ei(T, b, X, CA) {
      var NA = lt();
      try {
        je(T)(b, X, CA);
      } catch (KA) {
        if (ht(NA), KA !== KA + 0)
          throw KA;
        Rt(1, 0);
      }
    }
    function Rs(T, b) {
      var X = lt();
      try {
        je(T)(b);
      } catch (CA) {
        if (ht(X), CA !== CA + 0)
          throw CA;
        Rt(1, 0);
      }
    }
    function sr(T, b) {
      var X = lt();
      try {
        return je(T)(b);
      } catch (CA) {
        if (ht(X), CA !== CA + 0)
          throw CA;
        Rt(1, 0);
      }
    }
    function Ns(T, b, X) {
      var CA = lt();
      try {
        je(T)(b, X);
      } catch (NA) {
        if (ht(CA), NA !== NA + 0)
          throw NA;
        Rt(1, 0);
      }
    }
    function Fs(T) {
      var b = lt();
      try {
        return je(T)();
      } catch (X) {
        if (ht(b), X !== X + 0)
          throw X;
        Rt(1, 0);
      }
    }
    function tn(T, b, X, CA, NA, KA, WA, OA) {
      var zA = lt();
      try {
        je(T)(b, X, CA, NA, KA, WA, OA);
      } catch (Ce) {
        if (ht(zA), Ce !== Ce + 0)
          throw Ce;
        Rt(1, 0);
      }
    }
    function mg(T, b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve, Le, ct) {
      var st = lt();
      try {
        je(T)(b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve, Le, ct);
      } catch (Vt) {
        if (ht(st), Vt !== Vt + 0)
          throw Vt;
        Rt(1, 0);
      }
    }
    function Gs(T, b, X, CA, NA, KA, WA, OA) {
      var zA = lt();
      try {
        je(T)(b, X, CA, NA, KA, WA, OA);
      } catch (Ce) {
        if (ht(zA), Ce !== Ce + 0)
          throw Ce;
        Rt(1, 0);
      }
    }
    function ca(T, b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve, Le) {
      var ct = lt();
      try {
        je(T)(b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve, Le);
      } catch (st) {
        if (ht(ct), st !== st + 0)
          throw st;
        Rt(1, 0);
      }
    }
    function ar(T, b, X, CA) {
      var NA = lt();
      try {
        return je(T)(b, X, CA);
      } catch (KA) {
        if (ht(NA), KA !== KA + 0)
          throw KA;
        Rt(1, 0);
      }
    }
    function Pg(T, b, X, CA, NA) {
      var KA = lt();
      try {
        return je(T)(b, X, CA, NA);
      } catch (WA) {
        if (ht(KA), WA !== WA + 0)
          throw WA;
        Rt(1, 0);
      }
    }
    function Ir(T, b, X, CA, NA, KA, WA) {
      var OA = lt();
      try {
        je(T)(b, X, CA, NA, KA, WA);
      } catch (zA) {
        if (ht(OA), zA !== zA + 0)
          throw zA;
        Rt(1, 0);
      }
    }
    function ua(T, b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve, Le, ct, st, Vt, Ai) {
      var gn = lt();
      try {
        je(T)(b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve, Le, ct, st, Vt, Ai);
      } catch (ye) {
        if (ht(gn), ye !== ye + 0)
          throw ye;
        Rt(1, 0);
      }
    }
    function hI(T, b, X, CA, NA, KA, WA, OA, zA, Ce, Ge) {
      var ve = lt();
      try {
        je(T)(b, X, CA, NA, KA, WA, OA, zA, Ce, Ge);
      } catch (Le) {
        if (ht(ve), Le !== Le + 0)
          throw Le;
        Rt(1, 0);
      }
    }
    function qo(T, b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve, Le, ct, st) {
      var Vt = lt();
      try {
        return je(T)(b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve, Le, ct, st);
      } catch (Ai) {
        if (ht(Vt), Ai !== Ai + 0)
          throw Ai;
        Rt(1, 0);
      }
    }
    function TB(T, b, X, CA, NA, KA, WA, OA, zA, Ce) {
      var Ge = lt();
      try {
        return je(T)(b, X, CA, NA, KA, WA, OA, zA, Ce);
      } catch (ve) {
        if (ht(Ge), ve !== ve + 0)
          throw ve;
        Rt(1, 0);
      }
    }
    function Ct(T, b, X, CA, NA, KA, WA, OA, zA) {
      var Ce = lt();
      try {
        return je(T)(b, X, CA, NA, KA, WA, OA, zA);
      } catch (Ge) {
        if (ht(Ce), Ge !== Ge + 0)
          throw Ge;
        Rt(1, 0);
      }
    }
    function si(T, b, X, CA, NA, KA, WA, OA) {
      var zA = lt();
      try {
        return je(T)(b, X, CA, NA, KA, WA, OA);
      } catch (Ce) {
        if (ht(zA), Ce !== Ce + 0)
          throw Ce;
        Rt(1, 0);
      }
    }
    function zt(T, b, X, CA, NA, KA, WA, OA, zA, Ce) {
      var Ge = lt();
      try {
        je(T)(b, X, CA, NA, KA, WA, OA, zA, Ce);
      } catch (ve) {
        if (ht(Ge), ve !== ve + 0)
          throw ve;
        Rt(1, 0);
      }
    }
    function Ki(T, b, X, CA, NA, KA) {
      var WA = lt();
      try {
        je(T)(b, X, CA, NA, KA);
      } catch (OA) {
        if (ht(WA), OA !== OA + 0)
          throw OA;
        Rt(1, 0);
      }
    }
    function Sg(T) {
      var b = lt();
      try {
        je(T)();
      } catch (X) {
        if (ht(b), X !== X + 0)
          throw X;
        Rt(1, 0);
      }
    }
    function vs(T, b, X, CA, NA, KA, WA, OA, zA) {
      var Ce = lt();
      try {
        je(T)(b, X, CA, NA, KA, WA, OA, zA);
      } catch (Ge) {
        if (ht(Ce), Ge !== Ge + 0)
          throw Ge;
        Rt(1, 0);
      }
    }
    function rQ(T, b, X, CA, NA, KA, WA) {
      var OA = lt();
      try {
        return je(T)(b, X, CA, NA, KA, WA);
      } catch (zA) {
        if (ht(OA), zA !== zA + 0)
          throw zA;
        Rt(1, 0);
      }
    }
    function dI(T, b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve, Le, ct) {
      var st = lt();
      try {
        je(T)(b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve, Le, ct);
      } catch (Vt) {
        if (ht(st), Vt !== Vt + 0)
          throw Vt;
        Rt(1, 0);
      }
    }
    function fI(T, b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve, Le) {
      var ct = lt();
      try {
        je(T)(b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve, Le);
      } catch (st) {
        if (ht(ct), st !== st + 0)
          throw st;
        Rt(1, 0);
      }
    }
    function ha(T, b, X, CA, NA, KA) {
      var WA = lt();
      try {
        return je(T)(b, X, CA, NA, KA);
      } catch (OA) {
        if (ht(WA), OA !== OA + 0)
          throw OA;
        Rt(1, 0);
      }
    }
    function De(T, b, X, CA, NA, KA, WA, OA, zA, Ce, Ge) {
      var ve = lt();
      try {
        return je(T)(b, X, CA, NA, KA, WA, OA, zA, Ce, Ge);
      } catch (Le) {
        if (ht(ve), Le !== Le + 0)
          throw Le;
        Rt(1, 0);
      }
    }
    function nn(T, b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve, Le) {
      var ct = lt();
      try {
        return je(T)(b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve, Le);
      } catch (st) {
        if (ht(ct), st !== st + 0)
          throw st;
        Rt(1, 0);
      }
    }
    function Lt(T, b, X, CA) {
      var NA = lt();
      try {
        return je(T)(b, X, CA);
      } catch (KA) {
        if (ht(NA), KA !== KA + 0)
          throw KA;
        Rt(1, 0);
      }
    }
    function Po(T, b, X, CA) {
      var NA = lt();
      try {
        return je(T)(b, X, CA);
      } catch (KA) {
        if (ht(NA), KA !== KA + 0)
          throw KA;
        Rt(1, 0);
      }
    }
    function Yr(T, b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve) {
      var Le = lt();
      try {
        return je(T)(b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve);
      } catch (ct) {
        if (ht(Le), ct !== ct + 0)
          throw ct;
        Rt(1, 0);
      }
    }
    function Hr(T, b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve, Le, ct, st, Vt) {
      var Ai = lt();
      try {
        je(T)(b, X, CA, NA, KA, WA, OA, zA, Ce, Ge, ve, Le, ct, st, Vt);
      } catch (gn) {
        if (ht(Ai), gn !== gn + 0)
          throw gn;
        Rt(1, 0);
      }
    }
    function Br(T, b, X, CA, NA) {
      var KA = lt();
      try {
        return Io(T, b, X, CA, NA);
      } catch (WA) {
        if (ht(KA), WA !== WA + 0)
          throw WA;
        Rt(1, 0);
      }
    }
    var Us = ["run", "UTF8ArrayToString", "UTF8ToString", "stringToUTF8Array", "stringToUTF8", "lengthBytesUTF8", "addOnPreRun", "addOnInit", "addOnPreMain", "addOnExit", "addOnPostRun", "addRunDependency", "removeRunDependency", "FS_createFolder", "FS_createPath", "FS_createDataFile", "FS_createPreloadedFile", "FS_createLazyFile", "FS_createLink", "FS_createDevice", "FS_unlink", "getLEB", "getFunctionTables", "alignFunctionTables", "registerFunctions", "prettyPrint", "getCompilerSetting", "out", "err", "callMain", "abort", "keepRuntimeAlive", "wasmMemory", "stackAlloc", "stackSave", "stackRestore", "getTempRet0", "setTempRet0", "writeStackCookie", "checkStackCookie", "intArrayFromBase64", "tryParseAsDataURI", "ptrToString", "zeroMemory", "stringToNewUTF8", "exitJS", "getHeapMax", "emscripten_realloc_buffer", "ENV", "ERRNO_CODES", "ERRNO_MESSAGES", "setErrNo", "inetPton4", "inetNtop4", "inetPton6", "inetNtop6", "readSockaddr", "writeSockaddr", "DNS", "getHostByName", "Protocols", "Sockets", "getRandomDevice", "warnOnce", "traverseStack", "UNWIND_CACHE", "convertPCtoSourceLocation", "readAsmConstArgsArray", "readAsmConstArgs", "mainThreadEM_ASM", "jstoi_q", "jstoi_s", "getExecutableName", "listenOnce", "autoResumeAudioContext", "dynCallLegacy", "getDynCaller", "dynCall", "handleException", "runtimeKeepalivePush", "runtimeKeepalivePop", "callUserCallback", "maybeExit", "safeSetTimeout", "asmjsMangle", "asyncLoad", "alignMemory", "mmapAlloc", "writeI53ToI64", "writeI53ToI64Clamped", "writeI53ToI64Signaling", "writeI53ToU64Clamped", "writeI53ToU64Signaling", "readI53FromI64", "readI53FromU64", "convertI32PairToI53", "convertI32PairToI53Checked", "convertU32PairToI53", "getCFunc", "ccall", "cwrap", "uleb128Encode", "sigToWasmTypes", "generateFuncType", "convertJsFunctionToWasm", "freeTableIndexes", "functionsInTableMap", "getEmptyTableSlot", "updateTableMap", "addFunction", "removeFunction", "reallyNegative", "unSign", "strLen", "reSign", "formatString", "setValue", "getValue", "PATH", "PATH_FS", "intArrayFromString", "intArrayToString", "AsciiToString", "stringToAscii", "UTF16Decoder", "UTF16ToString", "stringToUTF16", "lengthBytesUTF16", "UTF32ToString", "stringToUTF32", "lengthBytesUTF32", "allocateUTF8", "allocateUTF8OnStack", "writeStringToMemory", "writeArrayToMemory", "writeAsciiToMemory", "SYSCALLS", "getSocketFromFD", "getSocketAddress", "JSEvents", "registerKeyEventCallback", "specialHTMLTargets", "maybeCStringToJsString", "findEventTarget", "findCanvasEventTarget", "getBoundingClientRect", "fillMouseEventData", "registerMouseEventCallback", "registerWheelEventCallback", "registerUiEventCallback", "registerFocusEventCallback", "fillDeviceOrientationEventData", "registerDeviceOrientationEventCallback", "fillDeviceMotionEventData", "registerDeviceMotionEventCallback", "screenOrientation", "fillOrientationChangeEventData", "registerOrientationChangeEventCallback", "fillFullscreenChangeEventData", "registerFullscreenChangeEventCallback", "JSEvents_requestFullscreen", "JSEvents_resizeCanvasForFullscreen", "registerRestoreOldStyle", "hideEverythingExceptGivenElement", "restoreHiddenElements", "setLetterbox", "currentFullscreenStrategy", "restoreOldWindowedStyle", "softFullscreenResizeWebGLRenderTarget", "doRequestFullscreen", "fillPointerlockChangeEventData", "registerPointerlockChangeEventCallback", "registerPointerlockErrorEventCallback", "requestPointerLock", "fillVisibilityChangeEventData", "registerVisibilityChangeEventCallback", "registerTouchEventCallback", "fillGamepadEventData", "registerGamepadEventCallback", "registerBeforeUnloadEventCallback", "fillBatteryEventData", "battery", "registerBatteryEventCallback", "setCanvasElementSize", "getCanvasElementSize", "demangle", "demangleAll", "jsStackTrace", "stackTrace", "ExitStatus", "getEnvStrings", "checkWasiClock", "flush_NO_FILESYSTEM", "dlopenMissingError", "createDyncallWrapper", "setImmediateWrapped", "clearImmediateWrapped", "polyfillSetImmediate", "uncaughtExceptionCount", "exceptionLast", "exceptionCaught", "ExceptionInfo", "exception_addRef", "exception_decRef", "getExceptionMessageCommon", "incrementExceptionRefcount", "decrementExceptionRefcount", "getExceptionMessage", "Browser", "setMainLoop", "wget", "FS", "MEMFS", "TTY", "PIPEFS", "SOCKFS", "_setNetworkCallback", "tempFixedLengthArray", "miniTempWebGLFloatBuffers", "heapObjectForWebGLType", "heapAccessShiftForWebGLHeap", "GL", "emscriptenWebGLGet", "computeUnpackAlignedImageSize", "emscriptenWebGLGetTexPixelData", "emscriptenWebGLGetUniform", "webglGetUniformLocation", "webglPrepareUniformLocationsBeforeFirstUse", "webglGetLeftBracePos", "emscriptenWebGLGetVertexAttrib", "writeGLArray", "AL", "SDL_unicode", "SDL_ttfContext", "SDL_audio", "SDL", "SDL_gfx", "GLUT", "EGL", "GLFW_Window", "GLFW", "GLEW", "IDBStore", "runAndAbortIfError", "ALLOC_NORMAL", "ALLOC_STACK", "allocate", "InternalError", "BindingError", "UnboundTypeError", "PureVirtualError", "init_embind", "throwInternalError", "throwBindingError", "throwUnboundTypeError", "ensureOverloadTable", "exposePublicSymbol", "replacePublicSymbol", "extendError", "createNamedFunction", "embindRepr", "registeredInstances", "getBasestPointer", "registerInheritedInstance", "unregisterInheritedInstance", "getInheritedInstance", "getInheritedInstanceCount", "getLiveInheritedInstances", "registeredTypes", "awaitingDependencies", "typeDependencies", "registeredPointers", "registerType", "whenDependentTypesAreResolved", "embind_charCodes", "embind_init_charCodes", "readLatin1String", "getTypeName", "heap32VectorToArray", "requireRegisteredType", "getShiftFromSize", "integerReadValueFromPointer", "enumReadValueFromPointer", "floatReadValueFromPointer", "simpleReadValueFromPointer", "runDestructors", "new_", "craftInvokerFunction", "embind__requireFunction", "tupleRegistrations", "structRegistrations", "genericPointerToWireType", "constNoSmartPtrRawPointerToWireType", "nonConstNoSmartPtrRawPointerToWireType", "init_RegisteredPointer", "RegisteredPointer", "RegisteredPointer_getPointee", "RegisteredPointer_destructor", "RegisteredPointer_deleteObject", "RegisteredPointer_fromWireType", "runDestructor", "releaseClassHandle", "finalizationRegistry", "detachFinalizer_deps", "detachFinalizer", "attachFinalizer", "makeClassHandle", "init_ClassHandle", "ClassHandle", "ClassHandle_isAliasOf", "throwInstanceAlreadyDeleted", "ClassHandle_clone", "ClassHandle_delete", "deletionQueue", "ClassHandle_isDeleted", "ClassHandle_deleteLater", "flushPendingDeletes", "delayFunction", "setDelayFunction", "RegisteredClass", "shallowCopyInternalPointer", "downcastPointer", "upcastPointer", "validateThis", "char_0", "char_9", "makeLegalFunctionName", "emval_handle_array", "emval_free_list", "emval_symbols", "init_emval", "count_emval_handles", "get_first_emval", "getStringOrSymbol", "Emval", "emval_newers", "craftEmvalAllocator", "emval_get_global", "emval_lookupTypes", "emval_allocateDestructors", "emval_methodCallers", "emval_addMethodCaller", "emval_registeredMethods"];
    Us.forEach(k);
    var ks = ["ptrToString", "zeroMemory", "stringToNewUTF8", "exitJS", "setErrNo", "inetPton4", "inetNtop4", "inetPton6", "inetNtop6", "readSockaddr", "writeSockaddr", "getHostByName", "getRandomDevice", "traverseStack", "convertPCtoSourceLocation", "readAsmConstArgs", "mainThreadEM_ASM", "jstoi_q", "jstoi_s", "listenOnce", "autoResumeAudioContext", "handleException", "runtimeKeepalivePush", "runtimeKeepalivePop", "callUserCallback", "maybeExit", "safeSetTimeout", "asmjsMangle", "asyncLoad", "alignMemory", "mmapAlloc", "writeI53ToI64", "writeI53ToI64Clamped", "writeI53ToI64Signaling", "writeI53ToU64Clamped", "writeI53ToU64Signaling", "readI53FromI64", "readI53FromU64", "convertI32PairToI53", "convertU32PairToI53", "getCFunc", "ccall", "cwrap", "uleb128Encode", "sigToWasmTypes", "generateFuncType", "convertJsFunctionToWasm", "getEmptyTableSlot", "updateTableMap", "addFunction", "removeFunction", "reallyNegative", "unSign", "strLen", "reSign", "formatString", "AsciiToString", "stringToAscii", "allocateUTF8", "allocateUTF8OnStack", "writeStringToMemory", "getSocketFromFD", "getSocketAddress", "registerKeyEventCallback", "maybeCStringToJsString", "findEventTarget", "findCanvasEventTarget", "getBoundingClientRect", "fillMouseEventData", "registerMouseEventCallback", "registerWheelEventCallback", "registerUiEventCallback", "registerFocusEventCallback", "fillDeviceOrientationEventData", "registerDeviceOrientationEventCallback", "fillDeviceMotionEventData", "registerDeviceMotionEventCallback", "screenOrientation", "fillOrientationChangeEventData", "registerOrientationChangeEventCallback", "fillFullscreenChangeEventData", "registerFullscreenChangeEventCallback", "JSEvents_requestFullscreen", "JSEvents_resizeCanvasForFullscreen", "registerRestoreOldStyle", "hideEverythingExceptGivenElement", "restoreHiddenElements", "setLetterbox", "softFullscreenResizeWebGLRenderTarget", "doRequestFullscreen", "fillPointerlockChangeEventData", "registerPointerlockChangeEventCallback", "registerPointerlockErrorEventCallback", "requestPointerLock", "fillVisibilityChangeEventData", "registerVisibilityChangeEventCallback", "registerTouchEventCallback", "fillGamepadEventData", "registerGamepadEventCallback", "registerBeforeUnloadEventCallback", "fillBatteryEventData", "battery", "registerBatteryEventCallback", "setCanvasElementSize", "getCanvasElementSize", "demangle", "demangleAll", "jsStackTrace", "stackTrace", "checkWasiClock", "createDyncallWrapper", "setImmediateWrapped", "clearImmediateWrapped", "polyfillSetImmediate", "getExceptionMessageCommon", "incrementExceptionRefcount", "decrementExceptionRefcount", "getExceptionMessage", "setMainLoop", "_setNetworkCallback", "heapObjectForWebGLType", "heapAccessShiftForWebGLHeap", "emscriptenWebGLGet", "computeUnpackAlignedImageSize", "emscriptenWebGLGetTexPixelData", "emscriptenWebGLGetUniform", "webglGetUniformLocation", "webglPrepareUniformLocationsBeforeFirstUse", "webglGetLeftBracePos", "emscriptenWebGLGetVertexAttrib", "writeGLArray", "SDL_unicode", "SDL_ttfContext", "SDL_audio", "GLFW_Window", "runAndAbortIfError", "ALLOC_NORMAL", "ALLOC_STACK", "allocate", "registerInheritedInstance", "unregisterInheritedInstance", "requireRegisteredType", "enumReadValueFromPointer", "validateThis", "getStringOrSymbol", "craftEmvalAllocator", "emval_get_global", "emval_lookupTypes", "emval_allocateDestructors", "emval_addMethodCaller"];
    ks.forEach(G);
    var _r;
    BA = function T() {
      _r || pI(), _r || (BA = T);
    };
    function KB() {
      di(), dA();
    }
    function pI(T) {
      if (Z > 0 || (KB(), Ae(), Z > 0))
        return;
      function b() {
        _r || (_r = !0, e.calledRun = !0, !H && (ie(), t(e), e.onRuntimeInitialized && e.onRuntimeInitialized(), _(!e._main, 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]'), de()));
      }
      e.setStatus ? (e.setStatus("Running..."), setTimeout(function() {
        setTimeout(function() {
          e.setStatus("");
        }, 1), b();
      }, 1)) : b(), vA();
    }
    if (e.preInit)
      for (typeof e.preInit == "function" && (e.preInit = [e.preInit]); e.preInit.length > 0; )
        e.preInit.pop()();
    return pI(), e.ready;
  };
})();
class cz {
  /**
   * This class serves as a semi automatic memory manager/garbage collector
   * for objects that internally store data and perform operations on the {@link http://emscripten.org emscripten}
   * heap, and hence cannot be freed by the Javascript garbage collector. These
   * include {@link DenseMatrix}, {@link SparseMatrix}, {@link Triplet}, {@link Complex}, {@link ComplexDenseMatrix},
   * {@link ComplexSparseMatrix} and {@link ComplexTriplet}. Since operations involving the above
   * matrices and linear algebra entities are frequent and generate a lot of intermediate
   * variables, EmscriptenMemoryManager automatically tracks all objects that are
   * allocated on the emscripten heap to ease the burden of manual memory management.
   * The user is required to inform the EmscriptenMemoryManager about when it should
   * clear the heap and which objects it should *not* delete while doing so.
   * @constructor EmscriptenMemoryManager
   * @property {Object[]} objectList Array of objects allocated on the emscripten heap.
   * @example
   * let memoryManager = new EmscriptenMemoryManager();
   *
   * let A = SparseMatrix.identity(100, 100);
   * let x = DenseMatrix.random(100, 1);
   * let B = A.timesDense(x).plus(x);
   *
   * // delete all objects created in the previous three calls except B
   * memoryManager.deleteExcept([B]);
   */
  constructor() {
    this.objectList = [];
  }
  /**
   * Deletes all objects in this memory manager's list of emscripten heap allocated
   * objects except those in the array passed to this method.
   * @method EmscriptenMemoryManager#deleteExcept
   * @param {Object[]} exceptList Array of objects allocated on the emscripten heap
   * that should not to be deleted.
   */
  deleteExcept(A) {
    for (let e of this.objectList) {
      let t = !0;
      for (let i of A)
        e === i && (t = !1);
      t && e.delete();
    }
    this.objectList = A;
  }
}
let aw = { current: void 0 };
class Mr {
  static module() {
    return aw.current;
  }
  static async init() {
    aw.current || (aw.current = await lz());
  }
}
Mr.mm = new cz();
class uz {
  constructor() {
    this.textureMap = {}, this.canvasSize = 512, this.processColorMapCanvas = (A, e) => {
      A.width = A.height = this.canvasSize;
      const t = A.getContext("2d");
      t.fillStyle = "transparent", t?.fillRect(0, 0, A.width, A.height);
      const i = 100, n = (A.width - i) / e.width, r = (A.height - i) / e.height, s = Math.min(n, r), B = (A.width - e.width * s) / 2, I = (A.height - e.height * s) / 2;
      t?.translate(A.width, 0), t?.scale(-1, 1), t?.drawImage(
        e,
        B,
        I,
        e.width * s,
        e.height * s
      );
    };
  }
  loadTexture(A) {
    return new Promise((e, t) => {
      if (A in this.textureMap) {
        const i = this.textureMap[A].clone();
        e(i);
      } else {
        const i = new Image();
        i.src = A, i.crossOrigin = "anonymous", i.onload = () => {
          const n = document.createElement("canvas");
          this.processColorMapCanvas(n, i);
          const r = new Ov(n);
          r.minFilter = Gi, this.textureMap[A] = r, e(r);
        }, i.onerror = (n) => t(n);
      }
    });
  }
}
const Yk = new uz();
function hz(g, A, e) {
  return Math.max(A, Math.min(e, g));
}
class er {
  /**
   * This class represents an element of Euclidean 3-space, along with all the usual
   * vector space operations (addition, multiplication by scalars, etc.).
   * @constructor Vector
   * @property {number} x The x component of this vector. Default value is 0.
   * @property {number} y The y component of this vector. Default value is 0.
   * @property {number} z The z component of this vector. Default value is 0.
   */
  constructor(A = 0, e = 0, t = 0) {
    this.x = A, this.y = e, this.z = t;
  }
  toString() {
    return `${this.x.toFixed(4)},${this.y.toFixed(4)},${this.z.toFixed(4)};`;
  }
  /**
   * Computes the Euclidean length of this vector.
   * @method Vector#norm
   * @returns {number}
   */
  norm() {
    return Math.sqrt(this.norm2());
  }
  /**
   * Computes the Euclidean length squared of this vector.
   * @method Vector#norm2
   * @returns {number}
   */
  norm2() {
    return this.dot(this);
  }
  /**
   * Divides this vector by its Euclidean length.
   * @method Vector#normalize
   */
  normalize() {
    let A = this.norm();
    this.x /= A, this.y /= A, this.z /= A;
  }
  /**
   * Returns a normalized copy of this vector.
   * @method Vector#unit
   * @returns {Vector}
   */
  unit() {
    let A = this.norm(), e = this.x / A, t = this.y / A, i = this.z / A;
    return new er(e, t, i);
  }
  /**
   * Checks whether this vector's components are finite.
   * @method Vector#isValid
   * @returns {boolean}
   */
  isValid() {
    return !isNaN(this.x) && !isNaN(this.y) && !isNaN(this.z) && isFinite(this.x) && isFinite(this.y) && isFinite(this.z);
  }
  /**
   * u += v
   * @method Vector#incrementBy
   * @param {Vector} v The vector added to this vector.
   */
  incrementBy(A) {
    this.x += A.x, this.y += A.y, this.z += A.z;
  }
  /**
   * u -= v
   * @method Vector#decrementBy
   * @param {Vector} v The vector subtracted from this vector.
   */
  decrementBy(A) {
    this.x -= A.x, this.y -= A.y, this.z -= A.z;
  }
  /**
   * u *= s
   * @method Vector#scaleBy
   * @param {number} s The number this vector is scaled by.
   */
  scaleBy(A) {
    this.x *= A, this.y *= A, this.z *= A;
  }
  /**
   * u /= s
   * @method Vector#divideBy
   * @param {number} s The number this vector is divided by.
   */
  divideBy(A) {
    this.scaleBy(1 / A);
  }
  /**
   * Returns u + v
   * @method Vector#plus
   * @param {Vector} v The vector added to this vector.
   * @return {Vector}
   */
  plus(A) {
    return new er(this.x + A.x, this.y + A.y, this.z + A.z);
  }
  /**
   * Returns u - v
   * @method Vector#minus
   * @param {Vector} v The vector subtracted from this vector.
   * @return {Vector}
   */
  minus(A) {
    return new er(this.x - A.x, this.y - A.y, this.z - A.z);
  }
  /**
   * Returns u * s
   * @method Vector#times
   * @param {number} s The number this vector is multiplied by.
   * @return {Vector}
   */
  times(A) {
    return new er(this.x * A, this.y * A, this.z * A);
  }
  /**
   * Returns u / s
   * @method Vector#over
   * @param {number} s The number this vector is divided by.
   * @return {Vector}
   */
  over(A) {
    return this.times(1 / A);
  }
  /**
   * Returns -u
   * @method Vector#negated
   * @return {Vector}
   */
  negated() {
    return this.times(-1);
  }
  /**
   * Computes the dot product of this vector and v
   * @method Vector#dot
   * @param {Vector} v The vector this vector is dotted with.
   * @return {number}
   */
  dot(A) {
    return this.x * A.x + this.y * A.y + this.z * A.z;
  }
  /**
   * Computes the cross product of this vector and v
   * @method Vector#cross
   * @param {Vector} v The vector this vector is crossed with.
   * @return {Vector}
   */
  cross(A) {
    return new er(
      this.y * A.z - this.z * A.y,
      this.z * A.x - this.x * A.z,
      this.x * A.y - this.y * A.x
    );
  }
}
class ln {
  /**
   * This class represents a real m by n real matrix where every entry, including
   * zero-valued entries, is stored explicitly. Do not create a DenseMatrix
   * from its constructor, instead use static factory methods such as zeros,
   * identity, ones, constant and random.
   * @constructor DenseMatrix
   * @example
   * let A = DenseMatrix.zeros(20, 5);
   * let B = DenseMatrix.identity(10, 10);
   * let C = DenseMatrix.ones(100, 1);
   * let D = DenseMatrix.constant(4.6, 5, 5);
   * let E = DenseMatrix.random(5, 20);
   */
  constructor(A) {
    this.data = A, Mr.mm.objectList.push(this);
  }
  /**
   * Deletes the emscripten heap allocated data of this dense matrix.
   * @ignore
   * @method DenseMatrix#delete
   */
  delete() {
    this.data.delete();
  }
  /**
   * Initializes a m by n matrix of zeros.
   * @method DenseMatrix.zeros
   * @param {number} m The number of rows in this dense matrix.
   * @param {number} n The number of columns in this dense matrix.
   * @returns {DenseMatrix}
   */
  static zeros(A, e = 1) {
    return new ln(new (Mr.module()).DenseMatrix(A, e));
  }
  /**
   * Initializes a m by n identity matrix.
   * @method DenseMatrix.identity
   * @param {number} m The number of rows in this dense matrix.
   * @param {number} n The number of columns in this dense matrix.
   * @returns {DenseMatrix}
   */
  static identity(A, e = 1) {
    return new ln(Mr.module().DenseMatrix.identity(A, e));
  }
  /**
   * Initializes a m by n matrix of ones.
   * @method DenseMatrix.ones
   * @param {number} m The number of rows in this dense matrix.
   * @param {number} n The number of columns in this dense matrix.
   * @returns {DenseMatrix}
   */
  static ones(A, e = 1) {
    return new ln(Mr.module().DenseMatrix.ones(A, e));
  }
  /**
   * Initializes a m by n constant matrix.
   * @method DenseMatrix.constant
   * @param {number} x The constant value stored in every entry of this dense matrix.
   * @param {number} m The number of rows in this dense matrix.
   * @param {number} n The number of columns in this dense matrix.
   * @returns {DenseMatrix}
   */
  static constant(A, e, t = 1) {
    return new ln(Mr.module().DenseMatrix.constant(e, t, A));
  }
  /**
   * Initializes a m by n random matrix.
   * @method DenseMatrix.random
   * @param {number} m The number of rows in this dense matrix.
   * @param {number} n The number of columns in this dense matrix.
   * @returns {DenseMatrix}
   */
  static random(A, e = 1) {
    return new ln(Mr.module().DenseMatrix.random(A, e));
  }
  /**
   * Returns the transpose of this dense matrix.
   * @method DenseMatrix#transpose
   * @returns {DenseMatrix}
   */
  transpose() {
    return new ln(this.data.transpose());
  }
  /**
   * Returns the number of rows in this dense matrix.
   * @method DenseMatrix#nRows
   * @returns {number}
   */
  nRows() {
    return this.data.nRows();
  }
  /**
   * Returns the number of columns in this dense matrix.
   * @method DenseMatrix#nCols
   * @returns {number}
   */
  nCols() {
    return this.data.nCols();
  }
  /**
   * Computes the lInfinity, l1 or l2 norm of this dense matrix.
   * @method DenseMatrix#norm
   * @param {number} n Computes the lInfinity norm if n = 0, l1 norm if n = 1
   * and l2 norm if n = 2.
   * @returns {number}
   */
  norm(A = 2) {
    return this.data.norm(A);
  }
  /**
   * Returns the rank of this dense matrix.
   * @method DenseMatrix#rank
   * @returns {number}
   */
  rank() {
    return this.data.rank();
  }
  /**
   * Sums all the entries in this dense matrix.
   * @method DenseMatrix#sum
   * @returns {number}
   */
  sum() {
    return this.data.sum();
  }
  /**
   * Extracts a sub-matrix in the range [r0, r1) x [c0, c1), i.e., a matrix
   * of size (r1 - r0) x (c1 - c0) starting at indices (r0, c0).
   * @method DenseMatrix#subMatrix
   * @param {number} r0 The start row index.
   * @param {number} r1 The end row index (not included).
   * @param {number} c0 The start column index.
   * @param {number} c1 The end column index (not included).
   * @returns {DenseMatrix}
   */
  subMatrix(A, e, t = 0, i = 1) {
    return new ln(this.data.subMatrix(A, e, t, i));
  }
  /**
   * A += B
   * @method DenseMatrix#incrementBy
   * @param {DenseMatrix} B The dense matrix added to this dense matrix.
   */
  incrementBy(A) {
    this.data.incrementBy(A.data);
  }
  /**
   * A -= B
   * @method DenseMatrix#decrementBy
   * @param {DenseMatrix} B The dense matrix subtracted from this dense matrix.
   */
  decrementBy(A) {
    this.data.decrementBy(A.data);
  }
  /**
   * A *= s
   * @method DenseMatrix#scaleBy
   * @param {number} s The number this dense matrix is scaled by.
   */
  scaleBy(A) {
    this.data.scaleBy(A);
  }
  /**
   * Returns A + B
   * @method DenseMatrix#plus
   * @param {DenseMatrix} B The dense matrix added to this dense matrix.
   * @returns {DenseMatrix}
   */
  plus(A) {
    return new ln(this.data.plus(A.data));
  }
  /**
   * Returns A - B
   * @method DenseMatrix#minus
   * @param {DenseMatrix} B The dense matrix subtracted from this dense matrix.
   * @returns {DenseMatrix}
   */
  minus(A) {
    return new ln(this.data.minus(A.data));
  }
  /**
   * Returns A * s
   * @method DenseMatrix#timesReal
   * @param {number} s The number this dense matrix is multiplied by.
   * @returns {DenseMatrix}
   */
  timesReal(A) {
    return new ln(this.data.timesReal(A));
  }
  /**
   * Returns A * B
   * @method DenseMatrix#timesDense
   * @param {DenseMatrix} B The dense matrix this dense matrix is multiplied by.
   * @returns {DenseMatrix}
   */
  timesDense(A) {
    return new ln(this.data.timesDense(A.data));
  }
  /**
   * Returns -A
   * @method DenseMatrix#negated
   * @return {DenseMatrix}
   */
  negated() {
    return new ln(this.data.negated());
  }
  /**
   * Returns A(i, j)
   * @method DenseMatrix#get
   * @param {number} i The ith row of this dense matrix.
   * @param {number} j The jth column of this dense matrix.
   * @return {number}
   */
  get(A, e = 0) {
    return this.data.get(A, e);
  }
  /**
   * A(i, j) = x
   * @method DenseMatrix#set
   * @param {number} x The real value the (i, j)th entry of this dense matrix is set to.
   * @param {number} i The ith row of this dense matrix.
   * @param {number} j The jth column of this dense matrix.
   */
  set(A, e, t = 0) {
    this.data.set(e, t, A);
  }
  /**
   * Concatenates two dense matrices horizontally.
   * @method DenseMatrix#hcat
   * @param {DenseMatrix} B The dense matrix that is concatenated horizontally
   * with this dense matrix.
   * @return {DenseMatrix}
   */
  hcat(A) {
    return new ln(this.data.hcat(A.data));
  }
  /**
   * Concatenates two dense matrices vertically.
   * @method DenseMatrix#vcat
   * @param {DenseMatrix} B The dense matrix that is concatenated vertically
   * with this dense matrix.
   * @return {DenseMatrix}
   */
  vcat(A) {
    return new ln(this.data.vcat(A.data));
  }
}
class Xr {
  /**
   * This class represents a m by n real matrix where only nonzero entries
   * are stored explicitly. Do not create a SparseMatrix from its constructor,
   * instead use static factory methods such as fromTriplet, identity and diag.
   * @constructor SparseMatrix
   * @example
   * let T = new Triplet(100, 100);
   * T.addEntry(3.4, 11, 43);
   * T.addEntry(6.4, 99, 99);
   * let A = SparseMatrix.fromTriplet(T);
   *
   * let B = SparseMatrix.identity(10, 10);
   *
   * let d = DenseMatrix.ones(100, 1);
   * let C = SparseMatrix.diag(d);
   */
  constructor(A) {
    this.data = A, Mr.mm.objectList.push(this);
  }
  /**
   * Deletes the emscripten heap allocated data of this sparse matrix.
   * @ignore
   * @method SparseMatrix#delete
   */
  delete() {
    this.data.delete();
  }
  /**
   * Initializes a sparse matrix from a {@link Triplet} object.
   * @method SparseMatrix.fromTriplet
   * @param {Triplet} T A triplet object containing only the nonzero entries that
   * need to be stored in this sparse matrix.
   * @returns {SparseMatrix}
   */
  static fromTriplet(A) {
    return new Xr(new (Mr.module()).SparseMatrix(A.data));
  }
  /**
   * Initializes a m by n sparse identity matrix.
   * @method SparseMatrix.identity
   * @param {number} m The number of rows in this sparse matrix.
   * @param {number} n The number of columns in this sparse matrix.
   * @returns {SparseMatrix}
   */
  static identity(A, e) {
    return new Xr(Mr.module().SparseMatrix.identity(A, e));
  }
  /**
   * Initializes a sparse diagonal matrix.
   * @method SparseMatrix.diag
   * @param {DenseMatrix} d The dense vector (d.nCols() == 1) used to initialize
   * this sparse diagonal matrix.
   * @returns {SparseMatrix}
   */
  static diag(A) {
    return new Xr(Mr.module().SparseMatrix.diag(A.data));
  }
  /**
   * Returns the transpose of this sparse matrix.
   * @method SparseMatrix#transpose
   * @returns {SparseMatrix}
   */
  transpose() {
    return new Xr(this.data.transpose());
  }
  /**
   * Returns the inverse of this diagonal sparse matrix.
   * @method SparseMatrix#invertDiagonal
   * @returns {SparseMatrix}
   */
  invertDiagonal() {
    let A = this.nRows(), e = this.timesDense(ln.ones(A, 1)), t = new Ey(A, A);
    for (let i = 0; i < A; i++)
      t.addEntry(1 / e.get(i, 0), i, i);
    return Xr.fromTriplet(t);
  }
  /**
   * Returns the number of rows in this sparse matrix.
   * @method SparseMatrix#nRows
   * @returns {number}
   */
  nRows() {
    return this.data.nRows();
  }
  /**
   * Returns the number of columns in this sparse matrix.
   * @method SparseMatrix#nCols
   * @returns {number}
   */
  nCols() {
    return this.data.nCols();
  }
  /**
   * Returns the number of nonzero entries in this sparse matrix.
   * @method SparseMatrix#nnz
   * @returns {number}
   */
  nnz() {
    return this.data.nnz();
  }
  /**
   * Computes the frobenius norm of this sparse matrix.
   * @method SparseMatrix#frobeniusNorm
   * @returns {number}
   */
  frobeniusNorm() {
    return this.data.frobeniusNorm();
  }
  /**
   * Extracts a sparse sub-matrix in the range [r0, r1) x [c0, c1), i.e., a matrix
   * of size (r1 - r0) x (c1 - c0) starting at indices (r0, c0).
   * @method SparseMatrix#subMatrix
   * @param {number} r0 The start row index.
   * @param {number} r1 The end row index (not included).
   * @param {number} c0 The start column index.
   * @param {number} c1 The end column index (not included).
   * @returns {SparseMatrix}
   */
  subMatrix(A, e, t, i) {
    return new Xr(this.data.subMatrix(A, e, t, i));
  }
  /**
   * Returns a sparse {@link Cholesky} factorization of this sparse matrix.
   * @method SparseMatrix#chol
   * @returns {Cholesky}
   */
  chol() {
    return new dz(this.data.chol());
  }
  /**
   * Returns a sparse {@link LU} factorization of this sparse matrix.
   * @method SparseMatrix#lu
   * @returns {LU}
   */
  lu() {
    return new fz(this.data.lu());
  }
  /**
   * Returns a sparse {@link QR} factorization of this sparse matrix.
   * @method SparseMatrix#qr
   * @returns {QR}
   */
  qr() {
    return new pz(this.data.qr());
  }
  /**
   * Returns a dense copy of this sparse matrix.
   * @method SparseMatrix#toDense
   * @returns {DenseMatrix}
   */
  toDense() {
    return new ln(this.data.toDense());
  }
  /**
   * A += B
   * @method SparseMatrix#incrementBy
   * @param {SparseMatrix} B The sparse matrix added to this sparse matrix.
   */
  incrementBy(A) {
    this.data.incrementBy(A.data);
  }
  /**
   * A -= B
   * @method SparseMatrix#decrementBy
   * @param {SparseMatrix} B The sparse matrix subtracted from this sparse matrix.
   */
  decrementBy(A) {
    this.data.decrementBy(A.data);
  }
  /**
   * A *= s
   * @method SparseMatrix#scaleBy
   * @param {number} s The number this sparse matrix is scaled by.
   */
  scaleBy(A) {
    this.data.scaleBy(A);
  }
  /**
   * Returns A + B
   * @method SparseMatrix#plus
   * @param {SparseMatrix} B The sparse matrix added to this sparse matrix.
   * @returns {SparseMatrix}
   */
  plus(A) {
    return new Xr(this.data.plus(A.data));
  }
  /**
   * Returns A - B
   * @method SparseMatrix#minus
   * @param {SparseMatrix} B The sparse matrix subtracted from this sparse matrix.
   * @returns {SparseMatrix}
   */
  minus(A) {
    return new Xr(this.data.minus(A.data));
  }
  /**
   * Returns A * s
   * @method SparseMatrix#timesReal
   * @param {number} s The number this sparse matrix is multiplied by.
   * @returns {SparseMatrix}
   */
  timesReal(A) {
    return new Xr(this.data.timesReal(A));
  }
  /**
   * Returns A * X
   * @method SparseMatrix#timesDense
   * @param {DenseMatrix} X The dense matrix this sparse matrix is multiplied by.
   * @returns {DenseMatrix}
   */
  timesDense(A) {
    return new ln(this.data.timesDense(A.data));
  }
  /**
   * Returns A * B
   * @method SparseMatrix#timesSparse
   * @param {SparseMatrix} B The sparse matrix this sparse matrix is multiplied by.
   * @returns {SparseMatrix}
   */
  timesSparse(A) {
    return new Xr(this.data.timesSparse(A.data));
  }
}
class Ey {
  /**
   * This class represents a small structure to hold nonzero entries in a {@link SparseMatrix}.
   * Each entry is a triplet of a value and the (i, j)th indices, i.e., (x, i, j).
   * @constructor Triplet
   * @param {number} m The number of rows in the sparse matrix that will be initialized
   * from this triplet.
   * @param {number} n The number of columns in the sparse matrix that will be initialized
   * from this triplet.
   * @example
   * let T = new Triplet(100, 100);
   * T.addEntry(3.4, 11, 43);
   * T.addEntry(6.4, 99, 99);
   *
   * let A = SparseMatrix.fromTriplet(T);
   */
  constructor(A, e) {
    this.data = new (Mr.module()).Triplet(A, e), Mr.mm.objectList.push(this);
  }
  /**
   * Deletes the emscripten heap allocated data of this sparse matrix.
   * @method Triplet#delete
   * @ignore
   */
  delete() {
    this.data.delete();
  }
  /**
   * A(i, j) += x
   * @method Triplet#addEntry
   * @param {number} x The value of the nonzero entry being inserted into this triplet.
   * @param {number} i The ith row of the sparse matrix that will be initialized
   * from this triplet.
   * @param {number} j The jth column of the sparse matrix that will be initialized
   * from this triplet.
   */
  addEntry(A, e, t) {
    this.data.addEntry(e, t, A);
  }
}
class dz {
  /**
   * This class represents a Choleksy LL^T factorization of a square positive definite
   * {@link SparseMatrix}. The factorization is computed on the first call to solvePositiveDefinite,
   * and is reused in subsequent calls to solvePositiveDefinite (e.g. when only the
   * right hand side b of the linear system Ax = b changes) unless the sparse matrix
   * itself is altered through operations such as *=, += and -=. Do not use the constructor
   * to initialize this class, instead access the Choleksy factorization of a sparse
   * matrix directly from the matrix itself.
   * @constructor Cholesky
   * @example
   * // solve the linear system Ax = b, where A is a square positive definite sparse matrix
   * let A = SparseMatrix.identity(5, 5);
   * let b = DenseMatrix.ones(5, 1);
   *
   * let llt = A.chol();
   * let x = llt.solvePositiveDefinite(b);
   *
   * b.scaleBy(5);
   * x = llt.solvePositiveDefinite(b); // factorization is reused
   */
  constructor(A) {
    this.data = A;
  }
  /**
   * Solves the linear system Ax = b, where A is a square positive definite sparse matrix.
   * @method Cholesky#solvePositiveDefinite
   * @param {DenseMatrix} b The dense right hand side of the linear system Ax = b.
   * @returns {DenseMatrix}
   */
  solvePositiveDefinite(A) {
    return new ln(this.data.solvePositiveDefinite(A.data));
  }
}
class fz {
  /**
   * This class represents a LU factorization of a square {@link SparseMatrix}. The factorization
   * is computed on the first call to solveSquare, and is reused in subsequent calls
   * to solveSquare (e.g. when only the right hand side b of the linear system Ax = b
   * changes) unless the sparse matrix itself is altered through operations such as
   * *=, += and -=. Do not use the constructor to initialize this class, instead
   * access the LU factorization of a sparse matrix directly from the matrix itself.
   * @constructor LU
   * @example
   * // solve the linear system Ax = b, where A is a square sparse matrix
   * let A = SparseMatrix.identity(5, 5);
   * let b = DenseMatrix.ones(5, 1);
   *
   * let lu = A.lu();
   * let x = lu.solveSquare(b);
   *
   * b.scaleBy(5);
   * x = lu.solveSquare(b); // factorization is reused
   */
  constructor(A) {
    this.data = A;
  }
  /**
   * Solves the linear system Ax = b, where A is a square sparse matrix.
   * @method LU#solveSquare
   * @param {DenseMatrix} b The dense right hand side of the linear system Ax = b.
   * @returns {DenseMatrix}
   */
  solveSquare(A) {
    return new ln(this.data.solveSquare(A.data));
  }
}
class pz {
  /**
   * This class represents a QR factorization of a rectangular {@link SparseMatrix}.
   * The factorization is computed on the first call to solve, and is reused in
   * subsequent calls to solve (e.g. when only the right hand side b of the linear
   * system Ax = b changes) unless the sparse matrix itself is altered through
   * operations such as *=, += and -=. Do not use the constructor to initialize
   * this class, instead access the QR factorization of a sparse matrix directly
   * from the matrix itself.
   * @constructor QR
   * @example
   * // solve the linear system Ax = b, where A is a rectangular sparse matrix
   * let A = SparseMatrix.identity(5, 5);
   * let b = DenseMatrix.ones(5, 1);
   *
   * let qr = A.qr();
   * let x = qr.solve(b);
   *
   * b.scaleBy(5);
   * x = qr.solve(b); // factorization is reused
   */
  constructor(A) {
    this.data = A;
  }
  /**
   * Solves the linear system Ax = b, where A is a rectangular sparse matrix.
   * @method QR#solve
   * @param {DenseMatrix} b The dense right hand side of the linear system Ax = b.
   * @returns {DenseMatrix}
   */
  solve(A) {
    return new ln(this.data.solve(A.data));
  }
}
class Dz {
  /**
   * This class represents the geometry of a {@link module:Core.Mesh Mesh}. This includes information such
   * as the position of vertices as well as methods to compute edge lengths, corner
   * angles, face area, normals, discrete curvatures etc.
   * @constructor module:Core.Geometry
   * @param {module:Core.Mesh} mesh The mesh this class describes the geometry of.
   * @param {module:LinearAlgebra.Vector[]} positions An array containing the position of each vertex in a mesh.
   * @param {boolean} normalizePositions flag to indicate whether positions should be normalized. Default value is true.
   * @property {module:Core.Mesh} mesh The mesh this class describes the geometry of.
   * @property {Object} positions A dictionary mapping each vertex to a normalized position.
   */
  constructor(A, e, t = !0) {
    this.normRadius = -1, this.mesh = A, this.positions = {};
    for (let i = 0; i < e.length; i++) {
      let n = this.mesh.vertices[i], r = e[i];
      this.positions[n.index] = r;
    }
    t && (this.normRadius = wz(this.positions, A.vertices));
  }
  /**
   * Computes the vector along a halfedge.
   * @method module:Core.Geometry#vector
   * @param {module:Core.Halfedge} h The halfedge along which the vector needs to be computed.
   * @returns {module:LinearAlgebra.Vector}
   */
  vector(A) {
    let e = this.positions[A.vertex.index];
    return this.positions[A.next.vertex.index].minus(e);
  }
  /**
   * Computes the length of an edge.
   * @method module:Core.Geometry#length
   * @param {module:Core.Edge} e The edge whose length needs to be computed.
   * @returns {number}
   */
  length(A) {
    return this.vector(A.halfedge).norm();
  }
  /**
   * Computes the midpoint of an edge.
   * @method module:Core.Geometry#midpoint
   * @param {module:Core.Edge} e The edge whose midpoint needs to be computed.
   * @returns {number}
   */
  midpoint(A) {
    let e = A.halfedge, t = this.positions[e.vertex.index], i = this.positions[e.twin.vertex.index];
    return t.plus(i).over(2);
  }
  /**
   * Computes the mean edge length of all the edges in a mesh.
   * @method module:Core.Geometry#meanEdgeLength
   * @returns {number}
   */
  meanEdgeLength() {
    let A = 0, e = this.mesh.edges;
    for (let t of e)
      A += this.length(t);
    return A / e.length;
  }
  /**
   * Computes the area of a face.
   * @method module:Core.Geometry#area
   * @param {module:Core.Face} f The face whose area needs to be computed.
   * @returns {number}
   */
  area(A) {
    if (A.isBoundaryLoop())
      return 0;
    let e = this.vector(A.halfedge), t = this.vector(A.halfedge.prev).negated();
    return 0.5 * e.cross(t).norm();
  }
  /**
   * Computes the total surface area of a mesh.
   * @method module:Core.Geometry#totalArea
   * @returns {number}
   */
  totalArea() {
    let A = 0;
    for (let e of this.mesh.faces)
      A += this.area(e);
    return A;
  }
  /**
   * Computes the normal of a face.
   * @method module:Core.Geometry#faceNormal
   * @param {module:Core.Face} f The face whose normal needs to be computed.
   * @returns {module:LinearAlgebra.Vector}
   */
  faceNormal(A) {
    if (A.isBoundaryLoop())
      return;
    let e = this.vector(A.halfedge), t = this.vector(A.halfedge.prev).negated();
    return e.cross(t).unit();
  }
  /**
   * Computes the centroid of a face.
   * @method module:Core.Geometry#centroid
   * @param {module:Core.Face} f The face whose centroid needs to be computed.
   * @returns {module:LinearAlgebra.Vector}
   */
  centroid(A) {
    let e = A.halfedge, t = this.positions[e.vertex.index], i = this.positions[e.next.vertex.index], n = this.positions[e.prev.vertex.index];
    return A.isBoundaryLoop() ? t.plus(i).over(2) : t.plus(i).plus(n).over(3);
  }
  /**
   * Computes the circumcenter of a face.
   * @method module:Core.Geometry#circumcenter
   * @param {module:Core.Face} f The face whose circumcenter needs to be computed.
   * @returns {module:LinearAlgebra.Vector}
   */
  circumcenter(A) {
    let e = A.halfedge, t = this.positions[e.vertex.index], i = this.positions[e.next.vertex.index], n = this.positions[e.prev.vertex.index];
    if (A.isBoundaryLoop())
      return t.plus(i).over(2);
    let r = n.minus(t), s = i.minus(t), B = s.cross(r), I = B.cross(s).times(r.norm2()), E = r.cross(B).times(s.norm2());
    return I.plus(E).over(2 * B.norm2()).plus(t);
  }
  /**
   * Computes an orthonormal bases for a face.
   * @method module:Core.Geometry#orthonormalBases
   * @param {module:Core.Face} f The face on which the orthonormal bases needs to be computed.
   * @returns {module:LinearAlgebra.Vector[]} An array containing two orthonormal vectors tangent to the face.
   */
  orthonormalBases(A) {
    let e = this.vector(A.halfedge).unit(), i = this.faceNormal(A).cross(e);
    return [e, i];
  }
  /**
   * Computes the angle (in radians) at a corner.
   * @method module:Core.Geometry#angle
   * @param {module:Core.Corner} c The corner at which the angle needs to be computed.
   * @returns {number} The angle clamped between 0 and .
   */
  angle(A) {
    let e = this.vector(A.halfedge.prev).unit(), t = this.vector(A.halfedge.next).negated().unit();
    return Math.acos(Math.max(-1, Math.min(1, e.dot(t))));
  }
  /**
   * Computes the cotangent of the angle opposite to a halfedge.
   * @method module:Core.Geometry#cotan
   * @param {module:Core.Halfedge} h The halfedge opposite to the angle whose cotangent needs to be computed.
   * @returns {number}
   */
  cotan(A) {
    if (A.onBoundary)
      return 0;
    let e = this.vector(A.prev), t = this.vector(A.next).negated();
    return e.dot(t) / e.cross(t).norm();
  }
  /**
   * Computes the signed angle (in radians) between two adjacent faces.
   * @method module:Core.Geometry#dihedralAngle
   * @param {module:Core.Halfedge} h The halfedge (shared by the two adjacent faces) on which
   * the dihedral angle is computed.
   * @returns {number} The dihedral angle.
   */
  dihedralAngle(A) {
    if (A.onBoundary || A.twin.onBoundary)
      return 0;
    let e = this.faceNormal(A.face), t = this.faceNormal(A.twin.face), i = this.vector(A).unit(), n = e.dot(t), r = e.cross(t).dot(i);
    return Math.atan2(r, n);
  }
  /**
   * Computes the barycentric dual area of a vertex.
   * @method module:Core.Geometry#barycentricDualArea
   * @param {module:Core.Vertex} v The vertex whose barycentric dual area needs to be computed.
   * @returns {number}
   */
  barycentricDualArea(A) {
    let e = 0;
    for (let t of A.adjacentFaces())
      e += this.area(t) / 3;
    return e;
  }
  /**
   * Computes the circumcentric dual area of a vertex.
   * @see {@link http://cs.cmu.edu/~kmcrane/Projects/Other/TriangleAreasCheatSheet.pdf}
   * @method module:Core.Geometry#circumcentricDualArea
   * @param {module:Core.Vertex} v The vertex whose circumcentric dual area needs to be computed.
   * @returns {number}
   */
  circumcentricDualArea(A) {
    let e = 0;
    for (let t of A.adjacentHalfedges()) {
      let i = this.vector(t.prev).norm2(), n = this.vector(t).norm2(), r = this.cotan(t.prev), s = this.cotan(t);
      e += (i * r + n * s) / 8;
    }
    return e;
  }
  /**
   * Computes the normal at a vertex using the "equally weighted" method.
   * @method module:Core.Geometry#vertexNormalEquallyWeighted
   * @param {module:Core.Vertex} v The vertex on which the normal needs to be computed.
   * @returns {module:LinearAlgebra.Vector}
   */
  vertexNormalEquallyWeighted(A) {
    let e = new er();
    for (let t of A.adjacentFaces()) {
      let i = this.faceNormal(t);
      e.incrementBy(i);
    }
    return e.normalize(), e;
  }
  /**
   * Computes the normal at a vertex using the "face area weights" method.
   * @method module:Core.Geometry#vertexNormalAreaWeighted
   * @param {module:Core.Vertex} v The vertex on which the normal needs to be computed.
   * @returns {module:LinearAlgebra.Vector}
   */
  vertexNormalAreaWeighted(A) {
    let e = new er();
    for (let t of A.adjacentFaces()) {
      let i = this.faceNormal(t), n = this.area(t);
      e.incrementBy(i.times(n));
    }
    return e.normalize(), e;
  }
  /**
   * Computes the normal at a vertex using the "tip angle weights" method.
   * @method module:Core.Geometry#vertexNormalAngleWeighted
   * @param {module:Core.Vertex} v The vertex on which the normal needs to be computed.
   * @returns {module:LinearAlgebra.Vector}
   */
  vertexNormalAngleWeighted(A) {
    let e = new er();
    for (let t of A.adjacentCorners()) {
      let i = this.faceNormal(t.halfedge.face), n = this.angle(t);
      e.incrementBy(i.times(n));
    }
    return e.normalize(), e;
  }
  /**
   * Computes the normal at a vertex using the "gauss curvature" method.
   * @method module:Core.Geometry#vertexNormalGaussCurvature
   * @param {module:Core.Vertex} v The vertex on which the normal needs to be computed.
   * @returns {module:LinearAlgebra.Vector}
   */
  vertexNormalGaussCurvature(A) {
    let e = new er();
    for (let t of A.adjacentHalfedges()) {
      let i = 0.5 * this.dihedralAngle(t) / this.length(t.edge);
      e.decrementBy(this.vector(t).times(i));
    }
    return e.normalize(), e;
  }
  /**
   * Computes the normal at a vertex using the "mean curvature" method (same as the "area gradient" method).
   * @method module:Core.Geometry#vertexNormalMeanCurvature
   * @param {module:Core.Vertex} v The vertex on which the normal needs to be computed.
   * @returns {module:LinearAlgebra.Vector}
   */
  vertexNormalMeanCurvature(A) {
    let e = new er();
    for (let t of A.adjacentHalfedges()) {
      let i = 0.5 * (this.cotan(t) + this.cotan(t.twin));
      e.decrementBy(this.vector(t).times(i));
    }
    return e.normalize(), e;
  }
  /**
   * Computes the normal at a vertex using the "inscribed sphere" method.
   * @method module:Core.Geometry#vertexNormalSphereInscribed
   * @param {module:Core.Vertex} v The vertex on which the normal needs to be computed.
   * @returns {module:LinearAlgebra.Vector}
   */
  vertexNormalSphereInscribed(A) {
    let e = new er();
    for (let t of A.adjacentCorners()) {
      let i = this.vector(t.halfedge.prev), n = this.vector(t.halfedge.next).negated();
      e.incrementBy(i.cross(n).over(i.norm2() * n.norm2()));
    }
    return e.normalize(), e;
  }
  /**
   * Computes the angle defect at a vertex (= 2 minus the sum of incident angles
   * at an interior vertex or  minus the sum of incident angles at a boundary vertex).
   * @method module:Core.Geometry#angleDefect
   * @param {module:Core.Vertex} v The vertex whose angle defect needs to be computed.
   * @returns {number}
   */
  angleDefect(A) {
    let e = 0;
    for (let t of A.adjacentCorners())
      e += this.angle(t);
    return A.onBoundary() ? Math.PI - e : 2 * Math.PI - e;
  }
  /**
   * Computes the (integrated) scalar gauss curvature at a vertex.
   * @method module:Core.Geometry#scalarGaussCurvature
   * @param {module:Core.Vertex} v The vertex whose gauss curvature needs to be computed.
   * @returns {number}
   */
  scalarGaussCurvature(A) {
    return this.angleDefect(A);
  }
  /**
   * Computes the (integrated) scalar mean curvature at a vertex.
   * @method module:Core.Geometry#scalarMeanCurvature
   * @param {module:Core.Vertex} v The vertex whose mean curvature needs to be computed.
   * @returns {number}
   */
  scalarMeanCurvature(A) {
    let e = 0;
    for (let t of A.adjacentHalfedges())
      e += 0.5 * this.length(t.edge) * this.dihedralAngle(t);
    return e;
  }
  /**
   * Computes the total angle defect (= 2 times the euler characteristic of the mesh).
   * @method module:Core.Geometry#totalAngleDefect
   * @returns {number}
   */
  totalAngleDefect() {
    let A = 0;
    for (let e of this.mesh.vertices)
      A += this.angleDefect(e);
    return A;
  }
  /**
   * Computes the (pointwise) minimum and maximum principal curvature values at a vertex.
   * @method module:Core.Geometry#principalCurvatures
   * @param {module:Core.Vertex} v The vertex on which the principal curvatures need to be computed.
   * @returns {number[]} An array containing the minimum and maximum principal curvature values at a vertex.
   */
  principalCurvatures(A) {
    let e = this.circumcentricDualArea(A), t = this.scalarMeanCurvature(A) / e, i = this.angleDefect(A) / e, n = t * t - i;
    n > 0 ? n = Math.sqrt(n) : n = 0;
    let r = t - n, s = t + n;
    return [r, s];
  }
  /**
   * Builds a sparse laplace matrix. The laplace operator is negative semidefinite;
   * instead we build a positive definite matrix by multiplying the entries of the
   * laplace matrix by -1 and shifting the diagonal elements by a small constant (e.g. 1e-8).
   * @method module:Core.Geometry#laplaceMatrix
   * @param {Object} vertexIndex A dictionary mapping each vertex of a mesh to a unique index.
   * @returns {module:LinearAlgebra.SparseMatrix}
   */
  laplaceMatrix(A) {
    let e = this.mesh.vertices.length, t = new Ey(e, e);
    for (let i of this.mesh.vertices) {
      let n = A[i.index], r = 1e-8;
      for (let s of i.adjacentHalfedges()) {
        let B = A[s.twin.vertex.index], I = (this.cotan(s) + this.cotan(s.twin)) / 2;
        r += I, t.addEntry(-I, n, B);
      }
      t.addEntry(r, n, n);
    }
    return Xr.fromTriplet(t);
  }
  /**
   * Builds a sparse diagonal mass matrix containing the barycentric dual area of each vertex
   * of a mesh.
   * @method module:Core.Geometry#massMatrix
   * @param {Object} vertexIndex A dictionary mapping each vertex of a mesh to a unique index.
   * @returns {module:LinearAlgebra.SparseMatrix}
   */
  massMatrix(A) {
    let e = this.mesh.vertices.length, t = new Ey(e, e);
    for (let i of this.mesh.vertices) {
      let n = A[i.index];
      t.addEntry(this.barycentricDualArea(i), n, n);
    }
    return Xr.fromTriplet(t);
  }
}
function wz(g, A, e = !0) {
  let t = A.length, i = new er();
  for (let r of A) {
    let s = g[r.index];
    i.incrementBy(s);
  }
  i.divideBy(t);
  let n = -1;
  for (let r of A) {
    let s = g[r.index];
    s.decrementBy(i), n = Math.max(n, s.norm());
  }
  if (e)
    for (let r of A)
      g[r.index].divideBy(n);
  return n;
}
class yz {
  /**
   * This class represents a corner in a {@link module:Core.Mesh Mesh}. It is a convenience
   * wrapper around {@link module:Core.Halfedge Halfedge} - each corner stores the halfedge opposite to it.
   * @constructor module:Core.Corner
   * @property {module:Core.Halfedge} halfedge The halfedge opposite to this corner.
   */
  constructor() {
    this.halfedge = void 0, this.index = -1;
  }
  /**
   * The vertex this corner lies on.
   * @member module:Core.Corner#vertex
   * @type {module:Core.Vertex}
   */
  get vertex() {
    return this.halfedge.prev.vertex;
  }
  /**
   * The face this corner is contained in.
   * @member module:Core.Corner#face
   * @type {module:Core.Face}
   */
  get face() {
    return this.halfedge.face;
  }
  /**
   * The next corner (in CCW order) in this corner's face.
   * @member module:Core.Corner#next
   * @type {module:Core.Corner}
   */
  get next() {
    return this.halfedge.next.corner;
  }
  /**
   * The previous corner (in CCW order) in this corner's face.
   * @member module:Core.Corner#prev
   * @type {module:Core.Corner}
   */
  get prev() {
    return this.halfedge.prev.corner;
  }
  /**
   * Defines a string representation for this corner as its index.
   * @ignore
   * @method module:Core.Corner#toString
   * @returns {string}
   */
  toString() {
    return this.index;
  }
}
class mz {
  /**
   * This class represents an edge in a {@link module:Core.Mesh Mesh}.
   * @constructor module:Core.Edge
   * @property {module:Core.Halfedge} halfedge One of the halfedges associated with this edge.
   */
  constructor() {
    this.halfedge = void 0, this.index = -1;
  }
  /**
   * Checks whether this edge lies on a boundary.
   * @method module:Core.Edge#onBoundary
   * @returns {boolean}
   */
  onBoundary() {
    return this.halfedge?.onBoundary || this.halfedge?.twin?.onBoundary;
  }
  /**
   * Defines a string representation for this edge as its index.
   * @ignore
   * @method module:Core.Edge#toString
   * @returns {string}
   */
  toString() {
    return this.index;
  }
}
class hG {
  /**
   * This class represents a face in a {@link module:Core.Mesh Mesh}.
   * @constructor module:Core.Face
   * @property {module:Core.Halfedge} halfedge One of the halfedges associated with this face.
   */
  constructor() {
    this.halfedge = void 0, this.index = -1;
  }
  /**
   * Checks whether this face is a boundary loop.
   * @method module:Core.Face#isBoundaryLoop
   * @returns {boolean}
   */
  isBoundaryLoop() {
    return this.halfedge?.onBoundary;
  }
  /**
   * Convenience function to iterate over the vertices in this face.
   * Iterates over the vertices of a boundary loop if this face is a boundary loop.
   * @method module:Core.Face#adjacentVertices
   * @param {boolean} ccw A flag indicating whether iteration should be in CCW or CW order.
   * @returns {module:Core.Vertex}
   * @example
   * let f = mesh.faces[0]; // or let b = mesh.boundaries[0]
   * for (let v of f.adjacentVertices()) {
   *     // Do something with v
   * }
   */
  adjacentVertices(A = !0) {
    return new Sz(this.halfedge, A);
  }
  /**
   * Convenience function to iterate over the edges in this face.
   * Iterates over the edges of a boundary loop if this face is a boundary loop.
   * @method module:Core.Face#adjacentEdges
   * @param {boolean} ccw A flag indicating whether iteration should be in CCW or CW order.
   * @returns {module:Core.Edge}
   * @example
   * let f = mesh.faces[0]; // or let b = mesh.boundaries[0]
   * for (let e of f.adjacentEdges()) {
   *     // Do something with e
   * }
   */
  adjacentEdges(A = !0) {
    return new Mz(this.halfedge, A);
  }
  /**
   * Convenience function to iterate over the faces neighboring this face.
   * @method module:Core.Face#adjacentFaces
   * @param {boolean} ccw A flag indicating whether iteration should be in CCW or CW order.
   * @returns {module:Core.Face}
   * @example
   * let f = mesh.faces[0]; // or let b = mesh.boundaries[0]
   * for (let g of f.adjacentFaces()) {
   *     // Do something with g
   * }
   */
  adjacentFaces(A = !0) {
    return new Rz(this.halfedge, A);
  }
  /**
   * Convenience function to iterate over the halfedges in this face.
   * Iterates over the halfedges of a boundary loop if this face is a boundary loop.
   * @method module:Core.Face#adjacentHalfedges
   * @param {boolean} ccw A flag indicating whether iteration should be in CCW or CW order.
   * @returns {module:Core.Halfedge}
   * @example
   * let f = mesh.faces[0]; // or let b = mesh.boundaries[0]
   * for (let h of f.adjacentHalfedges()) {
   *     // Do something with h
   * }
   */
  adjacentHalfedges(A = !0) {
    return new Nz(this.halfedge, A);
  }
  /**
   * Convenience function to iterate over the corners in this face. Not valid if this face
   * is a boundary loop.
   * @method module:Core.Face#adjacentCorners
   * @param {boolean} ccw A flag indicating whether iteration should be in CCW or CW order.
   * @returns {module:Core.Corner}
   * @example
   * let f = mesh.faces[0];
   * for (let c of f.adjacentCorners()) {
   *     // Do something with c
   * }
   */
  adjacentCorners(A = !0) {
    return new Fz(this.halfedge, A);
  }
  /**
   * Defines a string representation for this face as its index.
   * @ignore
   * @method module:Core.Face#toString
   * @returns {string}
   */
  toString() {
    return this.index;
  }
}
class Sz {
  // constructor
  constructor(A, e) {
    this._halfedge = A, this._ccw = e;
  }
  [Symbol.iterator]() {
    return {
      current: this._halfedge,
      end: this._halfedge,
      ccw: this._ccw,
      justStarted: !0,
      next() {
        if (!this.justStarted && this.current === this.end)
          return {
            done: !0
          };
        {
          this.justStarted = !1;
          let A = this.current.vertex;
          return this.current = this.ccw ? this.current.next : this.current.prev, {
            done: !1,
            value: A
          };
        }
      }
    };
  }
}
class Mz {
  // constructor
  constructor(A, e) {
    this._halfedge = A, this._ccw = e;
  }
  [Symbol.iterator]() {
    return {
      current: this._halfedge,
      end: this._halfedge,
      ccw: this._ccw,
      justStarted: !0,
      next() {
        if (!this.justStarted && this.current === this.end)
          return {
            done: !0
          };
        {
          this.justStarted = !1;
          let A = this.current.edge;
          return this.current = this.ccw ? this.current.next : this.current.prev, {
            done: !1,
            value: A
          };
        }
      }
    };
  }
}
class Rz {
  // constructor
  constructor(A, e) {
    for (; A.twin.onBoundary; )
      A = A.next;
    this._halfedge = A, this._ccw = e;
  }
  [Symbol.iterator]() {
    return {
      current: this._halfedge,
      end: this._halfedge,
      ccw: this._ccw,
      justStarted: !0,
      next() {
        for (; this.current.twin.onBoundary; )
          this.current = this.ccw ? this.current.next : this.current.prev;
        if (!this.justStarted && this.current === this.end)
          return {
            done: !0
          };
        {
          this.justStarted = !1;
          let A = this.current.twin.face;
          return this.current = this.ccw ? this.current.next : this.current.prev, {
            done: !1,
            value: A
          };
        }
      }
    };
  }
}
class Nz {
  // constructor
  constructor(A, e) {
    this._halfedge = A, this._ccw = e;
  }
  [Symbol.iterator]() {
    return {
      current: this._halfedge,
      end: this._halfedge,
      ccw: this._ccw,
      justStarted: !0,
      next() {
        if (!this.justStarted && this.current === this.end)
          return {
            done: !0
          };
        {
          this.justStarted = !1;
          let A = this.current;
          return this.current = this.ccw ? this.current.next : this.current.prev, {
            done: !1,
            value: A
          };
        }
      }
    };
  }
}
class Fz {
  // constructor
  constructor(A, e) {
    this._halfedge = A, this._ccw = e;
  }
  [Symbol.iterator]() {
    return {
      current: this._halfedge,
      end: this._halfedge,
      ccw: this._ccw,
      justStarted: !0,
      next() {
        return !this.justStarted && this.current === this.end ? {
          done: !0
        } : (this.justStarted = !1, this.current = this.ccw ? this.current.next : this.current.prev, {
          done: !1,
          value: this.current.corner
        });
      }
    };
  }
}
class dG {
  /**
   * This class defines the connectivity of a {@link module:Core.Mesh Mesh}.
   * @constructor module:Core.Halfedge
   * @property {module:Core.Vertex} vertex The vertex at the base of this halfedge.
   * @property {module:Core.Edge} edge The edge associated with this halfedge.
   * @property {module:Core.Face} face The face associated with this halfedge.
   * @property {module:Core.Corner} corner The corner opposite to this halfedge. Undefined if this halfedge is on the boundary.
   * @property {module:Core.Halfedge} next The next halfedge (in CCW order) in this halfedge's face.
   * @property {module:Core.Halfedge} prev The previous halfedge (in CCW order) in this halfedge's face.
   * @property {module:Core.Halfedge} twin The other halfedge associated with this halfedge's edge.
   * @property {boolean} onBoundary A flag that indicates whether this halfedge is on a boundary.
   */
  constructor() {
    this.vertex = void 0, this.edge = void 0, this.face = void 0, this.corner = void 0, this.next = void 0, this.prev = void 0, this.twin = void 0, this.onBoundary = void 0, this.index = -1;
  }
  /**
   * Defines a string representation for this halfedge as its index.
   * @ignore
   * @method module:Core.Halfedge#toString
   * @returns {string}
   */
  toString() {
    return this.index;
  }
}
class Gz {
  /**
   * This class represents a vertex in a {@link module:Core.Mesh Mesh}.
   * @constructor module:Core.Vertex
   * @property {module:Core.Halfedge} halfedge One of the outgoing halfedges associated with this vertex.
   */
  constructor() {
    this.halfedge = void 0, this.index = -1;
  }
  /**
   * Counts the number of edges adjacent to this vertex.
   * @method module:Core.Vertex#degree
   * @returns {number}
   */
  degree() {
    let A = 0;
    for (let e of this.adjacentEdges())
      A++;
    return A;
  }
  /**
   * Checks whether this vertex is isolated, i.e., it has no neighboring vertices.
   * @method module:Core.Vertex#isIsolated
   * @returns {boolean}
   */
  isIsolated() {
    return this.halfedge === void 0;
  }
  /**
   * Checks whether this vertex lies on a boundary.
   * @method module:Core.Vertex#onBoundary
   * @returns {boolean}
   */
  onBoundary() {
    for (let A of this.adjacentHalfedges())
      if (A.onBoundary)
        return !0;
    return !1;
  }
  /**
   * Convenience function to iterate over the vertices neighboring this vertex.
   * @method module:Core.Vertex#adjacentVertices
   * @param {boolean} ccw A flag indicating whether iteration should be in CCW or CW order.
   * @returns {module:Core.Vertex}
   * @example
   * let v = mesh.vertices[0];
   * for (let u of v.adjacentVertices()) {
   *     // Do something with u
   * }
   */
  adjacentVertices(A = !0) {
    return new vz(this.halfedge, A);
  }
  /**
   * Convenience function to iterate over the edges adjacent to this vertex.
   * @method module:Core.Vertex#adjacentEdges
   * @param {boolean} ccw A flag indicating whether iteration should be in CCW or CW order.
   * @returns {module:Core.Edge}
   * @example
   * let v = mesh.vertices[0];
   * for (let e of v.adjacentEdges()) {
   *     // Do something with e
   * }
   */
  adjacentEdges(A = !0) {
    return new Uz(this.halfedge, A);
  }
  /**
   * Convenience function to iterate over the faces adjacent to this vertex.
   * @method module:Core.Vertex#adjacentFaces
   * @param {boolean} ccw A flag indicating whether iteration should be in CCW or CW order.
   * @returns {module:Core.Face}
   * @example
   * let v = mesh.vertices[0];
   * for (let f of v.adjacentFaces()) {
   *     // Do something with f
   * }
   */
  adjacentFaces(A = !0) {
    return new kz(this.halfedge, A);
  }
  /**
   * Convenience function to iterate over the halfedges adjacent to this vertex.
   * @method module:Core.Vertex#adjacentHalfedges
   * @param {boolean} ccw A flag indicating whether iteration should be in CCW or CW order.
   * @returns {module:Core.Halfedge}
   * @example
   * let v = mesh.vertices[0];
   * for (let h of v.adjacentHalfedges()) {
   *     // Do something with h
   * }
   */
  adjacentHalfedges(A = !0) {
    return new xz(this.halfedge, A);
  }
  /**
   * Convenience function to iterate over the corners adjacent to this vertex.
   * @method module:Core.Vertex#adjacentCorners
   * @param {boolean} ccw A flag indicating whether iteration should be in CCW or CW order.
   * @returns {module:Core.Corner}
   * @example
   * let v = mesh.vertices[0];
   * for (let c of v.adjacentCorners()) {
   *     // Do something with c
   * }
   */
  adjacentCorners(A = !0) {
    return new Lz(this.halfedge, A);
  }
  /**
   * Defines a string representation for this vertex as its index.
   * @ignore
   * @method module:Core.Vertex#toString
   * @returns {string}
   */
  toString() {
    return this.index;
  }
}
class vz {
  // constructor
  constructor(A, e) {
    this._halfedge = A, this._ccw = e;
  }
  [Symbol.iterator]() {
    return {
      current: this._halfedge,
      end: this._halfedge,
      ccw: this._ccw,
      justStarted: !0,
      next() {
        if (!this.justStarted && this.current === this.end)
          return {
            done: !0
          };
        {
          this.justStarted = !1;
          let A = this.current.twin.vertex;
          return this.current = this.ccw ? this.current.twin.next : this.current.prev.twin, {
            done: !1,
            value: A
          };
        }
      }
    };
  }
}
class Uz {
  // constructor
  constructor(A, e) {
    this._halfedge = A, this._ccw = e;
  }
  [Symbol.iterator]() {
    return {
      current: this._halfedge,
      end: this._halfedge,
      ccw: this._ccw,
      justStarted: !0,
      next() {
        if (!this.justStarted && this.current === this.end)
          return {
            done: !0
          };
        {
          this.justStarted = !1;
          let A = this.current.edge;
          return this.current = this.ccw ? this.current.twin.next : this.current.prev.twin, {
            done: !1,
            value: A
          };
        }
      }
    };
  }
}
class kz {
  // constructor
  constructor(A, e) {
    for (; A.onBoundary; )
      A = A.twin.next;
    this._halfedge = A, this._ccw = e;
  }
  [Symbol.iterator]() {
    return {
      current: this._halfedge,
      end: this._halfedge,
      ccw: this._ccw,
      justStarted: !0,
      next() {
        for (; this.current.onBoundary; )
          this.current = this.ccw ? this.current.twin.next : this.current.prev.twin;
        if (!this.justStarted && this.current === this.end)
          return {
            done: !0
          };
        {
          this.justStarted = !1;
          let A = this.current.face;
          return this.current = this.ccw ? this.current.twin.next : this.current.prev.twin, {
            done: !1,
            value: A
          };
        }
      }
    };
  }
}
class xz {
  // constructor
  constructor(A, e) {
    this._halfedge = A, this._ccw = e;
  }
  [Symbol.iterator]() {
    return {
      current: this._halfedge,
      end: this._halfedge,
      ccw: this._ccw,
      justStarted: !0,
      next() {
        if (!this.justStarted && this.current === this.end)
          return {
            done: !0
          };
        {
          this.justStarted = !1;
          let A = this.current;
          return this.current = this.ccw ? this.current.twin.next : this.current.prev.twin, {
            done: !1,
            value: A
          };
        }
      }
    };
  }
}
class Lz {
  // constructor
  constructor(A, e) {
    for (; A.onBoundary; )
      A = A.twin.next;
    this._halfedge = A, this._ccw = e;
  }
  [Symbol.iterator]() {
    return {
      current: this._halfedge,
      end: this._halfedge,
      ccw: this._ccw,
      justStarted: !0,
      next() {
        for (; this.current.onBoundary; )
          this.current = this.ccw ? this.current.twin.next : this.current.prev.twin;
        if (!this.justStarted && this.current === this.end)
          return {
            done: !0
          };
        {
          this.justStarted = !1;
          let A = this.current.next.corner;
          return this.current = this.ccw ? this.current.twin.next : this.current.prev.twin, {
            done: !1,
            value: A
          };
        }
      }
    };
  }
}
class Tz {
  /**
   * This class represents a Mesh.
   * @constructor module:Core.Mesh
   * @property {module:Core.Vertex[]} vertices The vertices contained in this mesh.
   * @property {module:Core.Edge[]} edges The edges contained in this mesh.
   * @property {module:Core.Face[]} faces The faces contained in this mesh.
   * @property {module:Core.Corner[]} corners The corners contained in this mesh.
   * @property {module:Core.Halfedge[]} halfedges The halfedges contained in this mesh.
   * @property {module:Core.Face[]} boundaries The boundary loops contained in this mesh.
   * @property {Array.<module:Core.Halfedge[]>} generators An array of halfedge arrays, i.e.,
   * [[h11, h21, ..., hn1], [h12, h22, ..., hm2], ...] representing this mesh's
   * {@link https://en.wikipedia.org/wiki/Homology_(mathematics)#Surfaces homology generators}.
   */
  constructor() {
    this.vertices = [], this.edges = [], this.faces = [], this.corners = [], this.halfedges = [], this.boundaries = [], this.generators = [];
  }
  /**
   * Computes the euler characteristic of this mesh.
   * @method module:Core.Mesh#eulerCharacteristic
   * @returns {number}
   */
  eulerCharacteristic() {
    return this.vertices.length - this.edges.length + this.faces.length;
  }
  /**
   * Constructs this mesh.
   * @method module:Core.Mesh#build
   * @param {Object} polygonSoup A polygon soup mesh containing vertex positions and indices.
   * @param {module:LinearAlgebra.Vector[]} polygonSoup.v The vertex positions of the polygon soup mesh.
   * @param {number[]} polygonSoup.f The indices of the polygon soup mesh.
   * @returns {boolean} True if this mesh is constructed successfully and false if not
   * (when this mesh contains any one or a combination of the following - non-manifold vertices,
   *  non-manifold edges, isolated vertices, isolated faces).
   */
  build(A) {
    let e = A.v, t = A.f;
    this.preallocateElements(e, t);
    let i = /* @__PURE__ */ new Map();
    for (let C = 0; C < e.length; C++) {
      let c = new Gz();
      this.vertices[C] = c, i.set(C, c);
    }
    let n = 0, r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), B = /* @__PURE__ */ new Map();
    for (let C = 0; C < t.length; C += 3) {
      let c = new hG();
      this.faces[C / 3] = c;
      for (let u = 0; u < 3; u++) {
        let d = new dG();
        this.halfedges[C + u] = d;
      }
      for (let u = 0; u < 3; u++) {
        let d = (u + 1) % 3, p = t[C + u], D = t[C + d], f = this.halfedges[C + u];
        f.next = this.halfedges[C + d], f.prev = this.halfedges[C + (u + 3 - 1) % 3], f.onBoundary = !1, B.set(f, !1);
        let S = i.get(p);
        f.vertex = S, S.halfedge = f, f.face = c, c.halfedge = f, p > D && (D = [p, p = D][0]);
        let m = [p, D].toString();
        if (s.has(m)) {
          let N = s.get(m);
          f.twin = N, N.twin = f, f.edge = N.edge, B.set(f, !0), B.set(N, !0), r.set(m, r.get(m) + 1);
        } else {
          let N = new mz();
          this.edges[n++] = N, f.edge = N, N.halfedge = f, s.set(m, f), r.set(m, 1);
        }
        if (r.get(m) > 2)
          throw new Error("Mesh has non-manifold edges!");
      }
    }
    let I = t.length, E = 0;
    for (let C = 0; C < t.length; C++) {
      let c = this.halfedges[C];
      if (!B.get(c)) {
        let u = new hG();
        this.boundaries.push(u);
        let d = [], p = c;
        do {
          let f = new dG();
          this.halfedges[I++] = f, d.push(f);
          let S = p.next;
          for (; B.get(S); )
            S = S.twin.next;
          f.vertex = S.vertex, f.edge = p.edge, f.onBoundary = !0, f.face = u, u.halfedge = f, f.twin = p, p.twin = f, p = S;
        } while (p !== c);
        let D = d.length;
        for (let f = 0; f < D; f++)
          d[f].next = d[(f + D - 1) % D], d[f].prev = d[(f + 1) % D], B.set(d[f], !0), B.set(d[f].twin, !0);
      }
      if (!c.onBoundary) {
        let u = new yz();
        u.halfedge = c, c.corner = u, this.corners[E++] = u;
      }
    }
    return this.hasIsolatedVertices() || this.hasIsolatedFaces() || this.hasNonManifoldVertices() ? !1 : (this.indexElements(), !0);
  }
  /**
   * Preallocates mesh elements.
   * @private
   * @method module:Core.Mesh#preallocateElements
   * @param {module:LinearAlgebra.Vector[]} positions The vertex positions of a polygon soup mesh.
   * @param {number[]} indices The indices of a polygon soup mesh.
   */
  preallocateElements(A, e) {
    let t = 0, i = /* @__PURE__ */ new Map();
    for (let E = 0; E < e.length; E += 3)
      for (let C = 0; C < 3; C++) {
        let c = (C + 1) % 3, u = e[E + C], d = e[E + c];
        u > d && (d = [u, u = d][0]);
        let p = [u, d], D = p.toString();
        i.has(D) ? t-- : (i.set(D, p), t++);
      }
    let n = A.length, r = i.size, s = e.length / 3, B = 2 * r, I = B - t;
    this.vertices.length = 0, this.edges.length = 0, this.faces.length = 0, this.halfedges.length = 0, this.corners.length = 0, this.boundaries.length = 0, this.generators.length = 0, this.vertices = new Array(n), this.edges = new Array(r), this.faces = new Array(s), this.halfedges = new Array(B), this.corners = new Array(I);
  }
  /**
   * Checks whether this mesh has isolated vertices.
   * @private
   * @method module:Core.Mesh#hasIsolatedVertices
   * @returns {boolean}
   */
  hasIsolatedVertices() {
    for (let A of this.vertices)
      if (A.isIsolated())
        throw new Error("Mesh has isolated vertices!");
    return !1;
  }
  /**
   * Checks whether this mesh has isolated faces.
   * @private
   * @method module:Core.Mesh#hasIsolatedFaces
   * @returns {boolean}
   */
  hasIsolatedFaces() {
    for (let A of this.faces) {
      let e = 0;
      for (let t of A.adjacentHalfedges())
        t.twin.onBoundary && e++;
      if (e === 3)
        throw new Error("Mesh has isolated faces!");
    }
    return !1;
  }
  /**
   * Checks whether this mesh has non-manifold vertices.
   * @private
   * @method module:Core.Mesh#hasNonManifoldVertices
   * @returns {boolean}
   */
  hasNonManifoldVertices() {
    let A = /* @__PURE__ */ new Map();
    for (let e of this.vertices)
      A.set(e, 0);
    for (let e of this.faces)
      for (let t of e.adjacentVertices())
        A.set(t, A.get(t) + 1);
    for (let e of this.boundaries)
      for (let t of e.adjacentVertices())
        A.set(t, A.get(t) + 1);
    for (let e of this.vertices)
      if (A.get(e) !== e.degree())
        return !0;
    return !1;
  }
  /**
   * Assigns indices to this mesh's elements.
   * @private
   * @method module:Core.Mesh#indexElements
   */
  indexElements() {
    let A = 0;
    for (let e of this.vertices)
      e.index = A++;
    A = 0;
    for (let e of this.edges)
      e.index = A++;
    A = 0;
    for (let e of this.faces)
      e.index = A++;
    A = 0;
    for (let e of this.halfedges)
      e.index = A++;
    A = 0;
    for (let e of this.corners)
      e.index = A++;
    A = 0;
    for (let e of this.boundaries)
      e.index = A++;
  }
}
function Kz(g) {
  let A = 0, e = {};
  for (let t of g)
    e[t] = A++;
  return e;
}
class bz {
  /**
   * This class implements the {@link http://cs.cmu.edu/~kmcrane/Projects/HeatMethod/ heat method} to compute geodesic distance
   * on a surface mesh.
   * @constructor module:Projects.HeatMethod
   * @param {module:Core.Geometry} geometry The input geometry of the mesh this class acts on.
   * @property {module:Core.Geometry} geometry The input geometry of the mesh this class acts on.
   * @property {Object} vertexIndex A dictionary mapping each vertex of the input mesh to a unique index.
   * @property {module:LinearAlgebra.SparseMatrix} A The laplace matrix of the input mesh.
   * @property {module:LinearAlgebra.SparseMatrix} F The mean curvature flow operator built on the input mesh.
   */
  constructor(A) {
    this.geometry = A, this.vertexIndex = Kz(A.mesh.vertices);
    let e = Math.pow(A.meanEdgeLength(), 2), t = A.massMatrix(this.vertexIndex);
    this.A = A.laplaceMatrix(this.vertexIndex), this.F = t.plus(this.A.timesReal(e));
  }
  /**
   * Computes the vector field X = -u / |u|.
   * @private
   * @method module:Projects.HeatMethod#computeVectorField
   * @param {module:LinearAlgebra.DenseMatrix} u A dense vector (i.e., u.nCols() == 1) representing the
   * heat that is allowed to diffuse on the input mesh for a brief period of time.
   * @returns {Object} A dictionary mapping each face of the input mesh to a {@link module:LinearAlgebra.Vector Vector}.
   */
  computeVectorField(A) {
    let e = {};
    for (let t of this.geometry.mesh.faces) {
      let i = this.geometry.faceNormal(t), n = this.geometry.area(t), r = new er();
      for (let s of t.adjacentHalfedges()) {
        let B = this.vertexIndex[s.prev.vertex.index], I = A.get(B, 0), E = this.geometry.vector(s);
        r.incrementBy(i.cross(E).times(I));
      }
      r.divideBy(2 * n), r.normalize(), e[t.index] = r.negated();
    }
    return e;
  }
  /**
   * Computes the integrated divergence .X.
   * @private
   * @method module:Projects.HeatMethod#computeDivergence
   * @param {Object} X The vector field -u / |u| represented by a dictionary
   * mapping each face of the input mesh to a {@link module:LinearAlgebra.Vector Vector}.
   * @returns {module:LinearAlgebra.DenseMatrix}
   */
  computeDivergence(A) {
    let e = this.geometry.mesh.vertices, t = e.length, i = ln.zeros(t, 1);
    for (let n of e) {
      let r = this.vertexIndex[n.index], s = 0;
      for (let B of n.adjacentHalfedges())
        if (!B.onBoundary) {
          let I = A[B.face.index], E = this.geometry.vector(B), C = this.geometry.vector(B.prev.twin), c = this.geometry.cotan(B), u = this.geometry.cotan(B.prev);
          s += c * E.dot(I) + u * C.dot(I);
        }
      i.set(0.5 * s, r, 0);
    }
    return i;
  }
  /**
   * Shifts  such that its minimum value is zero.
   * @private
   * @method module:Projects.HeatMethod#subtractMinimumDistance
   * @param {module:LinearAlgebra.DenseMatrix} phi The (minimum 0) solution to the poisson equation  = .X.
   */
  subtractMinimumDistance(A) {
    let e = 1 / 0;
    for (let t = 0; t < A.nRows(); t++)
      e = Math.min(A.get(t, 0), e);
    for (let t = 0; t < A.nRows(); t++)
      A.set(A.get(t, 0) - e, t, 0);
  }
  /**
   * Computes the geodesic distances  using the heat method.
   * @method module:Projects.HeatMethod#compute
   * @param {module:LinearAlgebra.DenseMatrix} delta A dense vector (i.e., delta.nCols() == 1) containing
   * heat sources, i.e., u0 = (x).
   * @returns {module:LinearAlgebra.DenseMatrix}
   */
  compute(A) {
    let e = this.F.chol(), t = e.solvePositiveDefinite(A), i = this.computeVectorField(t), n = this.computeDivergence(i);
    e = this.A.chol();
    let r = e.solvePositiveDefinite(n.negated());
    return this.subtractMinimumDistance(r), r;
  }
}
const Yz = (g) => {
  const A = [];
  for (let e = 0; e < g.count; e++) {
    const [t, i, n] = [g.getX(e), g.getY(e), g.getZ(e)], r = new IA(t, i, n);
    A.push(Hk(r));
  }
  return A;
}, Hk = (g) => {
  g = g.normalize();
  let A = new IA();
  Math.abs(g.x) >= Math.abs(g.y) && Math.abs(g.x) >= Math.abs(g.z) ? A.set(-g.y, g.x, 0) : A.set(0, g.z, -g.y), A.normalize();
  let e = A.clone().cross(g);
  return { tan1: A, tan2: e };
};
let hg = {
  tangents: [],
  uvs: new Oe([], 2)
};
const Dc = -1e7, Hz = (g) => {
  const A = new Tz(), e = [], t = g.getAttribute("position");
  for (let r = 0; r < t.count; r++) {
    const [s, B, I] = [t.getX(r), t.getY(r), t.getZ(r)];
    e.push(new er(s, B, I));
  }
  const i = {
    f: g.index?.array,
    v: e
  };
  A.build(i);
  const n = new Dz(A, i.v);
  return new bz(n);
}, _z = (g, A) => {
  if (!(hg.tangents.length !== 0)) {
    hg.Heat = Hz(g);
    const p = hg.Heat.geometry.mesh.vertices.length;
    hg.Delta = ln.zeros(p, 1), hg.tangents = Yz(
      new Oe(g.attributes.normal.array, 3)
    );
    const D = g.attributes.normal.count;
    hg.uvs = new Oe(new Float32Array(2 * D), 2);
    for (let f = 0; f < D; f++)
      hg.uvs.setXY(f, Dc, Dc);
  }
  const t = hg.Heat.geometry.mesh, i = A.vertex, n = hg.Heat.vertexIndex[i];
  hg.Delta.set(1, n, 0);
  const r = hg.Heat.compute(hg.Delta);
  hg.Delta.set(0, n, 0);
  let s = [];
  const B = /* @__PURE__ */ new Map(), I = hg.Heat.geometry.normRadius;
  for (const p of t.vertices) {
    const D = r.get(p.index, 0) * I;
    B.set(p.index, D), s.push({ key: p.index, value: D });
  }
  let E = s.sort((p, D) => p.value - D.value);
  const C = hg.uvs.clone(), c = A.vertex;
  C.setXY(c, 0, 0);
  const u = g.attributes.normal, d = g.attributes.position;
  E = E.filter((p) => p.value !== 0);
  for (let p = 0; p < E.length; p++) {
    const D = E[p].key;
    if (B.get(D) > A.stopDist)
      break;
    const f = hg.Heat?.geometry.mesh.vertices[D].adjacentVertices();
    let S = [];
    for (const N of f)
      S.push({ key: N?.index, value: B.get(N?.index) });
    let y = 0, m = new ue(0, 0);
    S = S.filter((N) => C.getX(N.key) - Dc);
    for (let N = 0; N < S.length; N++) {
      const F = S[N].key, G = new IA(
        d.getX(D),
        d.getY(D),
        d.getZ(D)
      ), k = new IA(d.getX(F), d.getY(F), d.getZ(F)), v = 1 / G.distanceToSquared(k), x = Jz(
        D,
        F,
        c,
        d,
        u,
        C,
        hg.tangents
      );
      m.add(x.multiplyScalar(v)), y += v;
    }
    C.setXY(D, m.x / y, m.y / y);
  }
  for (let p = 0; p < C.count; p++) {
    const D = C.getX(p);
    Number.isFinite(D) || (C.setX(p, Dc), C.setY(p, Dc));
  }
  return C;
}, Jz = (g, A, e, t, i, n, r) => {
  const s = new IA(i.getX(e), i.getY(e), i.getZ(e)), B = r[e].tan1, I = new IA(i.getX(A), i.getY(A), i.getZ(A)), E = r[A].tan1, C = r[A].tan2, c = new IA(t.getX(g), t.getY(g), t.getZ(g)), u = new IA(t.getX(A), t.getY(A), t.getZ(A)), d = c.clone().sub(u), p = Math.sqrt(d.x * d.x + d.y * d.y + d.z * d.z);
  let D = new ue(d.clone().dot(E), d.clone().dot(C));
  D = D.normalize().multiplyScalar(p);
  const f = fG(s, I).rotmat, S = qz(f, B);
  let { axis: y, theta: m } = fG(S, E);
  y.dot(I) < 0 && (m = -m);
  const N = Math.cos(m), F = Math.sin(m);
  return D = Oz(
    new kt().fromArray([N, F, 0, -F, N, 0, 0, 0, 1]),
    D
  ), new ue(n.getX(A), n.getY(A)).add(D);
}, Oz = (g, A) => {
  const [e, t] = [
    g.elements[0] * A.x + g.elements[1] * A.y,
    g.elements[3] * A.x + g.elements[4] * A.y
  ];
  return new ue(e, t);
}, qz = (g, A) => {
  const [e, t, i] = [
    g.elements[0] * A.x + g.elements[1] * A.y + g.elements[2] * A.z,
    g.elements[3] * A.x + g.elements[4] * A.y + g.elements[5] * A.z,
    g.elements[6] * A.x + g.elements[7] * A.y + g.elements[8] * A.z
  ];
  return new IA(e, t, i);
}, fG = (g, A) => {
  const e = g.clone(), t = A.clone(), i = e.clone().dot(t) / (jd(e) * jd(t)), n = e.clone().cross(t);
  if (jd(n) > 0) {
    n.divideScalar(jd(n));
    const r = Math.acos(hz(i, -1, 1)), s = pG(n, r);
    return { axis: n, theta: r, rotmat: s };
  }
  if (i < 0) {
    const r = Hk(e);
    return {
      axis: r.tan1,
      theta: Math.PI,
      rotmat: pG(r.tan1, Math.PI)
    };
  }
  return {
    axis: new IA(0, 0, 1),
    theta: 0,
    rotmat: new kt().identity()
  };
}, jd = (g) => Math.sqrt(g.x * g.x + g.y * g.y + g.z * g.z), pG = (g, A) => {
  const e = Math.cos(A), t = Math.sin(A), i = 1 - e, n = g.x * g.x, r = g.y * g.y, s = g.z * g.z, B = g.x * g.y * i, I = g.x * g.z * i, E = g.y * g.z * i, C = g.x * t, c = g.y * t, u = g.z * t;
  return new kt().fromArray([
    n * i + e,
    B - u,
    I + c,
    B + u,
    r * i + e,
    E - C,
    I - c,
    E + C,
    s * i + e
  ]);
};
class Dm {
  constructor(A) {
    this.getGeometry = () => this.g, this.setRotation = (e) => {
      const t = this.g.getAttribute("uv");
      if (!t)
        return this;
      let i = Math.PI + Math.PI / 2 - e;
      for (let n = 0; n < t.count; n++) {
        const r = new ue(t.getX(n), t.getY(n)), s = [
          Math.cos(i),
          -Math.sin(i),
          1,
          Math.sin(i),
          Math.cos(i),
          1,
          1,
          1,
          1
        ], B = new kt().fromArray(s);
        r.subScalar(0.5), r.applyMatrix3(B), r.subScalar(0.5), t.setXY(n, r.x, r.y);
      }
      return this.g.setAttribute("uv", t), this;
    }, this.g = A.clone();
  }
  calculateUV(A, e, t, i) {
    const n = _z(this.g, {
      stopDist: Math.max(t * 300, 200),
      vertex: A
    });
    if (i)
      return this.g.setAttribute("uv", n), this;
    for (let r = 0; r < n.count; r++) {
      let s = new ue(n.getX(r), n.getY(r));
      s = s.sub(e).divideScalar(Math.SQRT2 * t * 300).addScalar(0.5), n.setXY(r, s.x, s.y);
    }
    return this.g.setAttribute("uv", n), this;
  }
}
Dm.expMapScale = 300;
const Pz = (g) => g.map((A) => ({
  id: A.id,
  image: A.image,
  position: A.position.toArray(),
  rotationAngle: A.rotationAngle,
  scale: A.scale,
  size: A.size.toArray(),
  face: A.face,
  translateFactor: A.translateFactor.toArray()
})), Wz = (g, A, e) => Promise.all(
  g.map(async (t) => {
    const i = new IA().fromArray(t.position), n = new IA().fromArray(t.size), r = e.clone(), s = new IA().fromArray(t.position);
    r.position.set(s.x, s.y, s.z);
    let B = t.face, I = t.scale;
    if (!t.face) {
      const u = i.divideScalar(5e-3), d = A.geometry.getAttribute("position");
      let p = Number.POSITIVE_INFINITY, D = -1;
      for (let f = 0; f < d.count; f++) {
        const S = new IA(
          d.getX(f),
          d.getY(f),
          d.getZ(f)
        ), y = u.distanceTo(S);
        y < p && (p = y, D = f);
      }
      B = D;
    }
    const E = await Yk.loadTexture(t.image), C = t.translateFactor ? new ue().fromArray(t.translateFactor) : new ue(0, 0), c = new Dm(A.geometry).calculateUV(B, C, I).setRotation(t.rotationAngle);
    return {
      id: t.id,
      image: t.image,
      position: i,
      rotationAngle: t.rotationAngle,
      scale: I,
      size: n,
      geometry: c,
      texture: E,
      face: B,
      translateFactor: C,
      mh: r
    };
  })
), DG = { toJson: Pz, fromJson: Wz }, zz = zc((g, A) => {
  const {
    cameraControls: e,
    sceneRef: t,
    modelMesh: i,
    raycastIntersectionRef: n,
    mousePosition: r,
    mouseHelper: s
  } = Vc(), { threeRef: B, setPastedStickers: I, pastedStickers: E } = dB();
  return SK(
    A,
    () => ({
      getStickerData: () => DG.toJson(E),
      presetStickers: async (C) => {
        const c = JSON.parse(C), u = await DG.fromJson(
          c,
          i.current,
          s.current
        );
        I(u);
      },
      exportData: async (C) => {
        if (C)
          return C === "3d" ? await nz(B.current.scene) : (iz(B.current.scene, !1), await gz(e.current));
      }
    }),
    [
      B,
      i,
      I,
      e,
      E,
      s
    ]
  ), gi(() => {
    Mr.init();
  }, []), /* @__PURE__ */ Wi("div", { className: "ms-relative ms-h-full", children: [
    /* @__PURE__ */ fe(
      g4,
      {
        gl: {
          alpha: !0,
          preserveDrawingBuffer: !0,
          outputEncoding: Ht
        },
        onCreated: (C) => {
          B.current = C, t.current = C.scene, uf.CanvasCapture.init(C?.gl.domElement);
        },
        onMouseMove: (C) => {
          const c = C.currentTarget.getBoundingClientRect(), u = (C.clientX - c.x - c.width / 2) / (c.width / 2), d = -(C.clientY - c.y - c.height / 2) / (c.height / 2);
          r.current = new ue(u, d);
        },
        children: /* @__PURE__ */ Wi(MK, { fallback: /* @__PURE__ */ fe(cq, {}), children: [
          /* @__PURE__ */ fe(n3, {}),
          /* @__PURE__ */ fe(Iq, { makeDefault: !0, position: [6, 0, 10] }),
          /* @__PURE__ */ fe(HP, {}),
          /* @__PURE__ */ fe(Ez, { ref: e }),
          /* @__PURE__ */ fe(
            _P,
            {
              modelMesh: i,
              intersectionRef: n,
              mousePosition: r
            }
          )
        ] })
      }
    ),
    /* @__PURE__ */ fe(LW, {})
  ] });
});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var ly = function(g, A) {
  return ly = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, t) {
    e.__proto__ = t;
  } || function(e, t) {
    for (var i in t)
      t.hasOwnProperty(i) && (e[i] = t[i]);
  }, ly(g, A);
};
function Vz(g, A) {
  ly(g, A);
  function e() {
    this.constructor = g;
  }
  g.prototype = A === null ? Object.create(A) : (e.prototype = A.prototype, new e());
}
var kc = function() {
  return kc = Object.assign || function(A) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var n in e)
        Object.prototype.hasOwnProperty.call(e, n) && (A[n] = e[n]);
    }
    return A;
  }, kc.apply(this, arguments);
};
function jz(g, A, e, t) {
  var i, n = !1, r = 0;
  function s() {
    i && clearTimeout(i);
  }
  function B() {
    s(), n = !0;
  }
  typeof A != "boolean" && (t = e, e = A, A = void 0);
  function I() {
    var E = this, C = Date.now() - r, c = arguments;
    if (n)
      return;
    function u() {
      r = Date.now(), e.apply(E, c);
    }
    function d() {
      i = void 0;
    }
    t && !i && u(), s(), t === void 0 && C > g ? u() : A !== !0 && (i = setTimeout(t ? d : u, t === void 0 ? g - C : g));
  }
  return I.cancel = B, I;
}
var ME = {
  Pixel: "Pixel",
  Percent: "Percent"
}, wG = {
  unit: ME.Percent,
  value: 0.8
};
function yG(g) {
  return typeof g == "number" ? {
    unit: ME.Percent,
    value: g * 100
  } : typeof g == "string" ? g.match(/^(\d*(\.\d+)?)px$/) ? {
    unit: ME.Pixel,
    value: parseFloat(g)
  } : g.match(/^(\d*(\.\d+)?)%$/) ? {
    unit: ME.Percent,
    value: parseFloat(g)
  } : (console.warn('scrollThreshold format is invalid. Valid formats: "120px", "50%"...'), wG) : (console.warn("scrollThreshold should be string or number"), wG);
}
var Zz = (
  /** @class */
  function(g) {
    Vz(A, g);
    function A(e) {
      var t = g.call(this, e) || this;
      return t.lastScrollTop = 0, t.actionTriggered = !1, t.startY = 0, t.currentY = 0, t.dragging = !1, t.maxPullDownDistance = 0, t.getScrollableTarget = function() {
        return t.props.scrollableTarget instanceof HTMLElement ? t.props.scrollableTarget : typeof t.props.scrollableTarget == "string" ? document.getElementById(t.props.scrollableTarget) : (t.props.scrollableTarget === null && console.warn(`You are trying to pass scrollableTarget but it is null. This might
        happen because the element may not have been added to DOM yet.
        See https://github.com/ankeetmaini/react-infinite-scroll-component/issues/59 for more info.
      `), null);
      }, t.onStart = function(i) {
        t.lastScrollTop || (t.dragging = !0, i instanceof MouseEvent ? t.startY = i.pageY : i instanceof TouchEvent && (t.startY = i.touches[0].pageY), t.currentY = t.startY, t._infScroll && (t._infScroll.style.willChange = "transform", t._infScroll.style.transition = "transform 0.2s cubic-bezier(0,0,0.31,1)"));
      }, t.onMove = function(i) {
        t.dragging && (i instanceof MouseEvent ? t.currentY = i.pageY : i instanceof TouchEvent && (t.currentY = i.touches[0].pageY), !(t.currentY < t.startY) && (t.currentY - t.startY >= Number(t.props.pullDownToRefreshThreshold) && t.setState({
          pullToRefreshThresholdBreached: !0
        }), !(t.currentY - t.startY > t.maxPullDownDistance * 1.5) && t._infScroll && (t._infScroll.style.overflow = "visible", t._infScroll.style.transform = "translate3d(0px, " + (t.currentY - t.startY) + "px, 0px)")));
      }, t.onEnd = function() {
        t.startY = 0, t.currentY = 0, t.dragging = !1, t.state.pullToRefreshThresholdBreached && (t.props.refreshFunction && t.props.refreshFunction(), t.setState({
          pullToRefreshThresholdBreached: !1
        })), requestAnimationFrame(function() {
          t._infScroll && (t._infScroll.style.overflow = "auto", t._infScroll.style.transform = "none", t._infScroll.style.willChange = "unset");
        });
      }, t.onScrollListener = function(i) {
        typeof t.props.onScroll == "function" && setTimeout(function() {
          return t.props.onScroll && t.props.onScroll(i);
        }, 0);
        var n = t.props.height || t._scrollableNode ? i.target : document.documentElement.scrollTop ? document.documentElement : document.body;
        if (!t.actionTriggered) {
          var r = t.props.inverse ? t.isElementAtTop(n, t.props.scrollThreshold) : t.isElementAtBottom(n, t.props.scrollThreshold);
          r && t.props.hasMore && (t.actionTriggered = !0, t.setState({ showLoader: !0 }), t.props.next && t.props.next()), t.lastScrollTop = n.scrollTop;
        }
      }, t.state = {
        showLoader: !1,
        pullToRefreshThresholdBreached: !1,
        prevDataLength: e.dataLength
      }, t.throttledOnScrollListener = jz(150, t.onScrollListener).bind(t), t.onStart = t.onStart.bind(t), t.onMove = t.onMove.bind(t), t.onEnd = t.onEnd.bind(t), t;
    }
    return A.prototype.componentDidMount = function() {
      if (typeof this.props.dataLength > "u")
        throw new Error('mandatory prop "dataLength" is missing. The prop is needed when loading more content. Check README.md for usage');
      if (this._scrollableNode = this.getScrollableTarget(), this.el = this.props.height ? this._infScroll : this._scrollableNode || window, this.el && this.el.addEventListener("scroll", this.throttledOnScrollListener), typeof this.props.initialScrollY == "number" && this.el && this.el instanceof HTMLElement && this.el.scrollHeight > this.props.initialScrollY && this.el.scrollTo(0, this.props.initialScrollY), this.props.pullDownToRefresh && this.el && (this.el.addEventListener("touchstart", this.onStart), this.el.addEventListener("touchmove", this.onMove), this.el.addEventListener("touchend", this.onEnd), this.el.addEventListener("mousedown", this.onStart), this.el.addEventListener("mousemove", this.onMove), this.el.addEventListener("mouseup", this.onEnd), this.maxPullDownDistance = this._pullDown && this._pullDown.firstChild && this._pullDown.firstChild.getBoundingClientRect().height || 0, this.forceUpdate(), typeof this.props.refreshFunction != "function"))
        throw new Error(`Mandatory prop "refreshFunction" missing.
          Pull Down To Refresh functionality will not work
          as expected. Check README.md for usage'`);
    }, A.prototype.componentWillUnmount = function() {
      this.el && (this.el.removeEventListener("scroll", this.throttledOnScrollListener), this.props.pullDownToRefresh && (this.el.removeEventListener("touchstart", this.onStart), this.el.removeEventListener("touchmove", this.onMove), this.el.removeEventListener("touchend", this.onEnd), this.el.removeEventListener("mousedown", this.onStart), this.el.removeEventListener("mousemove", this.onMove), this.el.removeEventListener("mouseup", this.onEnd)));
    }, A.prototype.componentDidUpdate = function(e) {
      this.props.dataLength !== e.dataLength && (this.actionTriggered = !1, this.setState({
        showLoader: !1
      }));
    }, A.getDerivedStateFromProps = function(e, t) {
      var i = e.dataLength !== t.prevDataLength;
      return i ? kc(kc({}, t), { prevDataLength: e.dataLength }) : null;
    }, A.prototype.isElementAtTop = function(e, t) {
      t === void 0 && (t = 0.8);
      var i = e === document.body || e === document.documentElement ? window.screen.availHeight : e.clientHeight, n = yG(t);
      return n.unit === ME.Pixel ? e.scrollTop <= n.value + i - e.scrollHeight + 1 : e.scrollTop <= n.value / 100 + i - e.scrollHeight + 1;
    }, A.prototype.isElementAtBottom = function(e, t) {
      t === void 0 && (t = 0.8);
      var i = e === document.body || e === document.documentElement ? window.screen.availHeight : e.clientHeight, n = yG(t);
      return n.unit === ME.Pixel ? e.scrollTop + i >= e.scrollHeight - n.value : e.scrollTop + i >= n.value / 100 * e.scrollHeight;
    }, A.prototype.render = function() {
      var e = this, t = kc({ height: this.props.height || "auto", overflow: "auto", WebkitOverflowScrolling: "touch" }, this.props.style), i = this.props.hasChildren || !!(this.props.children && this.props.children instanceof Array && this.props.children.length), n = this.props.pullDownToRefresh && this.props.height ? { overflow: "auto" } : {};
      return qi.createElement(
        "div",
        { style: n, className: "infinite-scroll-component__outerdiv" },
        qi.createElement(
          "div",
          { className: "infinite-scroll-component " + (this.props.className || ""), ref: function(r) {
            return e._infScroll = r;
          }, style: t },
          this.props.pullDownToRefresh && qi.createElement(
            "div",
            { style: { position: "relative" }, ref: function(r) {
              return e._pullDown = r;
            } },
            qi.createElement("div", { style: {
              position: "absolute",
              left: 0,
              right: 0,
              top: -1 * this.maxPullDownDistance
            } }, this.state.pullToRefreshThresholdBreached ? this.props.releaseToRefreshContent : this.props.pullDownToRefreshContent)
          ),
          this.props.children,
          !this.state.showLoader && !i && this.props.hasMore && this.props.loader,
          this.state.showLoader && this.props.hasMore && this.props.loader,
          !this.props.hasMore && this.props.endMessage
        )
      );
    }, A;
  }(RK)
);
function Xz() {
  const {
    stickers: g,
    threeRef: A,
    setPastedStickers: e,
    pastedStickers: t,
    selectedSticker: i,
    setSelectedSticker: n,
    setRotation: r,
    setScale: s,
    fetchingStickers: B,
    fetchMoreStickers: I
  } = dB(), { raycastIntersectionRef: E, modelMesh: C, mousePosition: c, mouseHelper: u } = Vc(), d = Dt(null), p = Dt(!1), [D, f] = cn(!0), S = Ak(
    async ({ type: N, args: F, xy: G }) => {
      const k = F[0];
      d.current.src = k.url, d.current.style.visibility = "visible", d.current.style.left = G[0] - 20 + "px", d.current.style.top = G[1] - 20 + "px";
      const v = A.current.gl.domElement.getBoundingClientRect(), x = (G[0] - v.x - v.width / 2) / (v.width / 2), H = -(G[1] - v.y - v.height / 2) / (v.height / 2);
      if (c.current = new ue(x, H), p.current = !0, N !== "pointermove") {
        if (d.current.style.visibility = "hidden", !E.current || !C.current || !u.current)
          return;
        const _ = E.current, j = await Yk.loadTexture(k.url), V = new IA(
          1,
          j.image.height / j.image.width,
          1
        ), iA = _.face?.a ?? 0, eA = new ue(0, 0), oA = 0.5, P = 2 * Math.PI, J = new Dm(C.current.geometry.clone());
        J.calculateUV(iA, eA, oA).setRotation(P);
        const tA = {
          face: iA,
          geometry: J,
          id: k.sticker_id ?? "",
          image: k.url,
          position: E.current.point.clone(),
          rotationAngle: P,
          scale: oA,
          size: V,
          texture: j,
          translateFactor: eA,
          mh: u.current.clone()
        };
        r(0), s(tA.scale), n(tA.id), e((Y) => [...Y, tA]);
      }
    },
    {
      threshold: 1
    }
  ), y = (N) => {
    e(
      (F) => F.filter((G) => G.id !== N)
    ), N.toString() === i && n("");
  }, m = async () => {
    const N = await I?.();
    f(N ?? !1);
  };
  return /* @__PURE__ */ Wi(Df, { children: [
    /* @__PURE__ */ fe(
      "img",
      {
        ref: d,
        draggable: !1,
        src: "data:image/gif;base64,R0lGODlhAQABAAAAACw=",
        className: "ms-fixed ms-top-0 ms-left-0 ms-z-10 ms-invisible ms-object-contain ms-w-10 ms-h-10",
        alt: "Hidden"
      }
    ),
    /* @__PURE__ */ Wi("div", { className: "ms-hidden lg:ms-flex ms-flex-col ms-w-full ms-h-full ms-p-3 ms-text-white ms-bg-black ms-rounded-md", children: [
      /* @__PURE__ */ fe("h4", { children: "NFT Collection" }),
      B ? /* @__PURE__ */ fe("div", { className: "ms-flex ms-justify-center ms-px-2 ms-pt-4", children: /* @__PURE__ */ fe(ZF, {}) }) : /* @__PURE__ */ fe(
        "div",
        {
          className: "ms-max-h-full ms-mt-4 ms-overflow-y-scroll no__scrollbar",
          id: "stickers__list",
          children: /* @__PURE__ */ fe(
            Zz,
            {
              className: "ms-grid ms-flex-grow ms-grid-cols-2 ms-gap-2 no__scrollbar",
              dataLength: g.length,
              next: m,
              hasMore: D,
              loader: /* @__PURE__ */ fe("div", { className: "ms-flex ms-justify-center ms-col-span-2 ms-py-2", children: /* @__PURE__ */ fe(ZF, {}) }),
              scrollableTarget: "stickers__list",
              children: g?.map((N) => {
                let F = t.map((G) => G.id).includes(N.sticker_id);
                return /* @__PURE__ */ Wi(
                  "div",
                  {
                    ...F ? {} : S(N),
                    draggable: !1,
                    onClick: (G) => {
                      if (!F && p.current) {
                        p.current = !1;
                        return;
                      }
                    },
                    style: { touchAction: "none" },
                    className: `ms-rounded-sm ms-p-0.5 ms-relative ${F ? "ms-cursor-not-allowed" : "hover:ms-scale-105 ms-cursor-pointer"}`,
                    children: [
                      /* @__PURE__ */ fe(
                        "img",
                        {
                          src: N.url,
                          alt: "Sticker",
                          className: `ms-rounded-sm ${F && "ms-opacity-80"}`,
                          draggable: !1
                        }
                      ),
                      F && /* @__PURE__ */ Wi("div", { className: "ms-absolute ms-bottom-0 ms-left-0 ms-right-0 ms-flex ms-justify-end ms-p-2 ms-space-x-1", children: [
                        /* @__PURE__ */ fe("div", { className: "ms-bg-blue-600 ms-text-white ms-text-[10px] ms-py-0.5 ms-px-2 ms-rounded-sm", children: "PASTED" }),
                        /* @__PURE__ */ fe(
                          "button",
                          {
                            type: "button",
                            className: "ms-bg-red-600 ms-rounded-sm ms-p-0.5 ms-text-white",
                            onClick: () => y(N.sticker_id),
                            children: /* @__PURE__ */ fe(
                              "svg",
                              {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 1.5,
                                stroke: "currentColor",
                                className: "ms-w-4 ms-h-4",
                                children: /* @__PURE__ */ fe(
                                  "path",
                                  {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M6 18L18 6M6 6l12 12"
                                  }
                                )
                              }
                            )
                          }
                        )
                      ] })
                    ]
                  },
                  N.sticker_id
                );
              })
            }
          )
        }
      )
    ] })
  ] });
}
const $z = zc(
  ({
    backgrounds: g,
    stickers: A,
    model: e,
    fetchingStickers: t,
    fetchMoreStickers: i,
    modelScaleFactor: n,
    modelPosition: r,
    children: s
  }, B) => /* @__PURE__ */ fe(
    FK,
    {
      backgrounds: g,
      stickers: A,
      model: e,
      fetchingStickers: t,
      fetchMoreStickers: i,
      modelScaleFactor: n,
      modelPosition: r,
      children: /* @__PURE__ */ Wi("div", { className: "ms-flex ms-space-x-4 ms-h-[95vh] ms-max-h-[95vh]", children: [
        /* @__PURE__ */ fe("div", { className: "ms-w-1/5 xl:ms-w-[17%] 2xl:ms-w-[14%]", children: /* @__PURE__ */ fe(Xz, {}) }),
        /* @__PURE__ */ fe("div", { className: "ms-flex-grow", children: /* @__PURE__ */ fe(zz, { ref: B }) }),
        /* @__PURE__ */ Wi("div", { className: "ms-flex ms-flex-col ms-justify-between ms-space-y-2 ms-w-1/5", children: [
          /* @__PURE__ */ fe("div", { className: "ms-flex-grow ms-overflow-y-scroll no__scrollbar", children: /* @__PURE__ */ fe(Qz, {}) }),
          /* @__PURE__ */ fe("div", { className: "ms-hidden lg:ms-flex ms-flex-col ms-space-y-3 ms-flex-shrink-0", children: s && s })
        ] })
      ] })
    }
  )
), A5 = (g) => {
  const [A, e] = cn(g.stickers), t = Dt(null), i = async () => (await new Promise(
    (n) => setTimeout(() => {
      n(e([...A, ...A]));
    }, 2e3)
  ), !0);
  return /* @__PURE__ */ fe(
    $z,
    {
      ref: t,
      backgrounds: g.backgrounds,
      stickers: A,
      model: g.modelUrl,
      fetchingStickers: !1,
      fetchMoreStickers: i,
      modelScaleFactor: 1,
      modelPosition: [0, -3.5, 0],
      children: /* @__PURE__ */ fe("p", { children: "Editor Children" })
    }
  );
}, e5 = ({
  container: g,
  modelUrl: A,
  stickers: e,
  backgrounds: t
}) => {
  mG.render(
    qi.createElement(A5, [A, e, t]),
    g
  );
}, t5 = () => {
  console.log("hellow from widget");
};
typeof window < "u" && (window.renderWidget = e5, window.hello = t5);
export {
  zz as Experience,
  Qz as LayerCustomization,
  Xz as NFTCollection,
  $z as StickerEditor,
  e5 as renderWidget
};
